Project Path: \\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src

Source Tree:

```
src
├── arrays
├── callbacks
│   ├── evaluateCache.ts
│   ├── playerCollectibleAdded.ts
│   ├── playerCollectibleRemoved.ts
│   ├── playerTakeDMG.ts
│   ├── postBombExploded.ts
│   ├── postBombInitLate.ts
│   ├── postBombUpdate.ts
│   ├── postEntityKill.ts
│   ├── postEntityRemove.ts
│   ├── postFireTear.ts
│   ├── postGameStartedReordered.ts
│   ├── postGreedWaveClear.ts
│   ├── postGridEntityCollision.ts
│   ├── postItemPickup.ts
│   ├── postNewLevel.ts
│   ├── postNewLevelReordered.ts
│   ├── postNewRoom.ts
│   ├── postNewRoomReordered.ts
│   ├── postNPCInitLate.ts
│   ├── postNPCUpdate.ts
│   ├── postPeffectUpdateReordered.ts
│   ├── postPickupChanged.ts
│   ├── postPickupCollect.ts
│   ├── postPickupInitFirst.ts
│   ├── postPickupInitLate.ts
│   ├── postPlayerChangeStat.ts
│   ├── postPlayerChangeType.ts
│   ├── postPlayerFatalDamage.ts
│   ├── postPlayerInit.ts
│   ├── postPlayerInitFirst.ts
│   ├── postPurchase.ts
│   ├── postRender.ts
│   ├── postRoomClear.ts
│   ├── postSacrifice.ts
│   ├── postSlotUse.ts
│   ├── postUpdate.ts
│   ├── postUseCard.ts
│   ├── postUseItem.ts
│   ├── postUsePill.ts
│   ├── preCustomRevive.ts
│   ├── preGameExit.ts
│   ├── preGetPedestal.ts
│   ├── preItemPickup.ts
│   ├── preNewLevel.ts
│   ├── prePickupCollision.ts
│   ├── prePlayerCollision.ts
│   └── preSpawnClearAward.ts
├── classes
│   ├── corruption
│   │   ├── actions
│   │   │   ├── Action.ts
│   │   │   ├── OnActiveUseAction.ts
│   │   │   ├── OnBombExplodeAction.ts
│   │   │   ├── OnCardUseAction.ts
│   │   │   ├── OnDamageAction.ts
│   │   │   ├── OnDeathAction.ts
│   │   │   ├── OnFloorAction.ts
│   │   │   ├── OnGreedWaveClearAction.ts
│   │   │   ├── OnKillAction.ts
│   │   │   ├── OnObtainAction.ts
│   │   │   ├── OnPickupCollectAction.ts
│   │   │   ├── OnPillUseAction.ts
│   │   │   ├── OnPurchaseAction.ts
│   │   │   ├── OnReviveAction.ts
│   │   │   ├── OnRoomAction.ts
│   │   │   ├── OnRoomClearAction.ts
│   │   │   ├── OnSacrificeAction.ts
│   │   │   ├── OnSlotDestroyAction.ts
│   │   │   ├── OnSlotUseAction.ts
│   │   │   └── OnStatAction.ts
│   │   ├── actionSets
│   │   │   ├── ActionSet.ts
│   │   │   ├── Inverted
│   │   │   │   ├── InvertedActiveActionSet.ts
│   │   │   │   ├── InvertedItemActionSet.ts
│   │   │   │   └── InvertedPassiveActionSet.ts
│   │   │   └── NonInverted
│   │   │       └── NonInvertedPickupActionSet.ts
│   │   └── responses
│   │       ├── GetCollectibleResponse.ts
│   │       ├── GetTrinketResponse.ts
│   │       ├── IfThenElseResponse.ts
│   │       ├── IfThenResponse.ts
│   │       ├── PlaySoundResponse.ts
│   │       ├── RemoveActionResponse.ts
│   │       ├── RemoveCollectibleResponse.ts
│   │       ├── RemoveEntityResponse.ts
│   │       ├── RemoveGridEntityResponse.ts
│   │       ├── Response.ts
│   │       ├── SpawnEffectResponse.ts
│   │       ├── SpawnEntityResponse.ts
│   │       ├── SpawnGridEntityResponse.ts
│   │       ├── SpawnHybridNPCResponse.ts
│   │       ├── SpawnLiveBombResponse.ts
│   │       ├── SpawnNPCResponse.ts
│   │       ├── SpawnPickupResponse.ts
│   │       ├── SpawnSlotResponse.ts
│   │       ├── SpawnTearResponse.ts
│   │       ├── TemporaryActionResponse.ts
│   │       ├── TemporaryActionSetResponse.ts
│   │       ├── TemporaryCollectibleResponse.ts
│   │       ├── TransformResponse.ts
│   │       ├── TriggerInQueueResponse.ts
│   │       ├── TriggerInSequenceResponse.ts
│   │       ├── TriggerOverTimeResponse.ts
│   │       ├── TriggerRandomResponse.ts
│   │       ├── UseActiveItemResponse.ts
│   │       └── WaitThenTriggerResponse.ts
│   ├── Facet.ts
│   ├── facets
│   │   ├── CorruptedCollectibleSpriteFacet.ts
│   │   ├── CustomActiveFacet.ts
│   │   ├── entityModifiers.ts
│   │   │   ├── EffectModifiers
│   │   │   ├── NPCModifiers
│   │   │   │   ├── BolsterNPCFacet.ts
│   │   │   │   ├── CensoredNPCFacet.ts
│   │   │   │   ├── FreezeNPCFacet.ts
│   │   │   │   ├── HideNPCFacet.ts
│   │   │   │   ├── HybridNPCFacet.ts
│   │   │   │   ├── NonMandatoryNPCFacet.ts
│   │   │   │   └── PermanentNPCStatusEffectFacet.ts
│   │   │   ├── pickupModifiers
│   │   │   │   └── EveryItemIsFacet.ts
│   │   │   └── UnstableEntityFacet.ts
│   │   ├── ExampleFacet.ts
│   │   ├── gameModifiers.ts
│   │   │   └── CantPickupFacet.ts
│   │   ├── pc
│   │   │   └── PCFacet.ts
│   │   ├── RenderOverHeadFacet.ts
│   │   └── SpawnEntityByNameFacet.ts
│   └── worms
│       ├── FriendlyWorm.ts
│       └── LevelOneWorm.ts
├── classes.ts
├── constants
│   ├── actionSetConstants.ts
│   ├── corruptionConstants.ts
│   ├── eidConstants.ts
│   ├── fileConstants.ts
│   ├── generalConstants.ts
│   ├── HUDConstants.ts
│   ├── id
│   ├── items
│   │   └── MYDOOMEyeConstants.ts
│   ├── mod
│   │   ├── itemConstants.ts
│   │   └── modConstants.ts
│   ├── modes
│   │   ├── HAPPY99Constants.ts
│   │   ├── ILOVEYOUConstants.ts
│   │   ├── MORRISConstants.ts
│   │   └── REVETONConstants.ts
│   ├── npcConstants.ts
│   ├── pcConstants.ts
│   ├── pickupConstants.ts
│   ├── renderConstants.ts
│   ├── soundConstants.ts
│   ├── spriteConstants.ts
│   └── tmtrainerConstants.ts
├── enums
│   ├── builders
│   ├── compatibility
│   │   ├── EID
│   │   │   ├── EIDColor.ts
│   │   │   ├── EIDColorTriplet.ts
│   │   │   └── EIDMarkup.ts
│   │   └── Mods.ts
│   ├── corruption
│   │   ├── actions
│   │   │   ├── ActionBuilders.ts
│   │   │   ├── ActionOrigin.ts
│   │   │   └── ActionType.ts
│   │   ├── actionSets
│   │   │   ├── ActionSetBuilders.ts
│   │   │   └── ActionSetType.ts
│   │   ├── Morality.ts
│   │   └── responses
│   │       └── ResponseType.ts
│   ├── data
│   │   └── ID
│   │       ├── EffectID.ts
│   │       ├── FamiliarID.ts
│   │       ├── GridID.ts
│   │       ├── modded
│   │       │   └── fiendFolio
│   │       └── PickupID.ts
│   ├── FriendlyWormType.ts
│   ├── general
│   │   ├── CharacterType.ts
│   │   ├── CollectibleTypeCustom.ts
│   │   ├── Conditional.ts
│   │   ├── DeletedColor.ts
│   │   ├── EntityCategory.ts
│   │   ├── HUDQuandrant.ts
│   │   ├── NPCFlag.ts
│   │   ├── PickupStage.ts
│   │   ├── PickupType.ts
│   │   ├── PlayerTypeCustom.ts
│   │   ├── SoundEffectCustom.ts
│   │   └── TemporaryEffectType.ts
│   ├── modes
│   │   └── Mode.ts
│   ├── pc
│   │   ├── PCAnimation.ts
│   │   └── PCStatus.ts
│   ├── settings
│   │   └── EIDObjectDisplaySetting.ts
│   ├── SlotCustom.ts
│   └── worlds
│       └── Worlds.ts
├── features
│   ├── compatibility
│   │   ├── EID
│   │   │   └── EIDInit.ts
│   │   └── ITEM_DISPLAY
│   │       ├── ItemDisplayLibrary.d.ts
│   │       └── ItemDisplayLibrary.lua
│   ├── console
│   │   └── testing.ts
│   ├── corruption
│   │   ├── corruptionGeneration.ts
│   │   ├── effects
│   │   │   ├── activeItemTracker.ts
│   │   │   ├── callbacks
│   │   │   │   └── postZazzRemoved.ts
│   │   │   ├── itemEffects.ts
│   │   │   ├── pickupEffects.ts
│   │   │   └── playerEffects.ts
│   │   ├── inventory
│   │   │   ├── bombInventory.ts
│   │   │   ├── callbacks
│   │   │   │   ├── itemInventoryPostGameContinuedReordered.ts
│   │   │   │   └── postPickupChangedToInverted.ts
│   │   │   ├── passiveItemInventory.ts
│   │   │   └── removedInvertedItems.ts
│   │   └── inversion
│   │       ├── callbacks
│   │       │   ├── bombCollection.ts
│   │       │   ├── coinCollection.ts
│   │       │   ├── invertedPostItemPickupCollectible.ts
│   │       │   ├── invertedPostPickupChanged.ts
│   │       │   ├── invertedPreGetPedestalCollectible.ts
│   │       │   └── invertedPreItemPickupCollectible.ts
│   │       ├── customActivePostGameContinuedReordered.ts
│   │       ├── customActives.ts
│   │       ├── lastPickedUpInverted.ts
│   │       ├── pickupInversion.ts
│   │       ├── playerInversion.ts
│   │       └── seenInvertedPickups.ts
│   ├── data
│   │   └── gameSets
│   │       ├── callbacks
│   │       │   └── gameSetsPostGameStartedReordered.ts
│   │       ├── gameEntitySetBuilder.ts
│   │       └── gameEntitySets.ts
│   ├── general
│   │   ├── backdropHelper.ts
│   │   ├── floorColorHelper.ts
│   │   ├── isLeavingGame.ts
│   │   ├── lastRoomVisited.ts
│   │   ├── lateSave.ts
│   │   ├── playerStats.ts
│   │   ├── RNGHelper.ts
│   │   ├── spriteCache.ts
│   │   └── temporaryItems.ts
│   ├── items
│   │   ├── bitflip.ts
│   │   ├── d14.ts
│   │   ├── extract.ts
│   │   ├── extractVariants
│   │   │   └── extractFire.ts
│   │   ├── eyes
│   │   │   ├── eye1.ts
│   │   │   ├── eye2.ts
│   │   │   ├── eye3.ts
│   │   │   └── eyeGeneral.ts
│   │   └── trash.ts
│   ├── modes
│   │   ├── BATTLEYE
│   │   │   └── BATTLEYE.ts
│   │   ├── CRYPTOLOCKER
│   │   │   └── CRYPTOLOCKER.ts
│   │   ├── HAPPY99
│   │   │   └── HAPPY99.ts
│   │   ├── HICURDISMOS
│   │   │   └── HICURDISMOS.ts
│   │   ├── ILOVEYOU
│   │   │   └── ILOVEYOU.ts
│   │   ├── JERUSALEM
│   │   │   └── JERUSALEM.ts
│   │   ├── MEMZ
│   │   │   └── MEMZ.ts
│   │   ├── mode.ts
│   │   ├── MORRIS
│   │   │   └── MORRIS.ts
│   │   ├── MYDOOM
│   │   │   └── MYDOOM.ts
│   │   ├── REVETON
│   │   │   └── REVETON.ts
│   │   ├── SOPHOS
│   │   │   └── SOPHOS.ts
│   │   ├── SPYWIPER
│   │   │   └── SPYWIPER.ts
│   │   ├── VCS
│   │   │   └── VCS.ts
│   │   └── ZIPBOMBER
│   │       └── ZIPBOMBER.ts
│   ├── pc
│   │   ├── callbacks
│   │   │   └── pcPostPlayerInitFirst.ts
│   │   └── uiPC.ts
│   ├── runIndex.ts
│   └── settings
│       ├── ActionSetThemeSetting.ts
│       ├── EIDSettings.ts
│       ├── GeneralSettings.ts
│       ├── HAPPY99Settings.ts
│       ├── ModdedEffectSettings.ts
│       ├── ModdedNPCSettings.ts
│       ├── ModdedPickupSettings.ts
│       └── SOPHOSSettings.ts
├── features.ts
├── globals.d.ts
├── helper
│   ├── activeHelper.ts
│   ├── advancedColorHelper.ts
│   ├── arrayHelper.ts
│   ├── bitflagHelper.ts
│   ├── builders
│   │   ├── actionSetBuilders.ts
│   │   ├── extra
│   │   │   ├── hybridActiveBuilders.ts
│   │   │   └── trinketActionSetBuilders.ts
│   │   ├── genericBuilders.ts
│   │   ├── items
│   │   │   └── EXTRACTBuilders.ts
│   │   └── modes
│   │       ├── HAPPY99Builders.ts
│   │       ├── HICURDISMOSBuilders.ts
│   │       ├── ILOVEYOUBuilders.ts
│   │       ├── MORRISBuilders.ts
│   │       ├── MYDOOMBuilders.ts
│   │       └── REVETONBuilders.ts
│   ├── collectibleHelper.ts
│   ├── colorHelper.ts
│   ├── compatibility
│   │   ├── Andromeda
│   │   │   └── andromedaHelper.ts
│   │   ├── EID
│   │   │   └── EIDHelper.ts
│   │   ├── externalModHelper.ts
│   │   ├── FiendFolio
│   │   │   └── fiendFolioHelper.ts
│   │   └── XML
│   │       ├── entities2XMLHelper.ts
│   │       ├── itemPoolsXMLHelper.ts
│   │       ├── itemsXMLHelper.ts
│   │       └── moddedXMLParserHelper.ts
│   ├── costumeHelper.ts
│   ├── curseHelper.ts
│   ├── damageHelper.ts
│   ├── deletedSpecific
│   │   ├── actionSetHelper.ts
│   │   ├── conditionHelper.ts
│   │   ├── deletedHelper.ts
│   │   ├── effects
│   │   │   ├── actionHelper.ts
│   │   │   ├── itemEffects.ts
│   │   │   ├── moralityHelper.ts
│   │   │   ├── pedestalEffects.ts
│   │   │   ├── pickupEffects.ts
│   │   │   └── responseHelper.ts
│   │   ├── funnyNames.ts
│   │   ├── funnySounds.ts
│   │   ├── funnySprites.ts
│   │   ├── generation
│   │   │   └── corruptionGeneration.ts
│   │   ├── glitchyPlayerTransform.ts
│   │   ├── inventory
│   │   │   ├── custom actives
│   │   │   │   ├── customActiveHelper.ts
│   │   │   │   └── invertedActives.ts
│   │   │   ├── invertedInventoryHelper.ts
│   │   │   └── removedItems.ts
│   │   ├── inversion
│   │   │   ├── pedestalInversion.ts
│   │   │   ├── playerInversion.ts
│   │   │   ├── spawnInverted.ts
│   │   │   ├── updateInverted.ts
│   │   │   └── worldInversionHelper.ts
│   │   ├── items
│   │   │   └── extractHelper.ts
│   │   ├── modeHelper.ts
│   │   ├── modes
│   │   └── worlds
│   │       └── worldHelper.ts
│   ├── entityHelper
│   │   ├── bombEntityHelper.ts
│   │   ├── effectHelper.ts
│   │   ├── effectIDHelper.ts
│   │   ├── entityIDHelper.ts
│   │   ├── entityIDNameHelper.ts
│   │   ├── explodeEntity.ts
│   │   ├── familiarHelper.ts
│   │   ├── familiarIDHelper.ts
│   │   ├── npcFlagHelper.ts
│   │   ├── npcHelper.ts
│   │   ├── npcIDHelper.ts
│   │   ├── pickupIDHelper copy.ts
│   │   ├── pickupIDHelper.ts
│   │   ├── pickupIndexHelper.ts
│   │   ├── slotHelper.ts
│   │   ├── tearHelper.ts
│   │   └── trinketHelper.ts
│   ├── entityHelper.ts
│   ├── entityTypeHelper.ts
│   ├── enumHelper.ts
│   ├── floorHelper.ts
│   ├── gameHelper.ts
│   ├── gridEntityHelper
│   │   ├── gridEntityHelper.ts
│   │   └── gridIDHelper.ts
│   ├── HUDHelper.ts
│   ├── inputHelper.ts
│   ├── inventoryHelper.ts
│   ├── mapHelper.ts
│   ├── numbers
│   │   ├── numberHelper.ts
│   │   └── numberToWords.ts
│   ├── objectHelper.ts
│   ├── patternHelper.ts
│   ├── pickupHelper.ts
│   ├── playerHelper.ts
│   ├── positionHelper.ts
│   ├── priceHelper.ts
│   ├── printHelper.ts
│   ├── randomHelper.ts
│   ├── renderHelper.ts
│   ├── rngHelper.ts
│   ├── roomHelper.ts
│   ├── ruleHelper.ts
│   ├── setHelper.ts
│   ├── soundHelper.ts
│   ├── spriteHelper.ts
│   ├── statHelper.ts
│   ├── stringHelper.ts
│   ├── textHelper.ts
│   └── tmtrainerHelper.ts
├── interfaces
│   ├── compatibility
│   │   └── EIDDescObject.ts
│   ├── corruption
│   │   ├── actions
│   │   │   └── TriggerData.ts
│   │   ├── actionSets
│   │   │   ├── ActionSetBuilderInput.ts
│   │   │   └── CustomActiveData.ts
│   │   ├── funny
│   │   │   ├── CorruptedCollectibleSprite.ts
│   │   │   └── CorruptedSoundEffect.ts
│   │   ├── inversion
│   │   │   └── LastPickedUpCollectibleData.ts
│   │   └── responses
│   │       ├── LogicResponseInterface.ts
│   │       ├── ResponseReturnData.ts
│   │       └── SpawnEntityResponseInterface.ts
│   ├── general
│   │   ├── AdvancedColor.ts
│   │   ├── CollectibleAttribute.ts
│   │   ├── NPCAttribute.ts
│   │   └── SoundEffectOptions.ts
│   ├── modes
│   │   └── ModeData.ts
│   └── xml
│       ├── entities2XML.ts
│       ├── itemPoolXML.ts
│       ├── itemsXML.ts
│       └── playersXML.ts
├── lua
│   └── lib
├── main.ts
├── maps
│   ├── activeChargeToZazzActive.ts
│   ├── activeSlotRenderMap.ts
│   ├── builders
│   │   └── actionSetBuilderMap.ts
│   ├── collectiblePrefixes.ts
│   ├── compatibility
│   │   ├── EIDColorMap.ts
│   │   └── EIDMap.ts
│   ├── conditionalToFunctionMap.ts
│   ├── corruption
│   │   └── responses
│   │       └── entityCategoryToResponseMap.ts
│   ├── data
│   │   ├── moddedEntityIDToModMap.ts
│   │   ├── moddedEntityIDToNameSubType.ts
│   │   ├── name
│   │   │   ├── bombEntityNameMap.ts
│   │   │   ├── championColorNameMap.ts
│   │   │   ├── conditionToNameMap.ts
│   │   │   ├── damageFlagNameMap.ts
│   │   │   ├── effectNameMap.ts
│   │   │   ├── entityCategoryNameMap.ts
│   │   │   ├── familiarNameMap.ts
│   │   │   ├── gridEntityTypeNameMap.ts
│   │   │   ├── gridIDNameMap.ts
│   │   │   ├── itemConfigChargeTypeNameMap.ts
│   │   │   ├── itemPoolTypeNameMap.ts
│   │   │   ├── itemTagNameMap.ts
│   │   │   ├── itemTypeNameMap.ts
│   │   │   ├── levelStageNameMap.ts
│   │   │   ├── npcFlagNameMap.ts
│   │   │   ├── npcNameMap.ts
│   │   │   ├── pickupNameMap.ts
│   │   │   ├── pickupTypeNameMap.ts
│   │   │   ├── roomTypeNameMap.ts
│   │   │   └── tearVariantNameMap.ts
│   │   ├── npc
│   │   │   ├── modded
│   │   │   ├── NPCMaxHitPointsMap.ts
│   │   │   └── NPCSizeMap.ts
│   │   ├── pickups
│   │   │   └── collectibles
│   │   │       ├── collectibleTypeItemPoolMap.ts
│   │   │       └── modded
│   │   │           └── moddedCollectibleTypeItemPoolMap.ts
│   │   ├── sounds
│   │   │   └── soundLengths.ts
│   │   └── xmlParsed
│   └── modes
│       ├── JERUSALEMData.ts
│       ├── modeInitMap.ts
│       ├── modeMap.ts
│       ├── MYDOOMData.ts
│       ├── SOPHOSData.ts
│       └── ZIPBOMBER
│           └── extractPickupBurnTimeMap.ts
├── mod.ts
├── objects
│   ├── deleted
│   ├── general
│   └── modes
│       ├── BATTLEYEData.ts
│       ├── CRYPTOLOCKERData.ts
│       ├── HAPPY99Data.ts
│       ├── HICURDISMOSData.ts
│       ├── ILOVEYOUData.ts
│       ├── JERUSALEMData.ts
│       ├── MEMZData.ts
│       ├── MORRISData.ts
│       ├── MYDOOMData.ts
│       ├── REVETONData.ts
│       ├── SOPHOSData.ts
│       ├── SPYWIPERData.ts
│       ├── VCSData.ts
│       └── ZIPBOMBERData.ts
├── sets
│   ├── data
│   │   ├── modded
│   │   │   ├── fiendFolio
│   │   │   └── ModdedFlyingNPCSet.ts
│   │   └── npc
│   │       ├── BossNPCSet.ts
│   │       └── FlyingNPCSet.ts
│   ├── funnyActionTexts.ts
│   ├── workingCollectibleEffects.ts
│   └── zazzSets.ts
└── types
    ├── compatibility
    ├── corruption
    │   ├── LogicResponseUnion.ts
    │   └── SpawnResponseUnion.ts
    ├── data
    │   ├── IDTypes.ts
    │   └── nameSubType.ts
    ├── general
    │   ├── Builder.ts
    │   ├── EntityUnion.ts
    │   ├── Mutable.ts
    │   ├── Percentage.ts
    │   └── Range.ts
    └── modes

```

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\evaluateCache.ts`:

```````ts
import { CacheFlag, ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";
import { playerStatsEvaluateCache } from "../features/general/playerStats";
import { modeEvaluateCacheTearColor } from "../features/modes/mode";

export function evaluateCacheInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.EVALUATE_CACHE, main);
  mod.AddCallback(ModCallback.EVALUATE_CACHE, tearColor, CacheFlag.TEAR_COLOR);
}

function main(player: EntityPlayer, cacheFlag: CacheFlag) {
  playerStatsEvaluateCache(player, cacheFlag);
}

function tearColor(player: EntityPlayer) {
  modeEvaluateCacheTearColor(player);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\playerCollectibleAdded.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";

export function postPlayerCollectibleAddedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED, main);
}

function main(player: EntityPlayer, collectibleType: CollectibleType) {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\playerCollectibleRemoved.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import {
  invertedItemEffectsPostZazzActiveCollectibleRemoved,
  invertedItemEffectsPostZazzPassiveCollectibleRemoved,
} from "../features/corruption/effects/callbacks/postZazzRemoved";
import { isZazzinatorActive, isZazzinatorPassive } from "../sets/zazzSets";

export function postPlayerCollectibleRemovedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED,
    mainZazzRemoved,
  );
}

function mainZazzRemoved(
  player: EntityPlayer,
  collectibleType: CollectibleType,
) {
  if (isZazzinatorPassive(collectibleType)) {
    invertedItemEffectsPostZazzPassiveCollectibleRemoved(
      player,
      collectibleType,
    );
  } else if (isZazzinatorActive(collectibleType)) {
    invertedItemEffectsPostZazzActiveCollectibleRemoved(player, collectibleType);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\playerTakeDMG.ts`:

```````ts
import type { DamageFlag } from "isaac-typescript-definitions";
import {
  EntityType,
  ModCallback,
  PlayerVariant,
} from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { triggerOnDamageActions } from "../classes/corruption/actions/OnDamageAction";
import { PlayerTypeCustom } from "../enums/general/PlayerTypeCustom";
import { temporaryItemsPlayerTakeDMG } from "../features/general/temporaryItems";
import { iloveyouPlayerTakeDMG } from "../features/modes/ILOVEYOU/ILOVEYOU";
import { fprint } from "../helper/printHelper";

// Add new callback for every use case, unless order is needed.
export function playerTakeDMGInit(mod: ModUpgraded): void {
  mod.AddCallback(
    ModCallback.ENTITY_TAKE_DMG,
    temporaryItems,
    EntityType.PLAYER,
  );
  mod.AddCallback(
    ModCallback.ENTITY_TAKE_DMG,
    onDamageAction,
    EntityType.PLAYER,
  );
  mod.AddCallbackCustom(
    ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER,
    iloveyou,
    PlayerVariant.PLAYER,
  );
}

function temporaryItems(
  entity: Entity,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  fprint("playerTakeDMGInit: temporaryItems");
  return temporaryItemsPlayerTakeDMG(
    entity,
    amount,
    damageFlags,
    source,
    countdownFrames,
  );
}

function onDamageAction(
  entity: Entity,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  return triggerOnDamageActions(
    entity,
    amount,
    damageFlags,
    source,
    countdownFrames,
  );
}

function iloveyou(
  player: EntityPlayer,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  if (player.GetPlayerType() !== PlayerTypeCustom.DELETED_ILOVEYOU) {
    return undefined;
  }
  return iloveyouPlayerTakeDMG(
    player,
    amount,
    damageFlags,
    source,
    countdownFrames,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postBombExploded.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { bombInventoryPostBombExploded } from "../features/corruption/inventory/bombInventory";
import { triggerOnBombExplodeActions } from "../classes/corruption/actions/OnBombExplodeAction";

// Add new callback for every use case, unless order is needed.
export function postBombExplodedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_BOMB_EXPLODED, main);
}

function main(bomb: EntityBomb) {
  bombInventoryPostBombExploded(bomb);
  triggerOnBombExplodeActions(bomb);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postBombInitLate.ts`:

```````ts
import { ModCallbackCustom, ModUpgraded } from "isaacscript-common";
import { postCorruptBombInitLate } from "../features/corruption/inventory/bombInventory";

// Add new callback for every use case, unless order is needed.
export function postBombInitLateInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_BOMB_INIT_LATE, mainCorruptBomb);
}

function mainCorruptBomb(bomb: EntityBomb) {
  postCorruptBombInitLate(bomb);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postBombUpdate.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";
import { postCorruptBombUpdate } from "../features/corruption/inventory/bombInventory";

// Add new callback for every use case, unless order is needed.
export function postBombExplodedInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_BOMB_UPDATE, mainCorruptBomb);
}

function mainCorruptBomb(bomb: EntityBomb) {
  postCorruptBombUpdate(bomb);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postEntityKill.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";
import { triggerOnKillActions } from "../classes/corruption/actions/OnKillAction";

export function postEntityKillInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_ENTITY_KILL, main);
}

function main(entity: Entity) {
  triggerOnKillActions(entity);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postEntityRemove.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import {
  CallbackPriority,
  EntityType,
  ModCallback,
} from "isaac-typescript-definitions";
import { fprint } from "../helper/printHelper";
import { getEntityIDFromEntity } from "../helper/entityHelper/entityIDHelper";
import { lateSavePostEntityRemoveLate } from "../features/general/lateSave";

export function postEntityRemoveInit(mod: ModUpgraded): void {
  mod.AddPriorityCallback(
    ModCallback.POST_ENTITY_REMOVE,
    CallbackPriority.LATE,
    lateMain,
  );
  mod.AddCallback(ModCallback.POST_ENTITY_REMOVE, main);
}

function lateMain(entity: Entity) {
  // Should not use this callback for anything other than lateSavePostEntityRemoveLate.
  lateSavePostEntityRemoveLate(entity);
}

function main(entity: Entity) {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postFireTear.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";
import { revetonPostFireTear } from "../features/modes/REVETON/REVETON";

export function postFireTearInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_FIRE_TEAR, main);
}

function main(tear: EntityTear) {
  revetonPostFireTear(tear);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postGameStartedReordered.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { facetPostGameContinuedReordered } from "../classes/Facet";
import { runIndexPostGameContinuedFacet } from "../features/runIndex";
import { postGameStartedReorderedGameEntitySetBuilder } from "../features/data/gameSets/callbacks/gameSetsPostGameStartedReordered";
import { _itemInventoryPostGameContinuedReordered } from "../features/corruption/inventory/callbacks/itemInventoryPostGameContinuedReordered";
import { _customActiveInventoryPostGameContinuedReordered } from "../features/corruption/inversion/customActivePostGameContinuedReordered";

export function postGameStartedReorderedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_GAME_STARTED_REORDERED,
    postGameStartedReordered,
    undefined,
  );
}

function postGameStartedReordered(isContinued: boolean) {
  if (isContinued) {
    facetPostGameContinuedReordered();
    runIndexPostGameContinuedFacet();
    _itemInventoryPostGameContinuedReordered();
    _customActiveInventoryPostGameContinuedReordered();
  } else {
    postGameStartedReorderedGameEntitySetBuilder();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postGreedWaveClear.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { triggerOnGreedWaveClearActions } from "../classes/corruption/actions/OnGreedWaveClearAction";

// Add new callback for every use case, unless order is needed.
export function postGreedWaveClearInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_GREED_MODE_WAVE, main);
}

function main(_oldWave: int, _newWave: int) {
  triggerOnGreedWaveClearActions();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postGridEntityCollision.ts`:

```````ts
import { SoundEffect } from "isaac-typescript-definitions";
import { ModCallbackCustom, ModUpgraded, sfxManager } from "isaacscript-common";

export function postGridEntityCollisionInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_GRID_ENTITY_COLLISION, main);
}

// Inactive.
function main(gridEntity: GridEntity, entity: Entity) {
  sfxManager.Play(SoundEffect.BATTERY_CHARGE);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postItemPickup.ts`:

```````ts
import { ItemType } from "isaac-typescript-definitions";
import {
  getPlayerIndex,
  ModCallbackCustom,
  ModUpgraded,
  PickingUpItem,
  PickingUpItemCollectible,
  PickingUpItemTrinket,
} from "isaacscript-common";
import { invertedPostItemPickupCollectible } from "../features/corruption/inversion/callbacks/invertedPostItemPickupCollectible";
import { fprint } from "../helper/printHelper";

export function postItemPickupInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_ITEM_PICKUP, main);
}

function main(player: EntityPlayer, pickingUpItem: PickingUpItem) {
  if (pickingUpItem.itemType === ItemType.TRINKET) {
    mainTrinketPickup(player, pickingUpItem);
  } else if (pickingUpItem.itemType !== ItemType.NULL) {
    mainCollectiblePickup(player, pickingUpItem);
  }
}

function mainCollectiblePickup(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemCollectible,
) {
  invertedPostItemPickupCollectible(player, pickingUpItem);
}

function mainTrinketPickup(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemTrinket,
) {
  fprint(
    `postItemPickup: ${getPlayerIndex(
      player,
    )} is picking up trinket of subType: ${pickingUpItem.subType}`,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNewLevel.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";

export function postNewLevelInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_NEW_LEVEL, main);
}

function main() {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNewLevelReordered.ts`:

```````ts
import { ModCallbackCustom, ModUpgraded } from "isaacscript-common";
import { triggerOnFloorActions } from "../classes/corruption/actions/OnFloorAction";

export function postNewLevelReorderedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_NEW_LEVEL_REORDERED, main);
}

function main() {
  // temporaryItemsPostNewLevelReordered();
  triggerOnFloorActions();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNewRoom.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";

export function postNewRoomInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_NEW_ROOM, main);
}

function main() {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNewRoomReordered.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { triggerOnRoomActions } from "../classes/corruption/actions/OnRoomAction";
import { backdropHelperPostNewRoomReordered } from "../features/general/backdropHelper";
import { floorColorHelperPostNewRoomReordered } from "../features/general/floorColorHelper";
import { lastRoomVisitedPostNewRoomReordered } from "../features/general/lastRoomVisited";
import { temporaryItemsPostNewRoomReordered } from "../features/general/temporaryItems";
import { iLoveYouPostNewRoom as iLoveYouPostNewRoomReordered } from "../features/modes/ILOVEYOU/ILOVEYOU";

export function postNewRoomReorderedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_NEW_ROOM_REORDERED, main);
}

function main() {
  lastRoomVisitedPostNewRoomReordered();
  backdropHelperPostNewRoomReordered();
  floorColorHelperPostNewRoomReordered();
  temporaryItemsPostNewRoomReordered();
  iLoveYouPostNewRoomReordered();
  triggerOnRoomActions();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNPCInitLate.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { CallbackPriority } from "isaac-typescript-definitions";

export function postNPCInitLateInit(mod: ModUpgraded): void {
  mod.AddPriorityCallbackCustom(
    ModCallbackCustom.POST_NPC_INIT_LATE,
    CallbackPriority.EARLY,
    main,
  );
}

function main(npc: EntityNPC) {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postNPCUpdate.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { fprint } from "../helper/printHelper";

export function postNPCUpdateInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.PRE_NPC_UPDATE, main);
}

function main(entity: Entity): boolean | undefined {
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPeffectUpdateReordered.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { fprint } from "../helper/printHelper";

export function postPeffectUpdateReorderedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED, main);
}

function main(player: EntityPlayer) {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPickupChanged.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { PickupVariant } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { invertedPostPickupChanged } from "../features/corruption/inversion/callbacks/invertedPostPickupChanged";
import { isZazzinatorAny } from "../sets/zazzSets";

export function postPickupChangedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PICKUP_CHANGED, main);
}

function main(
  pickup: EntityPickup,
  oldVariant: PickupVariant,
  oldSubType: int,
  newVariant: PickupVariant,
  newSubType: int,
) {
  /**
   * Going from any pickup --> zazzinator collectible should NOT update the pickup, and instead
   * determine if the change was due to the pre_get_pedestal morph or some other reason which should
   * be dealt with.
   *
   * If the pedestal is not in the pre_get_pedestal stage, and the item is zazz, it means the zazz
   * item has either spawned accidentally, fallen off the player (e.g butter!) or an inverted active
   * item has been swapped out.
   */
  if (
    newVariant === PickupVariant.COLLECTIBLE &&
    isZazzinatorAny(newSubType as CollectibleType)
  ) {
    return;
  }

  // if (isZazzinatorAny(oldSubType as CollectibleType)) { return; }
  invertedPostPickupChanged(
    pickup,
    oldVariant,
    oldSubType,
    newVariant,
    newSubType,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPickupCollect.ts`:

```````ts
import { PickupVariant } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { nonInvertedBombPostPickupCollect } from "../features/corruption/inversion/callbacks/bombCollection";
import { nonInvertedCoinPostPickupCollect } from "../features/corruption/inversion/callbacks/coinCollection";
import { triggerOnPickupCollectActions } from "../classes/corruption/actions/OnPickupCollectAction";

export function postPickupCollectInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PICKUP_COLLECT, main);
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PICKUP_COLLECT,
    mainCoinCollection,
    PickupVariant.COIN,
  );
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PICKUP_COLLECT,
    mainBombCollection,
    PickupVariant.BOMB,
  );
}

function main(pickup: EntityPickup, player: EntityPlayer) {
  triggerOnPickupCollectActions(pickup, player);
}

function mainCoinCollection(pickup: EntityPickup, player: EntityPlayer) {
  nonInvertedCoinPostPickupCollect(pickup, player);
}

function mainBombCollection(pickup: EntityPickup, player: EntityPlayer) {
  nonInvertedBombPostPickupCollect(pickup, player);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPickupInitFirst.ts`:

```````ts
import { PickupVariant } from "isaac-typescript-definitions";
import { ModCallbackCustom, ModUpgraded } from "isaacscript-common";
import { sophosPostCollectibleInitFirst } from "../features/modes/SOPHOS/SOPHOS";

export function postPickupInitFirst(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PICKUP_INIT_FIRST,
    main,
    PickupVariant.COLLECTIBLE,
  );
}

function main(pickup: EntityPickup) {
  sophosPostCollectibleInitFirst(pickup as EntityPickupCollectible);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPickupInitLate.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { PickupVariant } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { postCollectibleInitLateZazzinator } from "../features/corruption/inventory/callbacks/postPickupChangedToInverted";
import { updatePickup } from "../helper/deletedSpecific/inversion/updateInverted";
import { isZazzinatorAny } from "../sets/zazzSets";

export function postPickupInitLate(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PICKUP_INIT_LATE, all);
}

function all(pickup: EntityPickup) {
  if (
    pickup.Variant === PickupVariant.COLLECTIBLE &&
    isZazzinatorAny(pickup.SubType as CollectibleType)
  ) {
    postCollectibleInitLateZazzinator(pickup);
  }
  updatePickup(pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPlayerChangeStat.ts`:

```````ts
import { ModCallbackCustom } from "isaacscript-common";
import type { ModUpgraded, PlayerStat } from "isaacscript-common";
import { triggerOnStatActions } from "../classes/corruption/actions/OnStatAction";

export function postPlayerStatChangedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PLAYER_CHANGE_STAT, main);
}

function main<T extends PlayerStat>(
  player: EntityPlayer,
  statType: T,
  difference: int,
) {
  triggerOnStatActions(player, statType, difference);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPlayerChangeType.ts`:

```````ts
import { PlayerType } from "isaac-typescript-definitions";
import { ModCallbackCustom, ModUpgraded } from "isaacscript-common";
import { postPlayerChangeTypeMode } from "../features/modes/mode";

export function postPlayerChangeTypeInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PLAYER_CHANGE_TYPE, main); // 35
}

// ModCallback.PRE_PICKUP_COLLISION (35)
function main(
  player: EntityPlayer,
  oldCharacter: PlayerType,
  newCharacter: PlayerType,
) {
  postPlayerChangeTypeMode(player, oldCharacter, newCharacter);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPlayerFatalDamage.ts`:

```````ts
import { PlayerVariant } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { PlayerTypeCustom } from "../enums/general/PlayerTypeCustom";
import { happy99PostPlayerFatalDamage } from "../features/modes/HAPPY99/HAPPY99";
import { iloveyouPostPlayerFatalDamage } from "../features/modes/ILOVEYOU/ILOVEYOU";
import { playerInversionPostPlayerFatalDamage } from "../helper/deletedSpecific/inversion/playerInversion";
import { triggerOnDeathActions } from "../classes/corruption/actions/OnDeathAction";

export function postPlayerFatalDamageInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE, main);
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE,
    happy99,
    PlayerVariant.PLAYER,
    PlayerTypeCustom.DELETED_HAPPY99,
  );
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE,
    iloveyou,
    PlayerVariant.PLAYER,
    PlayerTypeCustom.DELETED_ILOVEYOU,
  );
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE,
    corruption,
    PlayerVariant.PLAYER,
  );
}

function happy99(player: EntityPlayer): boolean | undefined {
  return happy99PostPlayerFatalDamage(player);
}

function iloveyou(player: EntityPlayer): boolean | undefined {
  return iloveyouPostPlayerFatalDamage(player);
}

function corruption(player: EntityPlayer): boolean | undefined {
  return playerInversionPostPlayerFatalDamage(player);
}

function main(player: EntityPlayer): boolean | undefined {
  triggerOnDeathActions(player);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPlayerInit.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { fprint } from "../helper/printHelper";

export function postPlayerInitInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_PLAYER_INIT, main);
}

function main(player: EntityPlayer) {
  fprint("POST_PLAYER_INIT");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPlayerInitFirst.ts`:

```````ts
import { PlayerVariant } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { modePostPlayerInitFirst as modePostPlayerInitDeletedFirst } from "../features/modes/mode";
import { mainPCPostPlayerInitDeletedFirst } from "../features/pc/callbacks/pcPostPlayerInitFirst";
import {
  isPlayerNormalDeleted,
  isPlayerTaintedDeleted,
} from "../helper/deletedSpecific/deletedHelper";

export function postPlayerInitFirstInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_INIT_FIRST,
    normalDeletedInit,
    PlayerVariant.PLAYER,
  );
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_PLAYER_INIT_FIRST,
    taintedDeletedInit,
    PlayerVariant.PLAYER,
  );
}

function normalDeletedInit(player: EntityPlayer) {
  if (isPlayerNormalDeleted(player)) {
    mainPCPostPlayerInitDeletedFirst(player);
    modePostPlayerInitDeletedFirst(player);
  }
}

function taintedDeletedInit(player: EntityPlayer) {
  if (isPlayerTaintedDeleted(player)) {
    mainPCPostPlayerInitDeletedFirst(player);
    modePostPlayerInitDeletedFirst(player);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postPurchase.ts`:

```````ts
import { ModCallbackCustom } from "isaacscript-common";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnPurchaseActions } from "../classes/corruption/actions/OnPurchaseAction";

export function postPurchaseInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_PURCHASE, main);
}

function main(player: EntityPlayer, pickup: EntityPickup) {
  triggerOnPurchaseActions(player, pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postRender.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { uiPCPostRender } from "../features/pc/uiPC";

export function postRenderInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_RENDER, main);
}

function main() {
  uiPCPostRender();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postRoomClear.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { triggerOnRoomClearActions } from "../classes/corruption/actions/OnRoomClearAction";
import { fprint } from "../helper/printHelper";

export function postRoomClearInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.POST_ROOM_CLEAR_CHANGED,
    onRoomClearMain,
    true,
  );
}

function onRoomClearMain() {
  triggerOnRoomClearActions();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postSacrifice.ts`:

```````ts
import { ModCallbackCustom } from "isaacscript-common";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnSacrificeActions } from "../classes/corruption/actions/OnSacrificeAction";

export function postSacrificeInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_SACRIFICE, main);
}

function main(player: EntityPlayer, numSacrifices: int) {
  triggerOnSacrificeActions(player, numSacrifices);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postSlotUse.ts`:

```````ts
import { ModCallbackCustom } from "isaacscript-common";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnSlotUseActions } from "../classes/corruption/actions/OnSlotUseAction";
import { fprint } from "../helper/printHelper";

export function postSlotAnimationChanged(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.POST_SLOT_ANIMATION_CHANGED, main);
}

function main(
  slot: Entity,
  previousAnimation: string,
  currentAnimation: string,
) {
  fprint(`Slot animation changed: ${previousAnimation} to ${currentAnimation}`);
  triggerOnSlotUseActions(slot, previousAnimation, currentAnimation);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postUpdate.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";

export function postUpdateInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_UPDATE, main);
}

function main() {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postUseCard.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import type { CardType, UseFlag } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnCardUseActions } from "../classes/corruption/actions/OnCardUseAction";

export function postUseCardInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_USE_CARD, main);
}

function main(
  cardType: CardType,
  player: EntityPlayer,
  _useFlags: BitFlags<UseFlag>,
) {
  triggerOnCardUseActions(cardType, player);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postUseItem.ts`:

```````ts
import type { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { CollectibleTypeCustom } from "../enums/general/CollectibleTypeCustom";
import { bitflipPostUseItem } from "../features/items/bitflip";
import { d14PostUseItem } from "../features/items/d14";
import { extractPostUseItem } from "../features/items/extract";
import { extractFirePostUseItem } from "../features/items/extractVariants/extractFire";
import { eye1PostUseItem } from "../features/items/eyes/eye1";
import { eye2PostUseItem } from "../features/items/eyes/eye2";
import { eye3PostUseItem } from "../features/items/eyes/eye3";
import { trashPostUseItem } from "../features/items/trash";
import { triggerOnActiveUseActions } from "../classes/corruption/actions/OnActiveUseAction";

export function postUseItemInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_USE_ITEM, main);
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainBitflip,
    CollectibleTypeCustom.BITFLIP,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainBitflip,
    CollectibleTypeCustom.BITFLIP_PINK,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainBitflip,
    CollectibleTypeCustom.BITFLIP_BLUE,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainD14,
    CollectibleTypeCustom.D14,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainTrash,
    CollectibleTypeCustom.TRASH,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainExtract,
    CollectibleTypeCustom.EXTRACT,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainExtractFire,
    CollectibleTypeCustom.EXTRACT_FIRE,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainEye3,
    CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainEye2,
    CollectibleTypeCustom.MYDOOM_EYE_STAGE_2,
  );
  mod.AddCallback(
    ModCallback.POST_USE_ITEM,
    mainEye1,
    CollectibleTypeCustom.MYDOOM_EYE_STAGE_1,
  );
}

function mainBitflip(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return bitflipPostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainD14(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return d14PostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainTrash(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return trashPostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainExtract(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return extractPostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainExtractFire(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return extractFirePostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainEye3(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return eye3PostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainEye2(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return eye2PostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function mainEye1(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
) {
  return eye1PostUseItem(
    collectibleType,
    rng,
    player,
    useFlags,
    activeSlot,
    customVarData,
  );
}

function main(
  collectibleType: CollectibleType,
  _rng: RNG,
  player: EntityPlayer,
  _useFlags: BitFlags<UseFlag>,
  _activeSlot: int,
  _customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  triggerOnActiveUseActions(player, collectibleType);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\postUsePill.ts`:

```````ts
import { ModCallback, RoomType } from "isaac-typescript-definitions";
import type { PillEffect, UseFlag } from "isaac-typescript-definitions";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnPillUseActions } from "../classes/corruption/actions/OnPillUseAction";

export function postUsePillInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.POST_USE_PILL, main);
}

function main(
  pillEffect: PillEffect,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
) {
  triggerOnPillUseActions(pillEffect, player, useFlags);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preCustomRevive.ts`:

```````ts
import { ModCallbackCustom } from "isaacscript-common";
import type { ModUpgraded } from "isaacscript-common";
import { triggerOnReviveActions } from "../classes/corruption/actions/OnReviveAction";

export function preCustomReviveInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(
    ModCallbackCustom.PRE_CUSTOM_REVIVE,
    triggerOnReviveActions,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preGameExit.ts`:

```````ts
import { CallbackPriority, ModCallback } from "isaac-typescript-definitions";
import { fprint } from "../helper/printHelper";
import { facetPreGameExit } from "../classes/Facet";
import type { ModUpgraded } from "isaacscript-common";
import { isLeavingGamePreGameExitEarly } from "../features/general/isLeavingGame";
import { _preGameExitRemoveInvertedCollectibleActions } from "../features/corruption/effects/playerEffects";

export function preGameExitInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.PRE_GAME_EXIT, main); // 35
  mod.AddPriorityCallback(
    ModCallback.PRE_GAME_EXIT,
    CallbackPriority.EARLY,
    mainEarly,
  ); // 35
}

function mainEarly(shouldSave: boolean) {
  isLeavingGamePreGameExitEarly(shouldSave);
}

function main(shouldSave: boolean) {
  fprint(`PRE_GAME_EXIT: ${shouldSave}`);
  if (shouldSave) {
    // The run has been saved, but not ended:
    runSavedMain();
  } else {
    // The run has ended:
    runEndedMain();
  }
}

function runEndedMain() {
  facetPreGameExit();
}

function runSavedMain() {
  _preGameExitRemoveInvertedCollectibleActions();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preGetPedestal.ts`:

```````ts
import type { ModUpgraded } from "isaacscript-common";
import { ModCallbackCustom } from "isaacscript-common";
import { pickupInversionPreGetPedestalCollectible } from "../features/corruption/inversion/callbacks/invertedPreGetPedestalCollectible";

export function preGetPedestalInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.PRE_GET_PEDESTAL, main); // 35
}

// ModCallback.PRE_PICKUP_COLLISION (35)
function main(
  player: EntityPlayer,
  pickup: EntityPickupCollectible,
): boolean | undefined {
  return pickupInversionPreGetPedestalCollectible(player, pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preItemPickup.ts`:

```````ts
import { ItemType } from "isaac-typescript-definitions";
import {
  ModCallbackCustom,
  ModUpgraded,
  PickingUpItem,
  PickingUpItemCollectible,
  PickingUpItemTrinket,
} from "isaacscript-common";
import { invertedPreItemPickupCollectible } from "../features/corruption/inversion/callbacks/invertedPreItemPickupCollectible";

export function preItemPickupInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.PRE_ITEM_PICKUP, main);
}

function main(player: EntityPlayer, pickingUpItem: PickingUpItem) {
  if (pickingUpItem.itemType === ItemType.TRINKET) {
    mainTrinketPickup(player, pickingUpItem);
  } else if (pickingUpItem.itemType !== ItemType.NULL) {
    mainCollectiblePickup(player, pickingUpItem);
  }
}

function mainCollectiblePickup(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemCollectible,
) {
  invertedPreItemPickupCollectible(player, pickingUpItem);
}

function mainTrinketPickup(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemTrinket,
) {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preNewLevel.ts`:

```````ts
import { ModCallbackCustom, ModUpgraded } from "isaacscript-common";
import { temporaryItemsPreNewLevel } from "../features/general/temporaryItems";

export function preNewLevelReorderedInit(mod: ModUpgraded): void {
  mod.AddCallbackCustom(ModCallbackCustom.PRE_NEW_LEVEL, main);
}

function main(player: EntityPlayer) {
  temporaryItemsPreNewLevel(player);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\prePickupCollision.ts`:

```````ts
import { ModUpgraded } from "isaacscript-common";

// Add new callback for every use case, unless order is needed.
export function prePickupCollisionInit(mod: ModUpgraded): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\prePlayerCollision.ts`:

```````ts
import { ModCallback, PlayerVariant } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";
import { PlayerTypeCustom } from "../enums/general/PlayerTypeCustom";
import { iloveyouPlayerCollision } from "../features/modes/ILOVEYOU/ILOVEYOU";

// Add new callback for every use case, unless order is needed.
export function prePlayerCollisionInit(mod: ModUpgraded): void {
  mod.AddCallback(
    ModCallback.PRE_PLAYER_COLLISION,
    iloveyou,
    PlayerVariant.PLAYER,
  );
}

function iloveyou(player: EntityPlayer, collider: Entity): boolean | undefined {
  if (player.GetPlayerType() !== PlayerTypeCustom.DELETED_ILOVEYOU) {
    return undefined;
  }
  return iloveyouPlayerCollision(player, collider);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\callbacks\preSpawnClearAward.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModUpgraded } from "isaacscript-common";

// Add new callback for every use case, unless order is needed.
export function preSpawnClearAwardInit(mod: ModUpgraded): void {
  mod.AddCallback(ModCallback.PRE_SPAWN_CLEAR_AWARD, mainPreSpawnClearAward);
}

function mainPreSpawnClearAward(
  rng: RNG,
  spawnPosition: Vector,
): boolean | undefined {
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\Action.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import { ActionOrigin } from "../../../enums/corruption/actions/ActionOrigin";
import type { ActionOriginType } from "../../../enums/corruption/actions/ActionOrigin";
import type { ActionType } from "../../../enums/corruption/actions/ActionType";
import { Morality } from "../../../enums/corruption/Morality";

import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { Range } from "../../../types/general/Range";
import {
  randomInRange,
  rangeToString,
  validifyRange,
} from "../../../types/general/Range";

import type { Response } from "../responses/Response";
import { arrayEquals } from "isaacscript-common";

const EMPTY_ACTION_MORALITY = Morality.NEUTRAL;
const TRIGGER_AFTER_THEN_REMOVE_ACTIVATION_NUMBER = 0;
const STARTING_INTERVAL_COUNTER_NUMBER = 1;
const DEFAULT_INTERVAL = 1;
const DEFAULT_FLAG_FOR_REMOVAL = false;
const NO_RESPONSE_TEXT = "do nothing";
const DEFAULT_PERMANENCE = false;

/**
 * Actions are containers which hold Responses. After the Action has passed all its 'checks', it
 * will trigger the responses it holds. Usually Actions are tied to Callbacks. Actions may also have
 * additional properties which modify their behavior.
 *
 * @example Every 3 - 5 rooms, trigger response.
 */
export abstract class Action {
  readonly actionType!: ActionType;
  r?: Response;
  oat?: string;
  o?: ActionOriginType;
  p?: boolean;
  oc?: EIDColorShortcut;

  /**
   * When using getMorality() on the Action, this value will return instead of looking at the
   * Actions responses Moralities.
   */
  om?: Morality;

  /**
   * Distance between firing.
   *
   * @example "Every 3 rooms", get brimstone.
   * @example "Every 1-5 rooms", get brimstone.
   * @example If not specified defaults to every time: "Every room", get brimstone.
   */
  i?: Range | number;

  /**
   * Only fires after X triggers. Once triggered, will be disabled.
   *
   * @example "After 3 rooms", get brimstone. --> activateAfter: 3
   */
  fatr?: number;

  /** Used by interval property, shouldn't be changed. */
  ic?: number;

  /**
   * Indicates that the Action should be removed from whatever list or container it is being held
   * in. If this is set to true, the Action will not be removed immediately.An Action itself does
   * not know where it is being stored: so it has to 'signal' to tell its outer components it should
   * be removed.
   *
   * Will not be removed if the Action also has the 'permanent' tag enabled, but will stay flagged.
   *
   * @example In triggerAllPlayerActionsByType(), it will do a 'garbage disposal' at the end,
   *          removing actions with this tag from the player.
   */
  ffR?: boolean;

  /**
   * Get the assigned EID Color used to represent the Action. This can either be derived from the
   * Morality or overridden with overrideTextColor().
   */
  getTextColor(): EIDColorShortcut | undefined {
    return this.oc;
  }

  /** Override the text color generated to this Action through its Morality. */
  overrideTextColor(color: EIDColorShortcut): this {
    this.oc = color;
    return this;
  }

  /** Get collectibles involved in the Action and all its responses. */
  getInvolvedCollectibles(): readonly CollectibleType[] {
    const response = this.getResponse();
    if (response === undefined) {
      return [];
    }

    return response.getInvolvedCollectibles();
  }

  /** Get the origin of the Action. */
  getOrigin(): ActionOriginType | undefined {
    return this.o;
  }

  /**
   * Retrieves the ID of the temporary action origin, if it exists.
   *
   * @returns The ID of the temporary action origin, or undefined if it doesn't exist.
   */
  getTemporaryActionID(): int | undefined {
    const origin = this.getOrigin();
    if (origin === undefined) {
      return undefined;
    }

    const [actionOrigin, id] = origin;
    return actionOrigin === ActionOrigin.TEMPORARY_ACTION ? id : undefined;
  }

  /**
   * Checks if the origin of the action matches the specified origin type.
   *
   * @param origin The origin type to compare against (e.g [ActionOrigin.TEMPORARY_ACTION, 5]).
   * @returns Returns `true` if the origin matches, `false` otherwise. If the action has no origin,
   *          returns `false`.
   */
  doesOriginMatch(origin: ActionOriginType): boolean {
    const actionOrigin = this.getOrigin();
    if (actionOrigin === undefined) {
      return false;
    }

    return arrayEquals(actionOrigin, origin);
  }

  /**
   * Sets the origin of the Action to a temporary action with the given ID. This will override any
   * previous origin.
   *
   * @param id The ID of the temporary action origin.
   * @returns The Action instance, for chaining.
   */
  setTemporaryActionID(id: int): this {
    this.o = [ActionOrigin.TEMPORARY_ACTION, id];
    return this;
  }

  /**
   * Retrieves the ID of the inverted collectible origin, if it exists.
   *
   * @returns The ID of the inverted collectible origin, or undefined if it doesn't exist.
   */
  getInvertedCollectibleOrigin(): int | undefined {
    const origin = this.getOrigin();
    if (origin === undefined) {
      return undefined;
    }

    const [actionOrigin, id] = origin;
    return actionOrigin === ActionOrigin.INVERTED_COLLECTIBLE ? id : undefined;
  }

  /**
   * Checks if the action is from an inverted collectible.
   *
   * @returns A boolean indicating whether the action is from an inverted collectible.
   */
  isFromInvertedCollectible(): boolean {
    return this.getInvertedCollectibleOrigin() !== undefined;
  }

  /** If an Action is permanent, it can not be rerolled or removed with Action-altering effects. */
  isPermanent(): boolean {
    return this.p ?? DEFAULT_PERMANENCE;
  }

  /** If an Action is permanent, it can not be rerolled or removed with Action-altering effects. */
  setPermanence(permanent: boolean): this {
    this.p = permanent;
    return this;
  }

  /** Adds a Response to the Action. */
  setResponse(response: Response): this {
    this.r = response;
    return this;
  }

  /** Get the Response attached to the Action. */
  getResponse(): Response | undefined {
    return this.r;
  }

  /** Overrides the 'Action' portion of the Action text (when called from getText()). */
  getOverriddenActionText(): string | undefined {
    return this.oat;
  }

  /** Overrides the 'Action' portion of the Action text (when called from getText()). */
  setOverriddenActionText(text: string): this {
    this.oat = text;
    return this;
  }

  /** If the Action wants to be removed. */
  getFlagForRemoval(): boolean {
    return this.ffR ?? DEFAULT_FLAG_FOR_REMOVAL;
  }

  /** If the Action wants to be removed. */
  setFlagForRemoval(flag: boolean): this {
    this.ffR = flag || undefined;
    return this;
  }

  /**
   * Gets the general morality of the Action by looking at the responses. If there are multiple
   * responses, and they differ in Morality, it will return 'Neutral'. If there is an overridden
   * morality, returns that instead. An overridden Morality can be given to the Action with
   * setOverriddenMorality(). Note this will not auto-update if more responses are added.
   */
  getMorality(): Morality {
    const response = this.getResponse();
    if (response === undefined) {
      return EMPTY_ACTION_MORALITY;
    }

    if (this.om !== undefined) {
      return this.om;
    }

    return response.getMorality();
  }

  getOverriddenMorality(): Morality | undefined {
    return this.om;
  }

  setOverriddenMorality(morality: Morality): this {
    this.om = morality;
    return this;
  }

  /**
   * Whether the Action should remove itself after firing X times.
   *
   * @example 'Every 2 - 3 rooms' -> no FATR.
   * @example 'After 2 - 3 rooms' -> 1 FATR.
   * @example 'Every 2 - 3 rooms, up to three times' -> 3 FATR.
   */
  getFireAfterThenRemove(): number | undefined {
    return this.fatr;
  }

  getFireAfterThenRemoveText(): string | undefined {
    const fireAfterThenRemove = this.getFireAfterThenRemove();
    if (fireAfterThenRemove === undefined) {
      return undefined;
    }
    return `after ${fireAfterThenRemove}`;
  }

  /**
   * Whether the Action should remove itself after firing X times.
   *
   * @example 'Every 2 - 3 rooms' -> no FATR.
   * @example 'After 2 - 3 rooms' -> 1 FATR.
   * @example 'Every 2 - 3 rooms, up to three times' -> 3 FATR.
   */
  setFireAfterThenRemove(fireAfterThenRemove: number): this {
    this.fatr = fireAfterThenRemove;
    return this;
  }

  /** Use calculateInterval() instead! */
  getInterval(): number | Range | undefined {
    return this.i;
  }

  /**
   * Returns the interval text based on the interval value. If the interval is undefined, an empty
   * string is returned. If the interval is a number and equals the default interval, an empty
   * string is returned. Otherwise, the interval value is converted to a string and appended with "
   * times".
   *
   * @returns The interval text.
   *
   * @example 1-3 -> "1-3 times"
   */
  getIntervalText(): string {
    const interval = this.getInterval();
    if (interval === undefined) {
      return "";
    }
    if (typeof interval === "number") {
      if (interval === DEFAULT_INTERVAL) {
        return "";
      }
      return `${interval.toString()} times`;
    }
    return `${rangeToString(interval)} times`;
  }

  /** Will validify ranges. */
  setInterval(interval: number | Range): this {
    this.ic = STARTING_INTERVAL_COUNTER_NUMBER;
    this.i = typeof interval === "number" ? interval : validifyRange(interval);
    return this;
  }

  // Function to get the "trigger" part of the action text.
  protected getTriggerText(intervalText: string): string {
    const fireAfterThenRemove = this.getFireAfterThenRemove();
    if (fireAfterThenRemove !== undefined) {
      return fireAfterThenRemove === 1
        ? `the next time ${this.getTriggerClause()}`
        : `for the next ${fireAfterThenRemove} times ${this.getTriggerClause()}`;
    }
    if (intervalText !== "") {
      return `every ${intervalText} times ${this.getTriggerClause()}`;
    }
    return `every time ${this.getTriggerClause()}`;
  }

  // Function to get the specific trigger clause for the action type.
  protected abstract getTriggerClause(): string;

  // Get the action text.
  getActionText(): string {
    // If overridden, use the overridden text.
    if (this.oat !== undefined) {
      return this.oat;
    }

    // Get interval text.
    const intervalText = this.getIntervalText();

    // Combine trigger text and interval text.
    let text = this.getTriggerText(intervalText);

    text += ", "; // Add comma and space for consistency.
    return text;
  }

  // Only get the 'Responses' part of the text.
  getResponseText(eid = true): string {
    const response = this.getResponse();
    return response === undefined
      ? NO_RESPONSE_TEXT
      : response.getText(eid, false);
  }

  getText(): string {
    return `${this.getActionText()} ${this.getResponseText()}`;
  }

  /**
   * Triggers the action, which may or may not fire the actions responses. Tag order:
   *
   * @example Trigger after then remove.
   * @example Interval.
   * @example Fire.
   */
  trigger(triggerData: TriggerData): unknown {
    // Interval
    const interval = this.getInterval();
    if (interval !== undefined) {
      this.ic = 1 + (this.ic ?? STARTING_INTERVAL_COUNTER_NUMBER);
      if (
        this.ic >
        (typeof this.i === "number"
          ? (interval as number)
          : randomInRange(interval as Range))
      ) {
        this.ic = 1;
      } else {
        return;
      }
    }

    this.fire(triggerData);

    // Fire after then remove.
    const currentFireAfterThenRemove = this.getFireAfterThenRemove();
    if (currentFireAfterThenRemove !== undefined) {
      this.setFireAfterThenRemove(currentFireAfterThenRemove - 1);
      if (
        this.getFireAfterThenRemove() ===
        TRIGGER_AFTER_THEN_REMOVE_ACTIVATION_NUMBER
      ) {
        this.ffR = true;
      }
    }

    return true;
  }

  /** Fire the action, triggering its responses. */
  fire(triggerData: TriggerData): void {
    this.getResponse()?.trigger(triggerData);
  }
}

/** Type guard. */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
export function isAction(obj: any): obj is Action {
  return "actionType" in obj;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnActiveUseAction.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";
import { getCollectibleNameWithEIDSetting } from "../../../helper/compatibility/EID/EIDHelper";

const ACTION_TYPE = ActionType.ON_ACTIVE_USE;

/** Triggers every time the player uses an active item. */
/** Represents an action that is triggered when an active item is used. */
export class OnActiveUseAction extends Action {
  override actionType = ACTION_TYPE;
  act?: CollectibleType;

  /**
   * Constructs an instance of the OnActiveUseAction class.
   *
   * @param activeItem The active item to be set. If not provided, it will fire for any active item.
   * @returns The current instance of the OnActiveUseAction class.
   */
  construct(activeItem?: CollectibleType): this {
    this.act = activeItem;
    return this;
  }

  /**
   * Gets the active item associated with this action.
   *
   * @returns The active item or undefined if not set.
   */
  getActiveItem(): CollectibleType | undefined {
    return this.act;
  }

  /**
   * Sets the active item for this action.
   *
   * @param act The active item to set. If not provided, it will fire for any active item.
   */
  setActiveItem(act?: CollectibleType): void {
    this.act = act;
  }

  // Override the trigger clause for OnActiveUseAction.
  protected override getTriggerClause(): string {
    return `you use ${this.getActiveItemText() ?? "an active item"}`;
  }

  // Helper function to get the active item text.
  private getActiveItemText(): string | undefined {
    const activeItem = this.getActiveItem();
    if (activeItem === undefined) {
      return undefined;
    }
    return getCollectibleNameWithEIDSetting(activeItem);
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnActiveUseActions for all players.
 *
 * POST_USE_ITEM callback.
 */
export function triggerOnActiveUseActions(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onActiveUseAction: {
      player,
      active: collectibleType,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnBombExplodeAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_BOMB_EXPLODE;

/** Triggers every time a bomb explodes. */
export class OnBombExplodeAction extends Action {
  override actionType = ACTION_TYPE;

  protected override getTriggerClause(): string {
    return "a bomb explodes";
  }

  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnBombExplodeActions for all players.
 *
 * POST_BOMB_EXPLOSION callback.
 */
export function triggerOnBombExplodeActions(bomb: EntityBomb): void {
  const entity = bomb.Parent;
  // Check if the bomb is from a player.
  if (entity === undefined) {
    return;
  }

  const player = entity.ToPlayer();
  if (player === undefined) {
    return;
  }

  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onBombExplodeAction: {
      bomb,
    },
    spawnPosition: bomb.Position,
    spawnVelocity: bomb.Velocity,
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnCardUseAction.ts`:

```````ts
import type { CardType } from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import { Action } from "./Action";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";

const ACTION_TYPE = ActionType.ON_CARD_USE;

/** Triggers every time the player uses a card. */
/** Represents an action that triggers when a card is used. */
export class OnCardUseAction extends Action {
  override actionType = ACTION_TYPE;
  c?: CardType;

  /**
   * Constructs a new OnCardUseAction.
   *
   * @param card The card to associate with the action. If undefined, the action will trigger for
   *             any card.
   */
  construct(card?: CardType): this {
    this.setCard(card);
    return this;
  }

  /**
   * Gets the card associated with the action.
   *
   * @returns The card associated with the action, or undefined if the action triggers for any card.
   */
  getCard(): CardType | undefined {
    return this.c;
  }

  /**
   * Sets the card associated with the action.
   *
   * @param card The card to associate with the action. If undefined, the action will trigger for
   *             any card.
   * @returns The updated OnCardUseAction instance.
   */
  setCard(card?: CardType): this {
    this.c = card;
    return this;
  }

  protected override getTriggerClause(): string {
    const card = this.getCard();
    return card === undefined ? "you use a card" : `you use ${card}`;
  }

  override trigger(triggerData: TriggerData): void {
    if (this.c !== undefined && triggerData.onCardUseAction?.card !== this.c) {
      return;
    }

    super.trigger(triggerData);
  }
}

/**
 * Triggers all OnCardUseActions for all players.
 *
 * POST_USE_CARD callback.
 */
export function triggerOnCardUseActions(
  card: CardType,
  player: EntityPlayer,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onCardUseAction: {
      player,
      card,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnDamageAction.ts`:

```````ts
import type { DamageFlag } from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import { bitFlagsContainsValue } from "../../../helper/bitflagHelper";
import { isSensibleDamage } from "../../../helper/damageHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { damageFlagToString } from "../../../maps/data/name/damageFlagNameMap";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_DAMAGE;

/** Triggers every time the player is damaged. */
export class OnDamageAction extends Action {
  override actionType = ACTION_TYPE;
  df?: DamageFlag;

  /**
   * Constructs an instance of the OnDamageAction class.
   *
   * @param damageFlag The damage flag to set (optional).
   * @returns The instance of the OnDamageAction class.
   */
  construct(damageFlag?: DamageFlag): this {
    if (damageFlag !== undefined) {
      this.setDamageFlag(damageFlag);
    }
    return this;
  }

  getDamageFlagText(): string {
    const damageFlag = this.df;
    if (damageFlag === undefined) {
      return "";
    }
    return ` from ${damageFlagToString(damageFlag).toLowerCase()}`;
  }

  // Override the trigger clause for OnDamageAction.
  protected override getTriggerClause(): string {
    return `you take damage${this.getDamageFlagText()}`;
  }

  /** Only fires on this damage flag. */
  getDamageFlag(): DamageFlag | undefined {
    return this.df;
  }

  /** May add duplicates. Only fires on this damage flag. */
  setDamageFlag(damageFlag: DamageFlag): this {
    this.df = damageFlag;
    return this;
  }

  override trigger(triggerData: TriggerData): void {
    const onDamageTriggerData = triggerData.onDamageAction;
    if (onDamageTriggerData === undefined) {
      return;
    }

    // Damage flag checking...
    const damageFlag = this.getDamageFlag();
    if (damageFlag === undefined) {
      // No damageFlag specified.
      if (!isSensibleDamage(onDamageTriggerData.damageFlags)) {
        return;
      }
    } else if (
      // A specific damage flag specified.
      !bitFlagsContainsValue(onDamageTriggerData.damageFlags, damageFlag)
    ) {
      return;
    }

    super.trigger({ ...triggerData });
  }
}

/** Triggers all OnDamageActions for all players. */
export function triggerOnDamageActions(
  entity: Entity,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  const player = entity.ToPlayer();
  if (player === undefined) {
    return undefined;
  }

  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onDamageAction: {
      amount,
      damageFlags,
      source,
      countdownFrames,
    },
  });
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnDeathAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_DEATH;

/** Triggers every time the player dies. */
export class OnDeathAction extends Action {
  override actionType = ACTION_TYPE;

  protected override getTriggerClause(): string {
    return "you die";
  }

  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnDeathActions for all players.
 *
 * POST_PLAYER_FATAL_DAMAGE callback.
 */
export function triggerOnDeathActions(player: EntityPlayer): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onDeathAction: {
      player,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnFloorAction.ts`:

```````ts
import type { LevelStage } from "isaac-typescript-definitions";
import { game } from "isaacscript-common";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayersActionsByType } from "../../../features/corruption/effects/playerEffects";
import { addTheS } from "../../../helper/stringHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { levelStageToString } from "../../../maps/data/name/levelStageNameMap";
import { rangeToString } from "../../../types/general/Range";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_FLOOR;

const DEFAULT_INTERVAL = 1;

/**
 * Triggers every floor.
 *
 * @member lS - Fires only on the specified LevelStage.
 */
export class OnFloorAction extends Action {
  override actionType = ACTION_TYPE;
  lS?: LevelStage;

  /**
   * Constructs an instance of the OnFloorAction class.
   *
   * @param levelStage The level stage for the action. Undefined for all.
   * @returns The constructed instance of the OnFloorAction class.
   */
  construct(levelStage?: LevelStage | undefined): this {
    this.lS = levelStage;
    return this;
  }

  /** If set, will only fire on the specified LevelStage. */
  getLevelStage(): LevelStage | undefined {
    return this.lS;
  }

  /** If set, will only fire on the specified LevelStage. */
  setLevelStage(levelStage: LevelStage): this {
    this.lS = levelStage;
    return this;
  }

  protected override getTriggerClause(): string {
    const amount = this.getInterval() ?? 1;
    let intervalNoRange = amount;
    if (typeof intervalNoRange !== "number") {
      intervalNoRange = intervalNoRange[1];
    }

    return (
      this.getLevelStageText(intervalNoRange) ??
      addTheS("you reach a floor", intervalNoRange)
    );
  }

  getLevelStageText(amount: number): string | undefined {
    const { lS: levelStage } = this;
    if (levelStage !== undefined) {
      const name = levelStageToString(levelStage);
      return `${addTheS("visit", amount)} to ${name}`;
    }
    return undefined;
  }

  override getIntervalText(): string {
    const interval = this.getInterval();
    if (interval === undefined) {
      return "";
    }
    if (typeof interval === "number") {
      if (interval === DEFAULT_INTERVAL) {
        return "";
      }
      return `${interval.toString()} `;
    }
    return `${rangeToString(interval)} `;
  }

  override getActionText(): string {
    // If overridden.
    if (this.oat !== undefined) {
      return this.oat;
    }

    let text = "";
    const fireAfterThenRemove = this.getFireAfterThenRemove();
    const interval = this.getInterval() ?? 1;
    let intervalNoRange = interval;
    if (typeof intervalNoRange !== "number") {
      intervalNoRange = intervalNoRange[1];
    }

    if (fireAfterThenRemove === 1 && interval === 1) {
      text += `next ${this.getLevelStageText(intervalNoRange) ?? "floor"}`;
    } else if (fireAfterThenRemove === 1) {
      text += `after ${this.getIntervalText()} ${
        this.getLevelStageText(intervalNoRange) ?? "floor"
      }`;
    } else if (fireAfterThenRemove === undefined) {
      text += `every ${this.getIntervalText()} ${
        this.getLevelStageText(intervalNoRange) ??
        addTheS("floor", intervalNoRange)
      }`;
    } else {
      text += `up to ${fireAfterThenRemove} times, every ${this.getIntervalText()} ${
        this.getLevelStageText(intervalNoRange) ??
        addTheS("floor", intervalNoRange)
      }`;
    }
    text += ", ";
    return text;
  }

  override trigger(triggerData: TriggerData): void {
    const levelStage = this.getLevelStage();
    if (
      levelStage !== undefined &&
      game.GetLevel().GetAbsoluteStage() !== levelStage
    ) {
      return;
    }

    super.trigger(triggerData);
  }
}

/** Triggers all OnFloorActions for all players. */
export function triggerOnFloorActions(): void {
  triggerPlayersActionsByType(ACTION_TYPE, {});
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnGreedWaveClearAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayersActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_GREED_WAVE_CLEAR;

/** Triggers every time a greed wave is cleared. */
export class OnGreedWaveClearAction extends Action {
  override actionType = ACTION_TYPE;

  protected override getTriggerClause(): string {
    return "a Greed wave is cleared";
  }

  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnGreedWaveClearActions for all players.
 *
 * POST_GREED_WAVE_CLEAR callback.
 */
export function triggerOnGreedWaveClearActions(): void {
  triggerPlayersActionsByType(ACTION_TYPE, {});
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnKillAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayersActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_KILL;

/** Triggers every time an NPC is killed. */
// TODO: Update for boss only, etc..
export class OnKillAction extends Action {
  override actionType = ACTION_TYPE;

  // Override the trigger clause for OnKillAction.
  protected override getTriggerClause(): string {
    const intervalText = this.getIntervalText();
    return intervalText === ""
      ? "you kill an enemy"
      : `you kill ${intervalText} enemies`;
  }

  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/** Triggers all OnDamageActions for all players. */
export function triggerOnKillActions(entity: Entity): void {
  triggerPlayersActionsByType(ACTION_TYPE, {
    onKillAction: entity as EntityNPC,
    spawnPosition: entity.Position,
    spawnVelocity: entity.Velocity,
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnObtainAction.ts`:

```````ts
import { getRandomSetElement } from "isaacscript-common";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { FUNNY_ACTION_TEXT_SET } from "../../../sets/funnyActionTexts";
import { Action } from "./Action";

/**
 * Upon the player obtaining the passive or active inverted item, immediately triggers its responses
 * instead of adding the Action to the player. Functionally the same as adding Responses to the
 * player. Will activate every time an Active is picked up, even after putting it down.
 */
export class OnObtainAction extends Action {
  override actionType = ActionType.ON_OBTAIN;

  /**
   * Constructs an instance of the OnObtainAction class.
   *
   * @returns The instance of the OnObtainAction class.
   */
  construct(): this {
    return this;
  }

  /**
   * Overrides any ActionText and provides a 'dummy' value, which is randomly chosen from a set.
   *
   * @example 'On uninstalling isaac, ' ...
   */
  setRandomFunnyActionText(): this {
    this.oat = getRandomSetElement(FUNNY_ACTION_TEXT_SET, undefined);
    return this;
  }

  /** Obtain Actions are identical to naked responses, hence they usually do not have any text. */
  override getActionText(): string {
    // If overridden.
    if (this.oat !== undefined) {
      return this.oat;
    }

    return "";
  }

  protected override getTriggerClause(): string {
    return "";
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnPickupCollectAction.ts`:

```````ts
import type { PickupVariant } from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_PICKUP_COLLECT;

/** Triggers every time the player collects a pickup. */
/**
 * Represents an action that is triggered when a pickup is collected.
 *
 * @remarks The `OnPickupCollectAction` class extends the `Action` class and provides additional
 *          functionality for handling pickup collection events.
 */
export class OnPickupCollectAction extends Action {
  override actionType = ACTION_TYPE;
  pk?: PickupVariant;

  /**
   * Constructs a new instance of the `OnPickupCollectAction` class.
   *
   * @param pickup The pickup variant to associate with the action. If `undefined`, it means any
   *               pickup (provided it works with `ON_PICKUP_COLLECT`).
   * @returns The constructed `OnPickupCollectAction` instance.
   */
  construct(pickup?: PickupVariant): this {
    this.pk = pickup;
    return this;
  }

  /**
   * Gets the pickup variant associated with the action.
   *
   * @returns The pickup variant associated with the action, or `undefined` if no pickup is
   *          associated.
   */
  getPickup(): PickupVariant | undefined {
    return this.pk;
  }

  /**
   * Sets the pickup variant to associate with the action.
   *
   * @param pickup The pickup variant to associate with the action. If `undefined`, it means any
   *               pickup (provided it works with `ON_PICKUP_COLLECT`).
   */
  setPickup(pickup?: PickupVariant): void {
    this.pk = pickup;
  }

  /**
   * Gets the trigger clause for the action.
   *
   * @returns The trigger clause for the action.
   */
  protected override getTriggerClause(): string {
    return "you collect a pickup";
  }

  /**
   * Triggers the action with the specified trigger data.
   *
   * @param triggerData The trigger data to pass to the action.
   */
  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnPickupCollectActions for all players.
 *
 * POST_PICKUP_COLLECT callback.
 */
export function triggerOnPickupCollectActions(
  pickup: EntityPickup,
  player: EntityPlayer,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onPickupCollectAction: {
      player,
      pickup,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnPillUseAction.ts`:

```````ts
import type {
  PillEffect,
  PillColor,
  UseFlag,
  BombVariant,
} from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import { Action } from "./Action";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { getPillColorFromEffect } from "isaacscript-common";

const ACTION_TYPE = ActionType.ON_PILL_USE;

/** Triggers every time the player uses a pill. */
/** Represents an action that is triggered when a pill is used. */
export class OnPillUseAction extends Action {
  override actionType = ACTION_TYPE;
  pe?: PillEffect;
  pc?: PillColor;

  /**
   * Constructs an instance of the OnPillUseAction class.
   *
   * @param pillEffect The pill effect to set (optional).
   * @param pillColor The pill color to set (optional).
   * @returns The instance of the OnPillUseAction class.
   */
  construct(pillEffect?: PillEffect, pillColor?: PillColor): this {
    if (pillEffect !== undefined) {
      this.setPillEffect(pillEffect);
    }
    if (pillColor !== undefined) {
      this.setPillColor(pillColor);
    }
    return this;
  }

  protected override getTriggerClause(): string {
    const pillColor = this.getPillColor();
    const pillEffect = this.getPillEffect();

    if (pillColor !== undefined && pillEffect !== undefined) {
      return `you use a ${pillColor} pill with the ${pillEffect} effect`;
    }
    if (pillColor !== undefined) {
      return `you use a ${pillColor} pill`;
    }
    if (pillEffect !== undefined) {
      return `you use a pill with the ${pillEffect} effect`;
    }
    return "you use a pill";
  }

  /**
   * Sets the pill effect for this action.
   *
   * @param pillEffect The pill effect to set.
   * @returns The instance of the OnPillUseAction class.
   */
  setPillEffect(pillEffect: PillEffect): this {
    this.pe = pillEffect;
    return this;
  }

  getPillEffect(): PillEffect | undefined {
    return this.pe;
  }

  /**
   * Gets the pill color associated with this action.
   *
   * @returns The pill color, or undefined if not set.
   */
  getPillColor(): PillColor | undefined {
    return this.pc;
  }

  /**
   * Sets the pill color for this action.
   *
   * @param pillColor The pill color to set.
   * @returns The instance of the OnPillUseAction class.
   */
  setPillColor(pillColor: PillColor): this {
    this.pc = pillColor;
    return this;
  }

  // TODO: Add pill color text.
  getPillColorText(): string {
    const pillColor = this.getPillColor();
    if (pillColor === undefined) {
      return "";
    }
    return "";
  }

  // TODO: Add pill effect text.
  getPillEffectText(): string {
    const pillEffect = this.getPillEffect();
    if (pillEffect === undefined) {
      return "";
    }
    return "";
  }

  /**
   * Triggers the action with the provided trigger data.
   *
   * @param triggerData The trigger data.
   */
  override trigger(triggerData: TriggerData): void {
    const onPillUseTriggerData = triggerData.onPillUseAction;
    if (onPillUseTriggerData === undefined) {
      return;
    }

    const pillColor = this.getPillColor();
    const pillEffect = this.getPillEffect();

    if (
      (pillColor !== undefined &&
        pillColor !==
          getPillColorFromEffect(onPillUseTriggerData.pillEffect)) ||
      (pillEffect !== undefined &&
        pillEffect !== onPillUseTriggerData.pillEffect)
    ) {
      return;
    }

    super.trigger(triggerData);
  }
}

/** Triggers all OnPillUseActions for all players. */
export function triggerOnPillUseActions(
  pillEffect: PillEffect,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
): boolean | undefined {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onPillUseAction: {
      pillEffect,
      useFlags,
    },
  });
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnPurchaseAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";
import type { PickupID } from "../../../enums/data/ID/PickupID";
import type { PickupType } from "../../../enums/general/PickupType";
import {
  getPickupIDName,
  getPickupTypeFromPickupID,
} from "../../../helper/entityHelper/pickupIDHelper";
import { getEntityIDFromEntity } from "../../../helper/entityHelper/entityIDHelper";
import { pickupTypeToString } from "../../../maps/data/name/pickupTypeNameMap";

const ACTION_TYPE = ActionType.ON_PURCHASE;

/** Triggers every time the player purchases an item or pickup. */
/** Represents an action that is triggered when an item or pickup is purchased. */
export class OnPurchaseAction extends Action {
  override actionType = ACTION_TYPE;
  pk?: PickupID | PickupType;

  /**
   * Constructs an instance of the OnPurchaseAction class.
   *
   * @param pickup The pickup ID or pickup type. If not provided, it will fire for any pickup.
   * @returns The current instance of the OnPurchaseAction class.
   */
  construct(pickup?: PickupID | PickupType): this {
    this.pk = pickup;
    return this;
  }

  /**
   * Gets the pickup associated with this action.
   *
   * @returns The pickup or undefined if not set.
   */
  getPickup(): PickupID | PickupType | undefined {
    return this.pk;
  }

  /**
   * Sets the pickup for this action.
   *
   * @param pickup The pickup to set. If not provided, it will fire for any pickup.
   */
  setPickup(pickup?: PickupID | PickupType): void {
    this.pk = pickup;
  }

  doesPickupMatch(pickup: PickupID): boolean {
    const pk = this.getPickup();
    if (pk === undefined) {
      return true;
    }

    if (typeof pk === "string") {
      return pk === pickup;
    }

    // It's a PickupType.
    return getPickupTypeFromPickupID(pickup) === pk;
  }

  protected override getTriggerClause(): string {
    const pickup = this.getPickup();
    return pickup === undefined
      ? "you purchase an item"
      : `you purchase ${
          typeof pickup === "string"
            ? getPickupIDName(pickup) ?? "an item"
            : pickupTypeToString(pickup)
        }`;
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    const pickup = triggerData.onPurchaseAction?.pickup;
    if (pickup === undefined) {
      return;
    }

    if (!this.doesPickupMatch(getEntityIDFromEntity(pickup) as PickupID)) {
      return;
    }

    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnPurchaseActions for the specified player.
 *
 * POST_PURCHASE_ITEM callback.
 */
export function triggerOnPurchaseActions(
  player: EntityPlayer,
  pickup: EntityPickup,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onPurchaseAction: {
      player,
      pickup,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnReviveAction.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_REVIVE;

/** Triggers when the player dies, reviving them. */
export class OnReviveAction extends Action {
  override actionType = ACTION_TYPE;

  /**
   * Constructs an instance of the OnReviveAction class.
   *
   * @returns The instance of the OnReviveAction class.
   */
  construct(): this {
    return this;
  }

  protected override getTriggerClause(): string {
    return "you revive";
  }

  override trigger(triggerData: TriggerData): void {
    const onDeathTriggerData = triggerData.onDeathAction;
    if (onDeathTriggerData === undefined) {
      return;
    }

    super.trigger({ ...triggerData });
  }
}

/**
 * PRE_CUSTOM_REVIVE callback, return a value to revive the player.
 *
 * The way this works is that
 */
export function triggerOnReviveActions(player: EntityPlayer): int | undefined {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onReviveAction: {
      player,
    },
  });
  return CollectibleType.SAD_ONION;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnRoomAction.ts`:

```````ts
import { RoomType } from "isaac-typescript-definitions";
import { game, getRoomType } from "isaacscript-common";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayersActionsByType } from "../../../features/corruption/effects/playerEffects";
import { addTheS } from "../../../helper/stringHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { roomTypeToString as getRoomNameFromRoomType } from "../../../maps/data/name/roomTypeNameMap";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_ROOM;
const SINGULAR_CHEST_CLAUSE = "visits to the Chest";
const PLURAL_CHEST_CLAUSE = "time you enter the Chest";
const SINGULAR_NUMBER = 1;
const PLURAL_NUMBER = 2;

/** Triggers every floor. */
export class OnRoomAction extends Action {
  override actionType = ACTION_TYPE;
  rT?: RoomType;

  /**
   * Constructs an instance of the OnRoomAction class.
   *
   * @param roomType The room type to set (optional).
   * @returns The instance of the OnRoomAction class.
   */
  construct(roomType?: RoomType): this {
    if (roomType !== undefined) {
      this.setRoomType(roomType);
    }
    return this;
  }

  /** If set, will only fire on the specified RoomType. */
  getRoomType(): RoomType | undefined {
    return this.rT;
  }

  /** If set, will only fire on the specified RoomType. */
  setRoomType(roomType: RoomType): this {
    this.rT = roomType;
    return this;
  }

  getRoomTypeText(amount: number): string | undefined {
    const { rT: roomType } = this;
    if (roomType !== undefined) {
      if (roomType === RoomType.VAULT) {
        if (amount !== 1) {
          return SINGULAR_CHEST_CLAUSE;
        }
        return PLURAL_CHEST_CLAUSE;
      }
      const name = getRoomNameFromRoomType(roomType).toLowerCase();
      return addTheS(name, amount);
    }
    return undefined;
  }

  // Override the trigger clause for OnRoomAction.
  protected override getTriggerClause(): string {
    const amount = this.getInterval() ?? 1;
    let intervalNoRange = amount;
    if (typeof intervalNoRange !== "number") {
      intervalNoRange = intervalNoRange[1];
    }
    return `you enter ${
      this.getRoomTypeText(intervalNoRange) ??
      addTheS("a room", intervalNoRange)
    }`;
  }

  override trigger(triggerData: TriggerData): void {
    const room = game.GetRoom();
    if (!room.IsFirstVisit()) {
      return;
    }

    if (this.rT !== undefined && getRoomType() !== this.rT) {
      return;
    }

    super.trigger(triggerData);
  }
}

/** Triggers all OnRoomActions for all players. */
export function triggerOnRoomActions(): void {
  triggerPlayersActionsByType(ACTION_TYPE, {});
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnRoomClearAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayersActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_ROOM_CLEAR;

/** Triggers every time the player clears a room. */
/** Represents an action that is triggered when a room is cleared. */
export class OnRoomClearAction extends Action {
  override actionType = ACTION_TYPE;

  protected override getTriggerClause(): string {
    return "you clear a room";
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnRoomClearActions for all players.
 *
 * POST_CLEAR_ROOM callback.
 */
export function triggerOnRoomClearActions(): void {
  triggerPlayersActionsByType(ACTION_TYPE, {});
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnSacrificeAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";

const ACTION_TYPE = ActionType.ON_SACRIFICE;

/** Triggers every time the player makes a sacrifice. */
/** Represents an action that is triggered when a sacrifice is made. */
export class OnSacrificeAction extends Action {
  override actionType = ACTION_TYPE;

  protected override getTriggerClause(): string {
    return "you make a sacrifice";
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnSacrificeActions for all players.
 *
 * POST_SACRIFICE callback.
 */
export function triggerOnSacrificeActions(
  player: EntityPlayer,
  numSacrifices: number,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onSacrificeAction: {
      player,
      numSacrifices,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnSlotDestroyAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";
import type { EntityID } from "isaacscript-common";
import { getSlotIDName } from "../../../helper/entityHelper/slotHelper";
import { getEntityIDFromEntity } from "../../../helper/entityHelper/entityIDHelper";

const ACTION_TYPE = ActionType.ON_SLOT_DESTROY;

/** Triggers every time the player destroys a slot. */
export class OnSlotDestroyAction extends Action {
  override actionType = ACTION_TYPE;
  sID?: EntityID;

  /**
   * Constructs an instance of the OnSlotDestroyAction class.
   *
   * @param slotId The slot id to be set. If not provided, it will fire for any slot.
   * @returns The current instance of the OnSlotDestroyAction class.
   */
  construct(slotId?: EntityID): this {
    this.sID = slotId;
    return this;
  }

  /**
   * Gets the slot id associated with this action.
   *
   * @returns The slot id or undefined if not set.
   */
  getSlotID(): EntityID | undefined {
    return this.sID;
  }

  /**
   * Sets the slot id for this action.
   *
   * @param slotId The slot id to set. If not provided, it will fire for any slot.
   */
  setSlotID(slotId?: EntityID): void {
    this.sID = slotId;
  }

  // Override the trigger clause for OnSlotDestroyAction.
  protected override getTriggerClause(): string {
    return `you destroy ${this.getSlotText() ?? "a slot"}`;
  }

  // Helper function to get the slot text.
  private getSlotText(): string | undefined {
    const slotID = this.getSlotID();
    if (slotID === undefined) {
      return undefined;
    }
    return getSlotIDName(slotID);
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    const slot = triggerData.onSlotUseAction?.slot;
    if (slot === undefined) {
      return;
    }

    if (this.sID !== undefined && this.sID !== getEntityIDFromEntity(slot)) {
      return;
    }

    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnSlotDestroyActions for all players.
 *
 * POST_SLOT_DESTROY callback.
 */
export function triggerOnSlotDestroyActions(slot: Entity): void {
  const player = Isaac.GetPlayer(0);
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onSlotDestroyAction: {
      slot,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnSlotUseAction.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Action } from "./Action";
import { getSlotIDName } from "../../../helper/entityHelper/slotHelper";

const ACTION_TYPE = ActionType.ON_SLOT_USE;

/** Triggers every time the player uses a slot. */
/** Represents an action that is triggered when a slot is used. */
export class OnSlotUseAction extends Action {
  override actionType = ACTION_TYPE;
  sID?: EntityID;

  /**
   * Constructs an instance of the OnSlotUseAction class.
   *
   * @param slotId The slot id to be set. If not provided, it will fire for any slot.
   * @returns The current instance of the OnSlotUseAction class.
   */
  construct(slotId?: EntityID): this {
    this.sID = slotId;
    return this;
  }

  /**
   * Gets the slot id associated with this action.
   *
   * @returns The slot id or undefined if not set.
   */
  getSlotID(): EntityID | undefined {
    return this.sID;
  }

  /**
   * Sets the slot id for this action.
   *
   * @param slotId The slot id to set. If not provided, it will fire for any slot.
   */
  setSlotID(slotId?: EntityID): void {
    this.sID = slotId;
  }

  protected override getTriggerClause(): string {
    const slotID = this.getSlotID();
    return slotID === undefined
      ? "you use a slot"
      : `you use the ${getSlotIDName(slotID) ?? "slot"}`;
  }

  /** Triggers the action with the provided trigger data. */
  override trigger(triggerData: TriggerData): void {
    super.trigger({ ...triggerData });
  }
}

/**
 * Triggers all OnSlotUseActions for all players.
 *
 * POST_USE_SLOT callback.
 */
export function triggerOnSlotUseActions(
  slot: Entity,
  _previousAnimation: string,
  _currentAnimation: string,
): void {
  const player = Isaac.GetPlayer(0);
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onSlotUseAction: {
      slot,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actions\OnStatAction.ts`:

```````ts
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { triggerPlayerActionsByType } from "../../../features/corruption/effects/playerEffects";
import { Action } from "./Action";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { PlayerStat } from "isaacscript-common";

const ACTION_TYPE = ActionType.ON_STAT;

/**
 * Triggers every time a player's stat changes.
 *
 * TODO: Prevent firing lots of times in a single frame.
 */
export class OnStatAction extends Action {
  override actionType = ACTION_TYPE;
  stat?: PlayerStat;
  thr?: number;

  construct(stat?: PlayerStat): this {
    this.stat = stat;
    return this;
  }

  getStat(): PlayerStat | undefined {
    return this.stat;
  }

  setStat(stat: PlayerStat): this {
    this.stat = stat;
    return this;
  }

  // Set the threshold for stat difference.
  public setThreshold(threshold: number): this {
    this.thr = threshold;
    return this;
  }

  // Get the threshold for stat difference.
  public getThreshold(): number | undefined {
    return this.thr;
  }

  protected override getTriggerClause(): string {
    const stat = this.getStat();
    const threshold = this.getThreshold();

    if (stat === undefined) {
      return "your stats change"; // Generic clause for undefined stat.
    }
    switch (stat) {
      case PlayerStat.TEAR_FLAG: {
        return "your tear flags change";
      }

      case PlayerStat.TEAR_COLOR: {
        return "your tear color changes";
      }

      case PlayerStat.FLYING: {
        return "you gain or lose flight";
      }

      case PlayerStat.SIZE: {
        return "you change size";
      }

      default: {
        // Handle numerical stats as before.
        if (threshold !== undefined) {
          return `your ${stat} stat ${
            threshold > 0 ? "increases by" : "decreases by"
          } ${Math.abs(threshold)} or more`;
        }
        return `your ${stat} stat changes`;
      }
    }
  }

  override trigger(triggerData: TriggerData): void {
    const onStatTriggerData = triggerData.onStatAction;
    if (onStatTriggerData === undefined) {
      return;
    }

    const { stat } = onStatTriggerData;

    // Check if the stat is numerical.
    if (
      stat === PlayerStat.TEAR_FLAG ||
      stat === PlayerStat.TEAR_COLOR ||
      stat === PlayerStat.FLYING ||
      stat === PlayerStat.SIZE
    ) {
      // Non-numerical stat, trigger the action regardless of difference.
      super.trigger(triggerData);
    }

    const threshold = this.getThreshold();
    if (
      threshold !== undefined &&
      Math.abs(onStatTriggerData.difference) <= threshold
    ) {
      return; // Difference is not above threshold, don't trigger.
    }

    super.trigger(triggerData);
  }
}

/**
 * Triggers all OnStatActions for the player which had their stat changed.
 *
 * POST_STAT_CHANGE callback.
 */
export function triggerOnStatActions(
  player: EntityPlayer,
  stat: PlayerStat,
  difference: int,
): void {
  triggerPlayerActionsByType(player, ACTION_TYPE, {
    player,
    onStatAction: {
      player,
      stat,
      difference,
    },
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actionSets\ActionSet.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import type { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import { Morality } from "../../../enums/corruption/Morality";
import type { ActionSetType } from "../../../enums/corruption/actionSets/ActionSetType";
import { getActionSetThemeSetting } from "../../../features/settings/ActionSetThemeSetting";
import { getEIDMarkupFromShortcut } from "../../../helper/compatibility/EID/EIDHelper";
import { legibleString } from "../../../helper/stringHelper";
import {
  getEIDColorShortcutFromMorality,
  getEIDColorTupleFromTriplet,
} from "../../../maps/compatibility/EIDColorMap";
import type { Action } from "../actions/Action";
import { isAction } from "../actions/Action";
import type { Response } from "../responses/Response";
import { isResponse } from "../responses/Response";
import { NO_EFFECTS_DEFAULT_TEXT } from "../../../constants/actionSetConstants";
import { sortEffectsByMorality } from "../../../helper/deletedSpecific/effects/moralityHelper";

/** ActionSet class. */
export abstract class ActionSet {
  readonly actionSetType!: ActionSetType;
  effects: Array<Action | Response> = [];
  c: EIDColorShortcut | EIDColorTriplet | undefined;

  /** Returns Actions + Responses, does not deepCopy! */
  getEffects(): Array<Action | Response> {
    return this.effects;
  }

  /** Sort effects by Morality. */
  getSortedEffects(): Array<Action | Response> {
    return sortEffectsByMorality(this.effects);
  }

  /**
   * The color/s the ActionSet will adhere to. If no color is specified, will resort to default
   * Morality colors. If an Action or Response has its own color, that will override the color this
   * ActionSet provides it.
   *
   * If a triplet is specified, the first color will be used for positive effects, the second for
   * neutral effects, and the third for negative effects.
   */
  getTheme(): EIDColorShortcut | EIDColorTriplet | undefined {
    return this.c;
  }

  /**
   * Get the EIDColorShortcut for a specific Action or Response in the ActionSet.
   *
   * - If the Action/Response has an overridden color, that will be used.
   * - If the ActionSet has a color set, that will be used.
   * - If the ActionSet has no color set, the default morality color will be used.
   */
  getActionOrResponseColor(
    actionOrResponse: Action | Response,
  ): EIDColorShortcut {
    const overriddenTextColor = actionOrResponse.getTextColor();
    if (overriddenTextColor !== undefined) {
      return overriddenTextColor;
    }
    const morality = actionOrResponse.getMorality();
    if (this.c === undefined || !getActionSetThemeSetting()) {
      return getEIDColorShortcutFromMorality(morality);
    }
    if (typeof this.c === "string") {
      return this.c;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return getEIDColorTupleFromTriplet(this.c)[morality as number]!;
  }

  /**
   * The color/s the ActionSet will adhere to. If no color is specified, will resort to default
   * Morality colors. If an Action or Response has its own color, that will override the color this
   * ActionSet provides it.
   */
  setTheme(c: EIDColorShortcut | EIDColorTriplet | undefined): this {
    this.c = c;
    return this;
  }

  /** Get collectibles mentioned in any actions or responses. */
  getInvolvedCollectibles(): CollectibleType[] {
    const collectibles: CollectibleType[] = [];
    for (const actionOrResponse of this.effects) {
      collectibles.push(...actionOrResponse.getInvolvedCollectibles());
    }
    return collectibles;
  }

  /** Gets only the Responses (does not deepCopy!). */
  getResponses(): Response[] {
    return this.effects.filter(
      (actionOrResponse): actionOrResponse is Response =>
        isResponse(actionOrResponse),
    );
  }

  /** Gets only the Actions (does not deepCopy!). */
  getActions(): Action[] {
    return this.effects.filter((actionOrResponse): actionOrResponse is Action =>
      isAction(actionOrResponse),
    );
  }

  /**
   * Adds one or more actions or responses to the ActionSet. Can provide one action or response,
   * multiple actions or responses or an array of actions or responses. Probably need to update the
   * pickup after calling this function. Does not deepCopy!
   */
  addEffects(...effects: Array<Action | Response>): this {
    this.effects = [...this.effects, ...effects];
    return this;
  }

  /** Get the text describing the ActionSet. */
  getText(eid = true): string {
    let text = "";
    const sortedEffects = this.getSortedEffects();
    for (const actionOrResponse of sortedEffects) {
      text += "#";
      if (eid) {
        // Set color of action / response.
        text += getEIDMarkupFromShortcut(
          actionOrResponse.getTextColor() ??
            this.getActionOrResponseColor(actionOrResponse),
        );
      }
      text += legibleString(actionOrResponse.getText(eid, false));
      if (eid) {
        text += "{{CR}}";
      }
    }
    if (text === "") {
      return NO_EFFECTS_DEFAULT_TEXT;
    }
    return text;
  }

  abstract updateAppearance(entity: Entity): void;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actionSets\Inverted\InvertedActiveActionSet.ts`:

```````ts
import type { ActiveSlot } from "isaac-typescript-definitions";
import {
  CollectibleType,
  ItemConfigChargeType,
  ItemType,
} from "isaac-typescript-definitions";
import { ActionSetType } from "../../../../enums/corruption/actionSets/ActionSetType";
import { fprint } from "../../../../helper/printHelper";
import { getZazzActiveFromCharge } from "../../../../maps/activeChargeToZazzActive";
import { _addInvertedActiveToPlayer } from "../../../facets/CustomActiveFacet";
import { playPickupAnimationWithCustomSprite } from "../../../facets/RenderOverHeadFacet";
import type { Action } from "../../actions/Action";
import type { Response } from "../../responses/Response";
import { InvertedItemActionSet } from "./InvertedItemActionSet";
import { getEIDMarkupFromShortcut } from "../../../../helper/compatibility/EID/EIDHelper";
import { legibleString } from "../../../../helper/stringHelper";
import {
  INVERTED_ACTIVE_EID_ICON,
  NO_EFFECTS_DEFAULT_TEXT,
} from "../../../../constants/actionSetConstants";
import { sortEffectsByMorality } from "../../../../helper/deletedSpecific/effects/moralityHelper";
import type { EIDDescObject } from "../../../../interfaces/compatibility/EIDDescObject";
import { MOD_NAME } from "../../../../constants/mod/modConstants";
import type { CustomActiveData } from "../../../../interfaces/corruption/actionSets/CustomActiveData";
import { getTotalCharge, repeat } from "isaacscript-common";
import type { IfThenResponse } from "../../responses/IfThenResponse";

const DEFAULT_NAME = "Corrupted Active Item";
const DEFAULT_CHARGES = 4;
const DEFAULT_CHARGE_TYPE = ItemConfigChargeType.NORMAL;
const RESPONSE_EID_TEXT = "#{{Blank}} {{Blank}} {{Blank}} {{Blank}} On Use:";
const ACTION_EID_TEXT = "#{{Blank}} {{Blank}} {{Blank}} {{Blank}} While held:";

/** ActionSet class. */
export class InvertedActiveActionSet extends InvertedItemActionSet {
  override actionSetType: ActionSetType = ActionSetType.INVERTED_ACTIVE_ITEM;
  ch?: number;
  chT?: ItemConfigChargeType;

  /** Remove after X uses attribute. */
  rX?: number;

  /** Number of times the item has been used. */
  nu?: number;

  /**
   * Transform after use attribute. After the Inverted Active Item is used, it will immediately
   * transform itself into the specified inverted/non-inverted item (preserving the same slot if it
   * is an active).
   */
  tu?: {
    /** The item to transform into: */
    i: CollectibleType;

    /** Whether the new item should be inverted or non-inverted. */
    iI?: boolean;

    /** How many uses until transformation (undefined is equal to 1). */
    u?: number;
  };

  /**
   * Charge with - if this is enabled, item will not charge normally, instead charging when the
   * Action is triggered.
   */
  cw?: Action;

  /**
   * On use condition - E.g requires a key to use. If the condition is not satisfied, will not be
   * used.
   */
  uc?: IfThenResponse;

  /** Data related to the custom active item this ActionSet is attached to. */
  // cd?: CustomActiveData;

  /** The current charge count of the custom active item. */
  cc?: number;

  /**
   * The current charge count of the non-Inverted Active item that is on the flip side of this one.
   */
  fc?: number;

  override getName(): string {
    return this.n ?? DEFAULT_NAME;
  }

  override getDescObject(): EIDDescObject {
    return {
      Description: legibleString(this.getText()),
      Name: this.getName(),
      ModName: MOD_NAME,
      Quality: this.getQuality(),
      Icon: EID?.getIcon(INVERTED_ACTIVE_EID_ICON),
      ItemType: ItemType.ACTIVE,
      Charges: this.getTotalCharges(),
      ChargeType: this.getChargeType(),
    };
  }

  /**
   * Get the text describing the ActionSet. Overridden to separate 'On Use' and 'On Pickup' effects
   * and to prevent mistaking it for a Passive.
   */
  override getText(eid = true): string {
    let text = "";
    const actions = sortEffectsByMorality(this.getActions());
    const responses = sortEffectsByMorality(this.getResponses());
    for (let i = 0; i < 2; i++) {
      if (i === 0 && responses.length === 0) {
        continue;
      }
      if (i === 1 && actions.length === 0) {
        continue;
      }
      text += i === 0 ? RESPONSE_EID_TEXT : ACTION_EID_TEXT;
      for (const actionOrResponse of i === 0 ? responses : actions) {
        text += "#";
        if (eid) {
          // Set color of action / response.
          text += getEIDMarkupFromShortcut(
            actionOrResponse.getTextColor() ??
              this.getActionOrResponseColor(actionOrResponse),
          );
        }
        text += legibleString(actionOrResponse.getText(eid, false));
        if (eid) {
          text += "{{CR}}";
        }
      }
    }
    if (text === "") {
      return NO_EFFECTS_DEFAULT_TEXT;
    }
    return text;
  }

  /**
   * Update the tracking of the custom active's current charge. This does not actually change the
   * current charge of the custom active.
   */
  _setCurrentCharge(charge: number): this {
    this.cc = charge;
    return this;
  }

  /**
   * Get the tracked current charge of the custom active. Will return 0 if there is no current
   * charge tracked. This does not actually get the current charge of the custom active, but rather
   * the charge that is tracked.
   */
  _getCurrentCharge(): number {
    return this.cc ?? this.getTotalCharges();
  }

  /**
   * Update the tracking of the non-Inverted active's current charge. This does not actually change
   * the current charge of the non-Inverted active.
   */
  setFlipCharge(charge: number): this {
    this.fc = charge;
    return this;
  }

  /**
   * Get the tracked current charge of the non-Inverted active. Will return 0 if there is no current
   * charge tracked (for example, if the flipped item is a passive). This does not actually get the
   * current charge of the non-Inverted active, but rather the charge that is tracked.
   */
  getFlipCharge(): number {
    return this.fc ?? 0;
  }

  /**
   * Get total number of charges the active item has. This will have different meanings depending on
   * the ChargeType.
   */
  getTotalCharges(): number {
    return this.ch ?? DEFAULT_CHARGES;
  }

  /**
   * Set the total amount of charges the item has. This will have different meanings depending on
   * the ChargeType.
   */
  setTotalCharges(charges: number): this {
    this.ch = charges;
    return this;
  }

  /** Get the item's chargeType. */
  getChargeType(): ItemConfigChargeType {
    return this.chT ?? DEFAULT_CHARGE_TYPE;
  }

  /** Set the item's chargeType. */
  setChargeType(chargeType: ItemConfigChargeType): this {
    this.chT = chargeType;
    return this;
  }

  /**
   * Retrieves the correct 'Zazzinator Active' based on the configuration of this ActiveActionSet.
   */
  getZazzActive(actionSet: InvertedActiveActionSet): CollectibleType {
    return getZazzActiveFromCharge(
      actionSet.getChargeType(),
      actionSet.getTotalCharges(),
    );
  }

  /** Use the Inverted Active item. */
  // POST_USE_ITEM
  use(
    player: EntityPlayer,
    slot: ActiveSlot,
  ):
    | boolean
    | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
    | undefined {
    fprint(
      `Inverted Active with ${this.getTotalCharges()} charges used, triggering ${
        this.getResponses().length
      } responses..`,
    );

    /** Trigger responses. Do it twice if they have car battery. */
    const hasCarBattery = player.HasCollectible(CollectibleType.CAR_BATTERY);
    const repeatAmount = hasCarBattery ? 2 : 1;
    repeat(repeatAmount, () => {
      for (const response of this.getResponses()) {
        response.trigger({
          player,
        });
      }
    });

    /** Play sound. */
    this.playSoundEffect();

    /** Play 'use item' animation. */
    const icon = this.getIcon();
    playPickupAnimationWithCustomSprite(player, icon, 2);

    /** Update charges tracker. */
    this._setCurrentCharge(
      getTotalCharge(player, slot) - this.getTotalCharges(),
    );

    return { Discharge: true, Remove: false, ShowAnim: false };
  }

  preGetPedestal(
    _player: EntityPlayer,
    pedestal: EntityPickupCollectible,
  ): boolean | undefined {
    // Quickly change the item on the pedestal to the correct Zazzinator item.
    pedestal.SubType = getZazzActiveFromCharge(
      this.getChargeType(),
      this.getTotalCharges(),
    );

    // If the inverted active item associated with the pedestal already existed and is being
    // tracked, we use the tracked charge instead of the default charge. We don't remove it as we
    // still need to track it for postItemPickup.
    fprint(
      `preGetPedestal: Setting pedestal charge to ${this._getCurrentCharge()}`,
    );
    pedestal.Charge = this._getCurrentCharge();

    return false;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actionSets\Inverted\InvertedItemActionSet.ts`:

```````ts
import { ItemType } from "isaac-typescript-definitions";
import type { CollectibleType } from "isaac-typescript-definitions";
import type { PickingUpItemCollectible } from "isaacscript-common";
import { game } from "isaacscript-common";
import {
  DEFAULT_CORRUPTED_SOUND_EFFECT_AMOUNT,
  DEFAULT_CORRUPTED_SOUND_EFFECT_LENGTH,
} from "../../../../constants/corruptionConstants";
import { MOD_NAME } from "../../../../constants/mod/modConstants";
import { _invertedPickupHasBeenSeen } from "../../../../features/corruption/inversion/seenInvertedPickups";
import { getAdvancedInvertedItemIconSetting } from "../../../../features/settings/GeneralSettings";
import { setSpecificEntityEIDDescriptionObject } from "../../../../helper/compatibility/EID/EIDHelper";
import {
  generateCorruptedSound,
  playCorruptedSound,
} from "../../../../helper/deletedSpecific/funnySounds";
import { generateCorruptedCollectibleSprite } from "../../../../helper/deletedSpecific/funnySprites";
import { fprint } from "../../../../helper/printHelper";
import { legibleString } from "../../../../helper/stringHelper";
import type { CorruptedCollectibleSprite } from "../../../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import type { CorruptedSoundEffect } from "../../../../interfaces/corruption/funny/CorruptedSoundEffect";
import { replaceCollectibleSpriteWithCorrupted } from "../../../facets/CorruptedCollectibleSpriteFacet";
import { overridePickupAnimationWithCustomSprite } from "../../../facets/RenderOverHeadFacet";
import { ActionSet } from "../ActionSet";
import type { EIDDescObject } from "../../../../interfaces/compatibility/EIDDescObject";
import { INVERTED_ACTIVE_EID_ICON } from "../../../../constants/actionSetConstants";

const DEFAULT_QUALITY = 0;
const DEFAULT_DESCRIPTION = "Beware...";
const DEFAULT_NAME = "Corrupted Item";

/** ActionSet class for Inverted Items. */
export abstract class InvertedItemActionSet extends ActionSet {
  q?: number;
  d?: string;
  n?: string;
  ic?: CorruptedCollectibleSprite;
  sfx?: CorruptedSoundEffect;

  // Attributes.

  /** The Origin Item, which CollectibleType the ActionSet resides on. */
  oi?: CollectibleType;

  /** Negatives carry over. */
  ngo?: boolean;

  /**
   * If this is true, negative effects will carry over to the non-inverted pedestal the first time
   * that the pedestal changes from inverted -> non-inverted.
   */
  getNegativesCarryOver(): boolean {
    return this.ngo ?? false;
  }

  setNegativesCarryOver(negativesCarryOver: boolean): this {
    this.ngo = negativesCarryOver;
    return this;
  }

  /** Returns the inverted collectible type the ActionSet belongs to (or undefined if not set). */
  getCollectibleType(): CollectibleType | undefined {
    return this.oi;
  }

  /**
   * The sound effect that will be played upon picking up the corrupted item. If the corrupted item
   * is also an Active item, using the Active item will also play the sound effect.
   *
   * If no sound effect exists, generates a new default one.
   */
  getSoundEffect(): CorruptedSoundEffect {
    return this.sfx ?? this.generateSoundEffect();
  }

  /**
   * The sound effect that will be played upon picking up the corrupted item. If the corrupted item
   * is also an Active item, using the Active item will also play the sound effect.
   */
  setSoundEffect(soundEffect: CorruptedSoundEffect): this {
    this.sfx = soundEffect;
    return this;
  }

  /** Generates a new sound effect for the ActionSet. */
  generateSoundEffect(): CorruptedSoundEffect {
    this.sfx = generateCorruptedSound(
      DEFAULT_CORRUPTED_SOUND_EFFECT_AMOUNT,
      DEFAULT_CORRUPTED_SOUND_EFFECT_LENGTH,
    );
    return this.sfx;
  }

  /**
   * Plays the sound effect of the corrupted item. If a sound effect is not set yet, it will
   * generate and set a random default one and play it.
   */
  playSoundEffect(): void {
    const soundEffect = this.getSoundEffect();
    playCorruptedSound(soundEffect);
  }

  /** Will generate an Icon if none exists. */
  getIcon(): CorruptedCollectibleSprite {
    return this.ic ?? this.generateIcon();
  }

  // TODO.
  generateIcon(): CorruptedCollectibleSprite {
    const advancedIconSetting = getAdvancedInvertedItemIconSetting();
    this.ic = advancedIconSetting
      ? generateCorruptedCollectibleSprite()
      : generateCorruptedCollectibleSprite();
    return this.ic;
  }

  /** Depending on the Icon form, does the relevant actions. If no icon exist, will generate one. */
  updateIcon(pickup: EntityPickup): void {
    const icon = this.getIcon();
    replaceCollectibleSpriteWithCorrupted(pickup as EntityPickupCollectible, {
      ...icon,
    });
  }

  setIcon(icon: CorruptedCollectibleSprite): this {
    this.ic = icon;
    return this;
  }

  /** Get the name of the corrupted item. */
  getName(): string {
    return this.n ?? DEFAULT_NAME;
  }

  /** Set the name of the corrupted item. */
  setName(name: string): this {
    this.n = name;
    return this;
  }

  /** Get the description of the corrupted item. */
  getDescription(): string {
    return this.d ?? DEFAULT_DESCRIPTION;
  }

  /** Set the description of the corrupted item. */
  setDescription(description: string): this {
    this.d = description;
    return this;
  }

  getQuality(): number {
    return this.q ?? DEFAULT_QUALITY;
  }

  setQuality(quality: number): this {
    this.q = quality;
    return this;
  }

  getDescObject(): EIDDescObject {
    return {
      Description: legibleString(this.getText()),
      Name: this.getName(),
      ModName: MOD_NAME,
      Quality: this.getQuality(),
      Icon: EID?.getIcon(INVERTED_ACTIVE_EID_ICON),
      ItemType: ItemType.PASSIVE,
    };
  }

  /** Updates the EID Description and appearance of the collectible. */
  updateAppearance(collectible: EntityPickupCollectible): void {
    fprint(`Updating appearance of inverted item ${this.getName()}.`);
    this.updateIcon(collectible);

    /** When the pedestal is updating appearance, register it as being seen. */
    _invertedPickupHasBeenSeen(collectible);

    setSpecificEntityEIDDescriptionObject(collectible, this.getDescObject());
  }

  abstract preGetPedestal(
    player: EntityPlayer,
    pedestal: EntityPickupCollectible,
  ): boolean | undefined;

  prePickupCollectible(
    player: EntityPlayer,
    _collectible: PickingUpItemCollectible,
  ): void {
    this.playSoundEffect();
    game.GetHUD().ShowItemText(this.getName(), this.getDescription());
    const icon = this.getIcon();
    overridePickupAnimationWithCustomSprite(player, icon);

    fprint(
      `Picked up inverted item ${this.getName()}, With Description: ${this.getDescription()}`,
    );
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actionSets\Inverted\InvertedPassiveActionSet.ts`:

```````ts
import { ActionSetType } from "../../../../enums/corruption/actionSets/ActionSetType";
import { CollectibleTypeCustom } from "../../../../enums/general/CollectibleTypeCustom";
import { setTrackedPedestalCharge } from "../../../../features/corruption/effects/activeItemTracker";
import { InvertedItemActionSet } from "./InvertedItemActionSet";

const DEFAULT_NAME = "Corrupted Passive Item";

/** ActionSet class. */
export class InvertedPassiveActionSet extends InvertedItemActionSet {
  override actionSetType: ActionSetType = ActionSetType.INVERTED_PASSIVE_ITEM;

  preGetPedestal(
    _player: EntityPlayer,
    pedestal: EntityPickupCollectible,
  ): boolean | undefined {
    // Save the original charge of the item on the pedestal. This should always be the charge of the
    // non-Inverted active (if the non-Inverted item is a passive, we can ignore this). Even though
    // this is a passive inverted item, the non-inverted item may be an active item.
    setTrackedPedestalCharge(pedestal, pedestal.Charge);

    pedestal.SubType = CollectibleTypeCustom.ZAZZ;

    return false;
  }

  override getName(): string {
    return this.n ?? DEFAULT_NAME;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\actionSets\NonInverted\NonInvertedPickupActionSet.ts`:

```````ts
import { ColorDefault, deepCopy } from "isaacscript-common";
import { MOD_NAME } from "../../../../constants/mod/modConstants";
import { ActionSetType } from "../../../../enums/corruption/actionSets/ActionSetType";
import { _addActionsToTracker } from "../../../../features/corruption/effects/playerEffects";
import {
  getGenericEntityEIDDescriptionObject,
  setSpecificEntityEIDDescriptionObject,
} from "../../../../helper/compatibility/EID/EIDHelper";
import { legibleString } from "../../../../helper/stringHelper";
import type { Action } from "../../actions/Action";
import { isAction } from "../../actions/Action";
import type { Response } from "../../responses/Response";
import { ActionSet } from "../ActionSet";

/**
 * ActionSet class for Non-Inverted Pickups. Pickups by default do not have ActionSets, and adding
 * one will make them have an effect when picked up or used, depending on the pickup.
 */
export class NonInvertedPickupActionSet extends ActionSet {
  override actionSetType: ActionSetType = ActionSetType.NON_INVERTED_PICKUP;

  /** This color will be reflected in the entity which the ActionSet belongs to. */
  color?: Color;
  n?: string;

  /** Amount extracted by the 'Extract' item. */
  ext?: number;

  getColor(): Color | undefined {
    return this.color;
  }

  setColor(color: Color): this {
    this.color = color;
    return this;
  }

  /** Get the name of the corrupted item. */
  getName(): string | undefined {
    return this.n;
  }

  /** Set the name of the corrupted item. */
  setName(name: string): this {
    this.n = name;
    return this;
  }

  /** Updates the EID Description and appearance of the collectible. */
  updateAppearance(pickup: EntityPickup): void {
    // Set colour.
    const color = this.getColor();
    pickup.SetColor(color ?? ColorDefault, 0, 1);

    // Update the Description and Name.
    const genericDesc =
      getGenericEntityEIDDescriptionObject(pickup)?.Description ?? "";
    const desc = legibleString(this.getText());
    const newDesc = `${genericDesc} ${desc}`;
    const genericName = getGenericEntityEIDDescriptionObject(pickup)?.Name;

    // Set the EID Desc Object.
    setSpecificEntityEIDDescriptionObject(pickup, {
      Description: newDesc,
      ModName: MOD_NAME,
      Name: this.getName() ?? genericName,
    });
  }

  /**
   * Adding a non-Inverted Pickup ActionSet to the player will immediately trigger its Responses,
   * and add its Actions
   */
  addToPlayer(player: EntityPlayer): void {
    const actionsAndResponses = deepCopy<Array<Action | Response>>(
      this.getEffects(),
    );
    for (const actionOrResponse of actionsAndResponses) {
      if (isAction(actionOrResponse)) {
        _addActionsToTracker(player, actionOrResponse);
      } else {
        actionOrResponse.trigger({ player });
      }
    }
  }

  /**
   * Occurs when the player has 'interacted' with the ActionSet, such as picking up a corrupted item
   * or using a corrupted consumable.
   */
  // abstract trigger(player: EntityPlayer): void;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\GetCollectibleResponse.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { getCollectibleName } from "isaacscript-common";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import {
  collectibleAttributeToText,
  getRandomAssortmentOfCollectibles,
  getRandomCollectibleType,
} from "../../../helper/collectibleHelper";
import { numberToWords } from "../../../helper/numbers/numberToWords";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { CollectibleAttribute } from "../../../interfaces/general/CollectibleAttribute";
import { rangeToString } from "../../../types/general/Range";
import { Response } from "./Response";
import { getCollectibleNameWithEIDSetting } from "../../../helper/compatibility/EID/EIDHelper";
import { fprint } from "../../../helper/printHelper";
import { addTheS } from "../../../helper/stringHelper";

/** Defaults to The Poop if no activeItem is set. */
const EMPTY_COLLECTIBLE_TEXT = "a random collectible";
const EMPTY_COLLECTIBLE_TEXT_PLURAL = "random collectibles";
const FIRST_TIME_PICKING_UP = true;
const VERB = "get";
const VERB_PARTICIPLE = "getting";
const DEFAULT_COLLECTIBLE = CollectibleType.POOP;

/**
 * This Response gives the player collectibles. The collectible can be a specific item, or a random
 * item from a group of items.
 *
 * @field aT The collectible to get. Can be a specific item or randomly from a group of items
 *        (defined by CollectibleAttribute).
 *
 * @example Get The Poop.
 * @example Get a quality 4 active item.
 */
export class GetCollectibleResponse extends Response {
  override responseType: ResponseType = ResponseType.GET_COLLECTIBLE;
  private aT?: CollectibleType | CollectibleAttribute;

  /**
   * Constructs a new instance of the GetCollectibleResponse class.
   *
   * @param collectible The collectible type or attribute. Leave undefined to get a random
   *                    collectible.
   * @param morality The morality value.
   * @returns The constructed GetCollectibleResponse instance.
   */
  construct(
    collectible?: CollectibleType | CollectibleAttribute,
    morality?: Morality,
  ): this {
    if (morality !== undefined) {
      this.mo = morality;
    }
    if (collectible !== undefined) {
      this.aT = collectible;
    }
    return this;
  }

  /** Get collectibles mentioned. */
  override getInvolvedCollectibles(): readonly CollectibleType[] {
    const collectible = this.getCollectible();
    if (collectible === undefined) {
      return [];
    }
    if (typeof collectible === "object") {
      return getRandomAssortmentOfCollectibles([1, 3], collectible);
    }
    return [collectible];
  }

  /**
   * Calculates the collectible to get upon triggering the Response. If the collectible is a
   * CollectibleAttribute, a random collectible from the group is returned.
   *
   * If a collectible can not be found, returns undefined (which will mean this Response will not
   * fire properly).
   */
  calculateCollectible(): CollectibleType {
    const collectible = this.getCollectible();
    if (typeof collectible === "number") {
      return collectible;
    }
    return getRandomCollectibleType(collectible) ?? DEFAULT_COLLECTIBLE;
  }

  /**
   * The collectible to get. Can be a specific item or randomly from a group of items (defined by
   * CollectibleAttribute).
   */
  getCollectible(): CollectibleType | CollectibleAttribute | undefined {
    return this.aT;
  }

  /**
   * The collectible to get. Can be a specific item or randomly from a group of items (defined by
   * CollectibleAttribute).
   */
  setCollectible(collectible: CollectibleType | CollectibleAttribute): this {
    this.aT = collectible;
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getMorality(): Morality {
    return this.mo ?? Morality.NEUTRAL;
  }

  override getAmountOfActivationsText(): string {
    const amountOfActivations = this.getAmountOfActivations();
    if (typeof amountOfActivations === "number") {
      if (amountOfActivations === 1) {
        return "";
      }
      return `${numberToWords(amountOfActivations)}x`;
    }
    return `${rangeToString(amountOfActivations)}x`;
  }

  getCollectibleText(eid: boolean): string {
    const collectible = this.getCollectible();
    if (typeof collectible === "object") {
      return collectibleAttributeToText(collectible);
    }
    if (collectible === undefined) {
      return EMPTY_COLLECTIBLE_TEXT;
    }
    return eid
      ? getCollectibleNameWithEIDSetting(collectible)
      : getCollectibleName(collectible);
  }

  /**
   * Get noun text with amount of activations.
   *
   * @example "brimstone"
   * @example "3 brimstone's"
   */
  override getNoun(eid: boolean): string {
    const collectible = this.getCollectible();
    const amountOfActivationsText = this.getAmountOfActivationsText();
    const isMultiple = this.isMultiple();
    let text = amountOfActivationsText;

    if (typeof collectible === "object") {
      text += ` ${collectibleAttributeToText(collectible, isMultiple)}`;
    } else if (collectible === undefined) {
      text += isMultiple
        ? EMPTY_COLLECTIBLE_TEXT_PLURAL
        : EMPTY_COLLECTIBLE_TEXT;
    } else {
      text += ` ${getCollectibleNameWithEIDSetting(
        collectible,
        isMultiple,
        eid,
      )}`;
    }

    return text;
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun(eid);

    return `${verb} ${noun}`;
  }

  /** Array may be empty. */
  override trigger(triggerData?: TriggerData): CollectibleType[] {
    return super.trigger(triggerData) as CollectibleType[];
  }

  fire(triggerData: TriggerData): CollectibleType | undefined {
    const player = triggerData.player ?? Isaac.GetPlayer();

    // Standard firing procedure.
    const collectibleToFire = this.calculateCollectible();
    if (collectibleToFire === undefined) {
      fprint(
        "Failed to get a collectible to fire for the GetCollectibleResponse.",
      );
      return undefined;
    }

    player.AddCollectible(collectibleToFire, undefined, FIRST_TIME_PICKING_UP);
    return collectibleToFire;
  }
}

/** Type guard to check if a Response is a GetCollectibleResponse. */
export function isGetCollectibleResponse(
  response: Response,
): response is GetCollectibleResponse {
  return response.responseType === ResponseType.GET_COLLECTIBLE;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\GetTrinketResponse.ts`:

```````ts
import { TrinketType } from "isaac-typescript-definitions";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { getRandomTrinket } from "../../../helper/entityHelper/trinketHelper";
import { getTrinketNameWithEIDSetting } from "../../../helper/compatibility/EID/EIDHelper";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { getTrinketName, log, smeltTrinket } from "isaacscript-common";
import { getEIDTextSetting } from "../../../features/settings/EIDSettings";
import { EIDObjectDisplaySetting } from "../../../enums/settings/EIDObjectDisplaySetting";
import { fprint } from "../../../helper/printHelper";

const DEFAULT_TRINKET = TrinketType.BROKEN_MAGNET;
const NON_GULP_VERB = "get";
const NON_GULP_VERB_PARTICIPLE = "getting";
const GULP_VERB = "gulp";
const GULP_VERB_PARTICIPLE = "gulping";

/** Response to add a Trinket to the player, either gulped or to the players' TrinketSlot. */
export class GetTrinketResponse extends Response {
  override responseType: ResponseType = ResponseType.GET_TRINKET;
  t?: TrinketType | undefined;
  glp?: false;

  construct(trinket: TrinketType): this {
    this.t = trinket;
    return this;
  }

  /**
   * Set the TrinketType of the trinket this will give the player. If undefined, a random trinket
   * will be given.
   */
  getTrinket(): TrinketType | undefined {
    return this.t;
  }

  /**
   * Get the TrinketType of the trinket this will give the player. If undefined, a random trinket
   * will be given.
   */
  setTrinket(trinket: TrinketType): this {
    this.t = trinket;
    return this;
  }

  /** Whether the player should gulp the Trinket upon giving it to them. */
  getGulpSetting(): boolean {
    return this.glp === undefined;
  }

  /** Whether the player should gulp the Trinket upon giving it to them. */
  setGulpSetting(gulp: boolean): this {
    this.glp = gulp ? undefined : gulp;
    return this;
  }

  calculateTrinket(): TrinketType {
    const trinket = this.getTrinket();
    if (trinket !== undefined) {
      return trinket;
    }
    return getRandomTrinket() ?? DEFAULT_TRINKET;
  }

  getVerb(participle: boolean): string {
    const shouldGulp = this.getGulpSetting();
    if (shouldGulp) {
      return participle ? GULP_VERB_PARTICIPLE : GULP_VERB;
    }
    return participle ? NON_GULP_VERB_PARTICIPLE : NON_GULP_VERB;
  }

  /**
   * Get noun text with amount of activations.
   *
   * @example "match stick"
   * @example "3-5 match sticks"
   */
  override getNoun(eid: boolean): string {
    const trinket = this.getTrinket();
    const isMultiple = this.isMultiple();

    // Random.
    if (trinket === undefined) {
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random trinkets`;
      }

      return "a random trinket";
    }

    // Specific trinket.
    const trinketName = eid
      ? getTrinketNameWithEIDSetting(trinket)
      : getTrinketName(trinket);
    const eidSetting = getEIDTextSetting();

    if (isMultiple) {
      // If the trinket name is only an icon, we don't need to add an 's' to the end.
      if (eid && eidSetting === EIDObjectDisplaySetting.ICON_ONLY) {
        return `${this.getAmountOfActivationsText()} ${trinketName}`;
      }
      return `${this.getAmountOfActivationsText()} ${addTheS(
        trinketName,
        true,
      )}`;
    }

    // If the trinket name is only an icon, we don't need to add an article.
    if (eid && eidSetting === EIDObjectDisplaySetting.ICON_ONLY) {
      return getTrinketNameWithEIDSetting(trinket);
    }
    return addArticle(getTrinketNameWithEIDSetting(trinket));
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun(eid);

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): TrinketType[] {
    return super.trigger(triggerData) as TrinketType[];
  }

  override fire(triggerData: TriggerData): TrinketType {
    const shouldGulp = this.getGulpSetting();
    const trinket = this.calculateTrinket();
    const player = triggerData.player ?? Isaac.GetPlayer();

    log(`Giving player trinket: ${trinket}`);

    if (shouldGulp) {
      smeltTrinket(player, trinket);
    } else {
      player.AddTrinket(trinket);
    }

    return trinket;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\IfThenElseResponse.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { Conditional } from "../../../enums/general/Conditional";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { isConditionalSatisfied } from "../../../maps/conditionalToFunctionMap";
import { conditionalToString } from "../../../maps/data/name/conditionToNameMap";
import { Response } from "./Response";

/**
 * If a condition is met, trigger the Response. If it is not met, trigger another Response.
 *
 * @example 'If you have 3 or more hearts, spawn 3 spiders, otherwise spawn a trinket'.
 *
 * @field con The conditions to check.
 * @field r The Response to trigger if the conditions are met.
 * @field or The Response to trigger if the conditions are not met.
 */
export class IfThenElseResponse extends Response {
  override responseType = ResponseType.IF_THEN_ELSE_TRIGGER;
  con?: Array<[Conditional, number]>;
  r?: Response;
  or?: Response;

  construct(
    conditionsMetResponse: Response,
    conditionsNotMetResponse: Response,
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...conditions: Array<[Conditional, number]>
  ): this {
    this.con = conditions;
    this.or = conditionsNotMetResponse;
    this.r = conditionsMetResponse;
    return this;
  }

  getConditions(): Array<[Conditional, number]> | undefined {
    return this.con;
  }

  setConditions(
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...conditions: Array<[Conditional, number]>
  ): this {
    this.con = conditions;
    return this;
  }

  /**
   * Add a condition. The number corresponds to the number parameter specific to the condition, will
   * default to 1 if not specified. Not all conditions require a number parameter.
   */
  addCondition(condition: Conditional, number?: number): this {
    if (this.con === undefined) {
      this.con = [];
    }

    this.con.push([condition, number ?? 1]);
    return this;
  }

  /** The response to trigger if the conditions are met. */
  getConditionsMetResponse(): Response | undefined {
    return this.r;
  }

  /** The response to trigger if the conditions are met. */
  setConditionsMetResponse(response: Response): this {
    this.r = response;
    return this;
  }

  /** The response to trigger if the conditions are not met. */
  getConditionsNotMetResponse(): Response | undefined {
    return this.or;
  }

  /** The response to trigger if the conditions are not met. */
  setConditionsNotMetResponse(response: Response): this {
    this.or = response;
    return this;
  }

  /** Must pass all conditions to return true. */
  checkConditions(player: EntityPlayer): boolean {
    const conditions = this.getConditions();
    if (conditions === undefined) {
      return true;
    }

    const hasFailedAtLeastOne = conditions.some(
      (condition) =>
        !isConditionalSatisfied(condition[0], player, condition[1]),
    );

    return !hasFailedAtLeastOne;
  }

  getConditionsText(): string {
    const conditions = this.getConditions();
    let text = "";
    if (conditions === undefined) {
      return text;
    }

    for (let i = 0; i < conditions.length; i++) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const condition = conditions[i]!;
      text += conditionalToString(condition[0], condition[1]);
      if (i !== conditions.length - 1) {
        text += " and ";
      }
    }

    return text;
  }

  getConditionsMetResponseText(eid: boolean, participle: boolean): string {
    const response = this.getConditionsMetResponse();
    if (response === undefined) {
      error("IfThenElseResponse: Conditions met response is undefined.");
    }

    return response.getText(eid, participle);
  }

  getConditionsNotMetResponseText(eid: boolean, participle: boolean): string {
    const response = this.getConditionsNotMetResponse();
    if (response === undefined) {
      error("IfThenElseResponse: Conditions not met response is undefined.");
    }

    return response.getText(eid, participle);
  }

  override getVerb(_participle: boolean): string {
    error("IfThenElseResponse: No Verb required.");
  }

  override getNoun(_eid: boolean): string {
    error("IfThenElseResponse: No Noun required.");
  }

  override getText(eid: boolean, participle: boolean): string {
    if (participle) {
      return `${this.getConditionsMetResponseText(
        eid,
        participle,
      )} ${this.getConditionsText()}, otherwise ${this.getConditionsNotMetResponseText(
        eid,
        participle,
      )}`;
    }

    return `${this.getConditionsText()}, ${this.getConditionsMetResponseText(
      eid,
      participle,
    )}, otherwise ${this.getConditionsNotMetResponseText(eid, participle)}`;
  }

  override trigger(triggerData?: TriggerData): unknown[] {
    return super.trigger(triggerData);
  }

  override fire(triggerData: TriggerData): unknown {
    const player = triggerData.player ?? Isaac.GetPlayer(0);
    const response = this.getConditionsMetResponse();
    if (response === undefined) {
      error("IfThenElseResponse: Conditions met response is undefined.");
    }

    if (this.checkConditions(player)) {
      return response.trigger(triggerData);
    }
    const orResponse = this.getConditionsNotMetResponse();
    if (orResponse === undefined) {
      error("IfThenElseResponse: Conditions not met response is undefined.");
    }

    return orResponse.trigger(triggerData);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\IfThenResponse.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { Conditional } from "../../../enums/general/Conditional";
import { fprint } from "../../../helper/printHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { isConditionalSatisfied } from "../../../maps/conditionalToFunctionMap";
import { conditionalToString } from "../../../maps/data/name/conditionToNameMap";
import { Response } from "./Response";

/**
 * If a condition is met, trigger the Response.
 *
 * @example 'If you have 3 or more hearts, spawn 3 spiders'.
 *
 * @field con The conditions to check.
 * @field r The Response to trigger if the conditions are met.
 */
export class IfThenResponse extends Response {
  override responseType = ResponseType.IF_THEN_TRIGGER;
  con?: Array<[Conditional, number]>;
  r?: Response;

  construct(
    response: Response,
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...conditions: Array<[Conditional, number]>
  ): this {
    this.con = conditions;
    this.r = response;
    return this;
  }

  getConditions(): Array<[Conditional, number]> | undefined {
    return this.con;
  }

  setConditions(
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...conditions: Array<[Conditional, number]>
  ): this {
    this.con = conditions;
    return this;
  }

  /**
   * Add a condition. The number corresponds to the number parameter specific to the condition, will
   * default to 1 if not specified. Not all conditions require a number parameter.
   */
  addCondition(condition: Conditional, number?: number): this {
    if (this.con === undefined) {
      this.con = [];
    }

    this.con.push([condition, number ?? 1]);
    return this;
  }

  getResponse(): Response | undefined {
    return this.r;
  }

  setResponse(response: Response): this {
    this.r = response;
    return this;
  }

  /** Must pass all conditions to return true. */
  checkConditions(player: EntityPlayer): boolean {
    const conditions = this.getConditions();
    if (conditions === undefined) {
      return true;
    }

    const hasFailedAtLeastOne = conditions.some(
      (condition) =>
        !isConditionalSatisfied(condition[0], player, condition[1]),
    );

    return !hasFailedAtLeastOne;
  }

  getConditionsText(): string {
    const conditions = this.getConditions();
    let text = "";
    if (conditions === undefined) {
      return text;
    }

    for (let i = 0; i < conditions.length; i++) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const condition = conditions[i]!;
      text += conditionalToString(condition[0], condition[1]);
      if (i !== conditions.length - 1) {
        text += " and ";
      }
    }

    return text;
  }

  getResponseText(eid: boolean, participle: boolean): string {
    const response = this.getResponse();
    if (response === undefined) {
      fprint("IfThenResponse: Response is undefined.");
      return "";
    }

    return response.getText(eid, participle);
  }

  override getVerb(participle: boolean): string {
    const response = this.getResponse();
    if (response === undefined) {
      fprint("IfThenResponse: Response is undefined.");
      return "";
    }

    return response.getVerb(participle);
  }

  override getNoun(eid: boolean): string {
    const response = this.getResponse();
    if (response === undefined) {
      fprint("IfThenResponse: Response is undefined.");
      return "";
    }

    return response.getNoun(eid);
  }

  override getText(eid: boolean, participle: boolean): string {
    if (participle) {
      return `${this.getResponseText(
        eid,
        participle,
      )} ${this.getConditionsText()}`;
    }

    return `${this.getConditionsText()}, ${this.getResponseText(
      eid,
      participle,
    )}`;
  }

  override trigger(triggerData?: TriggerData): unknown[] {
    return super.trigger(triggerData);
  }

  override fire(triggerData: TriggerData): unknown {
    const player = triggerData.player ?? Isaac.GetPlayer(0);
    const response = this.getResponse();
    if (response === undefined) {
      fprint("IfThenResponse: Response is undefined.");
      return undefined;
    }

    if (this.checkConditions(player)) {
      return response.trigger(triggerData);
    }

    return undefined;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\PlaySoundResponse.ts`:

```````ts
import type { SoundEffect } from "isaac-typescript-definitions";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import type { SoundEffectOptions } from "../../../interfaces/general/SoundEffectOptions";
import {
  getRandomSoundEffect,
  playSoundEffectWithOptions,
} from "../../../helper/soundHelper";
import { sfxManager } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";

const VERB = "play";
const VERB_PARTICIPLE = "playing";

/**
 * Response to play a sound effect.
 *
 * @example 'Play the sound effect "Isaac Hurt"'.
 *
 * @field s The sound effect to play.
 */
export class PlaySoundResponse extends Response {
  override responseType = ResponseType.PLAY_SOUND;
  s?: SoundEffect | SoundEffectOptions;

  override construct(sound: SoundEffect | SoundEffectOptions): this {
    this.s = sound;
    return this;
  }

  getSoundEffect(): SoundEffect | SoundEffectOptions | undefined {
    return this.s;
  }

  setSoundEffect(sound: SoundEffect | SoundEffectOptions): this {
    this.s = sound;
    return this;
  }

  playSoundEffect(): SoundEffect {
    const soundEffect = this.getSoundEffect();
    if (soundEffect === undefined) {
      // Play a random sound effect.
      const randomSoundEffect = getRandomSoundEffect();
      sfxManager.Play(randomSoundEffect);
      return randomSoundEffect;
    }

    if (typeof soundEffect === "number") {
      // Play the sound effect.
      sfxManager.Play(soundEffect);
      return soundEffect;
    }

    // Why the fuck does this not filter out undefined?
    playSoundEffectWithOptions(soundEffect);
    return soundEffect.soundEffect;
  }

  // TODO.
  override getNoun(): string {
    return "";
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): SoundEffect[] {
    return super.trigger(triggerData) as SoundEffect[];
  }

  override fire(_triggerData: TriggerData): SoundEffect {
    return this.playSoundEffect();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\RemoveActionResponse.ts`:

```````ts
import type { ActionOrigin } from "../../../enums/corruption/actions/ActionOrigin";
import type { ActionType } from "../../../enums/corruption/actions/ActionType";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import {
  removeActionWithPredicate,
  _removeAllActionsWithPredicate,
} from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { Action } from "../actions/Action";
import { Response } from "./Response";

const DEFAULT_ALL_ACTIONS = false;
const VERB = "remove";
const VERB_PARTICIPLE = "removing";

/**
 * Response to Remove Actions that are attached to players. Will remove Actions which match the
 * given parameters. If 'removeAll' is true, then all Actions that match will be removed.
 */
export class RemoveActionResponse extends Response {
  override responseType: ResponseType = ResponseType.REMOVE_ACTION;

  /** The origin. */
  o?: ActionOrigin;

  /** ID for origin. */
  i?: number;

  /** ActionType of the Action to remove. */
  at?: ActionType;

  /** If all actions that match should be removed. */
  all?: boolean;

  /**
   * Response to Remove Actions that are attached to players. Will remove Actions which match the
   * given parameters. If 'removeAll' is true, then all Actions that match will be removed.
   */
  construct(
    actionOrigin?: ActionOrigin,
    id?: number,
    actionType?: ActionType,
    removeAll?: boolean,
  ): this {
    if (actionOrigin !== undefined) {
      this.setActionOrigin(actionOrigin);
    }

    if (id !== undefined) {
      this.setID(id);
    }

    if (actionType !== undefined) {
      this.setActionType(actionType);
    }

    if (removeAll !== undefined) {
      this.setRemoveAll(removeAll);
    }
    return this;
  }

  getActionOrigin(): ActionOrigin | undefined {
    return this.o;
  }

  setActionOrigin(actionOrigin: ActionOrigin): this {
    this.o = actionOrigin;
    return this;
  }

  getRemoveAll(): boolean {
    return this.all ?? DEFAULT_ALL_ACTIONS;
  }

  setRemoveAll(removeAll: boolean): this {
    this.all = removeAll;
    return this;
  }

  getID(): number | undefined {
    return this.i;
  }

  setID(id: number): this {
    this.i = id;
    return this;
  }

  getActionType(): ActionType | undefined {
    return this.at;
  }

  setActionType(actionType: ActionType): this {
    this.at = actionType;
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(): string {
    return "";
  }

  override getText(): string {
    return "";
  }

  fire(triggerData: TriggerData): void {
    const { player } = triggerData;

    const aT = this.getActionType();
    const actionOrigin = this.getActionOrigin();
    const id = this.getID();
    const removeAll = this.getRemoveAll();
    const predicate = (action: Action) => {
      if (actionOrigin !== undefined && action.o?.[0] !== actionOrigin) {
        return false;
      }

      if (id !== undefined && action.o?.[1] !== id) {
        return false;
      }

      return true;
    };

    if (removeAll) {
      _removeAllActionsWithPredicate(predicate, player, aT);
    } else {
      removeActionWithPredicate(predicate, player, aT);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\RemoveCollectibleResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { playerRemovePermanentCollectibleEffect } from "../../../features/general/temporaryItems";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import type { CollectibleAttribute } from "../../../interfaces/general/CollectibleAttribute";
import {
  collectibleAttributeToText,
  getRandomAssortmentOfCollectibles,
  getRandomCollectibleType,
} from "../../../helper/collectibleHelper";
import { fprint } from "../../../helper/printHelper";
import { getCollectibleNameWithEIDSetting } from "../../../helper/compatibility/EID/EIDHelper";
import { getCollectibleName } from "isaacscript-common";
import type { Range } from "../../../types/general/Range";
import type { Morality } from "../../../enums/corruption/Morality";

const VERB = "lose";
const VERB_PARTICIPLE = "losing";
const DEFAULT_CE = false;

/**
 * Response for removing a collectible from the player. If the player does not have the collectible,
 * nothing happens. The collectible can be in the form of a CollectibleType, a Collectible Effect,
 * or a CollectibleAttribute.
 *
 * @example Remove The Poop.
 * @example Remove the Poop effect.
 *
 * @param c The collectible to remove. Can be a CollectibleType, a CollectibleAttribute, or
 *          undefined.
 * @param ce Whether the collectible is a Collectible Effect. Default is false.
 */
export class RemoveCollectibleResponse extends Response {
  override responseType: ResponseType = ResponseType.REMOVE_COLLECTIBLE;
  c?: CollectibleType | CollectibleAttribute;
  ce?: boolean;

  /**
   * Response for removing a collectible from the player. If the player does not have the
   * collectible, nothing happens. The collectible can be in the form of a CollectibleType, a
   * Collectible Effect, or a CollectibleAttribute.
   *
   * @example Remove The Poop.
   * @example Remove the Poop effect.
   *
   * @param collectibleToRemove The collectible to remove. Can be a CollectibleType, a
   *                            CollectibleAttribute, or undefined.
   * @param amount The amount of times this Response can be activated. Default is 1.
   * @param morality The morality of this Response. Default is Morality.NEUTRAL.
   * @param isEffect Whether the collectible is a Collectible Effect. Default is false.
   */
  construct(
    collectibleToRemove: CollectibleType | CollectibleAttribute,
    amount?: number | Range,
    morality?: Morality,
    isEffect = false,
  ): this {
    if (morality !== undefined) {
      this.mo = morality;
    }
    if (amount !== undefined) {
      this.aoa = amount;
    }
    this.c = collectibleToRemove;
    this.ce = isEffect;
    return this;
  }

  /** Get collectibles mentioned. */
  override getInvolvedCollectibles(): readonly CollectibleType[] {
    const collectible = this.getCollectible();
    if (collectible === undefined) {
      return [];
    }
    if (typeof collectible === "object") {
      return getRandomAssortmentOfCollectibles([1, 3], collectible);
    }
    return [collectible];
  }

  /**
   * Whether the Response should remove a physical collectible or a 'permanent' collectible effect.
   * Default is false.
   */
  isCollectibleEffect(): boolean {
    return this.ce ?? DEFAULT_CE;
  }

  /**
   * Whether the Response should remove a physical collectible or a 'permanent' collectible effect.
   * Default is false.
   */
  setCollectibleEffect(isCollectibleEffect: boolean): this {
    this.ce = isCollectibleEffect;
    return this;
  }

  /**
   * Calculates the collectible to remove upon triggering the Response. If the collectible is a
   * CollectibleAttribute, a random collectible from the group is returned.
   *
   * If a collectible can not be found, returns undefined (which will mean this Response will not
   * fire properly).
   */
  calculateCollectible(): CollectibleType | undefined {
    const collectible = this.getCollectible();
    if (typeof collectible === "object") {
      return getRandomCollectibleType(collectible);
    }
    return collectible;
  }

  /** Get the collectible to remove. */
  getCollectible(): CollectibleType | CollectibleAttribute | undefined {
    return this.c;
  }

  /** The collectible to remove. */
  setCollectible(collectible: CollectibleType): this {
    this.c = collectible;
    return this;
  }

  override getNoun(eid = true): string {
    const collectible = this.getCollectible();
    const isMultiple = this.isMultiple();
    const amountOfActivationsText = this.getAmountOfActivationsText() ?? "";

    // CollectibleAttribute
    if (typeof collectible === "object") {
      return `${amountOfActivationsText} ${collectibleAttributeToText(
        collectible,
        isMultiple,
      )}`;
    }

    // Random.
    if (collectible === undefined) {
      if (isMultiple) {
        return `${amountOfActivationsText} random collectibles`;
      }

      return "a random collectible";
    }

    // Specific collectible.
    const collectibleName = getCollectibleNameWithEIDSetting(
      collectible,
      isMultiple,
      eid,
    );
    return `${amountOfActivationsText} ${collectibleName}`;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun(eid);

    return `${verb} ${noun}`;
  }

  fire(triggerData: TriggerData): void {
    const player = triggerData.player ?? Isaac.GetPlayer();
    const isCollectibleEffect = this.isCollectibleEffect();
    const collectible = this.calculateCollectible();

    if (collectible === undefined) {
      fprint("Collectible could not be found for RemoveCollectibleResponse.");
      return;
    }

    if (isCollectibleEffect) {
      fprint(
        `Trying to remove ${getCollectibleName(
          collectible,
        )} effect from player due to RemoveCollectibleResponse..`,
      );
      playerRemovePermanentCollectibleEffect(player, collectible);
    } else {
      fprint(
        `Trying to remove ${getCollectibleName(
          collectible,
        )} from player due to RemoveCollectibleResponse..`,
      );
      player.RemoveCollectible(collectible);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\RemoveEntityResponse.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import {
  getConstituentsFromEntityID,
  getEntities,
  getRandomArrayElementAndRemove,
} from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { Response } from "./Response";
import type { EntityCategory } from "../../../enums/general/EntityCategory";
import { getAllEntitiesWithCategory } from "../../../helper/entityHelper";
import { entityCategoryToString } from "../../../maps/data/name/entityCategoryNameMap";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { getEntitiesFromEntityID } from "../../../helper/entityHelper/entityIDHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { getEntityIDName } from "../../../helper/entityHelper/entityIDNameHelper";
import { fprint } from "../../../helper/printHelper";

const VERB = "remove";
const VERB_PARTICIPLE = "removing";
const UNKNOWN_ENTITY_NAME = "mysterious entity";
const RANDOM_ENTITY_NAME = "random entity";

/**
 * Response to remove a random Entity.
 *
 * @example 'Remove a random Gaper'.
 * @example 'Remove all entities'.
 *
 * @param entity The Entity type that will be removed. This can be an EntityCategory (e.g 'Remove a
 *               random Projectile'), an EntityID (e.g 'Remove a Charged Key'), or undefined (remove
 *               any entity). Defaults to undefined. If the entity is an EntityID, you can specify
 *               '-1' as the subtype to remove a random entity of that type (e.g 'Remove a random
 *               Key').
 * @param removeAll If true, will remove all entities of the specified type rather than one.
 *                  Defaults to false.
 * @param ignoreFriendly If true, will ignore friendly NPCs. Defaults to false.
 *
 * This response will flatten all removed entities into a singular array, regardless of how many
 * activations it has or whether removeAll is true or false.
 */
export class RemoveEntityResponse extends Response {
  override responseType: ResponseType = ResponseType.REMOVE_ENTITY;
  e?: EntityCategory | EntityID;
  all?: boolean;
  iF?: true;

  construct(
    entity: EntityCategory | EntityID | undefined,
    removeAll: boolean,
    ignoreFriendly?: true,
  ): this {
    this.setEntity(entity);
    this.setRemoveAll(removeAll);
    this.iF = ignoreFriendly;
    return this;
  }

  /**
   * Get the Entity type that will be removed. This can be:
   * - A specific EntityID (e.g 'Remove a Charged Key').
   * - An EntityCategory (e.g 'Remove a random Projectile').
   * - An EntityID with '-1' as the subtype (e.g 'Remove a random Key').
   */
  getEntity(): EntityCategory | EntityID | undefined {
    return this.e;
  }

  /**
   * Set the Entity type that will be removed. This can be:
   * - A specific EntityID (e.g 'Remove a Charged Key').
   * - An EntityCategory (e.g 'Remove a random Projectile').
   * - An EntityID with '-1' as the subtype (e.g 'Remove a random Key').
   * - undefined (remove any entity).
   */
  setEntity(entityID?: EntityCategory | EntityID): this {
    this.e = entityID;
    return this;
  }

  /** Whether to not remove friendly NPCs. */
  getIgnoreFriendly(): boolean {
    return this.iF ?? false;
  }

  /** Whether to not remove friendly NPCs. */
  setIgnoreFriendly(ignoreFriendly: boolean): this {
    this.iF = ignoreFriendly ? true : undefined;
    return this;
  }

  /** Whether to remove all the entities of the specified type. */
  getRemoveAll(): boolean {
    return this.all ?? false;
  }

  /** Whether to remove all the entities of the specified type. */
  setRemoveAll(removeAll: boolean): this {
    this.all = removeAll;
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "3-4 random entities".
   * @example "a random entity".
   * @example "a random gaper".
   * @example "all enemies".
   */
  override getNoun(_eid: boolean): string {
    const entityID = this.getEntity();
    const isMultiple = this.isMultiple();
    const isAll = this.getRemoveAll();
    if (typeof entityID === "string") {
      const [entityType] = getConstituentsFromEntityID(entityID);

      if ((entityType as number) === -1) {
        if (isAll) {
          return "all entities";
        }
        if (isMultiple) {
          return `${this.getAmountOfActivationsText()} random entities`;
        }
        return `a ${RANDOM_ENTITY_NAME}`;
      }

      // TODO: Add support for subType and variant being -1.

      if (isAll) {
        return `all ${addTheS(entityID, true)}`;
      }
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random ${addTheS(
          entityID,
          true,
        )}`;
      }
      return addArticle(getEntityIDName(entityID) ?? UNKNOWN_ENTITY_NAME);
    }
    if (entityID === undefined) {
      if (isAll) {
        return "all entities";
      }
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random entities`;
      }
      return `a ${RANDOM_ENTITY_NAME}`;
    }

    // It's a category.
    if (isAll) {
      return `all ${addTheS(
        entityCategoryToString(entityID).toLowerCase(),
        true,
      )}`;
    }
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} random ${addTheS(
        entityCategoryToString(entityID).toLowerCase(),
        true,
      )}`;
    }

    return `a random ${entityCategoryToString(entityID).toLowerCase()}`;
  }

  getText(eid: boolean, participle: boolean): string {
    const noun = this.getNoun(eid);
    const verb = this.getVerb(participle);

    return `${verb} ${noun}`;
  }

  getEntitiesToRemove(): Entity[] {
    const entityIDToRemove = this.getEntity();
    const ignoreFriendly = this.getIgnoreFriendly();

    // EntityID.
    if (typeof entityIDToRemove === "string") {
      return [...getEntitiesFromEntityID(entityIDToRemove, ignoreFriendly)];
    }

    // Category.
    if (typeof entityIDToRemove === "number") {
      return [...getAllEntitiesWithCategory(entityIDToRemove, ignoreFriendly)];
    }

    // Random.
    return [...getEntities()];
  }

  removeEntities(): Entity[] {
    const entitiesToRemove = this.getEntitiesToRemove();
    if (entitiesToRemove.length === 0) {
      fprint("RemoveEntityResponse: No entities to remove.");
      return [];
    }

    const amountToRemove = this.getRemoveAll()
      ? entitiesToRemove.length
      : this.calculateAmountOfActivations();

    // Remove the entities.
    const removedEntities: Entity[] = [];
    for (let i = 0; i < amountToRemove; i++) {
      const entityToRemove = getRandomArrayElementAndRemove(
        entitiesToRemove,
        undefined,
      );

      entityToRemove.Remove();
      removedEntities.push(entityToRemove);
    }

    return removedEntities;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override shouldSkipAmountOfActivations(): boolean {
    return true;
  }

  /** Override trigger() to flatten removed entities into a singular array. */
  override trigger(triggerData?: TriggerData): Entity[] {
    return super.trigger(triggerData) as Entity[];
  }

  fire(): Entity[] {
    return this.removeEntities();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\RemoveGridEntityResponse.ts`:

```````ts
import type { GridEntityID } from "isaacscript-common";
import {
  getConstituentsFromGridEntityID,
  getRandomArrayElementAndRemove,
  removeGridEntity,
} from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { GridID } from "../../../enums/data/ID/GridID";
import {
  getGridEntitiesFromGridID,
  getRandomGridID,
} from "../../../helper/gridEntityHelper/gridIDHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { gridIDToString } from "../../../maps/data/name/gridIDNameMap";
import { gridEntityTypeToString } from "../../../maps/data/name/gridEntityTypeNameMap";
import { addTheS } from "../../../helper/stringHelper";
import { fprint } from "../../../helper/printHelper";
import type { GridEntityType } from "isaac-typescript-definitions";

const GRID_ENTITY_NOUN = "obstacle";
const GRID_ENTITY_NOUN_PLURAL = "obstacles";
const VERB = "remove";
const VERB_PARTICIPLE = "removing";

/**
 * Response to remove a grid entity.
 *
 * @example 'Remove a random rock'.
 *
 * @param gridEntity The GridEntityID of the grid entity to remove. Can be a specific GridEntityID,
 *                   or undefined to remove any grid entity.
 * @param removeAll If true, will remove all grid entities of the specified type rather than one.
 */
export class RemoveGridEntityResponse extends Response {
  override responseType: ResponseType = ResponseType.REMOVE_GRID;
  g?: GridID | GridEntityType;
  all?: boolean;

  /**
   * Response to remove a grid entity.
   *
   * @example 'Remove a random rock'.
   *
   * @param gridEntity The GridEntityID of the grid entity to remove. Can be a specific
   *                   GridEntityID, a GridEntityType, or undefined to remove any grid entity.
   * @param removeAll If true, will remove all grid entities of the specified type rather than one.
   */
  override construct(
    gridEntity: GridID | GridEntityType | undefined,
    removeAll: boolean,
  ): this {
    this.setGridEntity(gridEntity);
    this.setRemoveAll(removeAll);
    return this;
  }

  /**
   * Get the GridEntityID of the grid entity to remove. Can be a specific GridEntityID, or undefined
   * to remove any grid entity.
   */
  getGridEntity(): GridID | GridEntityType | undefined {
    return this.g;
  }

  /**
   * Set the GridEntityID of the grid entity to remove. Can be a specific GridEntityID, a
   * GridEntityType, or undefined to remove any grid entity.
   */
  setGridEntity(gridEntity: GridID | GridEntityType | undefined): this {
    this.g = gridEntity;
    return this;
  }

  /** Whether to remove all the grid entities of the specified type. */
  getRemoveAll(): boolean {
    return this.all ?? false;
  }

  /** Whether to remove all the grid entities of the specified type. */
  setRemoveAll(removeAll: boolean): this {
    this.all = removeAll ? true : undefined;
    return this;
  }

  removeGridEntities(): GridEntity[] {
    fprint("Removing grid entities.");
    const gridEntitiesToRemove = this.getGridEntitiesToRemove();
    if (gridEntitiesToRemove.length === 0) {
      return [];
    }

    const amountOfActivations = this.getRemoveAll()
      ? gridEntitiesToRemove.length
      : this.calculateAmountOfActivations();

    fprint(`Removing ${amountOfActivations} grid entities.`);
    const returnValues: GridEntity[] = [];
    for (let i = 0; i < amountOfActivations; i++) {
      if (gridEntitiesToRemove.length === 0) {
        break;
      }

      const gridEntityToRemove = getRandomArrayElementAndRemove(
        gridEntitiesToRemove,
        undefined,
      );
      removeGridEntity(gridEntityToRemove, false);
      returnValues.push(gridEntityToRemove);
    }

    // Don't update the room, because of the USE_CALLBACK bug.

    // roomUpdateSafe();

    return returnValues;
  }

  getGridEntitiesToRemove(): GridEntity[] {
    const gridIDToRemove = this.calculateGridID();
    fprint(`Removing grid entity: ${gridIDToRemove}.`);
    return [...getGridEntitiesFromGridID(gridIDToRemove)];
  }

  calculateGridID(): GridID {
    const gridEntityToRemove = this.getGridEntity();
    if (typeof gridEntityToRemove === "string") {
      return gridEntityToRemove;
    }

    if (typeof gridEntityToRemove === "number") {
      return `${gridEntityToRemove}.-1` as GridID;
    }

    // Random Grid Entity.
    return getRandomGridID();
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random obstacle"
   * @example "3-4 random spikes"
   * @example "all locked doors"
   */
  override getNoun(): string {
    const gridEntityID = this.getGridEntity();
    const isMultiple = this.isMultiple();
    const removeAll = this.getRemoveAll();

    // Random grid.
    if (gridEntityID === undefined) {
      if (removeAll) {
        return `all ${GRID_ENTITY_NOUN_PLURAL}`;
      }

      if (isMultiple) {
        return `${
          this.getAmountOfActivationsText() ?? ""
        } random ${GRID_ENTITY_NOUN_PLURAL}`;
      }

      return `a random ${GRID_ENTITY_NOUN}`;
    }

    // GridEntityType
    if (typeof gridEntityID === "number") {
      const gridEntityTypeName =
        gridEntityTypeToString(gridEntityID).toLowerCase();

      if (removeAll) {
        return `all ${addTheS(gridEntityTypeName, true)}`;
      }

      if (isMultiple) {
        return `${this.getAmountOfActivationsText() ?? ""} random ${addTheS(
          gridEntityTypeName,
          true,
        )}`;
      }

      return `a random ${gridEntityTypeName}`;
    }

    // Specific grid.
    const [gridEntityType, variant] = getConstituentsFromGridEntityID(
      gridEntityID as GridEntityID,
    );
    if ((gridEntityType as number) === -1) {
      if (removeAll) {
        return `all ${GRID_ENTITY_NOUN_PLURAL}`;
      }

      if (isMultiple) {
        return `${
          this.getAmountOfActivationsText() ?? ""
        } random ${GRID_ENTITY_NOUN_PLURAL}`;
      }

      return `a random ${GRID_ENTITY_NOUN}`;
    }

    if (variant === -1) {
      if (removeAll) {
        return `all ${addTheS(gridEntityTypeToString(gridEntityType), true)}`;
      }

      if (isMultiple) {
        return `${this.getAmountOfActivationsText() ?? ""} random ${addTheS(
          gridEntityTypeToString(gridEntityType),
          true,
        )}`;
      }

      return `a random ${gridEntityTypeToString(gridEntityType)}`;
    }

    if (removeAll) {
      return `all ${addTheS(gridIDToString(gridEntityID), true)}`;
    }

    if (isMultiple) {
      return `${this.getAmountOfActivationsText() ?? ""} random ${addTheS(
        gridIDToString(gridEntityID),
        true,
      )}`;
    }

    return `a random ${gridIDToString(gridEntityID)}`;
  }

  override getText(_eid: boolean, participle: boolean): string {
    const noun = this.getNoun();
    const verb = this.getVerb(participle);

    return `${verb} ${noun}`;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override shouldSkipAmountOfActivations(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): GridEntity[] {
    return super.trigger(triggerData) as GridEntity[];
  }

  override fire(_triggerData: TriggerData): GridEntity[] {
    return this.removeGridEntities();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\Response.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { deepCopy } from "isaacscript-common";
import type { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import { Morality } from "../../../enums/corruption/Morality";
import type { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { fprint } from "../../../helper/printHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { Percentage } from "../../../types/general/Percentage";
import {
  createPercentage,
  rollPercentage,
} from "../../../types/general/Percentage";
import type { Range } from "../../../types/general/Range";
import {
  randomInRange,
  rangeToString,
  validifyRange,
} from "../../../types/general/Range";

const DEFAULT_PERCENTAGE_CHANCE_TO_ACTIVATE = 100;
const DEFAULT_AMOUNT_OF_ACTIVATIONS = 1;
const DEFAULT_MORALITY = Morality.NEUTRAL;
const NO_CHANCE_TO_ACTIVATE_TEXT = "don't";
const CHANCE_TO_ACTIVATE_POST_TEXT = "% chance to";

/**
 * Responses are triggered using trigger() and correlate to an event occurring in game.
 *
 * @example 'Spawn 3 spiders'.
 *
 * Responses can also have additional properties which modify their behavior (e.g percentage chance
 * to fire upon triggering the response). Each response has a 'Morality', indicating if it is
 * beneficial or not.
 */
export abstract class Response {
  abstract readonly responseType: ResponseType;
  mo?: Morality;
  aoa?: number | Range;

  /** Percentage chance to activate (100% will always pass). */
  cta?: Percentage;

  /** Overridden color of the Response. Default is derived from the Morality. */
  oc?: EIDColorShortcut;

  /**
   * Get the assigned EID Color Shortcut used to represent the Response. This can either be derived
   * from the Morality or overridden with overrideTextColor(). Note if this Response is wrapped in
   * an Action, it will use the Actions textColor instead.
   */
  getTextColor(): EIDColorShortcut | undefined {
    return this.oc;
  }

  /**
   * Override the text color generated to this Response through its Morality. Note if this Response
   * is wrapped in an Action, it will use the Actions textColor instead.
   */
  overrideTextColor(color: EIDColorShortcut): this {
    this.oc = color;
    return this;
  }

  getInvolvedCollectibles(): readonly CollectibleType[] {
    return [];
  }

  /**
   * Whether to flatten the results of the triggered Response into a singular array. This method is
   * overridden by some Responses. It will flatten the results with a depth of 1.
   *
   * Flattened Responses will usually be ones which trigger other Responses, such as
   * TriggerInQueueResponse, as the results of the triggered Response will be an array, and we don't
   * want to return an array of arrays.
   *
   * This can mean the final returned array may consist of different types of values, so caution
   * should be taken when using those kind of Responses and their return values.
   */
  shouldFlattenResults(): boolean {
    return false;
  }

  /**
   * Whether to skip the amount of activations causing the 'fire()' function to be called multiple
   * times in the trigger() function. This method is overridden by some Responses, particularly
   * those that recreate the amount of activations in their overridden fire() function.
   */
  shouldSkipAmountOfActivations(): boolean {
    return false;
  }

  // Use calculateAmountOfActivations() instead!
  getAmountOfActivations(): number | Range {
    return this.aoa ?? DEFAULT_AMOUNT_OF_ACTIVATIONS;
  }

  getAmountOfActivationsText(): string | undefined {
    const amountOfActivations = this.getAmountOfActivations();
    if (typeof amountOfActivations === "number") {
      if (amountOfActivations === 1) {
        return undefined;
      }
      return amountOfActivations.toString();
    }
    return rangeToString(amountOfActivations);
  }

  /**
   * Gets the amount of times the response will be fired. If the amountOfActivations is a Range,
   * returns a random number in the Range.
   */
  calculateAmountOfActivations(): number {
    const aoa = this.getAmountOfActivations();
    if (typeof aoa === "number") {
      return aoa;
    }
    return randomInRange(aoa);
  }

  /**
   * The amount of times it activates upon trigger(). Will validify ranges.
   *
   * @example "Spawn 2x spiders" --> 2 amountOfActivations.
   * @example "Spawn 1-3 spiders" --> [1,3] rangeOfActivations.
   */
  setAmountOfActivations(amount: number | Range): this {
    this.aoa = typeof amount === "number" ? amount : validifyRange(amount);
    if (this.aoa === 1) {
      this.aoa = undefined;
    }
    return this;
  }

  setMorality(morality: Morality): this {
    this.mo = morality;
    return this;
  }

  getMorality(): Morality {
    return this.mo ?? DEFAULT_MORALITY;
  }

  /** Returns true if the 'amountOfActivations' is either more than 1, or a Range. */
  isMultiple(): boolean {
    return this.getAmountOfActivations() !== 1;
  }

  /**
   * The percentage chance that the Response is activated upon trigger(). Can be to 2 decimal
   * places.
   *
   * @example "50% chance to spawn a spider" --> 50 chanceToActivate.
   */
  setChanceToActivate(percentage: Percentage): this {
    this.cta = createPercentage(percentage);
    return this;
  }

  getChanceToActivate(): Percentage {
    return this.cta ?? DEFAULT_PERCENTAGE_CHANCE_TO_ACTIVATE;
  }

  getChanceToActivateText(): string {
    const chanceToActivate = this.getChanceToActivate();
    if (chanceToActivate === 100) {
      return "";
    }
    if (chanceToActivate === 0) {
      return NO_CHANCE_TO_ACTIVATE_TEXT;
    }
    return `${chanceToActivate}${CHANCE_TO_ACTIVATE_POST_TEXT}`;
  }

  abstract getVerb(participle: boolean): string;

  abstract getNoun(eid: boolean): string;

  /** Class 'constructor()' behavior is unwanted so we have to create an alternate constructor. */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
  abstract construct(...any: any): this;

  /**
   * Describes the Response in string format.
   *
   * @param eid Whether to use EID formatting.
   * @param participle Whether to use the participle form of the verb (e.g 'getting' instead of
   *                   'get').
   */
  abstract getText(eid: boolean, participle: boolean): string;

  deepCopy(): this {
    return deepCopy(this);
  }

  /**
   * Trigger the Response, which may or may not fire depending on certain Tags. Actions will use
   * this function to fire the Responses tied to them.
   */
  trigger(triggerData: TriggerData = {}): unknown[] {
    fprint(`Triggering Response: ${this.getText(false, false)}.`);

    // Percentage
    if (!rollPercentage(this.getChanceToActivate())) {
      fprint(
        `Failed to activate Response due to ${this.getChanceToActivateText()} chance to activate.`,
      );
      return [];
    }

    // Firing + AmountOfActivations
    const amountOfActivations = this.shouldSkipAmountOfActivations()
      ? 1
      : this.calculateAmountOfActivations();

    fprint(`Firing Response ${amountOfActivations} times.`);

    const returnValues: unknown[] = [];
    for (let i = 0; i < amountOfActivations; i++) {
      fprint(`Firing Response: ${this.getText(false, false)}.`);
      const returnValue = this.fire(triggerData);

      // Don't include 'undefined' return values in array.
      if (returnValue !== undefined) {
        returnValues.push(returnValue);
      }
    }

    // Flatten the array of return values if necessary.
    if (this.shouldFlattenResults()) {
      fprint("Flattening Response return values.");
      return returnValues.flat(1);
    }

    return returnValues;
  }

  // eslint-disable-next-line jsdoc/informative-docs
  /** Fire the response. */
  abstract fire(triggerData: TriggerData): unknown;
}

/** Type guard. */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
export function isResponse(obj: any): obj is Response {
  return "responseType" in obj;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnEffectResponse.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { EffectID } from "../../../enums/data/ID/EffectID";
import {
  getEffectIDName,
  getRandomEffectID,
} from "../../../helper/entityHelper/effectIDHelper";
import { getIncludeModdedEffectsInGenerationSetting } from "../../../features/settings/ModdedEffectSettings";
import { spawnEffectID } from "../../../helper/entityHelper/effectHelper";
import { getRandomPosition } from "../../../helper/positionHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const DEFAULT_SPAWN_VELOCITY = Vector(0, 0);
const UNKNOWN_TEAR_NAME_TEXT = "mysterious effect";
const DEFAULT_EFFECT = EffectID.FART;

/** Response to spawn an Effect. */
export class SpawnEffectResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnEffectResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_EFFECT;
  e?: EffectID | undefined;
  sp?: Vector;
  v?: Vector;

  construct(
    effect?: EffectID,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    if (effect !== undefined) {
      this.setEffect(effect);
    }
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    return this;
  }

  getEffect(): EffectID | undefined {
    return this.e;
  }

  setEffect(effect: EffectID): this {
    this.e = effect;
    return this;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    return (
      this.getPosition() ?? triggerData.spawnPosition ?? getRandomPosition()
    );
  }

  calculateVelocity(triggerData: TriggerData): Vector {
    return triggerData.spawnVelocity ?? DEFAULT_SPAWN_VELOCITY;
  }

  calculateEffect(): EffectID {
    const effect = this.getEffect();
    if (effect !== undefined) {
      return effect;
    }
    const moddedEffectSetting = getIncludeModdedEffectsInGenerationSetting();
    // Random Effect.
    return (
      getRandomEffectID(moddedEffectSetting ? undefined : false) ??
      DEFAULT_EFFECT
    );
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random effect".
   * @example "a fart"
   * @example "50 farts"
   */
  override getNoun(): string {
    const effect = this.getEffect();
    const isMultiple = this.isMultiple();
    if (effect === undefined) {
      // Random effect.
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random effects`;
      }

      return "a random effect";
    }

    // Specific effect.
    const name =
      getEffectIDName(effect)?.toLowerCase() ?? UNKNOWN_TEAR_NAME_TEXT;
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} ${addTheS(effect, true)}`;
    }

    return `${addArticle(name)}`;
  }

  getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntityEffect[] {
    return super.trigger(triggerData) as EntityEffect[];
  }

  fire(triggerData: TriggerData): EntityEffect {
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);
    const effect = this.calculateEffect();

    return spawnEffectID(effect, position, velocity);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnEntityResponse.ts`:

```````ts
import {
  VectorZero,
  getRandomSetElement,
  spawnEntityID,
} from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { EntityCategory } from "../../../enums/general/EntityCategory";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import {
  getEntityIDSet,
  getEntityIDSetFromCategory,
} from "../../../features/data/gameSets/gameEntitySets";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";
import { getRandomPosition } from "../../../helper/positionHelper";
import { entityCategoryToString } from "../../../maps/data/name/entityCategoryNameMap";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { getEntityIDName } from "../../../helper/entityHelper/entityIDNameHelper";

const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const UNKNOWN_ENTITY = "mysterious entity";

/**
 * Response to spawn a non-Grid entity. Note that you should probably use the specific
 * EntityCategory's SpawnResponse instead (e.g SpawnNPCResponse).
 *
 * @param e The Entity to spawn. If undefined, will spawn a random Entity.
 * @param sp The overridden position the entity will spawn at. If undefined, will spawn at a random
 *           position.
 * @param v The overridden velocity the entity will spawn with. If undefined, will spawn with a
 *          random velocity.
 */
export class SpawnEntityResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnEntityResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_ENTITY;
  e?: EntityID | EntityCategory;
  sp?: Vector | undefined;
  v?: Vector | undefined;

  /**
   * Response to spawn a non-Grid entity. Note that you should probably use the specific
   * EntityCategory's SpawnResponse instead (e.g SpawnNPCResponse).
   *
   * @param entity The Entity to spawn. If undefined, will spawn a random Entity.
   * @param overridePos The overridden position the entity will spawn at. If undefined, will spawn
   *                    at a random position.
   * @param overrideVel The overridden velocity the entity will spawn with. If undefined, will spawn
   *                    with a random velocity.
   */
  override construct(
    entity: EntityID | EntityCategory | undefined,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    this.setEntity(entity);
    this.setPosition(overridePos);
    this.setVelocity(overrideVel);
    return this;
  }

  setEntity(entity: EntityID | EntityCategory | undefined): this {
    this.e = entity;
    return this;
  }

  getEntity(): EntityID | EntityCategory | undefined {
    return this.e;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    const position = this.getPosition();
    if (position !== undefined) {
      return position;
    }

    return triggerData.spawnPosition ?? getRandomPosition();
  }

  calculateVelocity(triggerData: TriggerData): Vector {
    const velocity = this.getVelocity();
    if (velocity !== undefined) {
      return velocity;
    }

    return triggerData.spawnVelocity ?? VectorZero;
  }

  calculateEntity(): EntityID {
    const entityID = this.getEntity();

    // Random entity.
    if (entityID === undefined) {
      return getRandomSetElement(getEntityIDSet(), undefined);
    }

    // Specific entity.
    if (typeof entityID === "string") {
      return entityID;
    }

    // Entity category.
    return getRandomSetElement(getEntityIDSetFromCategory(entityID), undefined);
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random entity"
   * @example "3 random entities"
   * @example "a random npc"
   * @example "3 random npcs"
   * @example "a fart"
   */
  override getNoun(_eid: boolean): string {
    const entityID = this.getEntity();
    const isMultiple = this.isMultiple();

    // Random entity.
    if (entityID === undefined) {
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random entities`;
      }
      return "a random entity";
    }

    // Entity category.
    if (typeof entityID === "number") {
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random ${addTheS(
          entityCategoryToString(entityID),
          true,
        )}`;
      }
      return `a random ${entityCategoryToString(entityID).toLowerCase()}`;
    }

    // Specific entity.
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} ${addTheS(
        getEntityIDName(entityID) ?? UNKNOWN_ENTITY,
        true,
      )}`;
    }

    return addArticle(getEntityIDName(entityID) ?? UNKNOWN_ENTITY);
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun(eid);

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): Entity[] {
    return super.trigger(triggerData) as Entity[];
  }

  override fire(triggerData: TriggerData): Entity {
    const entityID = this.calculateEntity();
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);
    return spawnEntityID(entityID, position, velocity);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnGridEntityResponse.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { Response } from "./Response";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { GridID } from "../../../enums/data/ID/GridID";
import {
  getRandomGridID,
  spawnGridID,
} from "../../../helper/gridEntityHelper/gridIDHelper";
import { gridIDToString } from "../../../maps/data/name/gridIDNameMap";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import {
  getRandomArrayElement,
  isVector,
  vectorToString,
} from "isaacscript-common";
import {
  getAllEmptyGridIndexes,
  positionToClampedGridIndex,
} from "../../../helper/gridEntityHelper/gridEntityHelper";
import { fprint } from "../../../helper/printHelper";
import { mod } from "../../../mod";
import type { GridEntityType } from "isaac-typescript-definitions";
import { gridEntityTypeToString } from "../../../maps/data/name/gridEntityTypeNameMap";

const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const GRID_ENTITY_NOUN = "obstacle";
const GRID_ENTITY_NOUN_PLURAL = "obstacles";

/**
 * Response to spawn a Grid Entity.
 *
 * @param ge The Grid Entity to spawn. If undefined, will spawn a random non-modded Grid Entity.
 * @param gi The overridden grid index the grid entity will spawn at. If it's a Vector, it will
 *           convert it to the nearest grid index.
 */
export class SpawnGridEntityResponse extends Response {
  override responseType: ResponseType = ResponseType.SPAWN_GRID;
  ge?: GridID | GridEntityType;
  gi?: number;

  /**
   * Response to spawn a Grid Entity.
   *
   * @param gridID The Grid Entity to spawn. If undefined, will spawn a random non-modded Grid
   *               Entity. If it's a GridEntityType, will spawn a random Grid Entity of that type.
   * @param positionOrGrid The overridden grid index the grid entity will spawn at. If it's a
   *                       Vector, it will convert it to the nearest grid index.
   */
  construct(
    gridID?: GridID | GridEntityType,
    positionOrGrid?: Vector | number,
  ): this {
    if (gridID !== undefined) {
      this.setGridEntity(gridID);
    }
    this.setPosition(positionOrGrid);
    return this;
  }

  /**
   * Set the overridden grid index the grid entity will spawn at. If it's a Vector, it will convert
   * it to the nearest grid index.
   *
   * @param positionOrGrid The overridden grid index the grid entity will spawn at. If it's a
   *                       Vector, it will convert it to the nearest grid index. If undefined, will
   *                       spawn at a random grid index.
   */
  setPosition(positionOrGrid: Vector | number | undefined): this {
    if (isVector(positionOrGrid)) {
      this.gi = positionToClampedGridIndex(positionOrGrid);
      return this;
    }
    this.gi = positionOrGrid;
    return this;
  }

  /** Get the overridden grid index the grid entity will spawn at. */
  getPosition(): number | undefined {
    return this.gi;
  }

  /**
   * Get the overridden grid index the grid entity will spawn at. If it's undefined, will spawn at a
   * random grid index.
   */
  calculatePosition(triggerData: TriggerData): number | undefined {
    const position = this.getPosition();
    if (position !== undefined) {
      return position;
    }

    const { spawnPosition } = triggerData;
    if (spawnPosition !== undefined) {
      const gridIndex = positionToClampedGridIndex(spawnPosition);
      fprint(
        `SpawnGridEntityResponse: Using index ${gridIndex} and spawn position: ${vectorToString(
          spawnPosition,
        )}.`,
      );
      return gridIndex;
    }

    const safeGridIndices = getAllEmptyGridIndexes();
    if (safeGridIndices.length === 0) {
      return undefined;
    }

    return getRandomArrayElement(safeGridIndices, undefined);
  }

  /**
   * Set the Grid Entity to spawn. If it is undefined, will spawn a random non-modded Grid Entity.
   */
  setGridEntity(gridID: GridID | GridEntityType | undefined): void {
    this.ge = gridID;
  }

  /**
   * Set the Grid Entity to spawn. If it is undefined, will spawn a random non-modded Grid Entity.
   */
  getGridEntity(): GridID | GridEntityType | undefined {
    return this.ge;
  }

  calculateGridEntity(): GridID {
    const gridEntity = this.getGridEntity();
    if (gridEntity === undefined) {
      return getRandomGridID();
    }

    if (typeof gridEntity === "number") {
      return `${gridEntity}.-1` as GridID;
    }

    return gridEntity;
  }

  spawnGridEntities(triggerData: TriggerData): GridEntity[] {
    const amountOfActivations = this.calculateAmountOfActivations();

    // Spawn the grid entities.
    const gridEntities: GridEntity[] = [];
    for (let i = 0; i < amountOfActivations; i++) {
      const gridEntityID = this.calculateGridEntity();
      const position = this.calculatePosition(triggerData);
      if (position === undefined) {
        break;
      }

      // We don't want to spawn the grid entity on top of another grid entity, as this calls 'room
      // update' and will invoke the room update USE_CALLBACK bug. If the grid entity does somehow
      // decide to spawn on top of another grid entity, nothing will happen.
      const spawnedGridEntity = spawnGridID(gridEntityID, position, false);
      if (spawnedGridEntity !== undefined) {
        gridEntities.push(spawnedGridEntity);
      }
    }

    // Update the room?

    return gridEntities;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a rock"
   * @example "3-4 random obstacles"
   */
  override getNoun(): string {
    const gridEntity = this.getGridEntity();
    const isMultiple = this.isMultiple();

    // GridEntityType
    if (typeof gridEntity === "number") {
      if (!isMultiple) {
        return addArticle(gridEntityTypeToString(gridEntity).toLowerCase());
      }

      return `${this.getAmountOfActivationsText()} ${addTheS(
        gridEntityTypeToString(gridEntity).toLowerCase(),
        true,
      )}`;
    }

    if (gridEntity !== undefined) {
      if (!isMultiple) {
        return addArticle(gridIDToString(gridEntity));
      }

      return `${this.getAmountOfActivationsText()} ${addTheS(
        gridIDToString(gridEntity),
        true,
      )}`;
    }

    // Random Grid Entity.
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} random ${GRID_ENTITY_NOUN_PLURAL}`;
    }

    return `a random ${GRID_ENTITY_NOUN}`;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override shouldSkipAmountOfActivations(): boolean {
    return true;
  }

  override getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  // Delay for TransformResponse.
  override trigger(triggerData?: TriggerData): GridEntity[] {
    if (triggerData?.shouldSpawnGridEntityResponseDelay ?? false) {
      fprint("Delaying SpawnGridEntityResponse.");
      mod.runInNGameFrames(() => super.trigger(triggerData), 1, true);
      return [];
    }
    return super.trigger(triggerData) as GridEntity[];
  }

  override fire(triggerData: TriggerData): GridEntity[] {
    // TODO: Use REPENTOGON's safe grid position code.
    return this.spawnGridEntities(triggerData);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnHybridNPCResponse.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import {
  getRandomAccessiblePosition,
  isPositionAccessible,
} from "../../../helper/positionHelper";
import {
  game,
  DISTANCE_OF_GRID_TILE,
  VectorZero,
  isArray,
} from "isaacscript-common";
import { spawnHybridNPC } from "../../facets/entityModifiers.ts/NPCModifiers/HybridNPCFacet";
import type { NPCAttribute } from "../../../interfaces/general/NPCAttribute";
import { getRandomAssortmentOfNPCs } from "../../../helper/entityHelper/npcHelper";
import {
  HYBRID_NPC_DEFAULT_NPC_AMOUNT,
  HYBRID_NPC_MINIMUM_NPC_AMOUNT,
} from "../../../constants/corruptionConstants";

const DEFAULT_SPAWN_VELOCITY = VectorZero;
const DEFAULT_NPC_MIX = [NPCID.SPIDER, NPCID.DIP] as const;

export class SpawnHybridNPCResponse extends Response {
  override responseType: ResponseType = ResponseType.SPAWN_HYBRID_NPC;
  npcs?: readonly NPCID[] | NPCAttribute;
  sp?: Vector;
  sv?: Vector;

  override construct(
    npc: readonly NPCID[] | NPCAttribute | undefined,
    overridePos?: Vector,
  ): this {
    this.setNPCs(npc);
    if (overridePos !== undefined) {
      this.setSpawnPosition(overridePos);
    }
    return this;
  }

  setNPCs(npcs: readonly NPCID[] | NPCAttribute | undefined): this {
    this.npcs = npcs;
    return this;
  }

  getNPCs(): readonly NPCID[] | NPCAttribute | undefined {
    return this.npcs;
  }

  setSpawnPosition(sp: Vector): this {
    this.sp = sp;
    return this;
  }

  getSpawnPosition(): Vector | undefined {
    return this.sp;
  }

  setSpawnVelocity(sv: Vector): this {
    this.sv = sv;
    return this;
  }

  getSpawnVelocity(): Vector | undefined {
    return this.sv;
  }

  calculateSpawnPosition(triggerData: TriggerData): Vector {
    const sp = this.getSpawnPosition();
    if (sp !== undefined) {
      return sp;
    }

    const triggerDataPosition = triggerData.spawnPosition;
    if (
      triggerDataPosition &&
      isPositionAccessible(
        triggerDataPosition,
        triggerData.player?.Position ?? Isaac.GetPlayer().Position,
      )
    ) {
      return triggerDataPosition;
    }

    return (
      getRandomAccessiblePosition(Isaac.GetPlayer().Position) ??
      game.GetRoom().GetRandomPosition(DISTANCE_OF_GRID_TILE)
    );
  }

  calculateSpawnVelocity(triggerData: TriggerData): Vector {
    const sv = this.getSpawnVelocity();
    if (sv !== undefined) {
      return sv;
    }

    const triggerDataVelocity = triggerData.spawnVelocity;
    if (triggerDataVelocity) {
      return triggerDataVelocity;
    }

    return DEFAULT_SPAWN_VELOCITY;
  }

  calculateNPCs(_triggerData: TriggerData): readonly NPCID[] {
    let npcs = this.getNPCs();

    // Random NPC.
    if (npcs === undefined) {
      return (
        getRandomAssortmentOfNPCs(HYBRID_NPC_DEFAULT_NPC_AMOUNT) ??
        DEFAULT_NPC_MIX
      );
    }

    // NPCAttribute.
    if (!isArray(npcs)) {
      npcs = getRandomAssortmentOfNPCs(
        HYBRID_NPC_DEFAULT_NPC_AMOUNT,
        npcs as NPCAttribute,
      );
    }

    if (npcs === undefined || npcs.length < HYBRID_NPC_MINIMUM_NPC_AMOUNT) {
      return DEFAULT_NPC_MIX;
    }

    return npcs as readonly NPCID[];
  }

  override getVerb(_participle: boolean): string {
    return "";
  }

  override getNoun(_eid: boolean): string {
    return "";
  }

  override getText(_eid: boolean, _participle: boolean): string {
    return "";
  }

  override fire(triggerData: TriggerData): EntityNPC {
    const spawnPosition = this.calculateSpawnPosition(triggerData);
    const _spawnVelocity = this.calculateSpawnVelocity(triggerData);
    const npcs = this.calculateNPCs(triggerData);

    return spawnHybridNPC(spawnPosition, ...npcs);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnLiveBombResponse.ts`:

```````ts
import type { BombVariant } from "isaac-typescript-definitions";
import { EntityType } from "isaac-typescript-definitions";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import type { EntityID } from "isaacscript-common";
import {
  getRandomInt,
  getRandomSetElement,
  getRandomVector,
  spawnEntityID,
} from "isaacscript-common";
import { EntityCategory } from "../../../enums/general/EntityCategory";
import { getEntityCategoryFromEntityID } from "../../../helper/entityHelper/entityIDHelper";
import { getEntityIDSetFromCategory } from "../../../features/data/gameSets/gameEntitySets";
import { getRandomPosition } from "../../../helper/positionHelper";
import { getBombEntityIDName } from "../../../helper/entityHelper/bombEntityHelper";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const DEFAULT_BOMB_SUBTYPE = 0;
const MINIMUM_SPEED = 0;
const MAXIMUM_SPEED = 40;
const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const UNKNOWN_BOMB_NAME = "mysterious bomb";

/**
 * Response to spawn a live bomb.
 *
 * @param lb Bomb variant to spawn.
 * @param sp The position to spawn the bomb at. If not specified, will spawn at a random position.
 * @param v The velocity to spawn the bomb with. If not specified, will spawn with a random
 *          velocity.
 */
export class SpawnLiveBombResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnLiveBombResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_LIVE_BOMB;
  lb?: EntityID;
  sp?: Vector;
  v?: Vector;

  override construct(
    bombVariantOrEntityID?: BombVariant | EntityID,
    subType?: number,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    if (bombVariantOrEntityID !== undefined) {
      this.setBomb(bombVariantOrEntityID, subType);
    }
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    return this;
  }

  /** Get the live bomb to spawn. If undefined, will spawn a random bomb. */
  getBomb(): EntityID | undefined {
    return this.lb;
  }

  /**
   * Set the live bomb to spawn. If bombVariantOrEntityID is a bomb EntityID, will spawn that
   * EntityID. If bombVariantOrEntityID is a BombVariant, will spawn that bomb variant with the
   * provided subType, or 0 if subType is undefined. If bombVariantOrEntityID is undefined, will
   * spawn a random bomb.
   */
  setBomb(
    bombVariantOrEntityID?: BombVariant | EntityID,
    subType?: number,
  ): this {
    if (bombVariantOrEntityID === undefined) {
      this.lb = undefined;
      return this;
    }

    if (typeof bombVariantOrEntityID === "string") {
      if (
        getEntityCategoryFromEntityID(bombVariantOrEntityID) !==
        EntityCategory.BOMB
      ) {
        error(`EntityID '${bombVariantOrEntityID}' is not a bomb!`);
      }
      this.lb = bombVariantOrEntityID;
      return this;
    }

    const entityID = `${EntityType.BOMB}.${bombVariantOrEntityID}.${
      subType ?? DEFAULT_BOMB_SUBTYPE
    }` as EntityID;
    this.lb = entityID;
    return this;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    return (
      this.getPosition() ?? triggerData.spawnPosition ?? getRandomPosition()
    );
  }

  calculateVelocity(_triggerData: TriggerData): Vector {
    const overrideVel = this.getVelocity();
    if (overrideVel !== undefined) {
      return overrideVel;
    }

    // We get a random velocity.
    const direction = getRandomVector(undefined);
    const speed = getRandomInt(MINIMUM_SPEED, MAXIMUM_SPEED, undefined);
    return direction.mul(speed);
  }

  // TODO: Implement random bomb spawning.
  calculateBomb(): EntityID {
    return (
      this.lb ??
      getRandomSetElement(
        getEntityIDSetFromCategory(EntityCategory.BOMB),
        undefined,
      )
    );
  }

  /**
   * Get noun text.
   *
   * @example "a random live bomb"
   * @example "3-4 live bobby bombs"
   */
  getNoun(): string {
    const bomb = this.getBomb();
    const isMultiple = this.isMultiple();
    if (bomb === undefined) {
      return isMultiple
        ? `${this.getAmountOfActivationsText()} random live bombs`
        : "a random live bomb";
    }

    const bombName =
      getBombEntityIDName(bomb)?.toLowerCase() ?? UNKNOWN_BOMB_NAME;
    return isMultiple
      ? `${this.getAmountOfActivationsText()} live ${addTheS(bombName, true)}`
      : `${addArticle(bombName)}`;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntityBomb[] {
    return super.trigger(triggerData) as EntityBomb[];
  }

  override fire(triggerData: TriggerData): EntityBomb {
    const bombEntityID = this.calculateBomb();
    const player = triggerData.player ?? Isaac.GetPlayer(0);
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);

    return spawnEntityID(
      bombEntityID,
      position,
      velocity,
      player,
    ) as EntityBomb;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnNPCResponse.ts`:

```````ts
import {
  DISTANCE_OF_GRID_TILE,
  VectorZero,
  game,
  getRandomSeed,
} from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import type { Range } from "../../../types/general/Range";
import type { NPCAttribute } from "../../../interfaces/general/NPCAttribute";
import type { NPCFlag } from "../../../enums/general/NPCFlag";
import { addNPCFlags } from "../../../helper/entityHelper/npcFlagHelper";
import {
  getRandomNPC,
  npcAttributesToText,
} from "../../../helper/entityHelper/npcHelper";
import {
  getNPCIDName,
  spawnNPCID,
} from "../../../helper/entityHelper/npcIDHelper";
import type { ChampionColor } from "isaac-typescript-definitions";
import { NPCID } from "isaac-typescript-definitions";
import { championColorToString } from "../../../maps/data/name/championColorNameMap";
import { npcFlagToString } from "../../../maps/data/name/npcFlagNameMap";
import {
  isPositionAccessible,
  getRandomAccessiblePosition,
} from "../../../helper/positionHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const DEFAULT_NPC = NPCID.GAPER;
const UNKNOWN_NPC_NAME_TEXT = "unknown npc";
const VERB = "spawn";
const DEFAULT_SPAWN_VELOCITY = VectorZero;

/**
 * Response to spawn an NPC.
 *
 * @param e The NPC you want to spawn. Can be a specific NPC, or a random NPC from a group.
 * @param sp The position to spawn the NPC/s at. If not specified, will spawn at a random accessible
 *           position.
 * @param rst How the NPC/s are spawned. Defaults to 'accessible to player but avoid'.
 * @param flg Custom NPC flags to modify the NPC's behavior or appearance.
 */
export class SpawnNPCResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnNPCResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_NPC;
  e?: NPCID | NPCAttribute;
  sp?: Vector;
  v?: Vector;
  flg?: readonly NPCFlag[];
  chmp?: ChampionColor;

  /**
   * Constructor for SpawnNPCResponse.
   *
   * @param entityNPC The NPC you want to spawn. Can be a specific NPC, or a random NPC from a
   *                  group.
   * @param overridePos The position to spawn the NPC/s at. If not specified, will spawn at a random
   *                    accessible position.
   * @param overrideVel The velocity of the NPC/s. Defaults to zero.
   * @param amount The amount of NPCs to spawn. If a range, will spawn a random amount between the
   *               range.
   * @param flags Custom NPC flags to modify the NPC's behavior or appearance.
   * @param championColor The champion color to make the NPC/s.
   */
  construct(
    entityNPC: NPCID | NPCAttribute,
    overridePos?: Vector,
    overrideVel?: Vector,
    amount?: number | Range,
    flags?: readonly NPCFlag[],
    championColor?: ChampionColor,
  ): this {
    this.setNPC(entityNPC);
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    if (amount !== undefined) {
      this.setAmountOfActivations(amount);
    }
    if (flags !== undefined) {
      this.setNPCFlags(flags);
    }
    if (championColor !== undefined) {
      this.setChampionColor(championColor);
    }
    return this;
  }

  getNPCFlags(): readonly NPCFlag[] | undefined {
    return this.flg;
  }

  setNPCFlags(flags: readonly NPCFlag[]): this {
    this.flg = flags;
    return this;
  }

  /**
   * Get the NPC name plus any adjectives (e.g. 'charmed', 'blue-champion') as text. Will
   * automatically add the article.
   *
   * @example "a charmed gaper"
   * @example "a flying boss"
   */
  getNPCNameClause(adjectives: string): string {
    const npc = this.getNPC();
    const plural = this.isMultiple();
    if (typeof npc === "string") {
      let npcNameClause = getNPCIDName(npc) ?? UNKNOWN_NPC_NAME_TEXT;
      if (plural) {
        // Add the plural 's' to the end of the name.
        npcNameClause = addTheS(npcNameClause, true);
      }

      npcNameClause = `${adjectives} ${npcNameClause}`;
      if (!plural) {
        // Only add the article if it's singular.
        npcNameClause = addArticle(npcNameClause);
      }

      return npcNameClause;
    }
    return npcAttributesToText(npc, plural, adjectives);
  }

  getNPC(): NPCID | NPCAttribute {
    return this.e ?? DEFAULT_NPC;
  }

  setNPC(npc: NPCID | NPCAttribute): this {
    this.e = npc;
    return this;
  }

  getChampionColor(): ChampionColor | undefined {
    return this.chmp;
  }

  setChampionColor(championColor: ChampionColor): this {
    this.chmp = championColor;
    return this;
  }

  calculatePostNPCSpawn(spawnedNPC: EntityNPC): EntityNPC {
    const championColor = this.getChampionColor();
    const flags = this.getNPCFlags();
    if (championColor !== undefined) {
      spawnedNPC.MakeChampion(getRandomSeed(), championColor);
    }
    if (flags !== undefined) {
      addNPCFlags(spawnedNPC, ...flags);
    }
    return spawnedNPC;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    const position = this.getPosition();
    if (position !== undefined) {
      return position;
    }

    const triggerDataPosition = triggerData.spawnPosition;
    if (
      triggerDataPosition &&
      isPositionAccessible(
        triggerDataPosition,
        triggerData.player?.Position ?? Isaac.GetPlayer().Position,
      )
    ) {
      return triggerDataPosition;
    }

    return (
      getRandomAccessiblePosition(Isaac.GetPlayer().Position) ??
      game.GetRoom().GetRandomPosition(DISTANCE_OF_GRID_TILE)
    );
  }

  calculateVelocity(triggerData: TriggerData): Vector {
    return triggerData.spawnVelocity ?? DEFAULT_SPAWN_VELOCITY;
  }

  spawnNPC(position: Vector, velocity: Vector): EntityNPC {
    const npc = this.getNPC();
    if (typeof npc === "string") {
      return this.calculatePostNPCSpawn(spawnNPCID(npc, position, velocity));
    }
    // Random.
    const randomNPC = getRandomNPC(npc);
    if (randomNPC === undefined) {
      return spawnNPCID(DEFAULT_NPC, position, velocity);
    }
    return this.calculatePostNPCSpawn(
      spawnNPCID(randomNPC, position, velocity),
    );
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB : VERB;
  }

  getNPCFlagText(): string {
    const flags = this.getNPCFlags();
    if (flags === undefined) {
      return "";
    }
    return flags.map((flag) => npcFlagToString(flag)).join(", ");
  }

  getChampionColorText(): string {
    const championColor = this.getChampionColor();
    if (championColor === undefined) {
      return "";
    }
    return `${championColorToString(championColor)}-Champion`;
  }

  // Get NPC modifiers (e.g. 'charmed', 'blue-champion') as text. This does not include
  // NPCAttributes for random NPCs.
  getAdjectivesText(): string {
    let text = "";
    text += this.getNPCFlagText();
    text += " ";
    text += this.getChampionColorText();
    return text;
  }

  /**
   * Get noun text.
   *
   * @example "3-4 gapers"
   * @example "a random flying boss"
   * @example "12 blue-champion enemies"
   */
  override getNoun(): string {
    const amountOfActivationsText = this.getAmountOfActivationsText() ?? "";
    const adjectives = this.getAdjectivesText();
    const npcNameClause = this.getNPCNameClause(adjectives);

    return `${amountOfActivationsText} ${npcNameClause}`;
  }

  getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntityNPC[] {
    return super.trigger(triggerData) as EntityNPC[];
  }

  fire(triggerData: TriggerData): EntityNPC {
    return this.spawnNPC(
      this.calculatePosition(triggerData),
      this.calculateVelocity(triggerData),
    );
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnPickupResponse.ts`:

```````ts
import { EntityType, PickupVariant } from "isaac-typescript-definitions";
import { VectorZero } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import type { PickupID } from "../../../enums/data/ID/PickupID";
import type { PickupType } from "../../../enums/general/PickupType";
import {
  getPickupIDName,
  getRandomPickupID,
  getRandomPickupIDFromPickupType,
  getSoftRandomPickupIDFromPickupType,
  spawnPickupID,
} from "../../../helper/entityHelper/pickupIDHelper";
import { getIncludeModdedPickupsInGenerationSetting } from "../../../features/settings/ModdedPickupSettings";
import { RANDOM_PICKUP_ID } from "../../../constants/pickupConstants";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { pickupTypeToString } from "../../../maps/data/name/pickupTypeNameMap";
import { getRandomPosition } from "../../../helper/positionHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const DEFAULT_PICKUP_ID =
  `${EntityType.PICKUP}.${PickupVariant.POOP}.0` as PickupID;
const DEFAULT_SOFT_RANDOM = false;
const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const UNKNOWN_PICKUP_TEXT = "mysterious pickup";

/**
 * Response to spawn a Pickup. The pickup will be spawned at a random accessible position with a
 * velocity of zero, unless overridden.
 *
 * @field p The PickupID or PickupType to spawn. If not specified, a random Pickup will be spawned.
 * @field sp Override the position to spawn the Pickup at.
 * @field v Override the velocity of the Pickup.
 * @field sft If true, if the pickup is a random pickup, it will have less chance of being a good
 *        pickup, instead of an equal chance at being a pickup of that type. Defaults to false.
 */
export class SpawnPickupResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnPickupResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_PICKUP;
  p?: PickupID | PickupType;
  sp?: Vector;
  v?: Vector;
  sft?: boolean;

  construct(
    pickupID?: PickupID | PickupType,
    softRandom?: boolean,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    if (pickupID !== undefined) {
      this.setPickup(pickupID);
    }
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    if (softRandom !== undefined) {
      this.setSoftRandom(softRandom);
    }
    return this;
  }

  getPickup(): PickupID | PickupType | undefined {
    return this.p;
  }

  setPickup(pickupID: PickupID | PickupType): this {
    this.p = pickupID;
    return this;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  /**
   * If true, if the pickup is a random pickup, it will have less chance of being a good pickup,
   * instead of an equal chance at being a pickup of that type. Defaults to false.
   */
  getSoftRandom(): boolean {
    return this.sft ?? DEFAULT_SOFT_RANDOM;
  }

  /**
   * If true, if the pickup is a random pickup, it will have less chance of being a good pickup,
   * instead of an equal chance at being a pickup of that type. Defaults to false.
   */
  setSoftRandom(softRandom: boolean): this {
    this.sft = softRandom;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  spawnPickup(
    pickup: PickupID,
    position: Vector,
    velocity: Vector,
  ): EntityPickup {
    return spawnPickupID(pickup, position, velocity);
  }

  calculatePickup(): PickupID {
    const softRandom = this.getSoftRandom();
    const pickup = this.getPickup();
    const moddedPickupSetting = getIncludeModdedPickupsInGenerationSetting();

    // If the Pickup is undefined, spawn a random pickup.
    if (pickup === undefined) {
      if (softRandom) {
        return RANDOM_PICKUP_ID;
      }
      return (
        getRandomPickupID(moddedPickupSetting ? undefined : false) ??
        DEFAULT_PICKUP_ID
      );
    }

    if (typeof pickup === "string") {
      return pickup;
    }

    // If the Pickup is a PickupType, and it is soft random.
    if (softRandom) {
      return getSoftRandomPickupIDFromPickupType(pickup);
    }

    return getRandomPickupIDFromPickupType(pickup) ?? DEFAULT_PICKUP_ID;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    const position = this.getPosition();
    if (position !== undefined) {
      return position;
    }

    return triggerData.spawnPosition ?? getRandomPosition();
  }

  calculateVelocity(triggerData: TriggerData): Vector {
    const velocity = this.getVelocity();
    if (velocity !== undefined) {
      return velocity;
    }

    return triggerData.spawnVelocity ?? VectorZero;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random pickup"
   * @example "a random bomb"
   * @example "3 sticky nickels"
   */
  override getNoun(): string {
    const isMultiple = this.isMultiple();
    const pickup = this.getPickup();

    if (pickup === undefined) {
      if (isMultiple) {
        const amountOfActivationsText = this.getAmountOfActivationsText();
        return `${amountOfActivationsText} random pickups`;
      }

      return "a random pickup";
    }

    // Is a PickupID.
    if (typeof pickup === "string") {
      const pickupName = getPickupIDName(pickup) ?? UNKNOWN_PICKUP_TEXT;

      if (isMultiple) {
        const amountOfActivationsText = this.getAmountOfActivationsText();
        return `${amountOfActivationsText} ${addTheS(pickup, isMultiple)}`;
      }

      return `${addArticle(pickupName)}`;
    }

    // It's a PickupType.
    const pickupTypeText = pickupTypeToString(pickup).toLowerCase();
    if (isMultiple) {
      const amountOfActivationsText = this.getAmountOfActivationsText();
      return `${amountOfActivationsText} random ${addTheS(
        pickupTypeText,
        isMultiple,
      )}`;
    }

    return `a random ${pickupTypeText}`;
  }

  getText(_eid: boolean, participle: boolean): string {
    const noun = this.getNoun();
    const verb = this.getVerb(participle);

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntityPickup[] {
    return super.trigger(triggerData) as EntityPickup[];
  }

  fire(triggerData: TriggerData): EntityPickup {
    // Determine the player.
    const pickup = this.calculatePickup();
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);

    return this.spawnPickup(pickup, position, velocity);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnSlotResponse.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { getRandomSetElement, spawnEntityID } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { getEntityIDSetFromCategory } from "../../../features/data/gameSets/gameEntitySets";
import { EntityCategory } from "../../../enums/general/EntityCategory";
import type { SlotVariant } from "isaac-typescript-definitions";
import { EntityType } from "isaac-typescript-definitions";
import { getSlotIDName } from "../../../helper/entityHelper/slotHelper";
import { addArticle, addTheS } from "../../../helper/stringHelper";
import { getRandomPosition } from "../../../helper/positionHelper";
import { getEntityCategoryFromEntityID } from "../../../helper/entityHelper/entityIDHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const DEFAULT_SPAWN_VELOCITY = Vector(0, 0);
const DEFAULT_SUBTYPE = 0;
const MACHINE_NOUN = "machine";
const MACHINE_NOUN_PLURAL = "machines";
const UNKNOWN_SLOT_NAME_TEXT = `mysterious ${MACHINE_NOUN}`;

/**
 * Response to spawn a Slot.
 *
 * @param e The EntityID referring to the Slot you want to spawn. If undefined, will spawn a random
 *          Slot.
 * @param sp The position to spawn the Slot/s at. If not specified, will spawn at a random safe
 *           position.
 * @param v The velocity to spawn the Slot/s with. If not specified, will spawn with no velocity.
 */
export class SpawnSlotResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnSlotResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_SLOT;
  e?: EntityID;
  sp?: Vector;
  v?: Vector;

  construct(
    slotVariantOrEntityID?: SlotVariant | EntityID,
    subType?: number,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    if (slotVariantOrEntityID !== undefined) {
      this.setSlot(slotVariantOrEntityID, subType);
    }
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    return this;
  }

  getSlot(): EntityID | undefined {
    return this.e;
  }

  /**
   * If an EntityID is specified, subType will be ignored. If a SlotVariant is specified, and
   * subType is undefined, subType will default to 0.
   */
  setSlot(slot: SlotVariant | EntityID, subType?: number): this {
    if (typeof slot === "string") {
      if (getEntityCategoryFromEntityID(slot) !== EntityCategory.SLOT) {
        error(`EntityID '${slot}' is not a slot!`);
      }
      this.e = slot;
      return this;
    }

    // SlotVariant.
    const entityID = `${EntityType.SLOT}.${slot}.${
      subType ?? DEFAULT_SUBTYPE
    }` as EntityID;
    this.e = entityID;
    return this;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    return (
      this.getPosition() ?? triggerData.spawnPosition ?? getRandomPosition()
    );
  }

  calculateVelocity(_triggerData: TriggerData): Vector {
    return this.getVelocity() ?? DEFAULT_SPAWN_VELOCITY;
  }

  calculateSlot(): EntityID {
    const slot = this.getSlot();
    if (slot !== undefined) {
      return slot;
    }

    // Random Slot.
    const slots = getEntityIDSetFromCategory(EntityCategory.SLOT);
    return getRandomSetElement<EntityID>(slots, undefined);
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random slot"
   * @example "3 shell games"
   */
  override getNoun(): string {
    const slot = this.getSlot();
    const isMultiple = this.isMultiple();
    if (slot === undefined) {
      // Random slot.
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random ${MACHINE_NOUN_PLURAL}`;
      }

      return `a random ${MACHINE_NOUN}`;
    }

    // Specific slot.
    const name = getSlotIDName(slot)?.toLowerCase() ?? UNKNOWN_SLOT_NAME_TEXT;
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} ${addTheS(
        name,
        isMultiple,
      )}`;
    }

    return `${addArticle(name)}`;
  }

  getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntitySlot[] {
    return super.trigger(triggerData) as EntitySlot[];
  }

  fire(triggerData: TriggerData): EntitySlot {
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);
    const slot = this.calculateSlot();

    return spawnEntityID(slot, position, velocity) as EntitySlot;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\SpawnTearResponse.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { getRandomSetElement, spawnEntityID } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { getEntityIDSetFromCategory } from "../../../features/data/gameSets/gameEntitySets";
import { EntityCategory } from "../../../enums/general/EntityCategory";
import type { TearVariant } from "isaac-typescript-definitions";
import { EntityType } from "isaac-typescript-definitions";
import { addArticle } from "../../../helper/stringHelper";
import { getTearIDName } from "../../../helper/entityHelper/tearHelper";
import { getRandomPosition } from "../../../helper/positionHelper";
import type { SpawnEntityResponseInterface } from "../../../interfaces/corruption/responses/SpawnEntityResponseInterface";

const VERB = "spawn";
const VERB_PARTICIPLE = "spawning";
const DEFAULT_SPAWN_VELOCITY = Vector(0, 0);
const UNKNOWN_TEAR_NAME_TEXT = "mysterious tear";

/** Response to spawn a Tear. */
export class SpawnTearResponse
  extends Response
  implements SpawnEntityResponseInterface<SpawnTearResponse>
{
  override responseType: ResponseType = ResponseType.SPAWN_TEAR;
  e?: TearVariant | undefined;
  sp?: Vector;
  v?: Vector;

  construct(
    tear?: TearVariant,
    overridePos?: Vector,
    overrideVel?: Vector,
  ): this {
    if (tear !== undefined) {
      this.setTear(tear);
    }
    if (overridePos !== undefined) {
      this.setPosition(overridePos);
    }
    if (overrideVel !== undefined) {
      this.setVelocity(overrideVel);
    }
    return this;
  }

  getTear(): TearVariant | undefined {
    return this.e;
  }

  setTear(tear: TearVariant): this {
    this.e = tear;
    return this;
  }

  getPosition(): Vector | undefined {
    return this.sp;
  }

  setPosition(position?: Vector): this {
    this.sp = position;
    return this;
  }

  getVelocity(): Vector | undefined {
    return this.v;
  }

  setVelocity(velocity?: Vector): this {
    this.v = velocity;
    return this;
  }

  calculatePosition(triggerData: TriggerData): Vector {
    return (
      this.getPosition() ?? triggerData.spawnPosition ?? getRandomPosition()
    );
  }

  calculateVelocity(triggerData: TriggerData): Vector {
    return triggerData.spawnVelocity ?? DEFAULT_SPAWN_VELOCITY;
  }

  calculateTear(): EntityID {
    const tear = this.getTear();
    if (tear !== undefined) {
      return `${EntityType.TEAR}.${tear}.0` as EntityID;
    }

    // Random Slot.
    const tears = getEntityIDSetFromCategory(EntityCategory.TEAR);
    return getRandomSetElement<EntityID>(tears, undefined);
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "a random tear"
   * @example "3-4 booger tears"
   */
  getNoun(): string {
    const tear = this.getTear();
    const isMultiple = this.isMultiple();
    if (tear === undefined) {
      // Random tears.
      if (isMultiple) {
        return `${this.getAmountOfActivationsText()} random tears`;
      }

      return "a random tear";
    }

    // Specific tear.
    const name =
      getTearIDName(
        `${EntityType.TEAR}.${tear}.0` as EntityID,
      )?.toLowerCase() ?? UNKNOWN_TEAR_NAME_TEXT;
    if (isMultiple) {
      return `${this.getAmountOfActivationsText()} ${tear} tears`;
    }

    return `${addArticle(name)} tear`;
  }

  getText(_eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const noun = this.getNoun();

    return `${verb} ${noun}`;
  }

  override trigger(triggerData?: TriggerData): EntityTear[] {
    return super.trigger(triggerData) as EntityTear[];
  }

  fire(triggerData: TriggerData): EntityTear {
    const position = this.calculatePosition(triggerData);
    const velocity = this.calculateVelocity(triggerData);
    const slot = this.calculateTear();

    return spawnEntityID(slot, position, velocity) as EntityTear;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TemporaryActionResponse.ts`:

```````ts
import { deepCopy } from "isaacscript-common";
import { ActionOrigin } from "../../../enums/corruption/actions/ActionOrigin";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import {
  _addActionsToTracker,
  addTemporaryActionToPlayer,
} from "../../../features/corruption/effects/playerEffects";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { mod } from "../../../mod";
import type { Action } from "../actions/Action";
import { OnRoomAction } from "../actions/OnRoomAction";
import { RemoveActionResponse } from "./RemoveActionResponse";
import { Response } from "./Response";
import { ActionType } from "../../../enums/corruption/actions/ActionType";

const DEFAULT_TEMP_ACTION = new OnRoomAction();
const DEFAULT_REMOVE_ON = new OnRoomAction();
const DEFAULT_REMOVAL_RESPONSE = new RemoveActionResponse();
const VERB = "give";
const VERB_PARTICIPLE = "giving";

/**
 * Gives the player a temporary Action until it is triggered for removal.
 *
 * @example Get the effect 'every room, get 1 blue spider' for the floor.
 */
export class TemporaryActionResponse extends Response {
  override responseType: ResponseType = ResponseType.TEMPORARY_ACTION;

  // The action to give to the player. It will be deep copied, as multiple may be given. Actions
  // will have their 'origin' be 'TEMPORARY_ACTION', and an ID which will keep track of them for
  // removal.
  a?: Action;

  /** Remove on. */
  ro?: Action;

  /** These will be deep copied. */
  construct(temporaryAction: Action, removeOn: Action): this {
    return this.setAction(temporaryAction).setRemoveOn(removeOn);
  }

  /** Get the Action that will be temporarily added. */
  getAction(): Action {
    return this.a ?? DEFAULT_TEMP_ACTION;
  }

  /**
   * Get the ActionType of the temporary Action, or the ActionType of the default temporary Action.
   */
  getActionType(): ActionType {
    return this.a?.actionType ?? ActionType.ON_ROOM;
  }

  /** Set the Action that should be temporarily added. This will deep copy it. */
  setAction(action: Action): this {
    this.a = deepCopy<Action>(action);
    return this;
  }

  /**
   * Deep copies the temporary Action, adding it to the player.
   *
   * @returns The TemporaryActionID of the temporary Action that was added to the player.
   */
  addTemporaryActionToPlayer(player: EntityPlayer): int {
    const deepCopiedAction = deepCopy<Action>(this.getAction());
    return addTemporaryActionToPlayer(player, deepCopiedAction);
  }

  /** When to remove the Action. When this action fires, the temporary Action will be removed. */
  getRemoveOn(): Action {
    return this.ro ?? DEFAULT_REMOVE_ON;
  }

  /**
   * Deep copies the RemoveOn Action, adding it to the player. Will always set 'FireAfterThenRemove'
   * to 1, as the Action should always remove itself after firing. Permanence will be set to true so
   * that it will not be removed by other means.
   *
   * @param player The player to add the RemoveOn Action to.
   * @param id The. ID of the temporary Action that should be removed.
   */
  addRemoveOnToPlayer(player: EntityPlayer, id: number): void {
    const removeOn = deepCopy<Action>(this.getRemoveOn())
      .setFireAfterThenRemove(1)
      .setPermanence(true);
    removeOn.setResponse(
      deepCopy<RemoveActionResponse>(DEFAULT_REMOVAL_RESPONSE).construct(
        ActionOrigin.TEMPORARY_ACTION,
        id,
        this.getActionType(),
        true,
      ),
    );
    addTemporaryActionToPlayer(player, removeOn);
  }

  /**
   * When to remove the collectible. When this action fires, the temporary Action will be removed.
   * The provided Action will be deep-copied, make sure its set to remove after firing once, and
   * make it set to permanent.
   */
  setRemoveOn(action: Action): this {
    this.ro = deepCopy<Action>(action);
    this.ro.setFireAfterThenRemove(1).setPermanence(true);
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(): string {
    return "";
  }

  getText(_eid: boolean, _participle: boolean): string {
    return "";
  }

  fire(triggerData: TriggerData): void {
    const player = triggerData.player ?? Isaac.GetPlayer();

    const temporaryActionID = this.addTemporaryActionToPlayer(player);
    this.addRemoveOnToPlayer(player, temporaryActionID);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TemporaryActionSetResponse.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { fprint } from "../../../helper/printHelper";
import type { ActionSet } from "../actionSets/ActionSet";
import { InvertedPassiveActionSet } from "../actionSets/Inverted/InvertedPassiveActionSet";
import { Response } from "./Response";

const DEFAULT_ACTION_SET = new InvertedPassiveActionSet();

/**
 * Gives the player a temporary ActionSet until it is triggered for removal.
 *
 * @example Get the effect 'every room, get 1 blue spider' for the floor.
 */
export class TemporaryActionSetResponse extends Response {
  override responseType: ResponseType = ResponseType.TEMPORARY_ACTION_SET;

  // The actionSet to give to the player. It will be deep copied, as multiple may be given. Actions
  // will have their 'origin' be 'TEMPORARY_ACTION', and an ID which will keep track of them for
  // removal.
  a?: ActionSet;

  construct(actionSet?: ActionSet): this {
    if (actionSet !== undefined) {
      this.a = actionSet;
    }
    return this;
  }

  /** Need to deep copy before use! */
  getActionSet(): ActionSet {
    return this.a ?? DEFAULT_ACTION_SET;
  }

  setActionSet(actionSet: ActionSet): this {
    this.a = actionSet;
    return this;
  }

  override getVerb(_participle: boolean): string {
    return "";
  }

  override getNoun(): string {
    return "";
  }

  getText(): string {
    return "";
  }

  fire(): void {
    fprint("fire");
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TemporaryCollectibleResponse.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { deepCopy } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { _addActionsToTracker } from "../../../features/corruption/effects/playerEffects";
import { addCollectibleOrEffect } from "../../../helper/collectibleHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { Action } from "../actions/Action";
import { OnRoomAction } from "../actions/OnRoomAction";
import { RemoveCollectibleResponse } from "./RemoveCollectibleResponse";
import { Response } from "./Response";

const DEFAULT_REMOVE_ON = new OnRoomAction();
const DEFAULT_REMOVAL_RESPONSE = new RemoveCollectibleResponse();
const DEFAULT_COLLECTIBLE = CollectibleType.POOP;
const VERB = "get";
const VERB_PARTICIPLE = "getting";

/**
 * Response which temporarily gives the player a collectible. The collectible may be in the form of
 * an actual collectible or a collectible effect (depending on whether the collectible effect
 * works).
 */
export class TemporaryCollectibleResponse extends Response {
  override responseType: ResponseType = ResponseType.TEMPORARY_COLLECTIBLE;
  ro?: Action;
  c?: CollectibleType;

  /** Remove On will be deep-copied. */
  construct(collectible: CollectibleType, removeOn: Action): this {
    return this.setCollectible(collectible).setRemoveOn(removeOn);
  }

  override getInvolvedCollectibles(): CollectibleType[] {
    return [this.getCollectible()];
  }

  getCollectible(): CollectibleType {
    return this.c ?? DEFAULT_COLLECTIBLE;
  }

  setCollectible(collectible: CollectibleType): this {
    this.c = collectible;
    return this;
  }

  /** When to remove the collectible. When the action fires, the collectible will be removed. */
  getRemoveOn(): Action {
    return this.ro ?? DEFAULT_REMOVE_ON;
  }

  /**
   * When to remove the collectible. When the action fires, the collectible will be removed. The
   * provided Action will be deep-copied.
   */
  setRemoveOn(action: Action): this {
    this.ro = deepCopy<Action>(action);
    return this;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(_eid: boolean): string {
    return "";
  }

  getText(): string {
    return "";
  }

  /**
   * Generates the removal Action. Will always set 'FireAfterThenRemove' to 1, as the Action should
   * always remove itself after firing.
   *
   * @param isEffect Whether the generated Response should remove a permanent collectible effect or
   *                 an actual collectible.
   */
  generateRemoveOn(isEffect: boolean): Action {
    const action = deepCopy<Action>(this.getRemoveOn());
    action.setFireAfterThenRemove(1).setPermanence(true);
    const response = deepCopy(DEFAULT_REMOVAL_RESPONSE);
    response
      .setCollectible(this.getCollectible())
      .setCollectibleEffect(isEffect);
    return action.setResponse(response);
  }

  fire(triggerData: TriggerData): void {
    const player = triggerData.player ?? Isaac.GetPlayer();
    const collectible = this.getCollectible();

    // Add collectible.
    const isEffect = addCollectibleOrEffect(player, collectible);

    // Add removal Action.
    _addActionsToTracker(player, this.generateRemoveOn(isEffect));
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TransformResponse.ts`:

```````ts
import { VectorZero, isGridEntity } from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { EntityOrGridEntity } from "../../../types/general/EntityUnion";
import { RemoveEntityResponse } from "./RemoveEntityResponse";
import { Response } from "./Response";
import type { EntityCategory } from "../../../enums/general/EntityCategory";
import type { Range } from "../../../types/general/Range";
import { RemoveGridEntityResponse } from "./RemoveGridEntityResponse";
import type { GridID } from "../../../enums/data/ID/GridID";
import { SpawnGridEntityResponse } from "./SpawnGridEntityResponse";
import { SpawnEntityResponse } from "./SpawnEntityResponse";
import type { GridEntityType } from "isaac-typescript-definitions";

const VERB = "transform";
const VERB_PARTICIPLE = "transforming";
const EMPTY_RESPONSE_TEXT = "nothing";

/**
 * Response which transforms entities or grid-entities in the room into other entities or
 * grid-entities. This is done by quickly removing the entity, then spawning the new entity in its
 * place (with the same position and velocity).
 *
 * @example 'Transform a random coin into a spider'.
 * @example 'Transform all spiders into coins'.
 *
 * @param rer The response responsible for getting entities or grid entities that will be
 *            transformed.
 */
export class TransformResponse extends Response {
  override responseType: ResponseType = ResponseType.TRANSFORM;
  rer?: RemoveEntityResponse | RemoveGridEntityResponse;
  ser?: SpawnEntityResponse | SpawnGridEntityResponse;

  /**
   * Response which transforms entities or grid-entities in the room into other entities or
   * grid-entities. This is done by quickly removing the entity, then spawning the new entity in its
   * place (with the same position and velocity).
   *
   * @example 'Transform a random coin into a spider'.
   * @example 'Transform all spiders into coins'.
   *
   * @param entitiesToTransform The entities to remove for transformation. Can be a specific
   *                            EntityID, an EntityCategory, a GridID, GridEntityType, or a random
   *                            grid or entity. i.e { entity: EntityID.COIN }.
   * @param entitiesToTransformTo The entities to spawn for transformation. Can be a SpawnResponse ,
   *                              a GridEntityType, EntityID, GridID, EntityCategory or random grid
   *                              or entity. i.e { entity: EntityID.COIN }.
   * @param amountToTransform The amount of entities to transform. Leave undefined to transform all
   *                          entities of the type. If a RemoveEntityResponse is provided, this
   *                          parameter will be ignored.
   */
  override construct(
    entitiesToTransform:
      | RemoveEntityResponse
      | RemoveGridEntityResponse
      | { grid: GridEntityType | GridID | undefined }
      | { entity: EntityID | EntityCategory | undefined },
    entitiesToTransformTo:
      | SpawnEntityResponse
      | SpawnGridEntityResponse
      | { grid: GridEntityType | GridID | undefined }
      | { entity: EntityID | EntityCategory | undefined },
    amountToTransform: number | Range | undefined = undefined,
  ): this {
    this.setRemoveResponse(entitiesToTransform, amountToTransform);
    this.setSpawnResponse(entitiesToTransformTo);
    return this;
  }

  /** The response responsible for getting entities or grid entities that will be transformed. */
  getRemoveResponse():
    | RemoveEntityResponse
    | RemoveGridEntityResponse
    | undefined {
    return this.rer;
  }

  /**
   * The response responsible for getting entities or grid entities that will be transformed. Does
   * not DeepCopy!
   *
   * @param removeEntityResponse The response responsible for getting entities or grid entities that
   *                             will be transformed. Can be a specific EntityID (or an EntityID
   *                             with '-1' as the variant / subType for more generalized entities),
   *                             an EntityCategory, a RemoveEntityResponse, or a Response which
   *                             triggers a RemoveEntityResponse.
   * @param amountToTransform The amount of entities to transform. Leave undefined to transform all
   *                          entities of the type. If a RemoveEntityResponse is provided, this
   *                          parameter will be ignored. To modify the amount of entities to
   *                          transform while passing a RemoveEntityResponse, use the
   *                          setAmountOfActivations() method on the RemoveEntityResponse.
   */
  setRemoveResponse(
    removeEntityResponse:
      | RemoveEntityResponse
      | RemoveGridEntityResponse
      | { grid: GridEntityType | GridID | undefined }
      | { entity: EntityID | EntityCategory | undefined },
    amountToTransform: number | Range | undefined = undefined,
  ): this {
    if ("entity" in removeEntityResponse) {
      this.rer = this.generateNewRemoveEntityResponse(
        removeEntityResponse.entity,
        amountToTransform,
      );
      return this;
    }

    if ("grid" in removeEntityResponse) {
      this.rer = this.generateNewRemoveGridEntityResponse(
        removeEntityResponse.grid,
        amountToTransform,
      );
      return this;
    }

    this.rer = removeEntityResponse;
    return this;
  }

  generateNewRemoveEntityResponse(
    entityID: EntityID | EntityCategory | undefined,
    amountToTransform: number | Range | undefined,
  ): RemoveEntityResponse {
    const newRemoveEntityResponse = new RemoveEntityResponse();
    if (amountToTransform === undefined) {
      newRemoveEntityResponse.setRemoveAll(true);
    } else {
      newRemoveEntityResponse.setAmountOfActivations(amountToTransform);
    }

    return newRemoveEntityResponse.setEntity(entityID);
  }

  generateNewRemoveGridEntityResponse(
    gridEntity: GridID | GridEntityType | undefined,
    amountToTransform: number | Range | undefined,
  ): RemoveGridEntityResponse {
    const removeGridEntityResponse = new RemoveGridEntityResponse();
    removeGridEntityResponse.setGridEntity(gridEntity);
    if (amountToTransform === undefined) {
      removeGridEntityResponse.setRemoveAll(true);
    } else {
      removeGridEntityResponse.setAmountOfActivations(amountToTransform);
    }
    return removeGridEntityResponse;
  }

  /** The response responsible for spawning the transformed entity or grid entity. */
  getSpawnResponse():
    | SpawnEntityResponse
    | SpawnGridEntityResponse
    | undefined {
    return this.ser;
  }

  /** The response responsible for spawning the transformed entity or grid entity. */
  setSpawnResponse(
    spawnEntityResponse:
      | SpawnEntityResponse
      | SpawnGridEntityResponse
      | { grid: GridEntityType | GridID | undefined }
      | { entity: EntityID | EntityCategory | undefined },
  ): this {
    if ("entity" in spawnEntityResponse) {
      this.ser = this.generateNewSpawnEntityResponse(
        spawnEntityResponse.entity,
      );
      return this;
    }

    if ("grid" in spawnEntityResponse) {
      this.ser = this.generateNewSpawnGridEntityResponse(
        spawnEntityResponse.grid,
      );
      return this;
    }

    this.ser = spawnEntityResponse;
    return this;
  }

  generateNewSpawnEntityResponse(
    entityID: EntityID | EntityCategory | undefined,
  ): SpawnEntityResponse {
    const newSpawnEntityResponse = new SpawnEntityResponse();
    return newSpawnEntityResponse.setEntity(entityID);
  }

  generateNewSpawnGridEntityResponse(
    gridEntity: GridID | GridEntityType | undefined,
  ): SpawnGridEntityResponse {
    const spawnGridEntityResponse = new SpawnGridEntityResponse();
    spawnGridEntityResponse.setGridEntity(gridEntity);
    return spawnGridEntityResponse;
  }

  transformEntities(): EntityOrGridEntity[] {
    const removeEntityResponse = this.getRemoveResponse();
    const spawnEntityResponse = this.getSpawnResponse();
    if (
      removeEntityResponse === undefined ||
      spawnEntityResponse === undefined
    ) {
      return [];
    }

    // Remove the entities.
    const removedEntities =
      removeEntityResponse.trigger() as EntityOrGridEntity[];

    // For each removed entity, spawn the transformed entity with the same position and velocity
    // (using TriggerData).
    let transformedEntities: EntityOrGridEntity[] = [];
    for (const removedEntity of removedEntities) {
      // Get old entity's position and velocity (if grid entity, will take middle pos for position,
      // and zero for velocity).
      const [position, velocity] = isGridEntity(removedEntity)
        ? [removedEntity.Position, VectorZero]
        : [removedEntity.Position, removedEntity.Velocity];

      // Update TriggerData
      const newTriggerData = {} as TriggerData;
      newTriggerData.spawnPosition = position;
      newTriggerData.spawnVelocity = velocity;
      newTriggerData.shouldSpawnGridEntityResponseDelay = true;

      // Spawn the transformed entity.
      const transformedEntity = spawnEntityResponse.trigger(
        newTriggerData,
      ) as EntityOrGridEntity[];

      transformedEntities = [...transformedEntities, ...transformedEntity];
    }

    return transformedEntities;
  }

  override setAmountOfActivations(_amount: number | Range): this {
    error(
      "TransformResponse does not use amountOfActivations. Use the removal responses' 'amount of activations' to dictate how many entities you want to transform.",
    );
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(_eid: boolean): string {
    error("TransformResponse.getNoun() should not be called");
  }

  /** E.g "all rocks" */
  getRemoveText(_eid: boolean): string {
    const removeResponse = this.getRemoveResponse();
    if (removeResponse === undefined) {
      return EMPTY_RESPONSE_TEXT;
    }

    return removeResponse.getNoun(_eid);
  }

  /** E.g "spikes" */
  getSpawnText(_eid: boolean): string {
    const spawnResponse = this.getSpawnResponse();
    if (spawnResponse === undefined) {
      return EMPTY_RESPONSE_TEXT;
    }

    return spawnResponse.getNoun(_eid);
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const removeText = this.getRemoveText(eid);
    const spawnText = this.getSpawnText(eid);

    return `${verb} ${removeText} into ${spawnText}`;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  /**
   * Use the removal responses' 'amount of activations' to dictate how many entities you want to
   * transform.
   */
  override shouldSkipAmountOfActivations(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): EntityOrGridEntity[] {
    return super.trigger(triggerData) as EntityOrGridEntity[];
  }

  override fire(_triggerData: TriggerData): EntityOrGridEntity[] {
    return this.transformEntities();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TriggerInQueueResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";
import { getMostFrequentElementInArray } from "../../../helper/arrayHelper";
import { Morality } from "../../../enums/corruption/Morality";

const UNKNOWN_MORALITY_MORALITY = Morality.NEUTRAL;
const VERB = "alternate between";
const VERB_PARTICIPLE = "alternating between";
const BETWEEN_RESPONSES_TEXT = " and ";

/**
 * Response to trigger Responses in a queue, putting each Response at the end of the queue after it
 * is triggered.
 */
export class TriggerInQueueResponse extends Response {
  override responseType: ResponseType = ResponseType.TRIGGER_IN_QUEUE;

  r: Response[] = [];

  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  override construct(...responses: Response[]): this {
    this.addResponses(...responses);
    return this;
  }

  /** Add Responses to the end of the Queue. */
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  addResponses(...responses: Response[]): this {
    this.r = [...this.r, ...responses];
    return this;
  }

  /** Returns the first element of the array, and moves it to the end of the Queue. */
  shiftResponses(): Response | undefined {
    const response = this.r.shift();
    if (response) {
      this.r.push(response);
    }
    return response;
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(): string {
    error("TriggerInQueueResponse.getNoun() should not be called");
  }

  override getInvolvedCollectibles(): CollectibleType[] {
    return this.r.flatMap((response) => response.getInvolvedCollectibles());
  }

  /**
   * Morality should be the general Morality of Queued Responses, unless morality is already set.
   */
  override getMorality(): Morality {
    return (
      this.mo ??
      getMostFrequentElementInArray(
        this.r.map((response) => response.getMorality()),
      ) ??
      UNKNOWN_MORALITY_MORALITY
    );
  }

  override getText(eid: boolean, participle: boolean): string {
    const verb = this.getVerb(participle);
    const responsesText = this.r
      .map((response) => response.getText(eid, true))
      .join(BETWEEN_RESPONSES_TEXT);
    return `${verb} ${responsesText}`;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): unknown[] {
    return super.trigger(triggerData);
  }

  override fire(triggerData: TriggerData): unknown {
    const response = this.shiftResponses();
    if (response) {
      return response.trigger(triggerData);
    }

    return undefined;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TriggerInSequenceResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { getMostFrequentElementInArray } from "../../../helper/arrayHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";

const UNKNOWN_MORALITY_MORALITY = Morality.NEUTRAL;
const BETWEEN_RESPONSES_TEXT = ", then ";

/**
 * Trigger one Response after another.
 *
 * @example 'Spawn a bomb, then spawn a troll bomb.'
 *
 * @param r The Responses to trigger in sequence.
 */
export class TriggerInSequenceResponse extends Response {
  override responseType: ResponseType = ResponseType.TRIGGER_IN_SEQUENCE;
  r: Response[] = [];

  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  construct(...responses: Response[]): this {
    this.addResponses(...responses);
    return this;
  }

  /** Add Responses to the end of the Trigger Sequence. */
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  addResponses(...responses: Response[]): this {
    this.r = [...this.r, ...responses];
    return this;
  }

  override getInvolvedCollectibles(): CollectibleType[] {
    return this.r.flatMap((response) => response.getInvolvedCollectibles());
  }

  /**
   * Morality should be the general Morality of Queued Responses, unless morality is already set.
   */
  override getMorality(): Morality {
    return (
      this.mo ??
      getMostFrequentElementInArray(
        this.r.map((response) => response.getMorality()),
      ) ??
      UNKNOWN_MORALITY_MORALITY
    );
  }

  /** There are no verbs for this Response. */
  override getVerb(_participle: boolean): string {
    error("There are no verbs for TriggerInSequenceResponse.");
  }

  override getNoun(): string {
    error("There are no nouns for TriggerInSequenceResponse.");
  }

  getText(eid: boolean, participle: boolean): string {
    let text = "";
    let iterations = this.r.length;
    for (const response of this.r) {
      text += ` ${response.getText(eid, participle)} `;
      // eslint-disable-next-line isaacscript/prefer-postfix-plusplus
      if (--iterations !== 0) {
        text += BETWEEN_RESPONSES_TEXT;
      }
    }
    return text;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): unknown[] {
    return super.trigger(triggerData);
  }

  fire(triggerData: TriggerData): unknown[] {
    const results: unknown[] = [];

    for (const response of this.r) {
      results.push(response.trigger(triggerData));
    }

    return results;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TriggerOverTimeResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { GAME_FRAMES_PER_SECOND } from "isaacscript-common";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { addTheS } from "../../../helper/stringHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { mod } from "../../../mod";
import type { Range } from "../../../types/general/Range";
import { Response } from "./Response";

const DEFAULT_INTERVAL_TIMES = 1;
const DEFAULT_TOTAL_TIME = 60;
const NO_RESPONSE_MORALITY = Morality.NEUTRAL;
const EMPTY_RESPONSE_TEXT = "do nothing";
const EMPTY_RESPONSE_TEXT_PARTICIPLE = "doing nothing";

/**
 * Triggers the set Response a set amount of times (amountOfTriggers) with a waiting period between
 * each activation (intervalTime).
 *
 * The Response does not trigger immediately, instead waits X interval seconds.
 */
export class TriggerOverTimeResponse extends Response {
  override responseType: ResponseType = ResponseType.WAIT_THEN_TRIGGER;
  private r?: Response;
  private it?: number;
  private tt?: number;
  private ct?: number;

  construct(
    response: Response,
    amountOfTriggers?: number,
    intervalTimeSec?: number,
  ): this {
    if (intervalTimeSec !== undefined) {
      this.it = intervalTimeSec;
    }
    // Amount of triggers x Interval between triggers = Total time.
    if (amountOfTriggers !== undefined) {
      this.tt = amountOfTriggers * this.getIntervalTimeSec();
    }
    this.ct = this._getTotalTimeSec();
    this.r = response;
    return this;
  }

  override getInvolvedCollectibles(): readonly CollectibleType[] {
    return this.getResponse()?.getInvolvedCollectibles() ?? [];
  }

  /** Ticks down the timer. If below or equal to 0, returns false. */
  tick(): boolean {
    this.ct = (this.ct ?? DEFAULT_TOTAL_TIME) - this.getIntervalTimeSec();
    return this.ct >= 0;
  }

  setIntervalTimeSec(seconds: number): this {
    this.it = seconds;
    return this;
  }

  getIntervalTimeSec(): number {
    return this.it ?? DEFAULT_INTERVAL_TIMES;
  }

  /** Don't use this. */
  _setTotalTime(seconds: number): this {
    this.tt = seconds;
    return this;
  }

  /** Don't use this. */
  _getTotalTimeSec(): number {
    return this.tt ?? DEFAULT_TOTAL_TIME;
  }

  getResponse(): Response | undefined {
    return this.r;
  }

  setResponse(response: Response): this {
    this.r = response;
    return this;
  }

  /** This response should not have more than one AmountOfActivations. */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  override setAmountOfActivations(amount: number | Range): this {
    error("TriggerOverTimeResponse: Cannot set amount of activations.");
  }

  override getVerb(participle: boolean): string {
    if (participle) {
      return "triggering";
    }
    const intervalTime = this.getIntervalTimeSec();
    const totalTime = this._getTotalTimeSec();
    return ` every ${intervalTime} ${addTheS(
      "second",
      intervalTime,
    )} for ${totalTime} ${addTheS("second", totalTime)}, `;
  }

  override getNoun(): string {
    error("TriggerOverTimeResponse.getNoun() should not be called");
  }

  getTriggeringResponseText(eid: boolean, participle: boolean): string {
    return (
      this.getResponse()?.getText(eid, participle) ??
      (participle ? EMPTY_RESPONSE_TEXT_PARTICIPLE : EMPTY_RESPONSE_TEXT)
    );
  }

  getText(eid: boolean, participle: boolean): string {
    return ` ${this.getVerb(participle)} ${this.getTriggeringResponseText(
      eid,
      participle,
    )}`;
  }

  override getMorality(): Morality {
    return this.mo ?? this.getResponse()?.getMorality() ?? NO_RESPONSE_MORALITY;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): [] {
    return super.trigger(triggerData) as [];
  }

  fire(triggerData: TriggerData): void {
    const response = this.getResponse();
    if (response !== undefined) {
      mod.runInNGameFrames(() => {
        if (this.tick()) {
          response.trigger(triggerData);
          this.trigger(triggerData);
        } else {
          this.ct = this.tt;
        }
      }, GAME_FRAMES_PER_SECOND * this.getIntervalTimeSec());
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\TriggerRandomResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { WeightedArray } from "isaacscript-common";
import { getRandomFromWeightedArray, isArray } from "isaacscript-common";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { getMostFrequentElementInArray } from "../../../helper/arrayHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { Response } from "./Response";

const DEFAULT_WEIGHT = 1;
const BETWEEN_RESPONSES_TEXT = " or ";

/**
 * Response which contains a WeightedArray of sub-responses. Upon triggering, will trigger a random
 * response in that sub-array, taking into account its weight. Default weight is 1.
 */
export class TriggerRandomResponse extends Response {
  override responseType: ResponseType = ResponseType.TRIGGER_RANDOM;
  r: WeightedArray<Response> = [];

  construct(
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...responseOrWeightedArrayTuple: Response[] | Array<[Response, number]>
  ): this {
    return this.addResponses(...responseOrWeightedArrayTuple);
  }

  override getInvolvedCollectibles(): CollectibleType[] {
    const collectibles: CollectibleType[] = [];
    for (const responseData of this.r) {
      const [response] = responseData;
      collectibles.push(...response.getInvolvedCollectibles());
    }
    return collectibles;
  }

  override getMorality(): Morality {
    return (
      this.mo ??
      getMostFrequentElementInArray(this.r.map((r) => r[0].getMorality())) ??
      Morality.NEUTRAL
    );
  }

  addResponses(
    // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
    ...responseOrWeightedArrayTuple: Response[] | Array<[Response, number]>
  ): this {
    for (const responseData of responseOrWeightedArrayTuple) {
      this.addResponse(responseData);
    }
    return this;
  }

  addResponse(
    responseOrWeightedArrayTuple: Response | [Response, number],
  ): this {
    if (isArray(responseOrWeightedArrayTuple)) {
      this.r.push(responseOrWeightedArrayTuple);
    } else {
      this.r.push([responseOrWeightedArrayTuple, DEFAULT_WEIGHT]);
    }
    return this;
  }

  getResponses(): readonly Response[] {
    return this.r.map((responseData) => responseData[0]);
  }

  /** This Response does not have a Verb. */
  override getVerb(_participle: boolean): string {
    error("TriggerRandomResponse: No verb.");
  }

  /** This Response does not have a Noun. */
  override getNoun(): string {
    error("TriggerRandomResponse: No noun.");
  }

  getResponsesText(eid: boolean, participle: boolean): string {
    const r = this.getResponses();
    let text = "";
    let iterations = r.length;
    for (const response of r) {
      text += response.getText(eid, participle);
      // eslint-disable-next-line isaacscript/prefer-postfix-plusplus
      if (--iterations !== 0) {
        text += BETWEEN_RESPONSES_TEXT;
      }
    }

    return text;
  }

  override getText(eid: boolean, participle: boolean): string {
    return `${this.getAmountOfActivationsText() ?? ""} ${this.getResponsesText(
      eid,
      participle,
    )}`;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): unknown[] {
    return super.trigger(triggerData);
  }

  fire(triggerData: TriggerData): unknown {
    return getRandomFromWeightedArray(this.r, undefined).trigger(triggerData);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\UseActiveItemResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { arrayToBitFlags, getCollectibleName } from "isaacscript-common";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import {
  collectibleAttributeToText,
  getRandomAssortmentOfCollectibles,
  getRandomCollectibleType,
} from "../../../helper/collectibleHelper";
import { useActiveItemAtPosition } from "../../../helper/playerHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import type { ActiveCollectibleAttribute } from "../../../interfaces/general/CollectibleAttribute";
import { Response } from "./Response";
import { fprint } from "../../../helper/printHelper";
import { USE_ACTIVE_ITEM_RESPONSE_BITFLAG_ARRAY } from "../../../constants/corruptionConstants";
import { getCollectibleNameWithEIDSetting } from "../../../helper/compatibility/EID/EIDHelper";

const EMPTY_COLLECTIBLE_TEXT = "nothing";
const VERB = "use";
const VERB_PARTICIPLE = "using";

/**
 * Response which uses Active items. The 'activeItem' field can either be a CollectibleType of the
 * active item, or a 'ActiveCollectibleAttribute' object. Every time the Response triggers, if using
 * the object, a random active item following the properties described in the
 * 'ActiveCollectibleAttribute' object will be used.
 *
 * @example Use The Poop.
 * @example Use a quality 4 active item.
 */
export class UseActiveItemResponse extends Response {
  override responseType: ResponseType = ResponseType.USE_ACTIVE_ITEM;
  private aT?: CollectibleType | ActiveCollectibleAttribute;
  private pos?: Vector;

  /** Alternative constructor so SaveData works with class. */
  construct(
    activeItem: CollectibleType | ActiveCollectibleAttribute,
    position?: Vector,
    morality?: Morality,
  ): this {
    if (morality !== undefined) {
      this.mo = morality;
    }
    if (position !== undefined) {
      this.setPosition(position);
    }
    this.aT = activeItem;
    return this;
  }

  /** Get collectibles mentioned. */
  override getInvolvedCollectibles(): readonly CollectibleType[] {
    const active = this.getActiveItem();
    if (active === undefined) {
      return [];
    }
    if (typeof active === "object") {
      return getRandomAssortmentOfCollectibles([1, 3], active);
    }
    return [active];
  }

  /**
   * Calculates the ActiveItem to use upon triggering the Response, taking into account the
   * different types of 'activeItem'.
   */
  calculateActiveItem(): CollectibleType | undefined {
    const activeItem = this.getActiveItem();
    if (typeof activeItem === "object") {
      return getRandomCollectibleType(activeItem);
    }
    return activeItem;
  }

  /**
   * The active item to use. Can be a specific active item or randomly from a group of active items
   * (defined by ActiveCollectibleAttribute).
   */
  getActiveItem(): CollectibleType | ActiveCollectibleAttribute | undefined {
    return this.aT;
  }

  /**
   * The active item to use. Can be a specific active item or randomly from a group of active items
   * (defined by ActiveCollectibleAttribute).
   */
  setActiveItem(activeItem: CollectibleType): this {
    this.aT = activeItem;
    return this;
  }

  /** Get the overridden position to use the active item at. */
  getPosition(): Vector | undefined {
    return this.pos;
  }

  /** Set the overridden position to use the active item at. */
  setPosition(position: Vector): this {
    this.pos = position;
    return this;
  }

  // TODO: Map ActiveItems to Morality and return that if undefined.
  override getMorality(): Morality {
    return this.mo ?? Morality.NEUTRAL;
  }

  override getAmountOfActivationsText(): string {
    const amountText = super.getAmountOfActivationsText();
    if (amountText !== undefined) {
      return `${amountText} times`;
    }

    return "";
  }

  override getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  /**
   * Get noun text.
   *
   * @example "use fortune cookie"
   * @example "use a random 3 charge active item 4 times"
   */
  override getNoun(eid: boolean): string {
    const activeItemText = this.getActiveItemText(eid);
    const amountText = this.getAmountOfActivationsText();

    return `${amountText} ${activeItemText}`;
  }

  /** If undefined, will spawn at player's position. */
  calculatePosition(triggerData: TriggerData): Vector | undefined {
    const position = this.getPosition();
    if (position !== undefined) {
      return position;
    }

    return triggerData.spawnPosition;
  }

  getActiveItemText(eid: boolean): string {
    const activeItem = this.getActiveItem();
    if (typeof activeItem === "object") {
      return collectibleAttributeToText(activeItem);
    }
    if (activeItem === undefined) {
      return EMPTY_COLLECTIBLE_TEXT;
    }
    return eid
      ? getCollectibleNameWithEIDSetting(activeItem)
      : getCollectibleName(activeItem);
  }

  override getText(eid: boolean, participle: boolean): string {
    const noun = this.getNoun(eid);
    const verb = this.getVerb(participle);

    return `${verb} ${noun}`;
  }

  /** Array may be empty. */
  override trigger(triggerData?: TriggerData): CollectibleType[] {
    return super.trigger(triggerData) as CollectibleType[];
  }

  fire(triggerData: TriggerData): CollectibleType | undefined {
    const player = triggerData.player ?? Isaac.GetPlayer();
    const activeItem = this.calculateActiveItem();

    if (activeItem === undefined) {
      fprint("Active item is undefined, can't fire UseActiveItemResponse.");
      return undefined;
    }

    const position = this.calculatePosition(triggerData);
    if (position === undefined) {
      player.UseActiveItem(
        activeItem,
        arrayToBitFlags(USE_ACTIVE_ITEM_RESPONSE_BITFLAG_ARRAY),
      );
      return activeItem;
    }

    useActiveItemAtPosition(
      activeItem,
      this.calculatePosition(triggerData) ?? player.Position,
      player,
    );

    return activeItem;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\corruption\responses\WaitThenTriggerResponse.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { GAME_FRAMES_PER_SECOND, isNumber } from "isaacscript-common";
import { Morality } from "../../../enums/corruption/Morality";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { addTheS } from "../../../helper/stringHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { mod } from "../../../mod";
import {
  randomInRangeWithDecimalPrecision,
  rangeToString,
} from "../../../types/general/Range";
import type { Range } from "../../../types/general/Range";
import { Response } from "./Response";

const DEFAULT_WAIT_TIME_SECONDS = 1;
const NO_RESPONSE_MORALITY = Morality.NEUTRAL;
const VERB = "wait";
const VERB_PARTICIPLE = "waiting";
const EMPTY_RESPONSE_TEXT = "do nothing";

/**
 * Waits a set amount of seconds, and then triggers the Response contained inside it. Note: If there
 * is more than one amountOfActivations, will wait then trigger them all at once.
 *
 * To get the behavior of wait, do X, wait, do X, wait, do X, then use TriggerOverIntervalResponse.
 *
 * @param response The Response to trigger after the wait.
 * @param secondsWait The amount of seconds to wait before the Response triggers. Can be a Range, in
 *                    which case a random number will be chosen from the range to a decimal
 *                    precision of 1.
 */
export class WaitThenTriggerResponse extends Response {
  override responseType: ResponseType = ResponseType.WAIT_THEN_TRIGGER;
  r?: Response;
  sW?: number | Range;

  construct(response: Response, secondsWait?: number): this {
    if (secondsWait !== undefined) {
      this.sW = secondsWait;
    }
    this.r = response;
    return this;
  }

  override getInvolvedCollectibles(): readonly CollectibleType[] {
    return this.getResponse()?.getInvolvedCollectibles() ?? [];
  }

  /** The amount of seconds to wait before the Response triggers. */
  setSecondsToWait(seconds: number | Range): this {
    this.sW = seconds;
    return this;
  }

  /** The amount of seconds to wait before the Response triggers. */
  getSecondsToWait(): number | Range {
    return this.sW ?? DEFAULT_WAIT_TIME_SECONDS;
  }

  getResponse(): Response | undefined {
    return this.r;
  }

  setResponse(response: Response): this {
    this.r = response;
    return this;
  }

  calculateSecondsToWait(): number {
    const secondsWait = this.getSecondsToWait();
    return isNumber(secondsWait)
      ? secondsWait
      : randomInRangeWithDecimalPrecision(secondsWait, 1);
  }

  /** This response should not have more than one AmountOfActivations. */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  override setAmountOfActivations(amount: number | Range): this {
    error(
      "WaitThenTriggerResponse should not have more than one AmountOfActivations.",
    );
  }

  getVerb(participle: boolean): string {
    return participle ? VERB_PARTICIPLE : VERB;
  }

  override getNoun(): string {
    error("WaitThenTriggerResponse should not have a noun.");
  }

  /** The amount of seconds to wait before the Response triggers. */
  getWaitText(participle: boolean): string {
    const secondsWait = this.getSecondsToWait();
    const secondsWaitText = isNumber(secondsWait)
      ? secondsWait
      : rangeToString(secondsWait);
    return `${this.getVerb(participle)} ${secondsWaitText} ${addTheS(
      "second",
      isNumber(secondsWait) ? secondsWait : true,
    )}, then `;
  }

  getResponseText(eid: boolean, participle: boolean): string {
    return this.getResponse()?.getText(eid, participle) ?? EMPTY_RESPONSE_TEXT;
  }

  getText(eid: boolean, participle: boolean): string {
    return ` ${this.getWaitText(participle)} ${this.getResponseText(
      eid,
      participle,
    )}`;
  }

  /**
   * Returns its set morality, if a morality is not set returns its responses morality, if there is
   * no response morality, returns a default morality.
   */
  override getMorality(): Morality {
    return this.mo ?? this.getResponse()?.getMorality() ?? NO_RESPONSE_MORALITY;
  }

  override shouldFlattenResults(): boolean {
    return true;
  }

  override trigger(triggerData?: TriggerData): [] {
    return super.trigger(triggerData) as [];
  }

  fire(triggerData: TriggerData): void {
    const response = this.getResponse();
    if (response !== undefined) {
      mod.runInNGameFrames(() => {
        response.trigger(triggerData);
      }, GAME_FRAMES_PER_SECOND * this.calculateSecondsToWait());
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\Facet.ts`:

```````ts
/**
 * Facet class, an extension of 'ModFeature' which facilitates tracking number of subscribers,
 * resubscribing upon exiting and entering the game on a continued save, and automatically
 * uninitialising the Facet upon a new run.
 */

import { ModCallback } from "isaac-typescript-definitions";
import { Callback, getTSTLClassName, ModFeature } from "isaacscript-common";
import { fprint } from "../helper/printHelper";
import { mod } from "../mod";

const v = {
  run: {
    facetSubscriberCount: new Map<string, number>([]),
  },
};

const allFacets = new Map<string, Facet>();

export function facetInit(): void {
  mod.saveDataManager("facetInit", v);
}

/**
 * Returns true if a Facet has more than 0 subscribers. This is used when a Facet is first
 * initializing to determine whether it should be initialized immediately, as ModFeatures get erased
 * upon exiting the game, even if the run is not over.
 *
 * @param facet The Facet to check. Can be a Facet object or the class name of a Facet.
 */
export function doesFacetHaveSubscribers(facet: Facet | string): boolean {
  let className: string | undefined;
  className = typeof facet === "string" ? facet : getTSTLClassName(facet);

  if (className === undefined) {
    error("Failed to get the class name.");
  }

  const count = v.run.facetSubscriberCount.get(className) ?? 0;
  return count > 0;
}

/**
 * Extension of ModFeature, to facilitate individual subscribers. Facets also auto-uninitialize upon
 * the run ending, as they do not do it automatically, as well as auto-init upon exit/continue if
 * there are subscribers.
 */
export abstract class Facet extends ModFeature {
  constructor() {
    super(mod, false);
  }

  /** Subscribe to the Facet, if the Facet is not initialized, will do so. */
  subscribe(): void {
    const className = getTSTLClassName(this);
    if (className === undefined) {
      error("Failed to get the class name.");
    }
    const count = v.run.facetSubscriberCount.get(className) ?? 0;
    v.run.facetSubscriberCount.set(className, count + 1);
    fprint(`Subscribed to ${className} (sub count: ${count + 1}).`);
    if (!this.initialized) {
      fprint(`Initializing ${className} due to subscribe().`);
      this.init();
    }
  }

  /**
   * Unsubscribe from the Facet, if the Facet is initialized and there are no more subscribers, will
   * uninitialize it.
   */
  unsubscribe(): void {
    const className = getTSTLClassName(this);
    if (className === undefined) {
      error("Failed to get the class name.");
    }
    const count = v.run.facetSubscriberCount.get(className) ?? 0;
    if (count <= 0) {
      fprint("Tried to unsubscribe from a Facet that had no subscribers.");
    } else {
      fprint(`Unsubscribed from ${className} (sub count: ${count - 1}).`);
      v.run.facetSubscriberCount.set(className, count - 1);
    }
    if (count - 1 <= 0 && this.initialized) {
      fprint(`Uninitialising ${className} due to unsubscribe().`);
      this.uninit();
    }
  }

  /** Unsubscribes all subscribers from the Facet, uninitialising it if not already. */
  unsubscribeAll(): void {
    const className = getTSTLClassName(this);
    if (className === undefined) {
      error("Failed to get the class name.");
    }
    const count = v.run.facetSubscriberCount.get(className) ?? 0;
    if (count <= 0) {
      fprint("Tried to unsubscribe from a Facet that had no subscribers.");
    } else {
      fprint(`Unsubscribed from ${className} (sub count: ${count - 1}).`);
      v.run.facetSubscriberCount.set(className, 0);
    }
    if (this.initialized) {
      fprint(`Uninitialising ${className} due to unsubscribeAll().`);
      uninitFacet(className);
    }
  }

  /** Subscribes to the Facet if it has no subscribers and is uninitialized. */
  subscribeIfNotAlready(): void {
    if (!this.isInitialized()) {
      this.subscribe();
    }
  }

  getSubscriberCount(): int {
    const className = getTSTLClassName(this);
    if (className === undefined) {
      error("Failed to get the class name.");
    }
    return v.run.facetSubscriberCount.get(className) ?? 0;
  }

  isInitialized(): boolean {
    return this.initialized;
  }
}

/**
 * Function to easily set up a Facet (NOT initialize the actual Facet), this should be called in
 * each Facet class file in an init() function.
 */
export function initGenericFacet<Type extends Facet>(
  facet: new () => Type,
  vObject?: object,
): Facet {
  // eslint-disable-next-line new-cap
  const newFacet = new facet();
  const facetName = getTSTLClassName(newFacet);
  if (facetName === undefined) {
    error("Failed to get the class name.");
  }

  allFacets.set(facetName, newFacet);

  fprint(`Initializing ${facetName} due to initGenericFacet().`);
  if (vObject !== undefined) {
    mod.saveDataManager(facetName, vObject);
  }
  return newFacet;
}

export function uninitFacet(facetName: string): void {
  const facet = allFacets.get(facetName);
  if (facet === undefined) {
    error(`Failed to get facet with name: ${facetName}.`);
  }
  if (facet.initialized) {
    fprint(`Uninitialising ${facetName} due to uninitFacet().`);
  }
}

// POST_GAME_STARTED_REORDERED, isContinued: TRUE. This is called when the game is exited and then
// continued, and is used to reinitialize Facets.
export function facetPostGameContinuedReordered(): void {
  // Reinitialize all Facets that have subscribers.
  for (const [name, facet] of allFacets) {
    fprint(`Trying to Re-Init Facet: ${getTSTLClassName(facet)}.`);
    if (doesFacetHaveSubscribers(facet) && !facet.initialized) {
      fprint(`Re-initializing ${name} due to POST_GAME_STARTED_REORDERED.`);
      facet.init();
    }
  }
}

// PRE_GAME_EXIT, shouldSave: FALSE. This is called when the game is exited and not to be continued.
export function facetPreGameExit(): void {
  // Uninitialize all Facets.
  for (const [name, facet] of allFacets) {
    fprint(`Uninitialising ${name} due to PRE_GAME_EXIT.`);
    if (facet.initialized) {
      facet.uninit();
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\CorruptedCollectibleSpriteFacet.ts`:

```````ts
import {
  CollectibleSpriteLayer,
  CollectibleType,
  ModCallback,
  PickupVariant,
} from "isaac-typescript-definitions";
import type { PickupIndex } from "isaacscript-common";
import {
  Callback,
  CallbackCustom,
  ColorDefault,
  ModCallbackCustom,
  clearSprite,
  getCollectibleGfxFilename,
  getTSTLClassName,
  isCollectible,
  isGlitchedCollectible,
  setCollectibleSprite,
} from "isaacscript-common";
import { renderCorruptedCollectibleSpriteOverCollectible } from "../../helper/deletedSpecific/funnySprites";
import { isCollectibleFree } from "../../helper/priceHelper";
import { fprint } from "../../helper/printHelper";
import { worldToRenderPosition } from "../../helper/renderHelper";
import { copySprite } from "../../helper/spriteHelper";
import type { CorruptedCollectibleSprite } from "../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import { mod } from "../../mod";
import { isZazzinatorAny } from "../../sets/zazzSets";
import { Facet, initGenericFacet } from "../Facet";
import { getEntityIDFromEntity } from "../../helper/entityHelper/entityIDHelper";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  level: {
    replacedPickups: new Map<PickupIndex, CorruptedCollectibleSprite>(),
  },
};

/**
 * This Facet facilitates the rendering of custom 'TMTRAINER'-esque sprites on pedestals, that are
 * represented by the object CorruptedCollectibleSprite. To use this Facet, simply call
 * replaceCollectibleSpriteWithCorrupted() with the desired sprite and pedestal. Then when you no
 * longer want to render the sprite, call returnCorruptedCollectibleSpriteToNormal(). The sprite
 * will be removed upon picking up or rerolling the item.
 *
 * This will handle TMTRAINER sprites, handle leaving the room, leaving the run, diplopia, and other
 * edge cases.
 */
let FACET: Facet | undefined;
class CorruptedCollectibleSpriteFacet extends Facet {
  @CallbackCustom(ModCallbackCustom.POST_PICKUP_CHANGED)
  postPickupChanged(
    pickup: EntityPickup,
    _oldVariant: PickupVariant,
    _oldSubType: number,
    _newVariant: PickupVariant,
    newSubType: number,
  ): void {
    fprint(
      `CorruptedCollectibleSpriteFacet: ${mod.getPickupIndex(
        pickup,
      )} changed, unsubscribing.`,
    );
    if ((newSubType as CollectibleType) === CollectibleType.NULL) {
      returnCorruptedCollectibleSpriteToNormal(
        pickup as EntityPickupCollectible,
      );
    }
  }

  /** This is where we render the CorruptedCollectibleSprites. */
  @Callback(ModCallback.POST_PICKUP_RENDER, PickupVariant.COLLECTIBLE)
  postPickupRender(pickup: EntityPickup, _renderOffset: Vector): void {
    const corruptedSprite = v.level.replacedPickups.get(
      mod.getPickupIndex(pickup),
    );

    /** If the pickup is not subscribed. */
    if (corruptedSprite === undefined) {
      return;
    }
    if (
      isGlitchedCollectible(pickup) &&
      isCollectibleFree(pickup as EntityPickupCollectible)
    ) {
      const newSprite = copySprite(pickup.GetSprite());
      newSprite.Color = ColorDefault;
      newSprite.Play("Alternates", true);
      newSprite.Render(worldToRenderPosition(pickup.Position));
    }

    /** Render the new sprite. */
    renderCorruptedCollectibleSpriteOverCollectible(
      pickup as EntityPickupCollectible,
      corruptedSprite,
    );
  }
}

export function initCorruptedCollectibleSpriteFacet(): void {
  FACET = initGenericFacet(CorruptedCollectibleSpriteFacet, v);
}

/**
 * This function will remove a pedestal's item sprite, instead replacing it with the sprite
 * described by the specified CorruptedCollectibleSprite. A random seed is necessary as the
 * CorruptedCollectibleSprite requires randomness, leave it blank to generate a random seed.
 *
 * This will handle leaving the room, exiting the game, duplicating the pedestal, rerolling the
 * pedestal, and other edge cases.
 *
 * To return the sprite to normal, call returnCollectibleSpriteToNormal().
 */
export function replaceCollectibleSpriteWithCorrupted(
  pickup: EntityPickupCollectible,
  sprite: CorruptedCollectibleSprite,
): void {
  const pickupIndex = mod.getPickupIndex(pickup);

  /**
   * If the pickup is a TMTRAINER collectible or non-trinket non-collectible pickup, we need to set
   * the sprite to be invisible, as once the sprite is removed there is no way to get it back. With
   * trinkets and standard collectibles, we can just remove the sprites as there is a way to
   * generate new sprites.
   */
  if (isCollectible(pickup)) {
    if (pickup.SubType === CollectibleType.NULL) {
      fprint("Cannot Remove Corrupted Collectible Sprite! (Null)");
      return;
    }
    if (isZazzinatorAny(pickup.SubType)) {
      fprint("Cannot Remove Corrupted Collectible Sprite! (Zazzinator)");
      return;
    }
    if (isGlitchedCollectible(pickup)) {
      pickup.GetSprite().Color = Color(0, 0, 0, 0);
    } else {
      clearSprite(pickup.GetSprite(), CollectibleSpriteLayer.HEAD);
    }
  }

  /** Save. */
  const pickupAlreadyHasCorruptedSprite =
    v.level.replacedPickups.has(pickupIndex);

  v.level.replacedPickups.set(mod.getPickupIndex(pickup), sprite);
  fprint(
    `Replacing item ${getEntityIDFromEntity(pickup)}'s sprite with Corrupted!`,
  );

  /**
   * If the pickup already has a corrupted sprite and we are updating the design, there is no need
   * to subscribe again. However, if this is the first time corrupting the sprite, we need to.
   */
  if (!pickupAlreadyHasCorruptedSprite) {
    FACET?.subscribe();
  }
}

/**
 * Returns a Corrupted Collectible sprite created from replacePickupSpriteWithCorrupted() to its
 * normal sprite, if it exists. We need to allow non-Collectible pickups to be passed in because a
 * Corrupted Collectible can be transformed into a non-Collectible pickup.
 */
export function returnCorruptedCollectibleSpriteToNormal(
  pickup: EntityPickup,
): void {
  const corruptedCollectibleSprite = v.level.replacedPickups.get(
    mod.getPickupIndex(pickup),
  );
  if (corruptedCollectibleSprite === undefined) {
    fprint("Tried to return a non-corrupted collectible to normal but failed!");
    return;
  }
  fprint(
    `Returning pickup ${pickup.SubType} to normal! (Corrupted Collectible Sprite)`,
  );

  v.level.replacedPickups.delete(mod.getPickupIndex(pickup));

  if (isCollectible(pickup)) {
    /** Should not t */
    // if (isZazzinatorAny(pickup.SubType)) { fprint("Removing Corrupted Collectible Sprite!
    // (Zazzinator)"); return; }

    if (isGlitchedCollectible(pickup)) {
      pickup.GetSprite().Color = ColorDefault;
    } else {
      setCollectibleSprite(pickup, getCollectibleGfxFilename(pickup.SubType));
    }
  }

  FACET?.unsubscribe();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\CustomActiveFacet.ts`:

```````ts
import type { UseFlag } from "isaac-typescript-definitions";
import {
  ActiveSlot,
  ButtonAction,
  CollectibleType,
  InputHook,
  ModCallback,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  Callback,
  CallbackCustom,
  ModCallbackCustom,
  getEnumEntries,
  getPlayers,
  getTSTLClassName,
} from "isaacscript-common";
import { addRemovedInvertedItemToTracker } from "../../features/corruption/inventory/removedInvertedItems";
import { fprint } from "../../helper/printHelper";
import { isZazzinatorActive } from "../../sets/zazzSets";
import { Facet, initGenericFacet } from "../Facet";
import type { InvertedActiveActionSet } from "../corruption/actionSets/Inverted/InvertedActiveActionSet";
import {
  doesAnyPlayerHaveAnyCustomActives,
  doesPlayerHaveCustomActive,
  doesPlayerHaveCustomActiveInSlot,
  getAllCustomActives,
  getAllCustomActivesWithSlot,
  getCustomActiveInSlot,
  _setCustomActiveInSlot,
} from "../../features/corruption/inversion/customActives";
import {
  _removeZazzActiveFromPlayer,
  doesInvertedActiveActionSetMatchZazzActive,
} from "../../helper/deletedSpecific/inventory/custom actives/customActiveHelper";
import { renderCorruptedCollectibleSpriteInSlot } from "../../helper/deletedSpecific/funnySprites";
import {
  _addActionsToTracker,
  _removeActionFromTracker,
} from "../../features/corruption/effects/playerEffects";
import { ActionType } from "../../enums/corruption/actions/ActionType";
import { getTotalCharges } from "../../helper/activeHelper";
import {
  getPedestalPickingUpData,
  isPlayerPickingUpItem,
} from "../../features/corruption/inversion/lastPickedUpInverted";

/**
 * Corrupted Actives are basically custom active items that can have a unique sprite, effects,
 * charge, etc, modified during the game. To simulate this, we need to set up 'dummy' invisible
 * active items that don't have a name, for every possible charge setting. The sprite will then be
 * rendered on top.
 *
 * What happens when a corrupted active is swapped out? It will appear on the floor as the dummy
 * item, which is not what we want. To solve this, we need to track which corrupted actives have
 * just been removed, then quickly swap them for the collectibleType they represent.
 *
 * Furthermore, custom actives need a way to retain their state after they have been swapped out /
 * placed on the floor. Unlike passives, you can put down an active item, and you don't expect it to
 * instantly have a refreshed charge. To alleviate this, all actives on the floor need to be tracked
 * and have a state (which is just their InvertedActiveActionSet).
 *
 * Custom actives' 'Responses' are triggered upon using the custom active. Custom actives' 'Actions'
 * are added to the player effect pool upon obtaining the custom active, and removed upon the custom
 * active's removal.
 */
let FACET: Facet | undefined;
class CustomActiveFacet extends Facet {
  /** If an Active-Dummy item is removed, we must update this Facet. */
  @CallbackCustom(ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED)
  postPlayerCollectibleRemoved(
    player: EntityPlayer,
    collectibleType: CollectibleType,
  ): void {
    /** We only care about zazzinator actives. */
    if (!isZazzinatorActive(collectibleType)) {
      /**
       * Edge case where slot 2 is a custom active, and a non-inverted item from slot 1 is removed.
       */
      const slot2Active = getCustomActiveInSlot(player, ActiveSlot.SECONDARY);
      if (
        slot2Active !== undefined &&
        player.GetActiveItem(ActiveSlot.SECONDARY) === CollectibleType.NULL
      ) {
        _setCustomActiveInSlot(player, ActiveSlot.PRIMARY, slot2Active);
        _setCustomActiveInSlot(player, ActiveSlot.SECONDARY, undefined);
      }
      return;
    }

    fprint(
      `Player removed active item with type: ${collectibleType}. Trying to remove custom active...`,
    );
    checkActiveRemoved(player, collectibleType);

    /** If no one is using the CustomActiveFacet, we unsubscribe. */
    if (!doesAnyPlayerHaveAnyCustomActives()) {
      fprint("No players have custom actives, unsubscribing.");
      this.unsubscribeAll();
    }
  }

  /** When an inverted active is used, all the Responses are immediately triggered. */
  @Callback(ModCallback.POST_USE_ITEM)
  postUseItem(
    collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    activeSlot: int,
    _customVarData: int,
  ):
    | boolean
    | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
    | undefined {
    if (!isZazzinatorActive(collectibleType)) {
      return undefined;
    }

    /** Find which InvertedActiveActionSet is being used. */
    const actionSet = getCustomActiveInSlot(player, activeSlot as ActiveSlot);

    // TODO: It should never be undefined, so if it is something should be done..
    if (actionSet === undefined) {
      return undefined;
    }

    fprint(
      `Using inverted active item with chargeType: ${actionSet.getChargeType()}, charge: ${actionSet.getTotalCharges()}`,
    );
    return actionSet.use(player, activeSlot as ActiveSlot);
  }

  /**
   * Render callback responsible for rendering the corrupted sprites over the physical dummy items.
   *
   * It also handles swapping the custom actives if a player presses the drop / swap button.
   */
  @Callback(ModCallback.POST_RENDER)
  postRender(): void {
    // For some reason this callback always runs.
    if (!(FACET?.isInitialized() ?? false)) {
      return;
    }

    for (const player of getPlayers()) {
      // Loop through ActiveSlots and render the custom actives, as well as updating charge
      // tracking.
      for (const activeSlot of getEnumEntries(ActiveSlot)) {
        if (doesPlayerHaveCustomActiveInSlot(player, activeSlot[1])) {
          renderPlayerCustomActive(player, activeSlot[1]);
          updateCustomActiveCurrentCharge(player, activeSlot[1]);
        }
      }
    }
  }

  /** Edge case where normal active is added, push corrupted item in slot1 to slot2. */
  @CallbackCustom(ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED)
  postPlayerCollectibleAdded(
    player: EntityPlayer,
    collectibleType: CollectibleType,
  ): void {
    if (
      player.HasCollectible(CollectibleType.SCHOOLBAG) &&
      !isZazzinatorActive(collectibleType)
    ) {
      const primaryActive = getCustomActiveInSlot(player, ActiveSlot.PRIMARY);
      if (
        primaryActive !== undefined &&
        !isZazzinatorActive(player.GetActiveItem(ActiveSlot.PRIMARY))
      ) {
        _setCustomActiveInSlot(player, ActiveSlot.SECONDARY, primaryActive);
        _setCustomActiveInSlot(player, ActiveSlot.PRIMARY, undefined);
      }
    }
  }

  /** We need to re-add Actions to the tracker, as they aren't saved on disk. */
  @CallbackCustom(ModCallbackCustom.POST_GAME_STARTED_REORDERED, true)
  postGameStartedReordered(): void {
    for (const player of getPlayers()) {
      const customActives = getAllCustomActives(player);
      for (const customActive of customActives) {
        const actions = customActive
          .getActions()
          .filter((action) => action.actionType !== ActionType.ON_OBTAIN);
        _addActionsToTracker(player, ...actions);
      }
    }
  }

  /** Listen out for item switching with schoolbag. */
  @CallbackCustom(
    ModCallbackCustom.INPUT_ACTION_PLAYER,
    undefined,
    undefined,
    InputHook.IS_ACTION_TRIGGERED,
    ButtonAction.DROP,
  )
  inputActionPlayer(player: EntityPlayer): boolean | undefined {
    if (Input.IsActionTriggered(ButtonAction.DROP, player.ControllerIndex)) {
      dropKeyPressed(player);
    }
    return undefined;
  }
}

export function initCustomActiveFacet(): void {
  FACET = initGenericFacet(CustomActiveFacet);
}

/**
 * Adds an InvertedActiveActionSet to the player. This function shouldn't get called, and you should
 * instead use the addInvertedActionSetToPlayer() or addInvertedItemToPlayer() functions.
 *
 * All this does is update the CustomActiveFacet, and it doesn't actually add the items.
 */
export function _addInvertedActiveToPlayer(
  player: EntityPlayer,
  actionSet: InvertedActiveActionSet,
  slot: ActiveSlot = ActiveSlot.PRIMARY,
): void {
  FACET?.subscribeIfNotAlready();

  // Pocket item.
  if (slot === ActiveSlot.POCKET) {
    fprint("Adding inverted active to pocket slot...");
    _setCustomActiveInSlot(player, ActiveSlot.POCKET, actionSet);
    return;
  }

  // Single use pocket item (unimplemented).
  if (slot === ActiveSlot.POCKET_SINGLE_USE) {
    fprint("Adding inverted active to single use pocket slot...");
    _setCustomActiveInSlot(player, ActiveSlot.POCKET_SINGLE_USE, actionSet);
    return;
  }

  if (player.HasCollectible(CollectibleType.SCHOOLBAG)) {
    fprint("Player has schoolbag, switching primary slot to secondary slot...");
    _setCustomActiveInSlot(
      player,
      ActiveSlot.SECONDARY,
      getCustomActiveInSlot(player, ActiveSlot.PRIMARY),
    );
  }
  fprint("Adding inverted active to primary slot...");
  _setCustomActiveInSlot(player, ActiveSlot.PRIMARY, actionSet);
}

/** This function fires when the 'drop' (switch active) key is pressed. */
function dropKeyPressed(player: EntityPlayer) {
  // If player doesn't have schoolbag, do nothing.
  if (!player.HasCollectible(CollectibleType.SCHOOLBAG)) {
    return;
  }

  // If player has no active in the secondary slot, do nothing.
  if (player.GetActiveItem(ActiveSlot.SECONDARY) === CollectibleType.NULL) {
    return;
  }

  const primarySlotCustomActive = getCustomActiveInSlot(
    player,
    ActiveSlot.PRIMARY,
  );
  const secondarySlotCustomActive = getCustomActiveInSlot(
    player,
    ActiveSlot.SECONDARY,
  );

  // If player has no custom actives, do nothing.
  if (
    primarySlotCustomActive === undefined &&
    secondarySlotCustomActive === undefined
  ) {
    return;
  }

  // Switch the custom actives.
  fprint("Switching custom actives in primary and secondary slot...");
  _setCustomActiveInSlot(player, ActiveSlot.PRIMARY, secondarySlotCustomActive);
  _setCustomActiveInSlot(player, ActiveSlot.SECONDARY, primarySlotCustomActive);
}

/**
 * Renders a custom active the player has in the specified slot (and does nothing if the player has
 * no custom active in that slot).
 */
function renderPlayerCustomActive(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
) {
  const actionSet = getCustomActiveInSlot(player, activeSlot);
  if (actionSet === undefined) {
    return;
  }

  const icon = actionSet.getIcon();
  renderCorruptedCollectibleSpriteInSlot(player, icon, activeSlot);
}

/** Update the tracking of the custom active's current charge. */
function updateCustomActiveCurrentCharge(
  player: EntityPlayer,
  slot: ActiveSlot,
) {
  const actionSet = getCustomActiveInSlot(player, slot);
  if (actionSet === undefined) {
    return;
  }

  const charge = getTotalCharges(player, slot);

  // Do not update the charge when player is picking up an item as this messed up extra battery
  // charge.
  if (!isPlayerPickingUpItem(player)) {
    actionSet._setCurrentCharge(charge);
  }
}

/**
 * Given a player and a removed CollectibleType, checks if they have removed a custom active in the
 * and if so, handles it.
 *
 * POST_PLAYER_COLLECTIBLE_REMOVED.
 *
 * @returns True if a custom active was removed.
 */
function checkActiveRemoved(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): boolean {
  const removedActiveSlot = findRemovedCustomActiveSlot(
    player,
    collectibleType,
  );
  fprint(`Removed active slot: ${removedActiveSlot}.`);

  if (removedActiveSlot === undefined) {
    return false;
  }

  const active = getCustomActiveInSlot(player, removedActiveSlot);

  // If the active is undefined, something has gone wrong.
  if (active === undefined) {
    return false;
  }

  // Remove the Actions from the tracker.
  for (const action of active.getActions()) {
    _removeActionFromTracker(player, action);
  }

  // Track removed item.
  addRemovedInvertedItemToTracker(
    player,
    collectibleType,
    active.oi ?? CollectibleType.SAD_ONION,
    active,
  );

  fprint(
    `removed custom active charge at time of removal: ${active._getCurrentCharge()}`,
  );

  // Edge case where custom active in slot1 is removed, and player has schoolbag. In this case, we
  // need to move the custom active in slot2 to slot1 (if there is one).
  if (
    player.HasCollectible(CollectibleType.SCHOOLBAG) &&
    removedActiveSlot === ActiveSlot.PRIMARY
  ) {
    _setCustomActiveInSlot(
      player,
      ActiveSlot.PRIMARY,
      getCustomActiveInSlot(player, ActiveSlot.SECONDARY),
    );
    _setCustomActiveInSlot(player, ActiveSlot.SECONDARY, undefined);

    fprint(
      `Removed custom active with type: ${active.oi} in slot1, moving slot2 to slot1.`,
    );
    return true;
  }

  // Update data.
  _setCustomActiveInSlot(player, removedActiveSlot, undefined);

  fprint(
    `Removed custom active with type: ${active.oi} from slot ${removedActiveSlot}.`,
  );
  return true;
}

/**
 * POST_PLAYER_COLLECTIBLE_REMOVED
 *
 * Given a player and a removed collectibleType, find which slot the removed item was in, given that
 * it was a custom active.
 */
function findRemovedCustomActiveSlot(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): ActiveSlot | undefined {
  if (!isZazzinatorActive(collectibleType)) {
    return undefined;
  }

  const slot1Active = getCustomActiveInSlot(player, ActiveSlot.PRIMARY);
  const slot2Active = getCustomActiveInSlot(player, ActiveSlot.SECONDARY);
  const pocketSlot = getCustomActiveInSlot(player, ActiveSlot.POCKET);
  const singleUsePocket = getCustomActiveInSlot(
    player,
    ActiveSlot.POCKET_SINGLE_USE,
  );

  // Pocket.
  if (
    pocketSlot !== undefined &&
    !isZazzinatorActive(player.GetActiveItem(ActiveSlot.POCKET))
  ) {
    return ActiveSlot.POCKET;
  }

  // Single use pocket.
  if (
    singleUsePocket !== undefined &&
    !isZazzinatorActive(player.GetActiveItem(ActiveSlot.POCKET_SINGLE_USE))
  ) {
    return ActiveSlot.POCKET_SINGLE_USE;
  }

  // Primary no schoolbag.
  if (!player.HasCollectible(CollectibleType.SCHOOLBAG)) {
    if (
      slot1Active !== undefined &&
      !isZazzinatorActive(player.GetActiveItem(ActiveSlot.PRIMARY))
    ) {
      return ActiveSlot.PRIMARY;
    }
    return undefined;
  }

  // Primary schoolbag.
  if (
    slot1Active !== undefined &&
    doesInvertedActiveActionSetMatchZazzActive(slot1Active, collectibleType)
  ) {
    return ActiveSlot.PRIMARY;
  }
  if (
    slot2Active !== undefined &&
    doesInvertedActiveActionSetMatchZazzActive(slot2Active, collectibleType)
  ) {
    return ActiveSlot.SECONDARY;
  }

  fprint(`Failed to find removed custom active slot for ${collectibleType}.`);
  return undefined;
}

export function printCustomActiveStatus(player: EntityPlayer): void {
  const getAllCustomActivesResult = getAllCustomActivesWithSlot(player);
  if (getAllCustomActivesResult.length === 0) {
    fprint(
      `Player has no custom actives. Facet sub count: ${
        FACET?.getSubscriberCount() ?? -1
      }. Initialized: ${FACET?.isInitialized() ?? false}`,
    );
    return;
  }

  for (const customActive of getAllCustomActivesResult) {
    FACET?.subscribe();
    fprint(
      `Player has custom active in slot ${
        customActive[0]
      }: ${customActive[1].getCollectibleType()}. Facet sub count: ${
        FACET?.getSubscriberCount() ?? -1
      }. Initialized: ${FACET?.isInitialized() ?? false}`,
    );
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\BolsterNPCFacet.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import { Callback, getNPCs } from "isaacscript-common";
import {
  getNPCFamily,
  isEntityNPC,
} from "../../../../helper/entityHelper/npcHelper";
import { Facet, initGenericFacet } from "../../../Facet";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  run: {
    /** Map of Bolstered NPCs and their positions. */
    bolsteredNPCs: new Map<PtrHash, Vector>(),
  },
};

let FACET: Facet | undefined;
class BolsterNPCFacet extends Facet {
  @Callback(ModCallback.POST_NPC_UPDATE)
  postNPCUpdate(npc: EntityNPC): void {
    const npcIndex = GetPtrHash(npc);
    if (!v.run.bolsteredNPCs.has(npcIndex)) {
      return;
    }

    const bolsterLocation = v.run.bolsteredNPCs.get(npcIndex);
    if (bolsterLocation === undefined) {
      return;
    }

    npc.Position = bolsterLocation;
  }

  @Callback(ModCallback.POST_ENTITY_REMOVE)
  postEntityRemove(entity: Entity): void {
    if (!isEntityNPC(entity)) {
      return;
    }

    const npcIndex = GetPtrHash(entity);
    if (!v.run.bolsteredNPCs.has(npcIndex)) {
      return;
    }

    v.run.bolsteredNPCs.delete(npcIndex);

    // Unsubscribe if there are no more bolstered NPCs.
    if (v.run.bolsteredNPCs.size === 0) {
      this.unsubscribeAll();
    }
  }
}

export function initBolsterNPCFacet(): void {
  FACET = initGenericFacet(BolsterNPCFacet, v);
}

/** Prevents an NPC from moving. It can still be damaged and attack the player. */
export function bolsterNPC(npc: EntityNPC, individual = false): void {
  if (individual) {
    v.run.bolsteredNPCs.set(GetPtrHash(npc), npc.Position);
  } else {
    const npcFamily = getNPCFamily(npc);
    for (const member of npcFamily) {
      const npcIndex = GetPtrHash(member);
      if (v.run.bolsteredNPCs.has(npcIndex)) {
        continue;
      }
      v.run.bolsteredNPCs.set(npcIndex, member.Position);
    }
  }

  FACET?.subscribeIfNotAlready();
}

/** Returns an NPC to normal after having been bolstered with "bolsterNPC()". */
export function unbolsterNPC(npc: EntityNPC, individual = false): void {
  if (individual) {
    v.run.bolsteredNPCs.delete(GetPtrHash(npc));
  } else {
    const npcFamily = getNPCFamily(npc);
    for (const member of npcFamily) {
      const npcIndex = GetPtrHash(member);
      if (!v.run.bolsteredNPCs.has(npcIndex)) {
        continue;
      }
      v.run.bolsteredNPCs.delete(npcIndex);
    }
  }

  if (v.run.bolsteredNPCs.size === 0) {
    FACET?.unsubscribeAll();
  }
}

/**
 * Stop all enemies in the room from moving in place, they can still attack and are vulnerable. If
 * you don't want them to attack, use "freezeAllNPCsInRoom()".
 */
export function bolsterAllNPCsInRoom(): void {
  for (const npc of getNPCs()) {
    bolsterNPC(npc, true);
  }
}

/** Return all enemies in room to normal after being bolstered. */
export function unbolsterAllNPCsInRoom(): void {
  for (const npc of getNPCs()) {
    unbolsterNPC(npc, true);
  }
}

/** Check if an NPC has been bolstered by the BolsterNPCFacet. */
export function isNPCBolstered(npc: EntityNPC): boolean {
  return v.run.bolsteredNPCs.has(GetPtrHash(npc));
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\CensoredNPCFacet.ts`:

```````ts
import type { NPCID } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import {
  COLORS,
  Callback,
  CallbackCustom,
  ModCallbackCustom,
  colorEquals,
  game,
  getNPCs,
  getRandomSeed,
  getTSTLClassName,
} from "isaacscript-common";
import { getNPCFamily } from "../../../../helper/entityHelper/npcHelper";
import { fprint } from "../../../../helper/printHelper";
import { worldToRenderPosition } from "../../../../helper/renderHelper";
import { newNPCSprite } from "../../../../helper/spriteHelper";
import { Facet, initGenericFacet } from "../../../Facet";
import { getEntityIDFromEntity } from "../../../../helper/entityHelper/entityIDHelper";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  room: {
    censoredNPCs: new Map<PtrHash, Sprite>(),
  },
};

let FACET: Facet | undefined;
class CensoredNPCFacet extends Facet {
  // Censor projectiles that are spawned from censored NPCs.
  @Callback(ModCallback.POST_PROJECTILE_RENDER)
  postProjectileRender(
    projectile: EntityProjectile,
    renderOffset: Vector,
  ): void {
    if (projectile.SpawnerEntity === undefined) {
      return;
    }

    const parentPtrHash = GetPtrHash(projectile.SpawnerEntity);
    if (v.room.censoredNPCs.has(parentPtrHash)) {
      projectile.SetColor(COLORS.Black, 0, 1);
    }
  }

  // Censor NPCs that are spawned from censored NPCs.
  @Callback(ModCallback.POST_NPC_INIT)
  postNPCInit(npc: EntityNPC): void {
    const spawnerEntity = npc.SpawnerEntity;
    if (spawnerEntity === undefined) {
      return;
    }

    const spawnerPtrHash = GetPtrHash(spawnerEntity);
    if (!v.room.censoredNPCs.has(spawnerPtrHash)) {
      return;
    }

    // Censor the NPC that was spawned from a censored NPC.
    censorNPC(npc);
  }

  @Callback(ModCallback.POST_NPC_RENDER)
  postNPCUpdate(npc: EntityNPC): void {
    const sprite = v.room.censoredNPCs.get(GetPtrHash(npc));
    if (sprite === undefined) {
      return;
    }

    if (sprite.IsFinished(sprite.GetAnimation())) {
      sprite.PlayRandom(getRandomSeed());
    }
    // Only update if frame count is even.
    if (game.GetFrameCount() % 2 === 0) {
      sprite.Update();
    }

    // Check if enemy is hurt, and update sprite color.
    sprite.Color = colorEquals(npc.GetColor(), COLORS.Black)
      ? COLORS.Black
      : npc.GetColor();
    npc.SetColor(COLORS.Black, 0, 999);

    sprite.Render(worldToRenderPosition(npc.Position));
  }

  @CallbackCustom(ModCallbackCustom.POST_NEW_ROOM_REORDERED)
  postNewRoomReordered(): void {
    this.unsubscribeAll();
  }
}

export function initCensoredNPCFacet(): void {
  FACET = initGenericFacet(CensoredNPCFacet, v);
}

/**
 * This will censor the NPC, turning them and any of their produced entities black. It will also
 * make them play random animations, obfuscating them even further.
 */
export function censorNPC(npc: EntityNPC, individual = false): void {
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    if (v.room.censoredNPCs.has(GetPtrHash(member))) {
      continue;
    }
    const copiedSprite = newNPCSprite(getEntityIDFromEntity(member) as NPCID);
    copiedSprite.PlayRandom(getRandomSeed());
    copiedSprite.Color = COLORS.Black;
    v.room.censoredNPCs.set(GetPtrHash(member), copiedSprite);

    member.SetColor(COLORS.Black, 0, 1);
    fprint(`Censoring NPC: ${member.Type} (${member.Variant})`);
  }

  FACET?.subscribeIfNotAlready();
}

export function censorAllNPCsInRoom(): void {
  for (const npc of getNPCs()) {
    censorNPC(npc);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\FreezeNPCFacet.ts`:

```````ts
import type { DamageFlag } from "isaac-typescript-definitions";
import { EntityFlag, ModCallback } from "isaac-typescript-definitions";
import { Callback, getNPCs } from "isaacscript-common";
import {
  getNPCFamily,
  isEntityNPC,
} from "../../../../helper/entityHelper/npcHelper";
import { Facet, initGenericFacet } from "../../../Facet";
import { fprint } from "../../../../helper/printHelper";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  level: {
    /** A set of the Frozen NPCs that are currently in the room. */
    frozenNPCs: new Map<PtrHash, number>(),
  },
};

let FACET: Facet | undefined;
class FreezeNPCFacet extends Facet {
  @Callback(ModCallback.POST_NPC_RENDER)
  postNPCRender(npc: EntityNPC): void {
    if (v.level.frozenNPCs.size === 0) {
      return;
    }

    if (!v.level.frozenNPCs.has(GetPtrHash(npc))) {
      return;
    }

    npc.AddEntityFlags(EntityFlag.FREEZE);
    npc.AddEntityFlags(EntityFlag.NO_SPRITE_UPDATE);

    /** If enemy is dead, remove sprite update as it interferes with bosses dying properly. */
    if (npc.HitPoints < 1) {
      npc.ClearEntityFlags(EntityFlag.NO_SPRITE_UPDATE);
    }
  }

  @Callback(ModCallback.POST_ENTITY_REMOVE)
  postEntityRemove(entity: Entity): void {
    if (!isEntityNPC(entity)) {
      return;
    }

    if (!v.level.frozenNPCs.has(GetPtrHash(entity))) {
      return;
    }

    v.level.frozenNPCs.delete(GetPtrHash(entity));

    // Unsubscribe if there are no more frozen NPCs.
    if (v.level.frozenNPCs.size === 0) {
      this.unsubscribeAll();
    }
  }
}

export function initFreezeNPCFacet(): void {
  FACET = initGenericFacet(FreezeNPCFacet, v);
}

/**
 * Stop an NPC from moving and attacking. The NPC will still be vulnerable and deal contact damage.
 * You can unfreeze an NPC with the "unfreezeNPC()" function. If an NPC is frozen multiple times,
 * you must unfreeze it the same number of times to completely unfreeze it. This allows multiple
 * features to use this Facet independently without interfering with each other.
 *
 * @param npc The NPC family to freeze.
 * @param individual If true, only the NPC passed in will be frozen. If false, the entire NPC family
 *                   will be frozen.
 */
export function freezeNPC(npc: EntityNPC, individual = false): void {
  fprint(`Freezing NPC (ptrHash: ${GetPtrHash(npc)})`);
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    const frozenNPC = v.level.frozenNPCs.get(GetPtrHash(member));
    if (frozenNPC === undefined) {
      v.level.frozenNPCs.set(GetPtrHash(member), 1);
    } else {
      v.level.frozenNPCs.set(GetPtrHash(member), frozenNPC + 1);
    }
  }

  FACET?.subscribeIfNotAlready();
}

/**
 * Unfreeze an NPC that has been frozen with the "freezeNPC()" function. If an NPC has been frozen
 * multiple times, you must unfreeze it the same number of times to completely unfreeze it.
 *
 * @param npc The NPC family to unfreeze.
 * @param individual If true, only the NPC passed in will be unfrozen. If false, the entire NPC
 *                   family will be unfrozen.
 */
export function unfreezeNPC(npc: EntityNPC, individual = false): void {
  const npcFamily = individual ? [npc] : getNPCFamily(npc);
  for (const member of npcFamily) {
    const frozenNPC = v.level.frozenNPCs.get(GetPtrHash(member));
    if (frozenNPC === undefined) {
      continue;
    } else if (frozenNPC === 1) {
      v.level.frozenNPCs.delete(GetPtrHash(member));
      member.ClearEntityFlags(EntityFlag.FREEZE);
      member.ClearEntityFlags(EntityFlag.NO_SPRITE_UPDATE);
    } else {
      v.level.frozenNPCs.set(GetPtrHash(member), frozenNPC - 1);
    }
  }

  if (v.level.frozenNPCs.size === 0) {
    FACET?.unsubscribeAll();
  }
}

export function freezeAllNPCsInRoom(): void {
  for (const npc of getNPCs()) {
    freezeNPC(npc);
  }
}

export function unfreezeAllNPCsInRoom(): void {
  for (const npc of getNPCs()) {
    unfreezeNPC(npc);
  }
}

/** Check if the NPC has been frozen by the FreezeNPCFacet. */
export function isNPCFrozen(npc: EntityNPC): boolean {
  return v.level.frozenNPCs.has(GetPtrHash(npc));
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\HideNPCFacet.ts`:

```````ts
import {
  Callback,
  CallbackCustom,
  ModCallbackCustom,
  getTSTLClassName,
} from "isaacscript-common";
import { Facet, initGenericFacet } from "../../../Facet";
import { getNPCFamily } from "../../../../helper/entityHelper/npcHelper";
import {
  makeEntityInvisible,
  makeEntityVisible,
} from "../../../../helper/entityHelper";
import { freezeNPC, unfreezeNPC } from "./FreezeNPCFacet";
import type { DamageFlag } from "isaac-typescript-definitions";
import { EntityFlag, ModCallback } from "isaac-typescript-definitions";
import { fprint } from "../../../../helper/printHelper";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  room: {
    /** Map of hidden NPCs, with [number of subscriptions, is already friendly]. */
    hiddenNPCs: new Map<PtrHash, [number, boolean]>(),
  },
};

let FACET: Facet | undefined;
class HiddenNPCFacet extends Facet {
  @Callback(ModCallback.PRE_NPC_COLLISION)
  postNPCUpdate(
    npc: EntityNPC,
    _collider: Entity,
    _low: boolean,
  ): boolean | undefined {
    const ptrHash = GetPtrHash(npc);
    const hiddenNPC = v.room.hiddenNPCs.get(ptrHash);
    if (hiddenNPC === undefined) {
      return;
    }

    return true;
  }

  @Callback(ModCallback.PRE_TEAR_COLLISION)
  preTearCollision(
    _tear: EntityTear,
    collider: Entity,
    _low: boolean,
  ): boolean | undefined {
    const isNPC = collider.ToNPC() !== undefined;
    if (!isNPC) {
      return;
    }

    const ptrHashNPC = GetPtrHash(collider);
    const hiddenNPC = v.room.hiddenNPCs.get(ptrHashNPC);
    if (hiddenNPC === undefined) {
      return;
    }

    return true;
  }

  @Callback(ModCallback.PRE_PROJECTILE_COLLISION)
  preProjectileCollision(
    _projectile: EntityProjectile,
    collider: Entity,
    _low: boolean,
  ): boolean | undefined {
    const isNPC = collider.ToNPC() !== undefined;
    if (!isNPC) {
      return;
    }

    const ptrHashNPC = GetPtrHash(collider);
    const hiddenNPC = v.room.hiddenNPCs.get(ptrHashNPC);
    if (hiddenNPC === undefined) {
      return;
    }

    return true;
  }

  @Callback(ModCallback.ENTITY_TAKE_DMG)
  entityTakeDamage(
    npc: Entity,
    _amount: float,
    _damageFlags: BitFlags<DamageFlag>,
    _source: EntityRef,
    _countdownFrames: int,
  ): boolean | undefined {
    const ptrHash = GetPtrHash(npc);
    const hiddenNPC = v.room.hiddenNPCs.get(ptrHash);
    if (hiddenNPC === undefined) {
      return;
    }

    return false;
  }

  @CallbackCustom(ModCallbackCustom.POST_NEW_ROOM_REORDERED)
  postNewRoomReordered(): void {
    this.unsubscribeAll();
  }
}

/**
 * Hide an NPC. If the NPC is multi-segmented, all segments will be hidden. Hidden NPCs are
 * technically still in the room, but are invisible, do not collide with anything, are friendly and
 * frozen in place.
 *
 * @param npc The NPC to hide.
 * @param individual If true, only hide the NPC entity passed in. If false, hide all of the NPC
 *                   family.
 */
export function hideNPC(npc: EntityNPC, individual = false): void {
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    const hiddenNPCs = v.room.hiddenNPCs.get(GetPtrHash(member));
    const isAlreadyFriendly = member.HasEntityFlags(EntityFlag.FRIENDLY);
    if (hiddenNPCs === undefined) {
      hide(member);
      v.room.hiddenNPCs.set(GetPtrHash(member), [1, isAlreadyFriendly]);
    } else {
      hiddenNPCs[0]++;
      v.room.hiddenNPCs.set(GetPtrHash(member), hiddenNPCs);
    }
  }
  FACET?.subscribeIfNotAlready();
}

/**
 * Unhide an NPC that was hidden via the hide() function. This will cause them to resume their
 * normal behavior. It will not re-close the room if the room is now open.
 *
 * @param npc The NPC to unhide.
 * @param individual If true, only unhide the NPC entity passed in. If false, unhide all of the NPC
 *                   family (default = false).
 */
export function unhideNPC(npc: EntityNPC, individual = false): void {
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    const hiddenNPCs = v.room.hiddenNPCs.get(GetPtrHash(member));
    if (hiddenNPCs === undefined) {
      return;
    }
    if (hiddenNPCs[0] === 1) {
      unhide(member, hiddenNPCs[1]);
      v.room.hiddenNPCs.delete(GetPtrHash(member));
    } else {
      hiddenNPCs[0]--;
      v.room.hiddenNPCs.set(GetPtrHash(member), hiddenNPCs);
    }
  }

  if (v.room.hiddenNPCs.size === 0) {
    FACET?.unsubscribeAll();
  }
}

export function initHideNPCFacet(): void {
  FACET = initGenericFacet(HiddenNPCFacet, v);
}

function hide(npc: EntityNPC) {
  makeEntityInvisible(npc);
  freezeNPC(npc, true);
  npc.AddEntityFlags(EntityFlag.FRIENDLY);
}

function unhide(npc: EntityNPC, isAlreadyFriendly = false) {
  makeEntityVisible(npc);
  unfreezeNPC(npc, true);
  if (!isAlreadyFriendly) {
    npc.ClearEntityFlags(EntityFlag.FRIENDLY);
  }
}

export function getHideNPCFacet(): Facet | undefined {
  return FACET;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\HybridNPCFacet.ts`:

```````ts
/**
 * This file contains the implementation of the `HybridNPCFacet` class and related functions. The
 * `HybridNPCFacet` class is a facet that handles the behavior of hybrid NPCs, which are monsters
 * that are a combination of two or more other monsters. The `spawnHybridNPC` function is used to
 * spawn a hybrid NPC with the specified NPCs, and the `isHybridNPC` function is used to check if an
 * NPC is a hybrid NPC. The file also includes helper functions for transforming the hybrid NPC and
 * managing its state.
 *
 * Hybrid NPCs work by combining the characteristics and abilities of multiple NPCs into a single
 * entity. They have a set of NPCs that are combined, and the currently active NPC determines the
 * behavior and appearance of the hybrid NPC. The hybrid NPC can transform into a different NPC
 * after a certain amount of time, and when it dies, it also kills the hidden counterparts at the
 * same position.
 */

import {
  Callback,
  CallbackCustom,
  GAME_FRAMES_PER_SECOND,
  ModCallbackCustom,
  getEntityFromPtrHash,
  round,
} from "isaacscript-common";
import { Facet, initGenericFacet } from "../../../Facet";
import type { NPCID } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { getRandomMapElementWithPredicate } from "../../../../helper/mapHelper";
import { findSet } from "../../../../helper/setHelper";
import { hideNPC, unhideNPC } from "./HideNPCFacet";
import { randomInRangeWithDecimalPrecision } from "../../../../types/general/Range";
import type { Range } from "../../../../types/general/Range";
import { spawnNPCID } from "../../../../helper/entityHelper/npcIDHelper";

// eslint-disable-next-line isaacscript/require-unannotated-const-assertions
const DEFAULT_TRANSFORMATION_TIME_RANGE_SEC: Range = [0.3, 1] as const;
const DECIMAL_PRECISION = 3;
const STARTING_HP = 0;
const MINIMUM_NPC_COUNT = 2;

export interface HybridNPC {
  /** The NPCs that are combined. */
  npcs: Map<NPCID, PtrHash>;

  /** The currently active NPC from the NPC array. */
  current: PtrHash;

  /** The current HP of the hybrid NPC. */
  hp: number;

  /** The current time in ms until transformation. */
  time: number;

  /** True if the HybridNPC is in dead state. */
  dead: boolean;
}

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  room: {
    /** A map of the Hybrid NPCs that are currently in the room. */
    hybridNPCs: new Set<HybridNPC>(),
  },
};

// TODO: Add grace period when transitioning.
let FACET: Facet | undefined;
class HybridNPCFacet extends Facet {
  @Callback(ModCallback.PRE_NPC_UPDATE)
  preNPCUpdate(npc: EntityNPC): boolean | undefined {
    const hybridNPC = findHybridNPCByCurrentNPC(npc);

    if (hybridNPC === undefined) {
      return undefined;
    }

    // If the time is up, then we want to transform to the NPC.
    if (hybridNPC.time <= 0) {
      transform(hybridNPC, npc);
      return undefined;
    }

    hybridNPC.time--;
    return undefined;
  }

  @Callback(ModCallback.POST_NPC_DEATH)
  postNPCDeath(npc: EntityNPC): void {
    const hybridNPC = findHybridNPCByCurrentNPC(npc);

    if (hybridNPC === undefined) {
      return;
    }

    // We also want to kill the hidden counterparts, at the same position.
    for (const npcPtrHash of hybridNPC.npcs.values()) {
      if (npcPtrHash === hybridNPC.current) {
        continue;
      }
      const npcToRemove = getEntityFromPtrHash(npcPtrHash);
      if (npcToRemove !== undefined) {
        unhideNPC(npcToRemove as EntityNPC);
        npcToRemove.Position = npc.Position;
        npcToRemove.Kill();
      }
    }
  }

  @CallbackCustom(ModCallbackCustom.POST_NEW_ROOM_REORDERED)
  postNewRoomReordered(): void {
    this.unsubscribeAll();
  }
}

export function initHybridNPCFacet(): void {
  FACET = initGenericFacet(HybridNPCFacet, v);
}

/**
 * Spawns a 'Hybrid NPC', a monster that is a hybrid between two or more monsters, and inherits both
 * monsters properties. Monsters supplied must be unique.
 *
 * @param position The position to spawn the Hybrid NPC at.
 * @param npcs The NPCs to spawn the Hybrid NPC with.
 */
export function spawnHybridNPC(
  position: Vector,
  ...npcs: readonly NPCID[]
): EntityNPC {
  // Must provide at least two NPCs.
  if (npcs.length < MINIMUM_NPC_COUNT) {
    error("You must provide at least two NPCs to spawn a hybrid NPC.");
  }

  // Check if NPCs are unique.
  const npcSet = new Set(npcs);
  if (npcSet.size !== npcs.length) {
    error("You must provide unique NPCs to spawn a hybrid NPC.");
  }

  // Set up the HybridNPC object.
  const hybrid: HybridNPC = {
    npcs: new Map(),

    current: 0 as PtrHash,

    hp: STARTING_HP,

    time: getCountdown(DEFAULT_TRANSFORMATION_TIME_RANGE_SEC),

    dead: false,
  };
  let startingNPC: EntityNPC | undefined;

  // For each NPC,
  for (const npc of npcs) {
    const spawnedNPC = spawnNPCID(npc, position);
    hybrid.hp += spawnedNPC.MaxHitPoints;
    const ptrHash = GetPtrHash(spawnedNPC);
    hybrid.npcs.set(npc, ptrHash);
    if (npcs[0] === npc) {
      // Set the starting NPC to be active.
      hybrid.current = ptrHash;
      startingNPC = spawnedNPC;
    } else {
      // Hide the other NPCs.
      hideNPC(spawnedNPC);
    }
  }

  // Set max HP to the average of all the NPCs health.
  if (startingNPC !== undefined) {
    startingNPC.MaxHitPoints = round(hybrid.hp / npcs.length);
    startingNPC.HitPoints = startingNPC.MaxHitPoints;
  }

  v.room.hybridNPCs.add(hybrid);
  FACET?.subscribeIfNotAlready();

  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return startingNPC!;
}

/** Returns true if the NPC is apart of a HybridNPC. */
export function isHybridNPC(entityNPC: EntityNPC): boolean {
  return findHybridNPCByCurrentNPC(entityNPC) !== undefined;
}

/** When the timer reaches 0 for a HybridNPC, it 'transforms'. */
function transform(hybrid: HybridNPC, currentNPC: EntityNPC) {
  // Get the new NPC (that is currently hidden) that will take the Hybrid's form. This will be a
  // random NPC in the chain, but not the current NPC.
  hybrid.current = getRandomMapElementWithPredicate<PtrHash>(
    hybrid.npcs,
    (npc) => npc !== hybrid.current,
  );

  // Reset time.
  hybrid.time = getCountdown(DEFAULT_TRANSFORMATION_TIME_RANGE_SEC);

  // Find NPC that we transformed into.
  const newNPC = getEntityFromPtrHash(hybrid.current);
  if (newNPC === undefined) {
    return;
  }

  // Update the new NPC's data to that of old NPC.
  newNPC.Position = currentNPC.Position;
  newNPC.Velocity = currentNPC.Velocity;
  newNPC.MaxHitPoints = currentNPC.MaxHitPoints;
  newNPC.HitPoints = currentNPC.HitPoints;
  newNPC.ClearEntityFlags(newNPC.GetEntityFlags());
  newNPC.AddEntityFlags(currentNPC.GetEntityFlags());

  hideNPC(currentNPC);
  unhideNPC(newNPC as EntityNPC);
}

/** Given a range in seconds, returns the appropriate number for the countdown. */
function getCountdown(range: Range): number {
  return (
    randomInRangeWithDecimalPrecision(range, DECIMAL_PRECISION) *
    GAME_FRAMES_PER_SECOND
  );
}

/** Find the HybridNPC that contains the current NPC. */
function findHybridNPCByCurrentNPC(npc: EntityNPC): HybridNPC | undefined {
  const ptrHash = GetPtrHash(npc);
  return findSet<HybridNPC>(v.room.hybridNPCs, (h) => h.current === ptrHash);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\NonMandatoryNPCFacet.ts`:

```````ts
import { ModCallback } from "isaac-typescript-definitions";
import {
  Callback,
  CallbackCustom,
  ModCallbackCustom,
  game,
  getNPCs,
  getTSTLClassName,
} from "isaacscript-common";
import {
  getNPCFamily,
  getNPCLineage,
  isEntityNPC,
} from "../../../../helper/entityHelper/npcHelper";
import { fprint } from "../../../../helper/printHelper";
import { clearRoom } from "../../../../helper/roomHelper";
import { Facet, initGenericFacet } from "../../../Facet";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  level: {
    nonMandatoryNPC: new Set<PtrHash>(),
  },
};

let FACET: Facet | undefined;
class NonMandatoryNPCFacet extends Facet {
  // TODO: Does this still always run?
  @Callback(ModCallback.POST_UPDATE)
  postNPCUpdate() {
    if (game.GetRoom().IsClear()) {
      return;
    }

    // Room is not clear, check if any mandatory NPCs are still alive.
    const thereAreMandatoryNPCs = getNPCs().some((npc) => {
      if (v.level.nonMandatoryNPC.has(GetPtrHash(npc))) {
        return false;
      }

      // We found a mandatory NPC.
      return true;
    });

    if (thereAreMandatoryNPCs) {
      return;
    }

    // There are no mandatory NPCs, so we can open the doors and clear room.
    clearRoom();
  }

  @Callback(ModCallback.POST_ENTITY_REMOVE)
  postEntityRemove(entity: Entity) {
    if (!isEntityNPC(entity)) {
      return;
    }

    if (!v.level.nonMandatoryNPC.has(GetPtrHash(entity))) {
      return;
    }

    v.level.nonMandatoryNPC.delete(GetPtrHash(entity));

    // Unsubscribe if there are no more non-mandatory NPCs.
    if (v.level.nonMandatoryNPC.size === 0) {
      this.unsubscribeAll();
    }
  }
}

/**
 * Non-Mandatory NPCs are NPCs within the room that do not keep the doors shut when only they exist
 * in the room with the player. As such, they are not required to be killed by the player. If a
 * normal and non-Mandatory NPC both exist in the room, the doors will still be shut.
 */
export function initNonMandatoryNPCFacet(): void {
  FACET = initGenericFacet(NonMandatoryNPCFacet, v);
}

/**
 * Makes a player not require to kill the NPC to trigger the room clear. If all NPCs in the room are
 * non-Mandatory, the room will clear automatically.
 */
export function makeNPCNonMandatory(npc: EntityNPC, individual = false): void {
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    if (v.level.nonMandatoryNPC.has(GetPtrHash(member))) {
      continue;
    }
    v.level.nonMandatoryNPC.add(GetPtrHash(member));
  }

  FACET?.subscribeIfNotAlready();
}

/** Makes all NPCs non-mandatory, hence clearing the room. */
export function makeAllNPCsInRoomNonMandatory(): void {
  for (const npc of getNPCs()) {
    makeNPCNonMandatory(npc);
  }
}

/**
 * Removes the NPC NonMandatory effect given by the NonMandatoryNPCFacet. Note that this does not
 * make an already non-mandatory NPC mandatory.
 */
export function removeNPCNonMandatoryEffect(
  npc: EntityNPC,
  individual = false,
): void {
  const npcFamily = individual ? new Set<EntityNPC>([npc]) : getNPCFamily(npc);
  for (const member of npcFamily) {
    if (!v.level.nonMandatoryNPC.has(GetPtrHash(member))) {
      continue;
    }
    v.level.nonMandatoryNPC.delete(GetPtrHash(member));
  }

  if (v.level.nonMandatoryNPC.size === 0) {
    FACET?.unsubscribeAll();
  }
}

/** Returns true if an NPC is non-Mandatory (not required to kill to clear the room). */
export function isNPCNonMandatory(npc: EntityNPC): boolean {
  return v.level.nonMandatoryNPC.has(GetPtrHash(npc));
}

export function getNonMandatoryNPCFacetSubscriberCount(): number {
  return FACET?.getSubscriberCount() ?? -1;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\NPCModifiers\PermanentNPCStatusEffectFacet.ts`:

```````ts
import { ModCallback, EntityFlag } from "isaac-typescript-definitions";
import { Facet, initGenericFacet } from "../../../Facet";
import { NPCFlag } from "../../../../enums/general/NPCFlag";
import {
  COLORS,
  Callback,
  ColorDefault,
  DefaultMap,
  GAME_FRAMES_PER_SECOND,
  ReadonlySet,
} from "isaacscript-common";
import {
  getNPCFamily,
  isEntityNPC,
} from "../../../../helper/entityHelper/npcHelper";
import { fprint } from "../../../../helper/printHelper";
import { setEntityDefaultColor } from "../../../../helper/colorHelper";

const DEFAULT_STATUS_EFFECT_DURATION = 5 * GAME_FRAMES_PER_SECOND;
const SLOW_STATUS_EFFECT_MULTIPLIER = 0.5;
const SLOW_COLOR = COLORS.Gray;

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  run: {
    /** Map of NPCs with permanent status effects. */
    npcsWithPermanentStatusEffects: new DefaultMap<PtrHash, Set<NPCFlag>>(
      () => new Set(),
    ),
  },
};

/**
 * Usually NPC Status effects are temporary, and it is not possible to make them permanent. This
 * Facet aims to change that.
 */
let FACET: Facet | undefined;
class PermanentNPCStatusEffectFacet extends Facet {
  @Callback(ModCallback.POST_NPC_UPDATE)
  postNPCUpdate(npc: EntityNPC): void {
    const npcIndex = GetPtrHash(npc);
    if (!v.run.npcsWithPermanentStatusEffects.has(npcIndex)) {
      return;
    }

    const permanentStatusEffects =
      v.run.npcsWithPermanentStatusEffects.get(npcIndex);
    if (permanentStatusEffects === undefined) {
      return;
    }

    for (const statusEffect of permanentStatusEffects) {
      applyNPCStatusEffectFromNPCFlag(npc, statusEffect);
    }
  }

  @Callback(ModCallback.POST_ENTITY_REMOVE)
  postEntityRemove(entity: Entity): void {
    if (!isEntityNPC(entity)) {
      return;
    }

    const npcIndex = GetPtrHash(entity);
    if (!v.run.npcsWithPermanentStatusEffects.has(npcIndex)) {
      return;
    }

    v.run.npcsWithPermanentStatusEffects.delete(npcIndex);

    // Unsubscribe if there are no more NPCs with permanent status effects.
    if (v.run.npcsWithPermanentStatusEffects.size === 0) {
      this.unsubscribeAll();
    }
  }
}

export function initPermanentNPCStatusEffectFacet(): void {
  FACET = initGenericFacet(PermanentNPCStatusEffectFacet, v);
}

export function addPermanentStatusEffectToNPC(
  npc: EntityNPC,
  statusEffect:
    | NPCFlag.BURN
    | NPCFlag.FEAR
    | NPCFlag.CHARMED
    | NPCFlag.CONFUSED
    | NPCFlag.ICE_FREEZE
    | NPCFlag.MIDAS_FREEZE
    | NPCFlag.POISONED
    | NPCFlag.SHRUNKEN
    | NPCFlag.SLOWING,
  individual = false,
): void {
  if (individual) {
    const npcIndex = GetPtrHash(npc);
    const permanentStatusEffects =
      v.run.npcsWithPermanentStatusEffects.getAndSetDefault(npcIndex);
    permanentStatusEffects.add(statusEffect);
    fprint(
      `Added permanent status effect ${statusEffect} to NPC with NPCIndex of ${npcIndex}.`,
    );
  } else {
    const npcFamily = getNPCFamily(npc);
    for (const member of npcFamily) {
      const npcIndex = GetPtrHash(member);
      const permanentStatusEffects =
        v.run.npcsWithPermanentStatusEffects.getAndSetDefault(npcIndex);
      permanentStatusEffects.add(statusEffect);
      fprint(
        `Added permanent status effect ${statusEffect} to NPC with NPCIndex of ${npcIndex}.`,
      );
    }
  }

  FACET?.subscribeIfNotAlready();
}

function applyNPCStatusEffectFromNPCFlag(npc: EntityNPC, npcFlag: NPCFlag) {
  switch (npcFlag) {
    case NPCFlag.BURN: {
      npc.AddBurn(EntityRef(undefined), DEFAULT_STATUS_EFFECT_DURATION, 1);
      break;
    }

    case NPCFlag.FEAR: {
      npc.AddFear(EntityRef(undefined), 99_999_999_999);
      break;
    }

    case NPCFlag.CHARMED: {
      npc.AddCharmed(EntityRef(undefined), DEFAULT_STATUS_EFFECT_DURATION);
      break;
    }

    case NPCFlag.CONFUSED: {
      npc.AddConfusion(
        EntityRef(undefined),
        DEFAULT_STATUS_EFFECT_DURATION,
        false,
      );
      break;
    }

    case NPCFlag.ICE_FREEZE: {
      npc.AddFreeze(EntityRef(undefined), DEFAULT_STATUS_EFFECT_DURATION);
      break;
    }

    case NPCFlag.MIDAS_FREEZE: {
      npc.AddMidasFreeze(EntityRef(undefined), 99_999_999_999);
      break;
    }

    case NPCFlag.POISONED: {
      npc.AddPoison(EntityRef(undefined), DEFAULT_STATUS_EFFECT_DURATION, 1);
      break;
    }

    case NPCFlag.SHRUNKEN: {
      npc.AddShrink(EntityRef(undefined), DEFAULT_STATUS_EFFECT_DURATION);
      break;
    }

    case NPCFlag.SLOWING: {
      npc.AddSlowing(
        EntityRef(undefined),
        DEFAULT_STATUS_EFFECT_DURATION,
        SLOW_STATUS_EFFECT_MULTIPLIER,
        SLOW_COLOR,
      );
      break;
    }

    default: {
      break;
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\pickupModifiers\EveryItemIsFacet.ts`:

```````ts
import {
  CollectibleType,
  ModCallback,
  PickupVariant,
} from "isaac-typescript-definitions";
import type { PickupIndex } from "isaacscript-common";
import {
  Callback,
  CallbackCustom,
  DefaultMap,
  ModCallbackCustom,
  getCollectibleName,
  getCollectibles,
  getTSTLClassName,
  setCollectibleSubType,
} from "isaacscript-common";
import {
  doesCollectibleTypeMatchAttributes,
  getRandomCollectibleType,
} from "../../../../helper/collectibleHelper";
import { objectToString } from "../../../../helper/objectHelper";
import { fprint } from "../../../../helper/printHelper";
import type { CollectibleAttribute } from "../../../../interfaces/general/CollectibleAttribute";
import { mod } from "../../../../mod";
import { Facet, initGenericFacet } from "../../../Facet";

const MORPH_LIMIT = 10;

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  run: {
    everyItemIs: undefined as
      | CollectibleType
      | CollectibleAttribute
      | undefined,
  },
  level: {
    /**
     * Tracks number of times a pickup has been morphed, to prevent endless loops when another mod
     * wants to do the same thing.
     */
    convertedPickups: new DefaultMap<PickupIndex, number>(0),
  },
};

let FACET: Facet | undefined;
class EveryItemIsFacet extends Facet {
  @CallbackCustom(
    ModCallbackCustom.POST_PICKUP_CHANGED,
    PickupVariant.COLLECTIBLE,
  )
  postPickupChanged(pickup: EntityPickup): void {
    pickup = pickup as EntityPickupCollectible;
    const { everyItemIs } = v.run;

    if (everyItemIs === undefined) {
      return;
    }

    morphItem(pickup, everyItemIs, MORPH_LIMIT);
  }

  @CallbackCustom(
    ModCallbackCustom.POST_PICKUP_INIT_LATE,
    PickupVariant.COLLECTIBLE,
  )
  postPickupInitLate(pickup: EntityPickup): void {
    pickup = pickup as EntityPickupCollectible;
    const { everyItemIs } = v.run;

    if (everyItemIs === undefined) {
      return;
    }

    morphItem(pickup, everyItemIs, MORPH_LIMIT);
  }
}

export function initEveryItemIsFacet(): void {
  FACET = initGenericFacet(EveryItemIsFacet, v);
}

/**
 * After calling this function, every pedestal will be the specified CollectibleType, or share the
 * specified CollectibleAttributes. This includes all existing pedestals. Call removeEveryItemIs()
 * to undo this. If you call this function multiple times, the last call will take precedence.
 */
export function everyItemIs(
  // eslint-disable-next-line @typescript-eslint/no-shadow
  everyItemIs: CollectibleType | CollectibleAttribute,
): void {
  v.run.everyItemIs = everyItemIs;

  /**
   * We need to Morph preexisting collectibles in the room. Don't check for endless loops as this
   * will only run once not infinitely.
   */
  for (const pickup of getCollectibles()) {
    morphItem(pickup, everyItemIs);
  }

  FACET?.subscribeIfNotAlready();
}

export function removeEveryItemIs(): void {
  v.run.everyItemIs = undefined;

  FACET?.unsubscribeAll();
}

function morphItem(
  pickup: EntityPickup,
  // eslint-disable-next-line @typescript-eslint/no-shadow
  everyItemIs: CollectibleType | CollectibleAttribute,
  iterationsTilStop: undefined | number = undefined,
) {
  if ((pickup.SubType as CollectibleType) === CollectibleType.NULL) {
    return;
  }

  const isCollectibleType = typeof everyItemIs === "number";

  /** Checking if the original pickup already matches the everyItemIs condition. */
  if (isCollectibleType) {
    if ((pickup.SubType as CollectibleType) === everyItemIs) {
      return;
    }
  } else if (
    doesCollectibleTypeMatchAttributes(
      pickup.SubType as CollectibleType,
      everyItemIs,
    )
  ) {
    return;
  }

  /** Prevent endless loops. */
  if (iterationsTilStop !== undefined) {
    const amountMorphed = v.level.convertedPickups.getAndSetDefault(
      mod.getPickupIndex(pickup),
    );
    if (amountMorphed >= iterationsTilStop) {
      fprint(
        `EveryItemIsFacet: Morph limit reached for ${mod.getPickupIndex(
          pickup,
        )}`,
      );
      return;
    }
  }

  /** Do the morphing. */
  const originalSubType = pickup.SubType as CollectibleType;
  if (isCollectibleType) {
    setCollectibleSubType(pickup, everyItemIs);
  } else {
    const randomCollectible = getRandomCollectibleType(everyItemIs);
    fprint(
      `EveryItemIsFacet: Random collectible for ${objectToString(
        everyItemIs,
      )} is ${randomCollectible}`,
    );
    if (randomCollectible === undefined) {
      fprint(
        `EveryItemIsFacet: No collectible found for ${objectToString(
          everyItemIs,
        )}`,
      );
      return;
    }

    setCollectibleSubType(pickup, randomCollectible);
  }
  fprint(
    `EveryItemIsFacet: Morphing ${getCollectibleName(
      originalSubType,
    )} to ${getCollectibleName(pickup)}`,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\entityModifiers.ts\UnstableEntityFacet.ts`:

```````ts
import { ModCallback, SoundEffect } from "isaac-typescript-definitions";
import type { PickupIndex } from "isaacscript-common";
import {
  Callback,
  CallbackCustom,
  GAME_FRAMES_PER_SECOND,
  ModCallbackCustom,
  game,
  getRoomListIndex,
  getTSTLClassName,
  isPickup,
  sfxManager,
} from "isaacscript-common";
import { explodeEntity } from "../../../helper/entityHelper/explodeEntity";
import { getPickupWithPickupIndex } from "../../../helper/entityHelper/pickupIndexHelper";
import {
  isPickupBeingCollected,
  isUselessPickup,
} from "../../../helper/pickupHelper";
import { fprint } from "../../../helper/printHelper";
import { isRoomAdjacent } from "../../../helper/roomHelper";
import { mod } from "../../../mod";
import { Facet, initGenericFacet } from "../../Facet";
import type { Range } from "../../../types/general/Range";
import { randomInRange } from "../../../types/general/Range";
import { secondsToGameFrames } from "../../../helper/gameHelper";

const SECONDS_LEFT_UNTIL_FAST_BEEP = 1;
const SLOW_BEEP_INTERVAL_SEC = 1;
const FAST_BEEP_INTERVAL_SEC = 0.1;
const BEEP_SOUND_EFFECT = SoundEffect.BEEP;
const NEXT_ROOM_SHAKE_DURATION = 5;
const OTHER_ROOM_SHAKE_DURATION = 1;
const DEFAULT_SEC_TO_EXPLODE_RANGE = [2, 8] as Range;

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  level: {
    /** [RoomListIndex, GameFramesToExplode]. */
    pickupsBeingExtracted: new Map<PickupIndex, [int, int]>(),

    /** [RoomListIndex, Pickups to remove. ] */
    pickupsToRemove: new Map<int, PickupIndex[]>(),
  },
  room: {
    enemiesBeingExtracted: new Map<Entity, int>(),
  },
};

/**
 * Unstable entities count down in seconds until they explode. The explosion hurts anything in a
 * radius and spawns a harmful fire on the ground. The explosion can be heard in other rooms if you
 * leave the room with an unstable pickup.
 */
let FACET: Facet | undefined;
class UnstableEntityFacet extends Facet {
  /** No entities last throughout floors. */
  @CallbackCustom(ModCallbackCustom.PRE_NEW_LEVEL)
  preNewLevel(): void {
    this.unsubscribeAll();
  }

  /** This is where it all happens. */
  @CallbackCustom(ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED)
  postPeffectUpdateReordered(): void {
    this.updatePickups();
    this.updateEnemies();
  }

  @CallbackCustom(ModCallbackCustom.POST_NEW_ROOM_REORDERED)
  postNewRoomReordered(): void {
    // Remove pickups that are in the room that we just entered.
    const currentRoomListIndex = getRoomListIndex();
    const pickupsToRemove = v.level.pickupsToRemove.get(currentRoomListIndex);
    if (pickupsToRemove !== undefined) {
      for (const pickupIndex of pickupsToRemove) {
        const pickup = getPickupWithPickupIndex(pickupIndex);
        if (pickup !== undefined) {
          pickup.Remove();
        }
      }

      v.level.pickupsToRemove.delete(currentRoomListIndex);
    }

    this.unsubscribeIfNotInUse();
  }

  /**
   * If a pickup is being removed by means other than leaving the room, if it is unstable, remove it
   * from the map.
   * TODO: MAKE SURE DOESN'T FIRE WHEN PLAYER IS LEAVING GAME.
   */
  @Callback(ModCallback.POST_ENTITY_REMOVE)
  postEntityRemove(entity: Entity): void {
    if (!isPickup(entity)) {
      return undefined;
    }

    if (mod.isLeavingRoom()) {
      return undefined;
    }

    const pickupIndex = mod.getPickupIndex(entity);
    if (v.level.pickupsBeingExtracted.has(pickupIndex)) {
      v.level.pickupsBeingExtracted.delete(pickupIndex);
      this.unsubscribeIfNotInUse();
    }
  }

  updatePickups(): void {
    for (const [pickupIndex, [pickupRoomListIndex, numFrames]] of v.level
      .pickupsBeingExtracted) {
      /** It's exploding. */
      if (numFrames <= 0) {
        v.level.pickupsBeingExtracted.delete(pickupIndex);
        const currentRoomListIndex = getRoomListIndex();

        /** Pickup is in another room. */
        if (currentRoomListIndex !== pickupRoomListIndex) {
          // TODO: Remove pickup upon entering the room it's in.
          if (isRoomAdjacent(pickupRoomListIndex)) {
            // If room is adjacent, make a small explosion sound and screen shake.
            sfxManager.Play(SoundEffect.EXPLOSION_WEAK);
            game.ShakeScreen(NEXT_ROOM_SHAKE_DURATION);
          } else {
            // Anywhere else, only the shake.
            game.ShakeScreen(OTHER_ROOM_SHAKE_DURATION);
          }

          // Add the pickup to the list of pickups to remove when we enter the room.
          let pickupsToRemove =
            v.level.pickupsToRemove.get(pickupRoomListIndex);
          if (pickupsToRemove === undefined) {
            pickupsToRemove = [];
            v.level.pickupsToRemove.set(pickupRoomListIndex, pickupsToRemove);
          }
          pickupsToRemove.push(pickupIndex);
          continue;
        }

        /** Pickup is in the room. */
        const pickup = getPickupWithPickupIndex(pickupIndex);
        if (pickup === undefined) {
          continue;
        }

        if (isPickupBeingCollected(pickup)) {
          continue;
        }

        if (isUselessPickup(pickup)) {
          continue;
        }

        explodeEntity(pickup);
        continue;
      }

      v.level.pickupsBeingExtracted.set(pickupIndex, [
        pickupRoomListIndex,
        numFrames - 1,
      ]);

      /** Make the 'beeping' sound. */
      const pickup = getPickupWithPickupIndex(pickupIndex);
      if (pickup === undefined) {
        continue;
      }

      if (isUselessPickup(pickup)) {
        v.level.pickupsBeingExtracted.delete(pickupIndex);
        continue;
      }

      /** Make the 'beeping' sound. */
      this.makeBeepSound(pickup, numFrames);
    }

    this.unsubscribeIfNotInUse();
  }

  updateEnemies(): void {
    for (const [entity, numFrames] of v.room.enemiesBeingExtracted) {
      /** Is exploding. */
      if (numFrames <= 0) {
        v.room.enemiesBeingExtracted.delete(entity);
        if (entity.IsDead() || !entity.Exists()) {
          continue;
        }
        explodeEntity(entity);
        continue;
      }

      v.room.enemiesBeingExtracted.set(entity, numFrames - 1);

      /** Make the 'beeping' sound. */
      this.makeBeepSound(entity, numFrames);
    }

    this.unsubscribeIfNotInUse();
  }

  makeBeepSound(entity: Entity, framesTilExplode: number): void {
    if (framesTilExplode > secondsToGameFrames(SECONDS_LEFT_UNTIL_FAST_BEEP)) {
      /** Slow beep. */
      if (
        framesTilExplode % secondsToGameFrames(SLOW_BEEP_INTERVAL_SEC) ===
        0
      ) {
        entity.SetColor(Color(1, 0, 0, 1, 0, 0, 0), 10, 0, true, false);
        sfxManager.Play(SoundEffect.BEEP, 10);
      }

      /** Fast beep. */
    } else if (
      framesTilExplode % secondsToGameFrames(FAST_BEEP_INTERVAL_SEC) ===
      0
    ) {
      entity.SetColor(Color(1, 0, 0, 1, 0, 0, 0), 3, 0, true, false);
      sfxManager.Play(BEEP_SOUND_EFFECT);
    }
  }

  /** Unsubscribe if there is no entities that are using this Facet. */
  unsubscribeIfNotInUse(): void {
    if (
      v.level.pickupsBeingExtracted.size === 0 &&
      v.room.enemiesBeingExtracted.size === 0 &&
      v.level.pickupsToRemove.size === 0
    ) {
      fprint(
        "Unsubscribing from the unstable entity Facet. (no entities in use)",
      );
      this.unsubscribeAll();
    }
  }
}

export function initUnstableEntityFacet(): void {
  FACET = initGenericFacet(UnstableEntityFacet, v);
}

/**
 * Set an entity to explode after an amount of seconds. For pickups, this will even work if the
 * player has gone into another room. For enemies, once the player has left a room the instability
 * will be removed.
 *
 * @param entity The entity to make unstable.
 * @param secToExplode The amount of seconds until the entity explodes. If not given, a random
 *                     amount of seconds will be chosen.
 */
export function setEntityInstability(
  entity: Entity,
  secToExplode?: number,
): Entity {
  secToExplode ??= randomInRange(DEFAULT_SEC_TO_EXPLODE_RANGE);
  if (isPickup(entity)) {
    const pickupIndex = mod.getPickupIndex(entity);
    const numFrames = secToExplode * GAME_FRAMES_PER_SECOND;
    v.level.pickupsBeingExtracted.set(pickupIndex, [
      getRoomListIndex(),
      numFrames,
    ]);
  } else {
    v.room.enemiesBeingExtracted.set(
      entity,
      secToExplode * GAME_FRAMES_PER_SECOND,
    );
  }

  FACET?.subscribeIfNotAlready();
  return entity;
}

/** Returns true if the given pickup is unstable and going to explode. */
export function isPickupUnstable(entityPickup: EntityPickup): boolean {
  return v.level.pickupsBeingExtracted.has(mod.getPickupIndex(entityPickup));
}

/** Returns true if the NPC is unstable and going to explode. */
export function isNPCUnstable(entityNPC: EntityNPC): boolean {
  const npcPtrHash = GetPtrHash(entityNPC);
  for (const [entity, _] of v.room.enemiesBeingExtracted) {
    if (GetPtrHash(entity) === npcPtrHash) {
      return true;
    }
  }

  return false;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\ExampleFacet.ts`:

```````ts
import type { PlayerIndex } from "isaacscript-common";
import { getPlayerIndex } from "isaacscript-common";
import { Facet, initGenericFacet } from "../Facet";

const v = {
  run: {
    playerUsingFacet: undefined as PlayerIndex | undefined,
  },
};

let FACET: Facet | undefined;
class ExampleFacet extends Facet {
  thing = 3;
}

export function initExampleFacet(): void {
  FACET = initGenericFacet(ExampleFacet, v);
}

export function subscribeToExampleFacet(player: EntityPlayer): void {
  if (FACET === undefined) {
    error("The example facet is not initialized.");
  }

  v.run.playerUsingFacet = getPlayerIndex(player);
  if (!FACET.isInitialized()) {
    FACET.subscribe();
  }
}

export function unsubscribeFromExampleFacet(): void {
  if (FACET === undefined) {
    error("The example facet is not initialized.");
  }

  v.run.playerUsingFacet = undefined;
  FACET.unsubscribe();
}

export function howManySubscribersDoesExampleFacetHave(): int {
  if (FACET === undefined) {
    error("The example facet is not initialized.");
  }

  return FACET.getSubscriberCount();
}

export function isExampleFacetInitialized(): boolean {
  if (FACET === undefined) {
    return false;
  }

  return FACET.isInitialized();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\gameModifiers.ts\CantPickupFacet.ts`:

```````ts
import type { PickupVariant } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import { Callback, getPlayerIndex, getTSTLClassName } from "isaacscript-common";
import { fprint } from "../../../helper/printHelper";
import { Facet, initGenericFacet } from "../../Facet";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  run: {
    player: new Map<PlayerIndex, Array<[PickupVariant, number]>>(),
  },
};

let FACET: Facet | undefined;
class CantPickupFacet extends Facet {
  @Callback(ModCallback.PRE_PICKUP_COLLISION)
  prePickupCollision(
    pickup: EntityPickup,
    collider: Entity,
    low: boolean,
  ): boolean | undefined {
    const player = collider.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    const playerIndex = getPlayerIndex(player);
    const pickups = v.run.player.get(playerIndex);
    if (pickups === undefined) {
      return undefined;
    }

    /** Check if the pickup matches. */
    const cantPickup = pickups.some(([pickupVariant, pickupSubType]) => {
      if (pickupVariant !== pickup.Variant) {
        return false;
      }

      if (pickupSubType !== 0 && pickupSubType !== pickup.SubType) {
        return false;
      }

      return true;
    });

    if (cantPickup) {
      return false;
    }

    return undefined;
  }
}

export function initCantPickupFacet(): void {
  FACET = initGenericFacet(CantPickupFacet, v);
}

/**
 * Make a player not able to pickup a certain type of pickup. If the pickupSubType is left
 * unspecified, it will default to all SubTypes.
 */
export function setPlayerCantPickup(
  player: EntityPlayer,
  pickupVariant: PickupVariant,
  pickupSubType = 0,
): void {
  const playerIndex = getPlayerIndex(player);

  const pickups = v.run.player.get(playerIndex);
  if (pickups === undefined) {
    v.run.player.set(playerIndex, [[pickupVariant, pickupSubType]]);
  } else {
    pickups.push([pickupVariant, pickupSubType]);
  }

  fprint(
    `Player ${playerIndex} can no longer pickup ${pickupVariant} ${pickupSubType}`,
  );
  FACET?.subscribeIfNotAlready();
}

/** Undo any modifications */
export function removePlayerCantPickup(
  player: EntityPlayer,
  pickupVariant: PickupVariant,
  pickupSubType = 0,
): void {
  const playerIndex = getPlayerIndex(player);

  const pickups = v.run.player.get(playerIndex);
  if (pickups === undefined) {
    return;
  }

  const index = pickups.findIndex(
    ([pickupVariant2, pickupSubType2]) =>
      pickupVariant === pickupVariant2 && pickupSubType === pickupSubType2,
  );
  if (index === -1) {
    return;
  }

  pickups.splice(index, 1);
  fprint(
    `Player ${playerIndex} can now pickup ${pickupVariant} ${pickupSubType}`,
  );
  if (pickups.length === 0) {
    v.run.player.delete(playerIndex);
  }

  if (v.run.player.size === 0) {
    FACET?.unsubscribe();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\pc\PCFacet.ts`:

```````ts
import type { SlotVariant } from "isaac-typescript-definitions";
import {
  ButtonAction,
  ModCallback,
  SoundEffect,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  Callback,
  CallbackCustom,
  ModCallbackCustom,
  getPlayerFromIndex,
  getPlayerIndex,
  getSlots,
  getTSTLClassName,
  gridCoordinatesToWorldPosition,
  sfxManager,
  spawnSlot,
} from "isaacscript-common";
import { SoundEffectCustom } from "../../../enums/general/SoundEffectCustom";
import { PCAnimation } from "../../../enums/pc/PCAnimation";
import { PCState } from "../../../enums/pc/PCStatus";
import { switchToNextModeOnCarousel } from "../../../helper/deletedSpecific/modeHelper";
import { getDistanceBetweenEntities } from "../../../helper/entityHelper";
import { fprint } from "../../../helper/printHelper";
import { Facet, initGenericFacet } from "../../Facet";

/**
 * Handles everything to do with the physical spawn PC. PC only spawns when the first Deleted spawns
 * in. The PC can only be used at the start of the run, before exiting the starting room.
 *
 * The PC only has one user at a time, who must be standing close to it. Once another user logs on
 * or user logs off, the now-logged-off user is physically booted from the PC.
 */

/** The distance that the PC can detect a User. */
const DETECTION_RADIUS = 35;

/** Sound effect when a User logs on to the PC. */
const ACTIVATION_SFX = SoundEffectCustom.PC_LOG_IN;

/** Sound effect when a User logs off the PC. */
const DEACTIVATION_SFX = SoundEffect.CHARACTER_SELECT_RIGHT;

/** The PC's variant. */
const PC_VARIANT = Isaac.GetEntityVariantByName(
  "Deleted Computer",
) as SlotVariant;

/** The PC's SubType. */
const PC_SUBTYPE = 0;

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  run: {
    /** Index of player using PC, or null if no users. */
    user: null as PlayerIndex | null,

    /** What state the PC is in. */
    state: PCState.OFFLINE,

    /** PtrHash of the PC. */
    index: null as PtrHash | null,

    /** Initial spawn tracker. */
    spawned: false,
  },
};

let FACET: Facet | undefined;
class PCFacet extends Facet {
  /**
   * In this callback, PC state is determined, and current user is continuously pinged to make sure
   * they are still in range.
   */
  @CallbackCustom(ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED)
  postPeffectUpdateReordered(player: EntityPlayer): void {
    const { state } = v.run;
    if (!isPCActive()) {
      return;
    }

    /** If the PC can not be found (e.g out of the starting room), switch it to "OFFLINE". */
    const pc = getPC();
    if (pc === undefined) {
      fprint("Can not find the active PC anymore, unsubscribing from PCFacet.");
      v.run.state = PCState.OFFLINE;
      this.unsubscribe();
      return;
    }

    /** If the PC is in Account mode (mode it is set up in), continuously check for user. */
    if (state === PCState.ACCOUNT) {
      if (isPCBeingUsed()) {
        const currentPCUser = getCurrentPCUser();
        if (currentPCUser === undefined) {
          v.run.user = null;
        } else if (!(isPlayerInPCRange(currentPCUser, pc) ?? false)) {
          bootCurrentUserFromPC();
        }
      } else if (isPlayerInPCRange(player, pc) ?? false) {
        logOnToPC(player);
      }
    }
  }

  @CallbackCustom(ModCallbackCustom.POST_PLAYER_RENDER_REORDERED)
  postPlayerRenderReordered(player: EntityPlayer): boolean | float | undefined {
    if (!isPlayerPCUser(player)) {
      return;
    }

    /** User can't shoot. */
    player.SetShootingCooldown(1);
    if (
      Input.IsActionTriggered(ButtonAction.SHOOT_RIGHT, player.ControllerIndex)
    ) {
      fprint("PC: Switching to next mode on carousel.");
      switchToNextModeOnCarousel(player);
    }
    return undefined;
  }
}

export function initPCFacet(): void {
  FACET = initGenericFacet(PCFacet, v);
}

/**
 * Spawns the PC in the top left grid index.
 * TODO: Sort out EntitySlotCustom and adjust position for greed mode.
 */
// POST_PLAYER_INIT_FIRST
export function setupPC(): void {
  if (hasPCSpawned()) {
    fprint("PC has already spawned, not setting it up.");
    return;
  }
  v.run.spawned = true;
  const PC = spawnSlot(
    PC_VARIANT,
    PC_SUBTYPE,
    gridCoordinatesToWorldPosition(0, 0),
  );
  v.run.index = GetPtrHash(PC);
  v.run.state = PCState.ACCOUNT;
  fprint("Setting up PC, subscribing to PCFacet...");
  FACET?.subscribe();
}

/** Logs player into PC, booting previous user if any. */
export function logOnToPC(player: EntityPlayer): void {
  const currentPCUser = getCurrentPCUser();
  if (currentPCUser === undefined) {
    /** Only play sound effects and animation if there was no one previously using PC. */
    sfxManager.Play(ACTIVATION_SFX);
    playInitiateAnimation();
  } else {
    bootCurrentUserFromPC();
  }

  v.run.user = getPlayerIndex(player);
}

/** Returns true if the PC is online. */
export function isPCActive(): boolean {
  return !(v.run.state === PCState.OFFLINE);
}

/** Checks if PC has a current user. */
export function isPCBeingUsed(): boolean {
  return !(v.run.user === null);
}

/** Gets current PC user, if any. */
export function getCurrentPCUser(): EntityPlayer | undefined {
  if (v.run.user === null) {
    return undefined;
  }

  return getPlayerFromIndex(v.run.user);
}

/** Removes the user by physically pushing them away. */
// TODO: Physically boot user from PC and play 'boot' animation.
export function bootCurrentUserFromPC(): void {
  sfxManager.Play(DEACTIVATION_SFX);
  playIdleOffAnimation();
  v.run.user = null;
}

/** Checks if player is in PC range, leave pc empty to manually get PC. */
function isPlayerInPCRange(
  player: EntityPlayer,
  pc: EntitySlot | undefined = getPC(),
): boolean | undefined {
  if (pc === undefined) {
    return;
  }
  return DETECTION_RADIUS > getDistanceBetweenEntities(pc, player);
}

/** If the PC is in the room, returns it. */
function getPC(): EntitySlot | undefined {
  return getSlots(PC_VARIANT, PC_SUBTYPE)[0];
}

/**
 * Checks if the PC has spawned at the start of the game. It will spawn when any Deleted player
 * spawns in (only once).
 */
export function hasPCSpawned(): boolean {
  return v.run.spawned;
}

/** Checks if the player is the current user, if there is one. */
export function isPlayerPCUser(player: EntityPlayer): boolean {
  const currentPCUser = getCurrentPCUser();
  if (currentPCUser === undefined) {
    return false;
  }
  return getPlayerIndex(currentPCUser) === getPlayerIndex(player);
}

function playInitiateAnimation() {
  const pc = getPC();
  if (pc === undefined) {
    return;
  }
  pc.GetSprite().Play(PCAnimation.INITIATE, true);
}

function playIdleOffAnimation() {
  const pc = getPC();
  if (pc === undefined) {
    return;
  }
  pc.GetSprite().Play(PCAnimation.IDLE_OFF, true);
}

function playIdleOnAnimation() {
  const pc = getPC();
  if (pc === undefined) {
    return;
  }
  pc.GetSprite().Play(PCAnimation.IDLE_ON, true);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\RenderOverHeadFacet.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import {
  CollectibleSpriteLayer,
  PlayerItemAnimation,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  CallbackCustom,
  ModCallbackCustom,
  getEnumValues,
  getPlayerIndex,
} from "isaacscript-common";
import { PLAYER_PICKUP_ANIMATION_RENDER_OFFSET } from "../../constants/renderConstants";
import { getCollectibleSpriteFromCache } from "../../features/general/spriteCache";
import { renderCorruptedCollectibleSprite } from "../../helper/deletedSpecific/funnySprites";
import { fprint } from "../../helper/printHelper";
import { worldToRenderPosition } from "../../helper/renderHelper";
import { newSparkleSprite } from "../../helper/spriteHelper";
import type { CorruptedCollectibleSprite } from "../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import { Facet, initGenericFacet } from "../Facet";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  room: {
    currentlyPickingUp: new Map<
      PlayerIndex,
      [CorruptedCollectibleSprite | CollectibleType, boolean, number]
    >(),
    sparkleSprite: new Map<PlayerIndex, Sprite>(),
  },
};

let FACET: Facet | undefined;
class RenderOverHeadFacet extends Facet {
  @CallbackCustom(ModCallbackCustom.POST_PLAYER_RENDER_REORDERED)
  postPlayerRender(player: EntityPlayer, _renderOffset: Vector): void {
    const playerData = v.room.currentlyPickingUp.get(getPlayerIndex(player));
    if (playerData === undefined) {
      return;
    }

    const spriteToRender = playerData[0];
    const override = playerData[1];
    const speed = playerData[2];

    if (shouldRenderPickupSprite(player, override)) {
      renderSparkleAboveHead(player);
      for (let i = 1; i < speed; i++) {
        player.GetSprite().Update();
      }
      renderCollectibleAboveHead(player, spriteToRender);
    } else {
      fprint(
        `Unsubscribing from RenderOverHeadFacet for player ${getPlayerIndex(
          player,
        )} (Pickup animation is finished).`,
      );
      const playerIndex = getPlayerIndex(player);
      v.room.currentlyPickingUp.delete(playerIndex);
      v.room.sparkleSprite.delete(playerIndex);
      FACET?.unsubscribe();
    }
  }
}

export function initRenderOverHeadFacet(): void {
  FACET = initGenericFacet(RenderOverHeadFacet, v);
}

/** Play the 'Pickup' animation with a custom sprite of your choosing. */
export function playPickupAnimationWithCustomSprite(
  player: EntityPlayer,
  spriteToRender: CorruptedCollectibleSprite | CollectibleType,
  speed = 1,
  sparkle = true,
): void {
  /** Pickup animation. */
  player.PlayExtraAnimation(PlayerItemAnimation.PICKUP);

  /** Sparkle. */
  if (sparkle) {
    const sparkleSprite = newSparkleSprite();
    v.room.sparkleSprite.set(getPlayerIndex(player), sparkleSprite);
  }

  fprint(
    `Subscribed to RenderOverHeadFacet for player ${getPlayerIndex(
      player,
    )} (playPickupAnimationWithCustomSprite).`,
  );

  v.room.currentlyPickingUp.set(getPlayerIndex(player), [
    spriteToRender,
    false,
    speed,
  ]);
  FACET?.subscribe();
}

/** This function should be called in PRE_PICKUP_ITEM. */
export function overridePickupAnimationWithCustomSprite(
  player: EntityPlayer,
  spriteToRender: CorruptedCollectibleSprite | CollectibleType,
): void {
  fprint(
    `Subscribed to RenderOverHeadFacet for player ${getPlayerIndex(
      player,
    )} (overridePickupAnimationWithCustomSprite).`,
  );
  v.room.currentlyPickingUp.set(getPlayerIndex(player), [
    spriteToRender,
    true,
    1,
  ]);
  FACET?.subscribe();
}

/**
 * Renders the sprite above the players' head, in the same position where you'd find the sprite
 * during the 'Pickup' animation.
 *
 * @param player The player to render the sprite above.
 * @param spriteToRender The sprite to render.
 * @param addSparkle Whether to add a sparkle effect to the sprite. When calling this function the
 *                   sparkle effect may be already added (e.g for an invisible item), so set it to
 *                   false.
 */
function renderCollectibleAboveHead(
  player: EntityPlayer,
  spriteToRender: CorruptedCollectibleSprite | CollectibleType,
) {
  if (typeof spriteToRender === "number") {
    const newSprite = getCollectibleSpriteFromCache(spriteToRender);
    newSprite.Render(
      worldToRenderPosition(
        player.Position.add(PLAYER_PICKUP_ANIMATION_RENDER_OFFSET),
      ),
    );
  } else {
    renderCorruptedCollectibleSprite(
      worldToRenderPosition(
        player.Position.add(PLAYER_PICKUP_ANIMATION_RENDER_OFFSET),
      ),
      spriteToRender,
    );
  }
}

function renderSparkleAboveHead(player: EntityPlayer) {
  const sparkle = v.room.sparkleSprite.get(getPlayerIndex(player));
  if (sparkle !== undefined) {
    sparkle.Update();
    sparkle.RenderLayer(
      CollectibleSpriteLayer.SPARKLE,
      worldToRenderPosition(player.Position.add(Vector(0, -40))),
    );
  }
}

function shouldRenderPickupSprite(
  player: EntityPlayer,
  override: boolean,
): boolean {
  if (override) {
    if (player.IsItemQueueEmpty()) {
      return false;
    }
    return true;
  }

  const playerSprite = player.GetSprite();
  const animation = playerSprite.GetAnimation();

  /** Check if animation is in PlayerItemAnimation enum. */
  const pickupAnimations: string[] = [...getEnumValues(PlayerItemAnimation)];
  if (!pickupAnimations.includes(animation)) {
    return false;
  }

  if (playerSprite.GetFrame() > 34) {
    return false;
  }

  return true;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\facets\SpawnEntityByNameFacet.ts`:

```````ts
import { Callback, spawnEntityID } from "isaacscript-common";
import { Facet, initGenericFacet } from "../Facet";
import { fprint } from "../../helper/printHelper";
import type { EntityType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { getEntityFromInitSeed } from "../../helper/entityHelper";

// eslint-disable-next-line isaacscript/require-v-registration
const v = {
  room: {
    spawnedEntity: undefined as Seed | undefined,
  },
};

let FACET: Facet | undefined;
class SpawnEntityByNameFacet extends Facet {
  @Callback(ModCallback.PRE_ENTITY_SPAWN)
  preEntitySpawn(
    entityType: EntityType,
    variant: int,
    subType: int,
    _position: Vector,
    _velocity: Vector,
    _spawner: Entity | undefined,
    initSeed: Seed,
  ):
    | [entityType: EntityType, variant: int, subType: int, initSeed: Seed]
    | undefined {
    v.room.spawnedEntity = initSeed;
    return undefined;
  }
}

export function initSpawnEntityByNameFacet(): void {
  FACET = initGenericFacet(SpawnEntityByNameFacet, v);
}

export function spawnEntityByName(
  entityName: string,
  position?: Vector,
  velocity?: Vector,
): Entity | undefined {
  if (FACET === undefined) {
    error("The spawn entity by name facet is not initialized.");
  }
  if (!FACET.isInitialized()) {
    fprint("Initializing LastSpawnedEntityFacet...");
    FACET.subscribeIfNotAlready();
  }

  // This will spawn the entity in the middle of the room.
  Isaac.ExecuteCommand(`spawn ${entityName}`);

  const lastSpawnedEnt = v.room.spawnedEntity;
  if (lastSpawnedEnt === undefined) {
    FACET.uninit();
    v.room.spawnedEntity = undefined;
    return undefined;
  }

  // We assume that the last spawned entity is the one we want.
  const entity = getEntityFromInitSeed(lastSpawnedEnt);
  if (entity === undefined) {
    FACET.uninit();
    v.room.spawnedEntity = undefined;
    return undefined;
  }

  if (position !== undefined) {
    entity.Position = position;
  }

  if (velocity !== undefined) {
    entity.Velocity = velocity;
  }

  FACET.unsubscribeAll();
  v.room.spawnedEntity = undefined;
  return entity;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\worms\FriendlyWorm.ts`:

```````ts
import { EntityFlag, EntityType } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  VectorZero,
  arrayToBitFlags,
  copyColor,
  getPlayerIndex,
  spawnNPC,
} from "isaacscript-common";
import type { FriendlyWormType } from "../../enums/FriendlyWormType";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { getRandomAccessiblePosition } from "../../helper/positionHelper";

export abstract class FriendlyWorm {
  readonly wormType!: FriendlyWormType;
  owner?: PlayerIndex;
  found?: true;

  construct(owner: EntityPlayer): EntityNPC {
    this.owner = getPlayerIndex(owner);
    return spawnNPC(
      EntityType.SMALL_MAGGOT,
      0,
      0,
      getRandomAccessiblePosition(owner.Position) ?? VectorZero,
    );
  }

  updateAppearance(npc: EntityNPC): void {
    npc.AddEntityFlags(
      arrayToBitFlags([EntityFlag.FRIENDLY, EntityFlag.PERSISTENT]),
    );
    npc.GetSprite().Color = copyColor(DeletedColor.WORM_TURQUOISE);
    npc.GetSprite().LoadGraphics();
    return undefined;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes\worms\LevelOneWorm.ts`:

```````ts
import { FriendlyWormType } from "../../enums/FriendlyWormType";
import { FriendlyWorm } from "./FriendlyWorm";

export class LevelOneWorm extends FriendlyWorm {
  override wormType = FriendlyWormType.LEVEL_ONE_WORM;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\classes.ts`:

```````ts
import { InvertedActiveActionSet } from "./classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { InvertedPassiveActionSet } from "./classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import { NonInvertedPickupActionSet } from "./classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import { OnActiveUseAction } from "./classes/corruption/actions/OnActiveUseAction";
import { OnBombExplodeAction } from "./classes/corruption/actions/OnBombExplodeAction";
import { OnCardUseAction } from "./classes/corruption/actions/OnCardUseAction";
import { OnDamageAction } from "./classes/corruption/actions/OnDamageAction";
import { OnDeathAction } from "./classes/corruption/actions/OnDeathAction";
import { OnFloorAction } from "./classes/corruption/actions/OnFloorAction";
import { OnGreedWaveClearAction } from "./classes/corruption/actions/OnGreedWaveClearAction";
import { OnKillAction } from "./classes/corruption/actions/OnKillAction";
import { OnObtainAction } from "./classes/corruption/actions/OnObtainAction";
import { OnPillUseAction } from "./classes/corruption/actions/OnPillUseAction";
import { OnPurchaseAction } from "./classes/corruption/actions/OnPurchaseAction";
import { OnReviveAction } from "./classes/corruption/actions/OnReviveAction";
import { OnRoomAction } from "./classes/corruption/actions/OnRoomAction";
import { OnRoomClearAction } from "./classes/corruption/actions/OnRoomClearAction";
import { OnSacrificeAction } from "./classes/corruption/actions/OnSacrificeAction";
import { OnSlotDestroyAction } from "./classes/corruption/actions/OnSlotDestroyAction";
import { OnSlotUseAction } from "./classes/corruption/actions/OnSlotUseAction";
import { OnStatAction } from "./classes/corruption/actions/OnStatAction";
import { GetCollectibleResponse } from "./classes/corruption/responses/GetCollectibleResponse";
import { GetTrinketResponse } from "./classes/corruption/responses/GetTrinketResponse";
import { IfThenElseResponse } from "./classes/corruption/responses/IfThenElseResponse";
import { IfThenResponse } from "./classes/corruption/responses/IfThenResponse";
import { RemoveActionResponse } from "./classes/corruption/responses/RemoveActionResponse";
import { RemoveCollectibleResponse } from "./classes/corruption/responses/RemoveCollectibleResponse";
import { RemoveEntityResponse } from "./classes/corruption/responses/RemoveEntityResponse";
import { RemoveGridEntityResponse } from "./classes/corruption/responses/RemoveGridEntityResponse";
import { SpawnEffectResponse } from "./classes/corruption/responses/SpawnEffectResponse";
import { SpawnEntityResponse } from "./classes/corruption/responses/SpawnEntityResponse";
import { SpawnGridEntityResponse } from "./classes/corruption/responses/SpawnGridEntityResponse";
import { SpawnHybridNPCResponse } from "./classes/corruption/responses/SpawnHybridNPCResponse";
import { SpawnLiveBombResponse } from "./classes/corruption/responses/SpawnLiveBombResponse";
import { SpawnNPCResponse } from "./classes/corruption/responses/SpawnNPCResponse";
import { SpawnPickupResponse } from "./classes/corruption/responses/SpawnPickupResponse";
import { SpawnSlotResponse } from "./classes/corruption/responses/SpawnSlotResponse";
import { SpawnTearResponse } from "./classes/corruption/responses/SpawnTearResponse";
import { TemporaryActionResponse } from "./classes/corruption/responses/TemporaryActionResponse";
import { TemporaryCollectibleResponse } from "./classes/corruption/responses/TemporaryCollectibleResponse";
import { TransformResponse } from "./classes/corruption/responses/TransformResponse";
import { TriggerInSequenceResponse } from "./classes/corruption/responses/TriggerInSequenceResponse";
import { TriggerOverTimeResponse } from "./classes/corruption/responses/TriggerOverTimeResponse";
import { TriggerRandomResponse } from "./classes/corruption/responses/TriggerRandomResponse";
import { UseActiveItemResponse } from "./classes/corruption/responses/UseActiveItemResponse";
import { WaitThenTriggerResponse } from "./classes/corruption/responses/WaitThenTriggerResponse";
import { LevelOneWorm } from "./classes/worms/LevelOneWorm";
import { mod } from "./mod";

export function initClasses(): void {
  mod.saveDataManagerRegisterClass(
    InvertedPassiveActionSet,
    InvertedActiveActionSet,
    NonInvertedPickupActionSet,
    OnDamageAction,
    OnFloorAction,
    OnObtainAction,
    OnRoomAction,
    OnKillAction,
    OnDeathAction,
    OnPurchaseAction,
    OnActiveUseAction,
    OnPillUseAction,
    OnCardUseAction,
    OnDamageAction,
    OnStatAction,
    OnBombExplodeAction,
    OnGreedWaveClearAction,
    OnReviveAction,
    OnRoomClearAction,
    UseActiveItemResponse,
    WaitThenTriggerResponse,
    TriggerRandomResponse,
    TriggerOverTimeResponse,
    TriggerInSequenceResponse,
    TemporaryCollectibleResponse,
    TemporaryActionResponse,
    RemoveCollectibleResponse,
    RemoveActionResponse,
    SpawnNPCResponse,
    SpawnPickupResponse,
    LevelOneWorm,
    GetCollectibleResponse,
    RemoveEntityResponse,
    SpawnSlotResponse,
    SpawnTearResponse,
    SpawnEffectResponse,
    SpawnGridEntityResponse,
    GetTrinketResponse,
    SpawnLiveBombResponse,
    IfThenResponse,
    IfThenElseResponse,
    TransformResponse,
    RemoveGridEntityResponse,
    SpawnEntityResponse,
    SpawnHybridNPCResponse,
    OnSacrificeAction,
    OnSlotUseAction,
    OnSlotDestroyAction,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\actionSetConstants.ts`:

```````ts
import { EIDMarkup } from "../enums/compatibility/EID/EIDMarkup";

export const NO_EFFECTS_DEFAULT_TEXT = "does nothing";

export const INVERTED_ACTIVE_EID_ICON = EIDMarkup.ERROR;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\corruptionConstants.ts`:

```````ts
import type { WeightedArray } from "isaacscript-common";
import { InvertedItemActionSetBuilderReference } from "../enums/corruption/actionSets/ActionSetBuilders";
import type { Range } from "../types/general/Range";
import { UseFlag } from "isaac-typescript-definitions";

export const DEFAULT_INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE: InvertedItemActionSetBuilderReference =
  InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_DEFAULT;

/** A weighted spread of how many segments an inverted collectible's sprite should have. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
export const INVERTED_COLLECTIBLE_CUSTOM_SPRITE_SEGMENT_AMOUNT_SPREAD: WeightedArray<number> =
  [
    [1, 5],
    [2, 50],
    [3, 50],
    [4, 50],
    [5, 30],
    [6, 10],
    [7, 5],
    [8, 1],
    [9, 0.1],
  ];

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const DEFAULT_CORRUPTED_SOUND_EFFECT_AMOUNT: Range = [1, 3];
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const DEFAULT_CORRUPTED_SOUND_EFFECT_LENGTH: Range = [0.4, 2];

export const CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE = 0.1;

export const DEFAULT_INVERTED_ACTIVE_GENERATION_PERCENTAGE = 100;

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const USE_ACTIVE_ITEM_RESPONSE_BITFLAG_ARRAY: readonly UseFlag[] = [
  UseFlag.NO_ANIMATION,
  UseFlag.NO_ANNOUNCER_VOICE,
];

export const HYBRID_NPC_MINIMUM_NPC_AMOUNT = 2;

export const HYBRID_NPC_DEFAULT_NPC_AMOUNT = 2;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\eidConstants.ts`:

```````ts
/** The key EID uses for the Entity.GetData() method. */
export const EID_ENTITY_DATA_KEY = "EID_Description";

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\fileConstants.ts`:

```````ts
/** Normal Deleted non-inverted starting character spritesheet png path. */
export const NORMAL_NONINVERTED_STARTING_SPRITESHEETS_PREFIX =
  "gfx/characters/costumes/normal/nonInverted/";

/** Normal Deleted inverted starting character spritesheet png path. */
export const NORMAL_INVERTED_STARTING_SPRITESHEETS_PREFIX =
  "gfx/characters/costumes/normal/inverted/";

/** Path to transitional glitch player spritesheets. */
export const TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX =
  "gfx/characters/costumes/bitflipTransition/";

/** An array of all transitional glitch spritesheets. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
export const TRANSITIONAL_GLITCH_SPRITES_ARRAY = [
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch2`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch3`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch4`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch5`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch6`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch7`,
  `${TRANSITIONAL_GLITCH_SPRITESHEETS_PREFIX}thedeleted_glitch8`,
];

/** The "default" deleted costume spritesheet (also JERUSALEM base spritesheet). */
export const DEFAULT_NORMAL_STARTING_SPRITESHEET_PATH = `${NORMAL_NONINVERTED_STARTING_SPRITESHEETS_PREFIX}thedeleted_eden.png`;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\generalConstants.ts`:

```````ts
export const MILLISECONDS_IN_A_SECOND = 1000;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\HUDConstants.ts`:

```````ts
import { RESOLUTION_FULL_SCREEN } from "isaacscript-common";

export const LOWER_HUD_QUADRANTS_X_POSITION_CUTOFF =
  RESOLUTION_FULL_SCREEN.X / 2;

export const RIGHT_HUD_QUADRANTS_Y_POSITION_CUTOFF = 242;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\items\MYDOOMEyeConstants.ts`:

```````ts
import { Percentage } from "../../types/general/Percentage";
/** Chance for MYDOOM eye to fail and degrade on use. */
export const MYDOOM_EYE_CHANCE_TO_DEGRADE: Percentage = 20;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\mod\itemConstants.ts`:

```````ts
export const BITFLIP_DESCRIPTION = "Bitflip Description.";
export const BITFLIP_PINK_DESCRIPTION = BITFLIP_DESCRIPTION;
export const D14_DESCRIPTION = "D-14 Description";
export const ZAZZ_DESCRIPTION = "Zazz Description";

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\mod\modConstants.ts`:

```````ts
import { ISCFeature } from "isaacscript-common";

export const MOD_NAME = "thedeleted";

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\modes\HAPPY99Constants.ts`:

```````ts
import { ColorDefault } from "isaacscript-common";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { AdvancedColor } from "../../interfaces/general/AdvancedColor";

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const HAPPY99InvertedItemSpriteColor: AdvancedColor = {
  color: ColorDefault,
  colorize: [
    DeletedColor.HAPPY_YELLOW.R * 2,
    DeletedColor.HAPPY_YELLOW.G * 2,
    DeletedColor.HAPPY_YELLOW.B * 2,
    1,
  ],
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\modes\ILOVEYOUConstants.ts`:

```````ts
import { ColorDefault } from "isaacscript-common";
import { EIDColorShortcut } from "../../enums/compatibility/EID/EIDColor";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { AdvancedColor } from "../../interfaces/general/AdvancedColor";

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const ILOVEYOU_ACTION_SET_COLOR_TRIPLET: [
  EIDColorShortcut,
  EIDColorShortcut,
  EIDColorShortcut,
] = [
  EIDColorShortcut.HAPPY_YELLOW,
  EIDColorShortcut.ANGRY_RED,
  EIDColorShortcut.HAPPY_YELLOW_DARKEST,
];

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const ILOVEYOUInvertedItemSpriteColor: AdvancedColor = {
  color: ColorDefault,
  colorize: [
    DeletedColor.LOVE_PINK.R * 2,
    DeletedColor.LOVE_PINK.G * 2,
    DeletedColor.LOVE_PINK.B * 2,
    1,
  ],
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\modes\MORRISConstants.ts`:

```````ts
import { ColorDefault } from "isaacscript-common";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { AdvancedColor } from "../../interfaces/general/AdvancedColor";

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const MORRISInvertedItemSpriteColor: AdvancedColor = {
  color: ColorDefault,
  colorize: [
    DeletedColor.WORM_TURQUOISE.R * 2,
    DeletedColor.WORM_TURQUOISE.G * 2,
    DeletedColor.WORM_TURQUOISE.B * 2,
    1,
  ],
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\modes\REVETONConstants.ts`:

```````ts
import { ColorDefault } from "isaacscript-common";
import { DeletedColor } from "../../enums/general/DeletedColor";
import type { AdvancedColor } from "../../interfaces/general/AdvancedColor";

export const NUM_ACTIVE_ITEMS_IN_INVERTED_ACTIVES = 2;

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const REVETONInvertedItemRedSpriteColor: AdvancedColor = {
  color: ColorDefault,
  colorize: [
    DeletedColor.REVETON_RED.R * 4,
    DeletedColor.REVETON_RED.G * 2,
    DeletedColor.REVETON_RED.B * 2,
    1,
  ],
};

// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const REVETONInvertedItemBlueSpriteColor: AdvancedColor = {
  color: ColorDefault,
  colorize: [
    DeletedColor.REVETON_BLUE.R * 2,
    DeletedColor.REVETON_BLUE.G * 2,
    DeletedColor.REVETON_BLUE.B * 4,
    1,
  ],
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\npcConstants.ts`:

```````ts
import { EntityType } from "isaac-typescript-definitions";

export const FIRST_NPC_ENTITY_TYPE = EntityType.GAPER;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\pcConstants.ts`:

```````ts
import { Mode } from "../enums/modes/Mode";

/**
 * Represents the 'character wheel' for non-Tainted modes. First and last index in the array would
 * theoretically wrap around.
 */
// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
export const NormalModeCarousel = [
  Mode.HAPPY99,
  Mode.ILOVEYOU,
  Mode.MORRIS,
  Mode.ZIPBOMBER,
  Mode.CRYPTOLOCKER,
  Mode.SPYWIPER,
  Mode.JERUSALEM,
  Mode.HICURDISMOS,
  Mode.VCS,
  Mode.MEMZ,
  Mode.MYDOOM,
  Mode.REVETON,
];

/**
 * Represents the 'character wheel' for Tainted modes. First and last index in the array would
 * theoretically wrap around.
 */
// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
export const TaintedModeCarousel = [Mode.SOPHOS, Mode.BATTLEYE];

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\pickupConstants.ts`:

```````ts
import { EntityType, PickupVariant } from "isaac-typescript-definitions";
import type { WeightedArray } from "isaacscript-common";
import { ReadonlySet } from "isaacscript-common";
import { PickupID } from "../enums/data/ID/PickupID";

/**
 * PickupVariants that have their subType auto-generated upon game start, depending on the number
 * and order of mods enabled. These pickups' subTypes can be found using their corresponding
 * ItemConfig class.
 */
export const PICKUP_VARIANTS_WITH_AUTOGENERATED_SUBTYPES = new ReadonlySet([
  PickupVariant.COLLECTIBLE,
  PickupVariant.TRINKET,
  PickupVariant.PILL,
  PickupVariant.CARD,
]);

/** All non-Modded Souls and most modded Souls should have their name prefixed with this. */
export const SOUL_PREFIX = "Soul of";

/** This PickupID refers to a random pickup decided by the game. */
export const RANDOM_PICKUP_ID =
  `${EntityType.PICKUP}${PickupVariant.NULL}.0` as PickupID;

// eslint-disable-next-line isaacscript/require-capital-read-only
export const RANDOM_SOFT_NON_MODDED_SOUL_PICKUP_ID_SPREAD = [
  [PickupID.SOUL_OF_APOLLYON, 1],
] as WeightedArray<PickupID>;

// eslint-disable-next-line isaacscript/require-capital-read-only
export const RANDOM_SOFT_NON_MODDED_RUNE_PICKUP_ID_SPREAD = [
  [PickupID.JERA_RUNE, 1],
] as WeightedArray<PickupID>;

// eslint-disable-next-line isaacscript/require-capital-read-only
export const RANDOM_SOFT_NON_MODDED_MISCELLANEOUS_PICKUP_ID_SPREAD = [
  [PickupID.MOMS_BED, 1],
] as WeightedArray<PickupID>;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\renderConstants.ts`:

```````ts
/**
 * The coordinates to render a Collectible sprite on the HUD in the Primary Active Slot. Note: you
 * should call `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1 = Vector(20, 38);

/**
 * The coordinates to render a Collectible sprite on the HUD in the Primary Active Slot. Note: you
 * should call `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2 = Vector(141, 34);

/**
 * The coordinates to render a Collectible sprite on the HUD in the Secondary Active Slot. Note: you
 * should call `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1 = Vector(3, 19);

/**
 * The coordinates to render a Collectible sprite on the HUD in the Secondary Active Slot. Note: you
 * should call `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2 = Vector(
  159,
  15,
);

/**
 * The coordinates to render a Collectible sprite on the HUD in the bottom pocket slot position.
 * Note: you should call `renderPositionToHUDPosition` on this value to get the adjusted render
 * position.
 */
export const POCKET_SLOT_1_HUD_RENDER_POSITION_PLAYER_1 = Vector(20, -8);

/**
 * The coordinates to render a Collectible sprite on the HUD in the second-to-bottom pocket slot
 * position. Note: you should call `renderPositionToHUDPosition` on this value to get the adjusted
 * render position.
 */
export const POCKET_SLOT_2_HUD_RENDER_POSITION_PLAYER_1 = Vector(12, 18);

/**
 * The coordinates to render a Collectible sprite on the HUD in the second-to-top pocket slot
 * position. Note: you should call `renderPositionToHUDPosition` on this value to get the adjusted
 * render position.
 */
export const POCKET_SLOT_3_HUD_RENDER_POSITION_PLAYER_1 = Vector(12, 28);

/**
 * The coordinates to render a Collectible sprite on the HUD in the top pocket slot position. Note:
 * you should call `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const POCKET_SLOT_4_HUD_RENDER_POSITION_PLAYER_1 = Vector(12, 38);

/**
 * The coordinates to render a Trinket sprite on the HUD in Trinket Slot 1. Note: you should call
 * `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const TRINKET_SLOT_1_HUD_RENDER_POSITION_PLAYER_1 = Vector(38, 3);

/**
 * The coordinates to render a Trinket sprite on the HUD in Trinket Slot 1. Note: you should call
 * `renderPositionToHUDPosition` on this value to get the adjusted render position.
 */
export const TRINKET_SLOT_2_HUD_RENDER_POSITION_PLAYER_1 = Vector(14, 27);

/** Offset needed to be added when rendering a sprite over a shop item. */
export const SHOP_ITEM_RENDER_OFFSET = Vector(0, 20);

/**
 * Offset needed for when rendering a sprite for the players' pickup animation, to add to the
 * players' position.
 */
export const PLAYER_PICKUP_ANIMATION_RENDER_OFFSET = Vector(0, -20);

export const SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_1 = Vector(
  0.5,
  0.5,
);

export const POCKET_SLOT_UNFOCUSSED_COLLECTIBLE_SPRITE_SCALE_PLAYER_1 = Vector(
  0.5,
  0.5,
);

export const SECONDARY_ACTIVE_SLOT_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1 =
  Vector(0.5, 0.5);

export const POCKET_SLOT_UNFOCUSSED_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1 =
  Vector(0.5, 0.5);

export const PRIMARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1 = Vector(
  0.25,
  0.25,
);

export const SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1 =
  Vector(0.1, 0.1);

export const POCKET_SLOT_UNFOCUSSED_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1 =
  Vector(0.1, 0.1);

export const POCKET_SLOT_FOCUSSED_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1 =
  Vector(0.25, 0.25);

export const PEDESTAL_HEIGHT = 45;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\soundConstants.ts`:

```````ts
import { SoundEffect } from "isaac-typescript-definitions";

/** Sound effects that play after picking up items on various types of pedestals. */
export const PICKUP_SOUNDS = [
  SoundEffect.POWER_UP_1,
  SoundEffect.POWER_UP_2,
  SoundEffect.POWER_UP_3,
  SoundEffect.CHOIR_UNLOCK,
  SoundEffect.DEVIL_ROOM_DEAL,
] as const;

// Not tested.
export const MAX_SOUND_EFFECT_PITCH = 10;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\spriteConstants.ts`:

```````ts
/** A 30x30 pure white sprite to be used for various things. */
export const WHITE_CLEAR_SPRITE_PNG_PATH = "gfx/white_clear_sprite.png";

/** Vector to expand a 30x30 sprite so it covers the whole screen. */
export const FILL_SPRITE_TO_SCREEN_VECTOR_SCALE = Vector(100, 100);

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\constants\tmtrainerConstants.ts`:

```````ts
/** TMTRAINER items subTypes will be over this number. */
export const TMTRAINER_THRESHOLD = 4_000_000_000;

/** The max number of unique TMTRAINER IDs that will be spawned before any duplicates occur. */
export const TMTRAINER_UNIQUE_LIMIT = 1024;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\compatibility\EID\EIDColor.ts`:

```````ts
/** Shortcuts for setting the Color of EID Text. */
export enum EIDColorShortcut {
  RED = "r_del",

  /** HAPPY99. */
  HAPPY_YELLOW = "happyy_yellow_del",
  HAPPY_YELLOW_DARKER = "happy_yellow_darker_del",
  HAPPY_YELLOW_DARKEST = "happy_yellow_darkest_del",

  /** ILOVEYOU. */
  LOVE_PINK = "love_pink_del",
  LOVE_PINK_DARKER = "love_pink_darker_del",
  LOVE_PINK_DARKEST = "love_pink_darkest_del",

  /** MORRIS. */
  WORM_TURQUOISE = "worm_turquoise_del",
  WORM_TURQUOISE_DARKER = "worm_turquoise_darker_del",
  WORM_TURQUOISE_DARKEST = "worm_turquoise_darkest_del",

  /** ZIPBOMBER. */
  ANGRY_RED = "angry_red_del",

  /** HICURDISMOS. */
  WINDOWS_BLUE = "windows_blue_del",
  WINDOWS_BLUE_DARKER = "windows_blue_darker_del",
  WINDOWS_BLUE_DARKEST = "windows_blue_darkest_del",
  WINDOWS_WHITE = "windows_white_del",

  /** MYDOOM. */
  DEATH_BLACK = "death_black_del",
  DEATH_BLACK_DARKER = "death_black_darker_del",
  DEATH_BLACK_DARKEST = "death_black_darkest_del",

  /** REVETON. */
  REVETON_RED = "reveton_red_del",
  REVETON_BLUE = "reveton_blue_del",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\compatibility\EID\EIDColorTriplet.ts`:

```````ts
/**
 * Represents a map of EIDColor to Morality, used for coloring ActionSet EID Text with 'setTheme()'.
 */
export enum EIDColorTriplet {
  HAPPY99_TRIPLET,
  ILOVEYOU_TRIPLET,
  MORRIS_TRIPLET,
  HICURDISMOS_TRIPLET,
  MYDOOM_TRIPLET,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\compatibility\EID\EIDMarkup.ts`:

```````ts
/** EID Icon Markup. */

// TODO: Finish
export enum EIDMarkup {
  ERROR = "{{ERROR}}",
  ARROW_UP = "{{ArrowUp}}",
  ARROW_DOWN = "{{ArrowDown}}",
  WARNING = "{{Warning}}",
  BLANK = "{{Blank}}",
  THROWABLE = "{{Throwable}}",
  CHARGEABLE = "{{Chargeable}}",
  QUALITY_0 = "{{Quality0}}",
  QUALITY_1 = "{{Quality1}}",
  QUALITY_2 = "{{Quality2}}",
  QUALITY_3 = "{{Quality3}}",
  QUALITY_4 = "{{Quality4}}",
  HEART = "{{Heart}}",
  HALF_HEART = "{{HalfHeart}}",
  ETERNAL_HEART = "{{EternalHeart}}",
  EMPTY_HEART = "{{EmptyHeart}}",
  BLENDED_HEART = "{{BlendedHeart}}",
  BONE_HEART = "{{BoneHeart}}",
  HALF_BONE_HEART = "{{HalfBoneHeart}}",
  EMPTY_BONE_HEART = "{{EmptyBoneHeart}}",
  SOUL_HEART = "{{SoulHeart}}",
  HALF_SOUL_HEART = "{{HalfSoulHeart}}",
  BLACK_HEART = "{{BlackHeart}}",
  HALF_BLACK_HEART = "{{HalfBlackHeart}}",
  GOLDEN_HEART = "{{GoldenHeart}}",
  COIN_HEART = "{{CoinHeart}}",
  HALF_COIN_HEART = "{{HalfCoinHeart}}",
  EMPTY_COIN_HEART = "{{EmptyCoinHeart}}",
  ROTTEN_HEART = "{{RottenHeart}}",
  BROKEN_HEART = "{{BrokenHeart}}",
  ROTTEN_BONE_HEART = "{{RottenBoneHeart}}",
  UNKNOWN_HEART = "{{UnknownHeart}}",
  HOLY_MANTLE_SMALL = "{{HolyMantleSmall}}",
  HOLY_MANTLE = "{{HolyMantle}}",
  KEY = "{{Key}}",
  GOLDEN_KEY = "{{GoldenKey}}",
  BOMB = "{{Bomb}}",
  GOLDEN_BOMB = "{{GoldenBomb}}",
  COIN = "{{Coin}}",
  RUNE = "{{Rune}}",
  CARD = "{{Card}}",
  RED_CARD = "{{RedCard}}",
  PILL = "{{Pill}}",
  BATTERY = "{{Battery}}",
  POOP_PICKUP = "{{PoopPickup}}",
  GRAB_BAG = "{{GrabBag}}",
  BLACK_SACK = "{{BlackSack}}",

  // Colors.
  COLOR_LIME = "{{ColorLime}}",
  COLOR_RESET = "{{ColorReset}}",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\compatibility\Mods.ts`:

```````ts
/** An assortment of mods the player may have installed that are recognized by this mod. */
export enum Mods {
  FIEND_FOLIO = "Damn, Fiend Folio Reheated",
  ANDROMEDA = "Andromeda",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\actions\ActionBuilders.ts`:

```````ts
/**
 * Collection of all ActionBuilders, use ACTION_BUILDER_MAP with one of these values to get the
 * ActionBuilder.
 */
export enum ActionBuilders {
  /** Default ActionBuilder to default to. */
  DEFAULT,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\actions\ActionOrigin.ts`:

```````ts
/** The 'parent' of the Action. */
export enum ActionOrigin {
  /**
   * If the Action is from an inverted collectible. This makes it easier to remove the Action when
   * the inverted collectible is rerolled or removed.
   */
  INVERTED_COLLECTIBLE,
  TEMPORARY_ACTION,
  TEMPORARY_TRINKET,
  TEMPORARY_RULE,
}

/** The source of the Action, along with an ID. */
export type ActionOriginType = [ActionOrigin, number];

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\actions\ActionType.ts`:

```````ts
/** The possible types of Actions. */
export enum ActionType {
  ON_FLOOR, // done.
  ON_ROOM, // done.
  ON_OBTAIN, // done.
  ON_DAMAGE, // done.
  ON_KILL, // partly done.
  ON_DEATH, // partly done.
  ON_REVIVE, // partly done.
  ON_TEAR,
  ON_ACTIVE_USE, // partly done.
  ON_PILL_USE, // partly done.
  ON_CARD_USE, // partly done.
  ON_BOMB_EXPLODE, // partly done.
  ON_PICKUP_COLLECT, // partly done.
  ON_GREED_WAVE_CLEAR, // partly done.
  ON_GRID_BREAK,
  ON_HOLY_MANTLE_BREAK,
  ON_STAT, // partly done.
  ON_PURCHASE, // partly done.
  ON_ROOM_CLEAR, // partly done.
  ON_SACRIFICE, // partly done.
  ON_SLOT_USE, // partly done.
  ON_SLOT_DESTROY,
  ON_TRANSFORMATION,

  ON_FRIENDLY_FIRE,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\actionSets\ActionSetBuilders.ts`:

```````ts
/**
 * Collection of all InvertedItemActionSetBuilders, use ACTION_SET_BUILDER_MAP with one of these
 * values to get the InvertedItemActionSetBuilder.
 */
export enum InvertedItemActionSetBuilderReference {
  INVERTED_ITEM_ACTION_SET_DEFAULT,
  INVERTED_ITEM_ACTION_SET_HAPPY_DEFAULT,
  INVERTED_ITEM_ACTION_SET_ILOVEYOU_DEFAULT,
  INVERTED_ITEM_ACTION_SET_MORRIS_DEFAULT,
  INVERTED_ITEM_ACTION_SET_HICURDISMOS_DEFAULT,
  INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  INVERTED_ITEM_ACTION_SET_REVETON_DEFAULT,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\actionSets\ActionSetType.ts`:

```````ts
/** The possible types of Responses. */
export enum ActionSetType {
  INVERTED_ACTIVE_ITEM,
  INVERTED_PASSIVE_ITEM,
  NON_INVERTED_PICKUP,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\Morality.ts`:

```````ts
/** Classifies effects by their benefit to the player. Order matters for ActionSet color setting. */
export enum Morality {
  POSITIVE,
  NEUTRAL,
  NEGATIVE,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\corruption\responses\ResponseType.ts`:

```````ts
/** The possible types of Responses. */
export enum ResponseType {
  // TODO: For logic responses, add a 'contains' func to check the types of responses contained.

  /** Trigger a Random response in a weighted array. */
  TRIGGER_RANDOM, // done.

  /** Wait X seconds then trigger Response. */
  WAIT_THEN_TRIGGER, // done.

  /** Trigger a Response multiple times over a period of time. */
  TRIGGER_OVER_TIME, // done.

  /** Trigger one Response after another. */
  TRIGGER_IN_SEQUENCE, // done.

  /** If a condition is met, trigger the Response. */
  IF_THEN_TRIGGER, // done.

  /** If a condition is met, trigger the Response, else trigger another Response. */
  IF_THEN_ELSE_TRIGGER, // done.

  /** Trigger a Response in a queue, then 'rotate' the queue ready for the next Response. */
  TRIGGER_IN_QUEUE, // done.

  // Game
  USE_ACTIVE_ITEM, // done.
  USE_CARD,
  USE_PILL,
  GET_COLLECTIBLE, // done.
  GET_TRINKET, // done.
  GET_CONSUMABLE,
  SPAWN_PICKUP, // done.
  SPAWN_NPC, // done.
  SPAWN_SLOT, // done.
  SPAWN_TEAR, // done.
  SPAWN_PROJECTILE,
  SPAWN_EFFECT, // done.
  SPAWN_GRID, // done (wtg for repentogon).
  SPAWN_ENTITY, // done.
  SPAWN_LIVE_BOMB, // done.
  PLAY_SOUND, // done (fix random sound).
  PLAY_MUSIC,
  GIVE_COSTUME,
  GIVE_STAT,
  TRANSFORM, // done.
  EXECUTE_COMMAND,
  SHOW_FORTUNE,

  // Mostly negative.
  GIVE_CURSE,
  REMOVE_ENTITY,
  REMOVE_GRID,
  REMOVE_CORRUPTED_ITEM,
  REMOVE_COLLECTIBLE,
  REMOVE_TRINKET,
  REMOVE_RULE,
  REROLL_COLLECTIBLE,
  REROLL_TRINKET,
  REROLL_STAT,
  CHANGE_CHARACTER,

  // Custom
  SPAWN_HYBRID_NPC,
  PLAY_CORRUPTED_SOUND,
  SPAWN_WORLD,
  HAVE_DREAM,
  HAVE_NIGHTMARE,
  GET_ACTION_SET,
  TEMPORARY_ACTION,
  TEMPORARY_ACTION_SET,
  TEMPORARY_COLLECTIBLE,
  TEMPORARY_TRINKET,
  TEMPORARY_RULE,
  PLAY_TUNE,
  ADD_RULE,
  REMOVE_ACTION,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\data\ID\EffectID.ts`:

```````ts
export enum EffectID {
  DEAD_BIRD = "1000.197.0",
  LEECH = "1000.63.2",
  HALLOWED_GROUND = "1000.112.0",
  MAGGOT = "1000.63.1",
  BOMB_EXPLOSION = "1000.1.0",
  BLOOD_EXPLOSION_MEDIUM_WITH_LEFTOVER_BLOOD = "1000.2.0",
  BLOOD_EXPLOSION_SMALL = "1000.2.1",
  BLOOD_EXPLOSION_MEDIUM = "1000.2.2",
  BLOOD_EXPLOSION_LARGE = "1000.2.3",
  BLOOD_EXPLOSION_GIANT = "1000.2.4",
  BLOOD_EXPLOSION_SWIRL = "1000.2.5",
  FLY_EXPLOSION = "1000.3.0",
  ROCK_PARTICLE = "1000.4.0",
  BLOOD_PARTICLE = "1000.5.0",
  BONE_PARTICLE = "1000.5.1",
  GUT_PARTICLE = "1000.5.2",
  EYE_PARTICLE = "1000.5.3",
  DEVIL = "1000.6.0",
  BLOOD_SPLAT = "1000.7.0",
  LADDER = "1000.8.0",
  ANGEL = "1000.9.0",
  BLUE_FLAME = "1000.10.0",
  BULLET_POOF = "1000.102.0",
  TEAR_POOF_A = "1000.12.0",
  TEAR_POOF_A_NO_TEAR = "1000.12.10",
  TEAR_POOF_B = "1000.13.0",
  RIPPLE_POOF = "1000.14.1",
  POOF_01_NORMAL = "1000.15.0",
  POOF_01_SMALL = "1000.15.1",
  POOF_01_LARGE = "1000.15.3",
  POOF_02 = "1000.16.0",
  LARGE_GROUND_POOF = "1000.16.1",
  LARGE_GROUND_POOF_FOREGROUND = "1000.16.2",
  LARGE_BLOOD_POOF = "1000.16.3",
  LARGE_BLOOD_POOF_FOREGROUND = "1000.16.4",
  BLOOD_CLOUD = "1000.16.5",
  FORGOTTEN_SOUL_POOF = "1000.16.10",
  HOLY_MANTLE_POOF = "1000.16.11",
  POOF_04 = "1000.17.0",
  BOMB_CRATER = "1000.18.0",
  CRACK_THE_SKY = "1000.19.0",
  SCYTHE_BREAK = "1000.20.0",
  TINY_BUG = "1000.21.0",
  WALL_BUG = "1000.68.0",
  CREEP_RED = "1000.22.0",
  CREEP_GREEN = "1000.23.0",
  CREEP_YELLOW = "1000.24.0",
  CREEP_WHITE = "1000.25.0",
  CREEP_BLACK = "1000.26.0",
  WOOD_PARTICLE = "1000.27.0",
  MONSTROS_TOOTH = "1000.28.0",
  MOM_FOOT_STOMP = "1000.29.0",
  DR_FETUS_TARGET = "1000.30.0",
  DR_FETUS_ROCKET = "1000.31.0",
  LEMON_MISHAP = "1000.32.0",
  LEMON_PARTY = "1000.78.0",
  TINY_FLY = "1000.33.0",
  FART = "1000.34.0",
  TOOTH_PARTICLE = "1000.35.0",
  WALL_HOLE_XRAY = "1000.36.0",
  PLAYER_CREEP_HOLY_WATER = "1000.37.0",
  SPIDER_EXPLOSION = "1000.38.0",
  HEAVEN_DOOR = "1000.39.0",
  WATER_DROPLET = "1000.41.0",
  BLOOD_GUSH = "1000.42.0",
  POOP_EXPLOSION = "1000.43.0",
  PLAYER_CREEP_WHITE = "1000.44.0",
  PLAYER_CREEP_BLACK = "1000.45.0",
  PLAYER_CREEP_RED = "1000.46.0",
  TRINITY_SHIELD = "1000.47.0",
  BATTERY_UP = "1000.48.0",
  EFFECT_NOTIFICATION = "1000.49.0",
  LASER_IMPACT = "1000.50.0",
  BRIMSTONE_IMPACT = "1000.50.1",
  SHOOP_IMPACT = "1000.50.2",
  BRIMSTONE_IMPACT_CAGE_VIS = "1000.50.3",
  BOUNCING_IMPACT = "1000.50.4",
  RING_IMPACT = "1000.50.5",
  FIRE = "1000.51.0",
  RED_FLAME = "1000.52.0",
  TEAR_CREEP_GREEN = "1000.53.0",
  PLAYER_CREEP_HOLY_WATER_TRAIL = "1000.54.0",
  SPIKE_EFFECT = "1000.55.0",
  BROWN_CREEP = "1000.56.0",
  PULLING_EFFECT = "1000.57.0",
  POOP_PARTICLE = "1000.58.0",
  DUST_CLOUD = "1000.59.0",
  BOOMERANG = "1000.60.0",
  SHOCKWAVE_RADIAL = "1000.61.0",
  ROCK_EXPLOSION = "1000.62.0",
  WORM = "1000.63.0",
  BEETLE = "1000.64.0",
  WISP = "1000.65.0", // Crashes game without changing SubType.
  EMBER_PARTICLE = "1000.66.0",
  BUTTERFLY = "1000.69.0",
  BLOOD_DROP = "1000.70.0",
  BRIMSTONE_SWIRL = "1000.71.0",
  ISAACS_CARPET = "1000.74.0",
  DICE_FLOOR_ONE_PIP = "1000.76.0",
  DICE_FLOOR_TWO_PIP = "1000.76.1",
  DICE_FLOOR_THREE_PIP = "1000.76.2",
  DICE_FLOOR_FOUR_PIP = "1000.76.3",
  DICE_FLOOR_FIVE_PIP = "1000.76.4",
  DICE_FLOOR_SIX_PIP = "1000.76.5",
  LARGE_BLOOD_EXPLOSION = "1000.77.0",
  BAR_PARTICLE = "1000.75.0",
  SHOCKWAVE_DIRECTIONAL = "1000.67.0",
  CRACK_WAVE = "1000.72.0",
  SHOCKWAVE_RANDOM = "1000.73.0",
  TEAR_POOF_SMALL = "1000.79.0",
  TEAR_POOF_VERY_SMALL = "1000.80.0",
  FRIENDLY_BALL = "1000.81.0",
  WOMB_HOLE_TELEPORT = "1000.82.0",
  SPEAR_OF_DESTINY = "1000.83.0",
  EVIL_EYE = "1000.84.0",
  DIAMOND_PARTICLE = "1000.95.0",
  NAIL_PARTICLE = "1000.86.0",
  FALLING_EMBER = "1000.87.0",
  DARK_BALL_SMOKE_PARTICLE = "1000.88.0",
  ULTRA_GREED_FOOTPRINT = "1000.89.0",
  MILK_PUDDLE = "1000.90.0",
  MOMS_HAND_EMERGENCY_CONTACT = "1000.91.0",
  PLAYER_CREEP_BLACK_POWDER = "1000.92.0",
  PENTAGRAM_BLACK_POWDER = "1000.93.0",
  SLIPPERY_BROWN_CREEP = "1000.94.0",
  HUSH_LASER = "1000.96.0",
  IMPACT = "1000.97.0",
  COIN_PARTICLE = "1000.98.0",
  WATER_SPLASH = "1000.99.0",
  HUSH_ASHES = "1000.100.0",
  HUSH_LASER_UP = "1000.101.0",
  ULTRA_GREED_BLING = "1000.103.0",
  FIREWORKS = "1000.104.0",
  BROWN_CLOUD = "1000.105.0",
  FART_RING = "1000.106.0",
  BLACK_HOLE = "1000.107.0",
  BLACK_HOLE_RAY = "1000.107.1",
  MR_ME = "1000.108.0",
  DEATH_SKULL = "1000.109.0",
  ENEMY_BRIMSTONE_SWIRL = "1000.110.0",
  HAEMOLACRIA_TRAIL = "1000.111.0",
  BRIMSTONE_BALL = "1000.113.0",
  FORGOTTEN_CHAIN = "1000.114.0",
  BROKEN_SHOVEL_SHADOW = "1000.115.0",
  DIRT_PATCH = "1000.116.0",
  FORGOTTEN_SOUL = "1000.117.0",
  SMALL_ROCKET = "1000.118.0",
  TIMER = "1000.119.0",
  SPAWNER = "1000.120.0",
  LIGHT = "1000.121.0",
  BIG_HORN_HOLE_HELPER = "1000.122.0",
  HALO = "1000.123.0",
  TELEKINESIS_HALO = "1000.123.1",
  TAR_BUBBLE = "1000.124.0",
  BIG_HORN_HAND = "1000.125.0",
  TECH_DOT = "1000.126.0",
  MAMA_MEGA_EXPLOSION = "1000.127.0",
  ULTRA_DEATH_SCYTHE = "1000.199.0",
  KEY_TEAR_POOF = "1000.12.20",
  BLOODY_KEY_TEAR_POOF = "1000.12.21",
  SWORD_TEAR_POOF = "1000.12.22",
  TECH_SWORD_TEAR_POOF = "1000.12.23",
  LAVA_SPLASH = "1000.16.66",
  LAVA_SPLASH_LARGE = "1000.16.67",
  BIG_BRIMSTONE_IMPACT = "1000.50.6",
  BRIMSTONE_IMPACT_POOP = "1000.50.7",
  MONSTRANCE_HALO = "1000.123.2",
  CURSE_HALO = "1000.123.3",
  STATIC_HALO = "1000.123.4",
  SATURNUS_HALO = "1000.123.5",
  THORNS_HALO = "1000.123.6",
  STATIC_HALO_PRERENDERED = "1000.123.7",
  DARK_ARTS_HALO = "1000.123.8",
  MOMS_CARPET_1 = "1000.74.1",
  MOMS_CARPET_2 = "1000.74.2",
  LEECH_EXPLOSION = "1000.130.0",
  MAGGOT_EXPLOSION = "1000.131.0",
  BIG_WATER_SPLASH = "1000.132.0",
  STATIC_SPLASH = "1000.132.1",
  STATIC_SPLASH_2 = "1000.132.2",
  WATER_RIPPLE = "1000.133.0",
  SMALL_WATER_RIPPLE = "1000.133.1",
  PEDESTAL_RIPPLE = "1000.134.0",
  RAIN_DROP = "1000.135.0",
  GRID_PROJECTILE_HELPER = "1000.136.0",
  WORMWOOD_HOLE = "1000.137.0",
  WORMWOOD_HOLE_SPRAY = "1000.137.1",
  MIST = "1000.138.0",
  TRAP_DOOR_COVER = "1000.139.0",
  BACKDROP_DECORATION = "1000.140.0",
  SMOKE_CLOUD = "1000.141.0",
  WHIRLPOOL = "1000.142.0",
  WHIRLPOOL_PARTICLE = "1000.142.1",
  FART_WAVE = "1000.143.0",
  ENEMY_GHOST = "1000.144.0",
  ROCK_TEAR_POOF = "1000.145.0",
  DIRT_PILE = "1000.146.0",
  FIRE_JET = "1000.147.0",
  FIRE_JET_PURPLE = "1000.147.1",
  FIRE_WAVE = "1000.148.0",
  BIG_ROCK_EXPLOSION = "1000.149.0",
  BIG_ROCK_WAVE = "1000.150.0",
  GIDEON_ATTRACT_RING = "1000.151.0",
  GIDEON_ATTRACT_TRAIL = "1000.151.1",
  SHOCKWAVE_RING = "1000.151.10",
  SHOCKWAVE_TRAIL = "1000.151.11",
  HORNFEL_ROOM_CONTROLLER = "1000.152.0",
  OCCULT_TARGET = "1000.153.0",
  DOOR_OUTLINE = "1000.154.0",
  MOONLIGHT = "1000.39.1",
  SLIPPERY_BROWN_CREEP_GROWING = "1000.155.0",
  TALL_LADDER = "1000.156.0",
  STAIRWAY = "1000.156.1",
  WILLO_SPAWNER = "1000.157.0",
  TADPOLE = "1000.158.0",
  LIL_GHOST = "1000.159.0",
  BISHOP_SHIELD = "1000.160.0",
  PORTAL_TELEPORT_YELLOW = "1000.161.0",
  PORTAL_TELEPORT_RED = "1000.161.1",
  PORTAL_TELEPORT_BLUE = "1000.161.2",
  PORTAL_TELEPORT_PURPLE = "1000.161.3",
  HERETIC_PENTAGRAM = "1000.162.0",
  CHAIN_GIB = "1000.163.0",
  SIREN_RING = "1000.164.0",
  SIREN_CHARM_EFFECT = "1000.165.0",
  SIREN_CHARM_GLOW = "1000.165.1",
  SPRITE_TRAIL = "1000.166.0",
  CHAIN_LIGHTNING = "1000.167.0",
  COLOSTOMIA_PUDDLE = "1000.168.0",
  CREEP_STATIC = "1000.169.0",
  DOGMA_DEBRIS = "1000.170.0",
  DOGMA_BLACK_HOLE = "1000.171.0",
  DOGMA_ORB = "1000.172.0",
  CRACKED_ORB_POOF = "1000.173.0",
  SHOP_SPIKES = "1000.174.0",
  KINETI_BEAM = "1000.175.0",
  CLEAVER_SLASH = "1000.176.0",
  REVERSE_EXPLOSION = "1000.177.0",
  REVERSE_EXPLOSION_DEBRIS = "1000.177.1",
  URN_OF_SOULS = "1000.178.0",
  URN_OF_SOULS_BELIAL = "1000.178.1",
  ENEMY_SOUL = "1000.179.0",
  ENEMY_SOUL_BELIAL = "1000.179.1",
  RIFT = "1000.180.0",
  LAVA_SPAWNER = "1000.181.0",
  BIG_KNIFE_PROJECTILE = "1000.182.0",
  MOTHER_SHOCKWAVE = "1000.183.0",
  WORM_FRIEND_SNARE = "1000.184.0",
  REDEMPTION = "1000.185.0",
  HUNGRY_SOUL = "1000.186.0",
  EXPLOSION_WAVE = "1000.187.0",
  DIVINE_INTERVENTION = "1000.188.0",
  PURGATORY_RIFT = "1000.189.0",
  PURGATORY_SOUL = "1000.189.1",
  MOTHER_TRACER = "1000.190.0",
  PICKUP_GHOST = "1000.191.0",
  FISSURE_SPAWNER = "1000.192.0",
  ANIMA_CHAIN = "1000.193.0",
  DARK_SNARE = "1000.194.0",
  LIQUID_POOP_CREEP = "1000.195.0",
  GROUND_GLOW = "1000.196.0",
  GENERIC_TRACER = "1000.198.0",
  BULLET_POOF_STATIC = "1000.200.0",
  UMBILICAL_CORD_HELPER = "1000.201.0",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\data\ID\FamiliarID.ts`:

```````ts
/* eslint-disable isaacscript/enum-member-number-separation */
/** An enum of EntityIDs which correlate to a Pickup. */
export enum FamiliarID {
  BROTHER_BOBBY = "3.1.0",
  DEMON_BABY = "3.2.0",
  LITTLE_CHUBBY = "3.3.0",
  LITTLE_GISH = "3.4.0",
  LITTLE_STEVE = "3.5.0",
  ROBO_BABY = "3.6.0",
  SISTER_MAGGY = "3.7.0",
  ABEL = "3.8.0",
  GHOST_BABY = "3.9.0",
  HARLEQUIN_BABY = "3.10.0",
  RAINBOW_BABY = "3.11.0",
  ISAACS_HEAD = "3.12.0",
  BLUE_BABY_SOUL = "3.13.0",
  EVES_BIRD_FOOT = "3.15.0",
  DADDY_FOOT = "3.16.0",
  PEEPERS_EYE = "3.17.0",
  BOMB_BAG = "3.20.0",
  SACK_OF_PENNIES = "3.21.0",
  LITTLE_CHAD = "3.22.0",
  THE_RELIC = "3.23.0",
  BUM_FIEND = "3.24.0",
  HOLY_WATER = "3.25.0",
  KEY_PIECE_1 = "3.26.0",
  KEY_PIECE_2 = "3.27.0",
  FULL_KEY = "3.28.0",
  FOREVER_ALONE = "3.30.0",
  DISTANT_ADMIRATION = "3.31.0",
  GUARDIAN_ANGEL = "3.32.0",
  FLY_ORBITAL = "3.33.0",
  SACRIFICIAL_DAGGER = "3.35.0",
  DEAD_CAT = "3.40.0",
  ONE_UP = "3.41.0",
  GUPPYS_HAIR_BALL = "3.42.0",
  CUBE_OF_MEAT_L1 = "3.44.0",
  CUBE_OF_MEAT_L2 = "3.45.0",
  CUBE_OF_MEAT_L3 = "3.46.0",
  CUBE_OF_MEAT_L4 = "3.47.0",
  ISAACS_BODY = "3.48.0",
  SMART_FLY = "3.50.0",
  DRY_BABY = "3.51.0",
  JUICY_SACK = "3.52.0",
  ROBO_BABY_20 = "3.53.0",
  ROTTEN_BABY = "3.54.0",
  HEADLESS_BABY = "3.55.0",
  MYSTERY_SACK = "3.57.0",
  BBF = "3.58.0",
  BOBS_BRAIN = "3.59.0",
  BEST_BUD = "3.60.0",
  LIL_BRIMSTONE = "3.61.0",
  ISAACS_HEART = "3.62.0",
  DARK_BUM = "3.64.0",
  BIG_FAN = "3.65.0",
  SISSY_LONGLEGS = "3.66.0",
  PUNCHING_BAG = "3.67.0",
  GUILLOTINE = "3.68.0",
  BALL_OF_BANDAGES_L1 = "3.69.0",
  BALL_OF_BANDAGES_L2 = "3.70.0",
  BALL_OF_BANDAGES_L3 = "3.71.0",
  BALL_OF_BANDAGES_L4 = "3.72.0",
  BLUE_SPIDER = "3.73.0",
  MONGO_BABY = "3.74.0",
  SAMSONS_CHAINS = "3.75.0",
  SCISSORS = "3.78.0",
  GEMINI_FAMILIAR = "3.79.0",
  CAINS_EYE = "3.76.0",
  S_ONLY_FRIEND = "3.77.0",
  INCUBUS = "3.80.0",
  FATES_REWARD = "3.81.0",
  LIL_CHEST = "3.82.0",
  SWORN_PROTECTOR = "3.83.0",
  FRIEND_ZONE = "3.84.0",
  LOST_FLY = "3.85.0",
  CHARGED_BABY = "3.86.0",
  LIL_GURDY = "3.87.0",
  BUMBO = "3.88.0",
  CENSER = "3.89.0",
  KEY_BUM = "3.90.0",
  RUNE_BAG = "3.91.0",
  SERAPHIM = "3.92.0",
  GB_BUG = "3.93.0",
  SPIDER_MOD = "3.94.0",
  FARTING_BABY = "3.95.0",
  SUCCUBUS = "3.96.0",
  LIL_LOKI = "3.97.0",
  OBSESSED_FAN = "3.98.0",
  PAPA_FLY = "3.99.0",
  MILK = "3.100.0",
  MULTIDIMENSIONAL_BABY = "3.101.0",
  SUPER_BUM = "3.102.0",
  TONSIL = "3.103.0",
  BIG_CHUBBY = "3.104.0",
  DEPRESSION = "3.105.0",
  SHADE = "3.106.0",
  HUSHY = "3.107.0",
  LIL_MONSTRO = "3.108.0",
  KING_BABY = "3.109.0",
  FINGER = "3.110.0",
  YO_LISTEN = "3.111.0",
  ACID_BABY = "3.112.0",
  SPIDER_BABY = "3.113.0",
  SACK_OF_SACKS = "3.114.0",
  BROWN_NUGGET = "3.115.0",
  MOMS_RAZOR = "3.117.0",
  ANGRY_FLY = "3.118.0",
  BOX_BUDDY = "3.119.0",
  SPRINKLER = "3.120.0",
  LEPROCY = "3.121.0",
  LIL_HARBINGERS = "3.122.0",
  ANGELIC_PRISM = "3.123.0",
  MYSTERY_EGG = "3.124.0",
  LIL_SPEWER = "3.125.0",
  SLIPPED_RIB = "3.126.0",
  POINTY_RIB = "3.127.0",
  BONE_ORBITAL = "3.128.0",
  JAW_BONE = "3.130.0",
  FORGOTTEN_BODY = "3.900.0",
  INTRUDER = "3.200.0",
  DIP_FAMILIAR = "3.201.0",
  DIP_FAMILIAR_RED = "3.201.1",
  DIP_FAMILIAR_CORNY = "3.201.2",
  DIP_FAMILIAR_GOLD = "3.201.3",
  DIP_FAMILIAR_RAINBOW = "3.201.4",
  DIP_FAMILIAR_BLACK = "3.201.5",
  DIP_FAMILIAR_WHITE = "3.201.6",
  DIP_FAMILIAR_STONE = "3.201.12",
  DIP_FAMILIAR_FLAMING = "3.201.13",
  DIP_FAMILIAR_STINKY = "3.201.14",
  DIP_FAMILIAR_BROWNIE = "3.201.20",
  DAMOCLES = "3.202.0",
  BLOOD_OATH = "3.203.0",
  PSY_FLY = "3.204.0",
  MENORAH = "3.205.0",
  WISP_FAMILIAR = "3.206.0",
  PEEPERS_OTHER_EYE = "3.207.0",
  BOILED_BABY = "3.208.0",
  FREEZER_BABY = "3.209.0",
  BIRD_CAGE = "3.210.0",
  LOST_SOUL = "3.211.0",
  LIL_DUMPY = "3.212.0",
  KNIFE_PIECE_1 = "3.213.0",
  KNIFE_PIECE_2 = "3.214.0",
  KNIFE_PIECE_3 = "3.215.0",
  TINYTOMA = "3.216.0",
  TINYTOMA_SMALL = "3.217.0",
  BOT_FLY = "3.218.0",
  DEAD_BIRD_PERMANENT = "3.219.0",
  SIREN_MINION = "3.220.0",
  PASCHAL_CANDLE = "3.221.0",
  STITCHES = "3.222.0",
  FULL_KNIFE = "3.223.0",
  BABY_PLUM_FAMILIAR = "3.224.0",
  FRUITY_PLUM = "3.225.0",
  SPIN_TO_WIN = "3.226.0",
  BETHS_HEART = "3.227.0",
  MINISAAC = "3.228.0",
  SWARM_FLY_ORBITAL = "3.229.0",
  LIL_ABADDON = "3.230.0",
  ABYSS_LOCUST = "3.231.0",
  WORM_FRIEND = "3.233.0",
  BONE_SPUR = "3.234.0",
  TWISTED_BABY_1 = "3.235.0",
  TWISTED_BABY_2 = "3.235.1",
  STAR_OF_BETHLEHEM = "3.236.0",
  ITEM_WISP_FAMILIAR = "3.237.0",
  BLOOD_BABY = "3.238.0",
  CUBE_BABY = "3.239.0",
  UMBILICAL_BABY = "3.240.0",
  VANISHING_TWIN = "3.242.0",
  DECAP_ATTACK = "3.243.0",
  ESAU_JR = "3.244.0",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\data\ID\GridID.ts`:

```````ts
/** A list of unique grid entities, indexed using their GridEntityID. */
export enum GridID {
  NULL = "0.0",
  DECORATION = "1.0", // Check if more.
  ROCK = "2.0",
  EVENT_ROCK = "2.1",
  BLOCK = "3.0",
  ROCK_TINTED = "4.0",
  ROCK_BOMB = "5.0",
  ROCK_ALT = "6.0",
  PIT = "7.0",
  PIT_FISSURE_SPAWNER = "7.16",
  SPIKES = "8.0",
  SPIKES_ON_OFF = "9.0",
  SPIDER_WEB = "10.0",
  LOCK = "11.0",
  TNT = "12.0",
  FIREPLACE = "13.0",
  FIREPLACE_RED = "13.1",
  POOP = "14.0",
  POOP_RED = "14.1",
  POOP_CORNY = "14.2",
  POOP_GOLDEN = "14.3",
  POOP_RAINBOW = "14.4",
  POOP_BLACK = "14.5",
  POOP_WHITE = "14.6",
  POOP_GIANT_TOP_LEFT = "14.7",
  POOP_GIANT_TOP_RIGHT = "14.8",
  POOP_GIANT_BOTTOM_LEFT = "14.9",
  POOP_GIANT_BOTTOM_RIGHT = "14.10",
  POOP_CHARMING = "14.11",
  WALL = "15.0",
  DOOR = "16.0",
  DOOR_LOCKED = "16.1",
  DOOR_LOCKED_DOUBLE = "16.2",
  DOOR_LOCKED_CRACKED = "16.3",
  DOOR_LOCKED_BARRED = "16.4",
  DOOR_LOCKED_KEY_FAMILIAR = "16.5",
  DOOR_LOCKED_GREED = "16.6",
  DOOR_HIDDEN = "16.7",
  DOOR_UNLOCKED = "16.8",
  TRAPDOOR = "17.0",
  VOID_PORTAL = "17.1",
  CRAWL_SPACE = "18.0",
  CRAWL_SPACE_GREAT_GIDEON = "18.1",
  CRAWL_SPACE_SECRET_SHOP = "18.2",
  CRAWL_SPACE_PASSAGE_TO_BEGINNING_OF_FLOOR = "18.3",
  CRAWL_SPACE_NULL = "18.4",
  GRAVITY = "19.0",
  PRESSURE_PLATE = "20.0",
  REWARD_PLATE = "20.1",
  GREED_PLATE = "20.2",
  RAIL_PLATE = "20.3",
  KILL_ALL_ENEMIES_PLATE = "20.9",
  SPAWN_ROCKS_PLATE = "20.10",
  STATUE_DEVIL = "21.0",
  STATUE_ANGEL = "21.1",
  ROCK_SUPER_SPECIAL = "22.0",
  TELEPORTER = "23.0",
  PILLAR = "24.0",
  ROCK_SPIKED = "25.0",
  ROCK_FOOL_CARD = "26.0",
  ROCK_GOLD = "27.0",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\data\ID\PickupID.ts`:

```````ts
/** An enum of EntityIDs which correlate to a Pickup. */
export enum PickupID {
  BOMB = "5.40.1",
  TROLL_BOMB = "5.40.3",
  MEGATROLL_BOMB = "5.40.5",
  HALF_HEART = "5.10.2",
  SOUL_HEART = "5.10.3",
  ETERNAL_HEART = "5.10.4",
  DOUBLE_HEART = "5.10.5",
  BLACK_HEART = "5.10.6",
  GOLD_HEART = "5.10.7",
  SOUL_HEART_HALF = "5.10.8",
  SCARED_HEART = "5.10.9",
  BLENDED_HEART = "5.10.10",
  BONE_HEART = "5.10.11",
  PENNY = "5.20.1",
  NICKEL = "5.20.2",
  DIME = "5.20.3",
  DOUBLE_PENNY = "5.20.4",
  LUCKY_PENNY = "5.20.5",
  STICKY_NICKEL = "5.20.6",
  KEY = "5.30.1",
  GOLDEN_KEY = "5.30.2",
  KEY_RING = "5.30.3",
  CHARGED_KEY = "5.30.4",
  DOUBLE_BOMB = "5.40.2",
  GOLDEN_BOMB = "5.40.4",
  LIL_BATTERY = "5.90.1",
  MICRO_BATTERY = "5.90.2",
  CHEST = "5.50.0",
  BOMB_CHEST = "5.51.0",
  SPIKED_CHEST = "5.52.0",
  ETERNAL_CHEST = "5.53.0",
  MIMIC_CHEST = "5.54.0",
  LOCKED_CHEST = "5.60.0",
  GRAB_BAG = "5.69.1",
  BLUE_BLUE_PILL = "5.70.1",
  WHITE_BLUE_PILL = "5.70.2",
  ORANGE_ORANGE_PILL = "5.70.3",
  WHITE_WHITE_PILL = "5.70.4",
  DOTS_RED_PILL = "5.70.5",
  PINK_RED_PILL = "5.70.6",
  BLUE_CADET_BLUE_PILL = "5.70.7",
  YELLOW_ORANGE_PILL = "5.70.8",
  DOTS_WHITE_PILL = "5.70.9",
  WHITE_AZURE_PILL = "5.70.10",
  BLACK_YELLOW_PILL = "5.70.11",
  WHITE_BLACK_PILL = "5.70.12",
  WHITE_YELLOW_PILL = "5.70.13",
  COLLECTIBLE = "5.100.0",
  BROKEN_SHOVEL = "5.110.0",
  SHOP_ITEM = "5.150.0",
  BIG_CHEST = "5.340.0",
  TRINKET = "5.350.0",
  RED_CHEST = "5.360.0",
  CHALLENGE_TROPHY = "5.370.0",
  ISAACS_BED = "5.380.0",
  GIGA_BOMB = "5.40.7",
  THROWABLE_BOMB = "5.41.0",
  GOLDEN_PENNY = "5.20.7",
  BLACK_SACK = "5.69.2",
  GOLD_GOLD_PILL = "5.70.14",
  BLUE_BLUE_HORSE_PILL = "5.70.2049",
  WHITE_BLUE_HORSE_PILL = "5.70.2050",
  ORANGE_ORANGE_HORSE_PILL = "5.70.2051",
  WHITE_WHITE_HORSE_PILL = "5.70.2052",
  DOTS_RED_HORSE_PILL = "5.70.2053",
  PINK_RED_HORSE_PILL = "5.70.2054",
  BLUE_CADET_BLUE_HORSE_PILL = "5.70.2055",
  YELLOW_ORANGE_HORSE_PILL = "5.70.2056",
  DOTS_WHITE_HORSE_PILL = "5.70.2057",
  WHITE_AZURE_HORSE_PILL = "5.70.2058",
  BLACK_YELLOW_HORSE_PILL = "5.70.2059",
  WHITE_BLACK_HORSE_PILL = "5.70.2060",
  WHITE_YELLOW_HORSE_PILL = "5.70.2061",
  GOLD_GOLD_HORSE_PILL = "5.70.2062",
  ROTTEN_HEART = "5.10.12",
  POOP_NUGGET = "5.42.0",
  BIG_POOP_NUGGET = "5.42.1",
  MEGA_BATTERY = "5.90.3",
  GOLDEN_BATTERY = "5.90.4",
  FOOL_CARD = "5.300.1",
  MAGICIAN_CARD = "5.300.2",
  HIGH_PRIESTESS_CARD = "5.300.3",
  EMPRESS_CARD = "5.300.4",
  EMPEROR_CARD = "5.300.5",
  HIEROPHANT_CARD = "5.300.6",
  LOVERS_CARD = "5.300.7",
  CHARIOT_CARD = "5.300.8",
  JUSTICE_CARD = "5.300.9",
  HERMIT_CARD = "5.300.10",
  WHEEL_OF_FORTUNE_CARD = "5.300.11",
  STRENGTH_CARD = "5.300.12",
  HANGED_MAN_CARD = "5.300.13",
  DEATH_CARD = "5.300.14",
  TEMPERANCE_CARD = "5.300.15",
  DEVIL_CARD = "5.300.16",
  TOWER_CARD = "5.300.17",
  STARS_CARD = "5.300.18",
  MOON_CARD = "5.300.19",
  SUN_CARD = "5.300.20",
  JUDGEMENT_CARD = "5.300.21",
  WORLD_CARD = "5.300.22",
  TWO_OF_CLUBS_CARD = "5.300.23",
  TWO_OF_DIAMONDS_CARD = "5.300.24",
  TWO_OF_SPADES_CARD = "5.300.25",
  TWO_OF_HEARTS_CARD = "5.300.26",
  ACE_OF_CLUBS_CARD = "5.300.27",
  ACE_OF_DIAMONDS_CARD = "5.300.28",
  ACE_OF_SPADES_CARD = "5.300.29",
  ACE_OF_HEARTS_CARD = "5.300.30",
  JOKER_CARD = "5.300.31",
  HAGALAZ_RUNE = "5.300.32",
  JERA_RUNE = "5.300.33",
  EHWAZ_RUNE = "5.300.34",
  DAGAZ_RUNE = "5.300.35",
  ANSUZ_RUNE = "5.300.36",
  PERTHRO_RUNE = "5.300.37",
  BERKANO_RUNE = "5.300.38",
  ALGIZ_RUNE = "5.300.39",
  BLANK_RUNE = "5.300.40",
  BLACK_RUNE = "5.300.41",
  CHAOS_CARD = "5.300.42",
  CREDIT_CARD = "5.300.43",
  RULES_CARD = "5.300.44",
  CARD_AGAINST_HUMANITY = "5.300.45",
  SUICIDE_KING_CARD = "5.300.46",
  GET_OUT_OF_JAIL_FREE_CARD = "5.300.47",
  QUESTION_MARK_CARD = "5.300.48",
  DICE_SHARD_CARD = "5.300.49",
  EMERGENCY_CONTACT_CARD = "5.300.50",
  HOLY_CARD = "5.300.51",
  HUGE_GROWTH_CARD = "5.300.52",
  ANCIENT_RECALL_CARD = "5.300.53",
  ERA_WALK_CARD = "5.300.54",
  RUNE_SHARD = "5.300.55",
  REVERSE_FOOL_CARD = "5.300.56",
  REVERSE_MAGICIAN_CARD = "5.300.57",
  REVERSE_HIGH_PRIESTESS_CARD = "5.300.58",
  REVERSE_EMPRESS_CARD = "5.300.59",
  REVERSE_EMPEROR_CARD = "5.300.60",
  REVERSE_HIEROPHANT_CARD = "5.300.61",
  REVERSE_LOVERS_CARD = "5.300.62",
  REVERSE_CHARIOT_CARD = "5.300.63",
  REVERSE_JUSTICE_CARD = "5.300.64",
  REVERSE_HERMIT_CARD = "5.300.65",
  REVERSE_WHEEL_OF_FORTUNE_CARD = "5.300.66",
  REVERSE_STRENGTH_CARD = "5.300.67",
  REVERSE_HANGED_MAN_CARD = "5.300.68",
  REVERSE_DEATH_CARD = "5.300.69",
  REVERSE_TEMPERANCE_CARD = "5.300.70",
  REVERSE_DEVIL_CARD = "5.300.71",
  REVERSE_TOWER_CARD = "5.300.72",
  REVERSE_STARS_CARD = "5.300.73",
  REVERSE_MOON_CARD = "5.300.74",
  REVERSE_SUN_CARD = "5.300.75",
  REVERSE_JUDGEMENT_CARD = "5.300.76",
  REVERSE_WORLD_CARD = "5.300.77",
  CRACKED_KEY = "5.300.78",
  QUEEN_OF_HEARTS_CARD = "5.300.79",
  WILD_CARD = "5.300.80",
  SOUL_OF_ISAAC = "5.300.81",
  SOUL_OF_MAGDALENE = "5.300.82",
  SOUL_OF_CAIN = "5.300.83",
  SOUL_OF_JUDAS = "5.300.84",
  SOUL_OF_BLUE_BABY = "5.300.85",
  SOUL_OF_EVE = "5.300.86",
  SOUL_OF_SAMSON = "5.300.87",
  SOUL_OF_AZAZEL = "5.300.88",
  SOUL_OF_LAZARUS = "5.300.89",
  SOUL_OF_EDEN = "5.300.90",
  SOUL_OF_LOST = "5.300.91",
  SOUL_OF_LILITH = "5.300.92",
  SOUL_OF_KEEPER = "5.300.93",
  SOUL_OF_APOLLYON = "5.300.94",
  SOUL_OF_FORGOTTEN = "5.300.95",
  SOUL_OF_BETHANY = "5.300.96",
  SOUL_OF_JACOB_AND_ESAU = "5.300.97",
  MOMS_BED = "5.380.10",
  MOMS_CHEST = "5.390.0",
  OLD_CHEST = "5.55.0",
  WOODEN_CHEST = "5.56.0",
  MEGA_CHEST = "5.57.0",
  HAUNTED_CHEST = "5.58.0",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\FriendlyWormType.ts`:

```````ts
export enum FriendlyWormType {
  LEVEL_ONE_WORM,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\CharacterType.ts`:

```````ts
/** A type to differentiate 'non tainted a.k.a normal' elements from tainted. */
export enum CharacterType {
  NORMAL,
  TAINTED,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\CollectibleTypeCustom.ts`:

```````ts
export const CollectibleTypeCustom = {
  BITFLIP: Isaac.GetItemIdByName("Bitflip"),
  BITFLIP_PINK: Isaac.GetItemIdByName(" Bitflip"),
  BITFLIP_BLUE: Isaac.GetItemIdByName("  Bitflip"),
  D14: Isaac.GetItemIdByName("D-14"),
  TRASH: Isaac.GetItemIdByName("Trash"),
  EXTRACT: Isaac.GetItemIdByName("Extract"),
  EXTRACT_FIRE: Isaac.GetItemIdByName(" Extract"),
  MYDOOM_EYE_STAGE_1: Isaac.GetItemIdByName("Qdwho Uou  "),
  MYDOOM_EYE_STAGE_2: Isaac.GetItemIdByName("Kfiuj Uou  "),
  MYDOOM_EYE_STAGE_3: Isaac.GetItemIdByName("Cyhqsbu Uou  "),
  MYDOOM_EYE_STAGE_4: Isaac.GetItemIdByName("Xkdwho Uou  "),
  ZAZZ: Isaac.GetItemIdByName("Corrupted Passive"),
  ZAZZ_ACTIVE_NORMAL_0: Isaac.GetItemIdByName(" "),
  ZAZZ_ACTIVE_NORMAL_0_COPY: Isaac.GetItemIdByName(" ."),
  ZAZZ_ACTIVE_NORMAL_1: Isaac.GetItemIdByName("  "),
  ZAZZ_ACTIVE_NORMAL_1_COPY: Isaac.GetItemIdByName("  ."),
  ZAZZ_ACTIVE_NORMAL_2: Isaac.GetItemIdByName("   "),
  ZAZZ_ACTIVE_NORMAL_2_COPY: Isaac.GetItemIdByName("   ."),
  ZAZZ_ACTIVE_NORMAL_3: Isaac.GetItemIdByName("    "),
  ZAZZ_ACTIVE_NORMAL_3_COPY: Isaac.GetItemIdByName("    ."),
  ZAZZ_ACTIVE_NORMAL_4: Isaac.GetItemIdByName("     "),
  ZAZZ_ACTIVE_NORMAL_4_COPY: Isaac.GetItemIdByName("     ."),
  ZAZZ_ACTIVE_NORMAL_5: Isaac.GetItemIdByName("      "),
  ZAZZ_ACTIVE_NORMAL_5_COPY: Isaac.GetItemIdByName("      ."),
  ZAZZ_ACTIVE_NORMAL_6: Isaac.GetItemIdByName("       "),
  ZAZZ_ACTIVE_NORMAL_6_COPY: Isaac.GetItemIdByName("       ."),
  ZAZZ_ACTIVE_NORMAL_7: Isaac.GetItemIdByName("        "),
  ZAZZ_ACTIVE_NORMAL_7_COPY: Isaac.GetItemIdByName("        ."),
  ZAZZ_ACTIVE_NORMAL_8: Isaac.GetItemIdByName("         "),
  ZAZZ_ACTIVE_NORMAL_8_COPY: Isaac.GetItemIdByName("         ."),
  ZAZZ_ACTIVE_NORMAL_9: Isaac.GetItemIdByName("          "),
  ZAZZ_ACTIVE_NORMAL_9_COPY: Isaac.GetItemIdByName("          ."),
  ZAZZ_ACTIVE_NORMAL_10: Isaac.GetItemIdByName("           "),
  ZAZZ_ACTIVE_NORMAL_10_COPY: Isaac.GetItemIdByName("           ."),
  ZAZZ_ACTIVE_NORMAL_11: Isaac.GetItemIdByName("            "),
  ZAZZ_ACTIVE_NORMAL_11_COPY: Isaac.GetItemIdByName("            ."),
  ZAZZ_ACTIVE_NORMAL_12: Isaac.GetItemIdByName("             "),
  ZAZZ_ACTIVE_NORMAL_12_COPY: Isaac.GetItemIdByName("             ."),
} as const;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\Conditional.ts`:

```````ts
/**
 * Requirements that may need to be completed to invoke certain features or responses. Conditionals
 * may require a number value to complement them (e.g PLAYER_HAS_X_OR_MORE_HEALTH). Conditionals may
 * also be reversed to check if the player does meet certain requirement.
 */
export enum Conditional {
  /** Check if the player has X or more hearts. */
  PLAYER_HAS_X_OR_MORE_HEALTH,

  /** Check if the player has X or more coins. */
  PLAYER_HAS_X_OR_MORE_COINS,

  /** Check if the player has X or more bombs. */
  PLAYER_HAS_X_OR_MORE_BOMBS,

  /** Check if the player has X or more keys. */
  PLAYER_HAS_X_OR_MORE_KEYS,

  /** Check if the player has X or more collectibles. */
  PLAYER_HAS_X_OR_MORE_COLLECTIBLES,

  /** Check if the player has X transformation (X is TransformationType). */
  PLAYER_HAS_TRANSFORMATION_X,

  /** Check if the player is holding a trinket (not including gulped). */
  PLAYER_HOLDING_TRINKET,

  /** Check if the player is holding the trinket X (X is TrinketType). */
  PLAYER_HAS_TRINKET_X,

  /** Check if the player is holding a pill. */
  PLAYER_HOLDING_PILL,

  /** Check if the player is holding the pill X (X is PillType). */
  PLAYER_HOLDING_PILL_X,

  /** Check if the player is holding a card. */
  PLAYER_HOLDING_CARD,

  /** Check if the player is holding the card X (X is CardType). */
  PLAYER_HOLDING_CARD_X,

  /** Check if the player has an active item. */
  PLAYER_HAS_ACTIVE_ITEM,

  /** Check if the player has the collectible X (X is CollectibleType). */
  PLAYER_HAS_COLLECTIBLE_X,

  /** Check if the player is in room X (X is RoomType). */
  PLAYER_IS_IN_ROOM_X,

  /** Check if the player is on floor X (X is levelStage). */
  PLAYER_IS_ON_FLOOR_X,

  /** Check if the player is on character X (X is CharacterType). */
  PLAYER_IS_CHARACTER_X,

  /** If player is on the left side of the room. */
  PLAYER_IS_ON_LEFT_SIDE_OF_ROOM,

  /** If the player is on exactly X health (X is a number constituting half a heart). */
  PLAYER_IS_ON_X_HEALTH,

  /** If player has X heart type (X is HeartType). */
  PLAYER_HAS_X_HEART_TYPE,

  /** If the world is in its inverted state. */
  WORLD_IS_INVERTED,

  /** If the world is X. (X is WorldVariant). */
  WORLD_IS_X,

  /** If the difficulty is X (X is Difficulty). */
  IS_DIFFICULTY_X,

  /** If there are enemies in the room (room isn't clear). */
  ROOM_HAS_ENEMIES,

  /** If the room has any pickups. */
  ROOM_HAS_PICKUPS,

  /** If the room has any obstacles. */
  ROOM_HAS_OBSTACLES,

  /** If the player is moving (velocity is not 0). */
  PLAYER_IS_MOVING,

  /** If the player has flight. */
  PLAYER_IS_FLYING,

  /** If the day is X (X is Day enum). */
  IS_DAY_X,

  /** If it's holiday X (X is Holiday enum). */
  IS_HOLIDAY,

  /** If the floor has a curse. */
  FLOOR_IS_CURSED,

  /** If the player only has hearts of X type (Where X is HeartType). */
  PLAYER_HAS_ONLY_X_HEARTS,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\DeletedColor.ts`:

```````ts
/** Colors that are commonly used in The Deleted mod. */
export const DeletedColor = {
  /** HAPPY99. */
  HAPPY_YELLOW: Color(1.0, 0.8, 0.0),
  HAPPY_YELLOW_DARKER: Color(0.8, 0.6, 0.0),
  HAPPY_YELLOW_DARKEST: Color(0.6, 0.4, 0.0),

  /** ILOVEYOU. */
  LOVE_PINK: Color(1.0, 0.48, 0.7),
  LOVE_PINK_DARKER: Color(0.8, 0.38, 0.6),
  LOVE_PINK_DARKEST: Color(0.6, 0.28, 0.5),

  /** MORRIS. */
  WORM_TURQUOISE: Color(0.0, 0.96, 0.7),
  WORM_TURQUOISE_DARKER: Color(0.0, 0.76, 0.5),
  WORM_TURQUOISE_DARKEST: Color(0.0, 0.56, 0.3),

  /** ZIPBOMBER. */
  ANGRY_RED: Color(0.86, 0.18, 0.18),

  /** HICURDISMOS. */
  WINDOWS_BLUE: Color(0.46, 0.53, 0.69),
  WINDOWS_BLUE_DARKER: Color(0.36, 0.43, 0.59),
  WINDOWS_BLUE_DARKEST: Color(0.26, 0.33, 0.49),
  WINDOWS_WHITE: Color(0.9, 0.9, 0.9),

  /** MYDOOM. */
  DEATH_BLACK: Color(0.5, 0.5, 0.5),
  DEATH_BLACK_DARKER: Color(0.4, 0.4, 0.4),
  DEATH_BLACK_DARKEST: Color(0.3, 0.3, 0.3),

  /** REVETON. */
  REVETON_RED: Color(0.99, 0.3, 0.3),
  REVETON_BLUE: Color(0.68, 0.68, 0.99),
} as const;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\EntityCategory.ts`:

```````ts
/** The categories non-Grid Entities belong to. */
export enum EntityCategory {
  FAMILIAR = 0,
  TEAR = 1,
  BOMB = 2,
  KNIFE = 3,
  LASER = 4,
  NPC = 5,
  PROJECTILE = 6,
  PICKUP = 7,
  PLAYER = 8,
  EFFECT = 9,
  SLOT = 10,
}

/**
 * The categories entities belong to, including grids. These entity categories have the same values
 * as the EntityCategory enum, however type casting may be necessary.
 */
export enum EntityCategoryWithGrid {
  FAMILIAR = 0,
  TEAR = 1,
  BOMB = 2,
  KNIFE = 3,
  LASER = 4,
  NPC = 5,
  PROJECTILE = 6,
  PICKUP = 7,
  PLAYER = 8,
  EFFECT = 9,
  SLOT = 10,
  GRID = 11,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\HUDQuandrant.ts`:

```````ts
/**
 * Quadrants represented in the HUD, so indicate which corner the UI will move towards when the HUD
 * Offset is changed / screen resolution changes.
 */
export enum HUDQuadrant {
  TOP_LEFT,
  TOP_RIGHT,
  BOTTOM_LEFT,
  BOTTOM_RIGHT,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\NPCFlag.ts`:

```````ts
/**
 * Custom NPC flags to modify the NPC's behavior or appearance. There are no non-Custom NPC flags,
 * instead 'EntityFlags' are used for general modification between NPCs and other entities. NPCFlag
 * may include some of these existing flags, which will guarantee that it will work on NPCs.
 */
export enum NPCFlag {
  /** Prevents an NPC from moving. It can still be damaged and attack the player. */
  BOLSTERED,

  /** Custom freeze an enemy, to stop them from moving or attacking. */
  FROZEN,

  /** Makes an NPC not be required to kill to clear a room. */
  NON_MANDATORY,

  /** Obstructs an enemies appearance by censoring them and things they spawn. */
  CENSORED,

  /** The NPC will explode after a random period of time. */
  UNSTABLE,

  /** Existing Flags. */

  /**
   * Existing fear status effect. This effect will be permanently applied until the NPC dies or the
   * player leaves the game.
   */
  FEAR,

  /**
   * Existing burn status effect. This effect will be permanently applied until the NPC dies or the
   * player leaves the game.
   */
  BURN,

  /**
   * Existing charmed status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  CHARMED,

  /**
   * Existing confused status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  CONFUSED,

  /**
   * Existing frozen status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  ICE_FREEZE,

  /**
   * Existing midas freeze status effect. This effect will be permanently applied until the NPC dies
   * or the player leaves the game.
   */
  MIDAS_FREEZE,

  /**
   * Existing poison status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  POISONED,

  /**
   * Existing shrink status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  SHRUNKEN,

  /**
   * Existing slowing status effect. This effect will be permanently applied until the NPC dies or
   * the player leaves the game.
   */
  SLOWING,

  /** Friendly ball NPC that persists between rooms and floors. */
  FRIENDLY,

  /** Persists between rooms and floors. TODO: Support leave/continue. */
  PERSISTENT,

  // TODO:

  // STONE_SHOOTER - NPC will be a stone shooter, shooting out NPCs of the same type which disappear
  // after a few seconds and have reduced HitPoints. The stone shooter is unable to move or be
  // attacked.

  // PERMANENT - NPC will stay in one room until killed.

  // GLASS - Similar to an iced enemy, but works with bosses.

  // STONE - NPC will behave similar to a stoney, unable to hurt the player but also unable to be
  // hurt by the player.

  // SLIPPERY - NPC will slide around the room, as if they were on ice.

  // HONEY - NPC will have reduced momentum, as if they were on honey.

  // HIBERNATING - NPC will be permanent and non-mandatory, and will be 'asleep', unable to move or
  // attack. They will be woken up if an enemy or player gets too close, removing their
  // non-mandatory status.

  // NIGHTMARE - Upon being touched by this enemy, the player will be teleported to a nightmare.

  // OVERCLOCKED - Sped up.

  // INVISIBLE - Invisible.
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\PickupStage.ts`:

```````ts
/** Set of callbacks a picked up collectible can be in. */
export enum PickupStage {
  PRE_GET_PEDESTAL,
  PRE_GET_PEDESTAL_ZAZZ,
  PRE_ITEM_PICKUP,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\PickupType.ts`:

```````ts
/**
 * An enum of categories a Pickup can fall into. This is used over 'PickupVariant' in some cases as
 * PickupVariant has multiple values for the same PickupType (e.g Chests).
 */
export enum PickupType {
  HEART,
  COIN,
  KEY,
  BOMB,
  POOP,
  CHEST,
  SACK,
  PILL,
  CARD,
  SOUL,
  RUNE,
  BATTERY,
  COLLECTIBLE,
  TRINKET,
  SHOP_ITEM,
  MISCELLANEOUS,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\PlayerTypeCustom.ts`:

```````ts
/** TODO: Change back to Deleted. */

export const PlayerTypeCustom = {
  DELETED_HAPPY99: Isaac.GetPlayerTypeByName("Deleted"),
  DELETED_ILOVEYOU: Isaac.GetPlayerTypeByName("Deleted_ILOVEYOU"),
  DELETED_MORRIS: Isaac.GetPlayerTypeByName("Deleted_MORRIS"),
  DELETED_ZIPBOMBER: Isaac.GetPlayerTypeByName("Deleted_ZIPBOMBER"),
  DELETED_CRYPTOLOCKER: Isaac.GetPlayerTypeByName("Deleted_CRYPTOLOCKER"),
  DELETED_SPYWIPER: Isaac.GetPlayerTypeByName("Deleted_SPYWIPER"),
  DELETED_JERUSALEM: Isaac.GetPlayerTypeByName("Deleted_JERUSALEM"),
  DELETED_HICURDISMOS: Isaac.GetPlayerTypeByName("Deleted_HICURDISMOS"),
  DELETED_VCS: Isaac.GetPlayerTypeByName("Deleted_VCS"),
  DELETED_MYDOOM: Isaac.GetPlayerTypeByName("Deleted_MYDOOM"),
  DELETED_MEMZ: Isaac.GetPlayerTypeByName("Deleted_MEMZ"),
  DELETED_REVETON: Isaac.GetPlayerTypeByName("Deleted_REVETON"),
  T_DELETED_SOPHOS: Isaac.GetPlayerTypeByName("Deleted", true),
  T_DELETED_BATTLEYE: Isaac.GetPlayerTypeByName("Deleted_BATTLEYE", true),
} as const;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\SoundEffectCustom.ts`:

```````ts
export const SoundEffectCustom = {
  BITFLIP_IN: Isaac.GetSoundIdByName("thedeleted_Glitch In"),
  BITFLIP_OUT: Isaac.GetSoundIdByName("thedeleted_Glitch Out"),
  ROLL_DICE: Isaac.GetSoundIdByName("thedeleted_diceroll"),
  TRASH: Isaac.GetSoundIdByName("thedeleted_Trash"),
  PC_LOG_IN: Isaac.GetSoundIdByName("thedeleted_pc_login"),
  KISS: Isaac.GetSoundIdByName("thedeleted_kiss"),
  ILOVEYOU_GRUNT: Isaac.GetSoundIdByName("thedeleted_iloveyou_hurt"),

  /** Voiceover */
  VO_ANIMAL: Isaac.GetSoundIdByName("thedeleted_voiceover_Animal"),
  VO_ILOVEYOU: Isaac.GetSoundIdByName("thedeleted_voiceover_ILoveYou"),
  VO_SPYWIPER: Isaac.GetSoundIdByName("thedeleted_voiceover_Spywiper"),
  VO_REVETON: Isaac.GetSoundIdByName("thedeleted_voiceover_Reveton"),
  VO_MYDOOM: Isaac.GetSoundIdByName("thedeleted_voiceover_MyDoom"),
  VO_VCS: Isaac.GetSoundIdByName("thedeleted_voiceover_VCS"),
  VO_ZIPBOMBER: Isaac.GetSoundIdByName("thedeleted_voiceover_ZipBomber"),
  VO_MYLIFE: Isaac.GetSoundIdByName("thedeleted_voiceover_MyLife"),
  VO_MORRIS: Isaac.GetSoundIdByName("thedeleted_voiceover_Morris"),
  VO_MEMZ: Isaac.GetSoundIdByName("thedeleted_voiceover_Memz"),
  VO_MADMAN: Isaac.GetSoundIdByName("thedeleted_voiceover_MadMan"),
  VO_JERUSALEM: Isaac.GetSoundIdByName("thedeleted_voiceover_Jerusalem"),
  VO_HICURDISMOS: Isaac.GetSoundIdByName("thedeleted_voiceover_Hicurdismos"),
  VO_HAPPY99: Isaac.GetSoundIdByName("thedeleted_voiceover_Happy99"),
  VO_DREAMWORLD: Isaac.GetSoundIdByName("thedeleted_voiceover_Dreamworld"),
  VO_DOZER: Isaac.GetSoundIdByName("thedeleted_voiceover_Dozer"),
  VO_CRYPTOLOCKER: Isaac.GetSoundIdByName("thedeleted_voiceover_CryptoLocker"),
  VO_CODERED: Isaac.GetSoundIdByName("thedeleted_voiceover_CodeRed"),
  VO_YOUAREANIDIOT: Isaac.GetSoundIdByName(
    "thedeleted_voiceover_YouAreAnIdiot",
  ),
  VO_BAGLE1: Isaac.GetSoundIdByName("thedeleted_voiceover_Bagle1"),
  VO_BAGLE2: Isaac.GetSoundIdByName("thedeleted_voiceover_Bagle2"),
  VO_CREEPER: Isaac.GetSoundIdByName("thedeleted_voiceover_Creeper"),
} as const;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\general\TemporaryEffectType.ts`:

```````ts
/** Dictates how long various effects affect the player or other beings. */
export enum TemporaryEffectType {
  /** Lasts until you exit the room. */
  ROOM,
  /** Lasts for the level. */
  LEVEL,
  /** Lasts until you are hit. */
  ON_HIT,
  /** Lasts forever. */
  PERMANENT,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\modes\Mode.ts`:

```````ts
/** Both Normal-Deleted and Tainted-Deleted's modes. */
export enum Mode {
  // Deleted.
  HAPPY99,
  ILOVEYOU,
  MORRIS,
  ZIPBOMBER,
  CRYPTOLOCKER,
  SPYWIPER,
  JERUSALEM,
  HICURDISMOS,
  VCS,
  MEMZ,
  MYDOOM,
  REVETON,
  // T. Deleted.
  SOPHOS,
  BATTLEYE,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\pc\PCAnimation.ts`:

```````ts
/** Animations that the PC can play. */
export enum PCAnimation {
  IDLE_OFF = "Idle",
  IDLE_ON = "IdleOn",
  INITIATE = "Initiate",
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\pc\PCStatus.ts`:

```````ts
/** Tracks state of PC in starting room. */
export enum PCState {
  /** Player/s have left starting room, rendering it unusable, or before the PC spawns in. */
  OFFLINE,

  /** PC is online, and there may or may not be an active user. */
  ACCOUNT,

  OTHER,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\settings\EIDObjectDisplaySetting.ts`:

```````ts
/**
 * The method of displaying 'things' (collectibles, trinkets, monsters, etc) in an External Item
 * Description. Note not all things may have icons, so they will resort to text.
 */
export enum EIDObjectDisplaySetting {
  TEXT_ONLY,
  TEXT_AND_ICON,
  ICON_ONLY,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\SlotCustom.ts`:

```````ts
export const SlotCustom = {
  SPAWN_PC: Isaac.GetEntityVariantByName("Deleted Computer"),
} as const;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\enums\worlds\Worlds.ts`:

```````ts
export enum World {
  /* Health is money in this world, getting hit drops coins that rapidly disappear instead of
   * damaging you. A few other Sonic tricks as well. */
  GRASSY_HILLS_ZONE,

  /* Pedestals are replaced with 3 - 4 pedestals of lower quality. Pickups are also replaced with
  multiple lower quality pickups. */
  SCRAPYARD,
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\compatibility\EID\EIDInit.ts`:

```````ts
import { getEnumValues, KColorDefault } from "isaacscript-common";
import {
  BITFLIP_DESCRIPTION,
  BITFLIP_PINK_DESCRIPTION,
  D14_DESCRIPTION,
  ZAZZ_DESCRIPTION,
} from "../../../constants/mod/itemConstants";
import { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import { CollectibleTypeCustom } from "../../../enums/general/CollectibleTypeCustom";
import { getKColorFromEIDColorShortcut } from "../../../maps/compatibility/EIDColorMap";

/** Initialize EID data. */
export function initEID(): void {
  if (EID === undefined) {
    return;
  }
  initEIDColors(EID);
  initEIDItems(EID);
}

function initEIDItems(EID: EIDInterface) {
  EID.addCollectible(CollectibleTypeCustom.BITFLIP, BITFLIP_DESCRIPTION);
  EID.addCollectible(
    CollectibleTypeCustom.BITFLIP_PINK,
    BITFLIP_PINK_DESCRIPTION,
  );
  EID.addCollectible(CollectibleTypeCustom.D14, D14_DESCRIPTION);
  EID.addCollectible(CollectibleTypeCustom.ZAZZ, ZAZZ_DESCRIPTION);
}

function initEIDColors(EID: EIDInterface) {
  getEnumValues(EIDColorShortcut).forEach((shortcut) => {
    const KColor = getKColorFromEIDColorShortcut(shortcut);
    if (typeof KColor === "function") {
      EID.addColor(shortcut, KColorDefault, KColor);
    } else {
      EID.addColor(shortcut, KColor);
    }
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\compatibility\ITEM_DISPLAY\ItemDisplayLibrary.d.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";

declare global {
  const CCO: CCOInterface;

  interface CCOInterface {
    ItemDisplay: {
      API: ItemDisplayLibraryInterface;
    };
  }

  interface ItemDisplayLibraryInterface {
    queueItemDisplay(
      this: void,
      player: EntityPlayer,
      item: CollectibleType,
    ): void;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\compatibility\ITEM_DISPLAY\ItemDisplayLibrary.lua`:

```````lua
local ItemDisplay_libVersion = 1.1
CCO = CCO or {}

if CCO.ItemDisplay then
	if not CCO.ItemDisplay.VERSION
	or CCO.ItemDisplay.VERSION < ItemDisplay_libVersion
	then
		Isaac.DebugString("Item Display Library: [WARNING] A mod (or more) above this message has an outdated version of Item Display Library, make sure to check which mod(s) do and notify their developer(s) to avoid errors.")
		Isaac.DebugString("Item Display Library: [WARNING] Most up to date version: [" .. tostring(ItemDisplay_libVersion) .. "] (mods with an older version than this should be disabled or updated)")
		Isaac.DebugString("Item Display Library: [WARNING] Current loaded version: [" .. tostring(CCO.ItemDisplay.VERSION or "UNKNOWN") .. "]")
		print("Item Display Library: [WARNING] Outdated Item Display Library version, check the log.txt file for more information.")
		print("Item Display Library: [WARNING] C:/Users/[username]/Documents/My Games/Binding of Isaac Repentance/log.txt")
	end

	return CCO.ItemDisplay.API
end

--= IMPORTANT =--
-- In order for the library to work, you're required to copy
-- the [ gfx/item display lib ] folder into your project,
-- under the same root, to have the necessary assets.
CCO.ItemDisplay = RegisterMod("Item Display Library", 1)
CCO.ItemDisplay.VERSION = ItemDisplay_libVersion
local game = Game()
local sound = SFXManager()
local zeroV = Vector.Zero
local itemConfig = Isaac.GetItemConfig()
local randomizer = RNG()
randomizer:SetSeed(Random() + 1, 35)

local script = {}

local ITEM_DISPLAY_DURATION = 90
local ITEM_OFFSET = Vector(24, -24)
local SEC_OFFSET = Vector(0, -1)
local OUTLINE_SCALE = Vector(1.125, 1.125)
local NORMAL_COLOR = Color(1, 1, 1, 1)
local WHITE_COLOR = Color(1, 1, 1, 1, 1, 1, 1)
local MAX_TMTRAINER_VARIANTS = 24

local SETTINGS = {
	SPEED_MULTI = 1, -- increments of 0.25 | min 0.5 / max 2.0
	SCALE = 1, -- increments of 0.25 | min 0.5 / max 1.5
	MAX_DISPLAY = 2, -- min 1 / max 5
	PLAY_SOUND = true,
}

local function copyTable(sourceTab)
	local targetTab = {}
	sourceTab = sourceTab or {}

	if type(sourceTab) ~= "table" then
		error("[ERROR] - cucco_helper.copyTable - invalid argument #1, table expected, got " .. type(sourceTab), 2)
	end

	for i, v in pairs(sourceTab) do
		if type(v) == "table" then
			targetTab[i] = copyTable(sourceTab[i])
		else
			targetTab[i] = sourceTab[i]
		end
	end

	return targetTab
end
local function mergeTables(tabPriority, tab2)
	local targetTab = {}
	tabPriority = tabPriority or {}
	tab2 = tab2 or {}

	if type(tabPriority) ~= "table" then
		error("[ERROR] - cucco_helper.mergeTables - invalid argument #1, table expected, got " .. type(tabPriority), 2)
	elseif type(tab2) ~= "table" then
		error("[ERROR] - cucco_helper.mergeTables - invalid argument #2, table expected, got " .. type(tabPriority), 2)
	end

	for i, v in pairs(tabPriority) do
		if type(v) == "table" then
			targetTab[i] = mergeTables(tabPriority[i], tab2[i])
		else
			targetTab[i] = tabPriority[i] ~= nil and tabPriority[i] or tab2[i]
		end
	end

	for i, v in pairs(tab2) do
		if type(v) == "table" then
			targetTab[i] = mergeTables(tabPriority[i], tab2[i])
		else
			targetTab[i] = tabPriority[i] ~= nil and tabPriority[i] or tab2[i]
		end
	end

	return targetTab
end

---------------
----= API =----
---------------

-- Use these specific tables to handle dssmenu settings for this library in your mod.
-- See the Job Modpack dss_menu.lua for reference.
script.DSS_MENU = {
	MAIN = {
		str = 'item display lib',
		dest = 'DISPLAY_LIB_SETTINGS',
		tooltip = {strset = {'settings for', 'the item', 'display', 'library'}},
	},
	MAIN_SUB = {str = 'item_display_library.lua settings', fsize = 1, clr = 3, nosel = true},
	DISPLAY_LIB_SETTINGS = {
        title = 'Item Display Library',
		generate = function()
			local player = Isaac.GetPlayer()
			for i = 1, SETTINGS.MAX_DISPLAY * 3 do
				script.queueItemDisplay(player, 1)
			end
		end,
        buttons = {
			{
				str = 'Scroll Speed',
				choices = {'50%', '75%', '100%', '125%', '150%', '175%', '200%'},
				variant = "DISPLAY_LIB_SPEED_MULTI",
				setting = 3,
				load = function()
					return (SETTINGS.SPEED_MULTI - 0.25) / 0.25
				end,
				store = function(var)
					SETTINGS.SPEED_MULTI = (var * 0.25) + 0.25
				end,
				changefunc = function(button)
					SETTINGS.SPEED_MULTI = (button.setting * 0.25) + 0.25
				end,
				tooltip = {strset = {'the speed at', 'which items', 'scroll', 'upwards'}},
			},
			{
				str = 'Item Scale',
				choices = {'50%', '75%', '100%', '125%', '150%'},
				variant = "DISPLAY_LIB_SCALE",
				setting = 3,
				load = function()
					return (SETTINGS.SCALE - 0.25) / 0.25
				end,
				store = function(var)
					SETTINGS.SCALE = (var * 0.25) + 0.25
				end,
				changefunc = function(button)
					SETTINGS.SCALE = (button.setting * 0.25) + 0.25
				end,
				tooltip = {strset = {'the size', 'of displayed', 'items'}},
			},
			{
                str = 'Visible Item Num',
                increment = 1, max = 5,
                slider = true,
                variable = 'MAX_DISPLAY',
                setting = 2,
                load = function()
                    return SETTINGS.MAX_DISPLAY
                end,
                store = function(var)
                    SETTINGS.MAX_DISPLAY = var
                end,
				changefunc = function(button)
					SETTINGS.MAX_DISPLAY = button.setting
				end,
                tooltip = {strset = {'the amount', 'of items', 'that can be', 'displayed', 'at once'}},
            },
			{
				str = 'Display Sound',
				choices = {'enabled', 'disabled'},
				variant = "DISPLAY_LIB_PLAY_SOUND",
				setting = 1,
				load = function()
					return SETTINGS.PLAY_SOUND and 1 or 2
				end,
				store = function(var)
					SETTINGS.PLAY_SOUND = var == 1
				end,
				changefunc = function(button)
					SETTINGS.PLAY_SOUND = button.setting == 1
				end,
				tooltip = {strset = {'whether', 'items should', 'play a', 'sound when', 'displayed'}},
			},
        },
        tooltip = menuOpenToolTip
	},
}

--[[ Call this function when saving your mod's data.

local json = require("json")
local itemDisplayLib = require("item_display_library")

local SAVE_STATE = {}
local function saveData()
	SAVE_STATE.ITEM_DISPLAY_LIBRARY = itemDisplayLib.getSaveData

	mod:SaveData(json.encode(SAVE_STATE))
end

]]
script.getSaveData = function()
	return copyTable(SETTINGS)
end

--[[ Call this function when loading your mod's data.

local json = require("json")
local itemDisplayLib = require("item_display_library")

local SAVE_STATE = {}
local function loadData()
	SAVE_STATE = json.decode(mod:LoadData())

	itemDisplayLib.loadData(SAVE_STATE.ITEM_DISPLAY_LIBRARY)
end

]]
script.loadData = function(tab)
	SETTINGS = mergeTables(tab, SETTINGS)
end

-----------------
----= LOGIC =----
-----------------

local playerData = {}

local function getData(dataTable, entity)
	local index = tostring(entity.InitSeed)

	if dataTable[index] == nil then
		dataTable[index] = {}
	end

	return dataTable[index]
end

local function getPlayerData(entity)
	return getData(playerData, entity)
end

function randomfloat(x, y, rng)
	if not x
	and not y
	then
		rng = rng or randomizer
		return rng:RandomFloat()
	end
    if not y then
        y = x
        x = 0
    end
	x = x * 1000
	y = y * 1000
   	rng = rng or randomizer
    return math.floor((rng:RandomInt(y - x + 1)) + x) / 1000
end

local function createSprite(gfxroot, anmtoplay, anmframe, newspr, layer, returnobject)
	local newSprite = Sprite()
	newSprite:Load(tostring(gfxroot), true)

	if not anmframe then
		newSprite:Play(anmtoplay and tostring(anmtoplay) or newSprite:GetDefaultAnimationName(), true)
	else
		newSprite:SetFrame(anmtoplay and tostring(anmtoplay) or newSprite:GetDefaultAnimationName(), anmframe)
	end

	if newspr then
		if layer == true then
			for i = 0, newSprite:GetLayerCount() - 1 do
				newSprite:ReplaceSpritesheet(i, newspr)
			end
			newSprite:LoadGraphics()
		else
			newSprite:ReplaceSpritesheet(layer or 0, newspr)
			newSprite:LoadGraphics()
		end
	end

	return returnobject and {Sprite = sprite, Anm2Root = gfxroot, SprRoot = newspr, AnmName = anmtoplay, AnmFrame = anmframe or 0} or newSprite
end

local function isPaused()
	return game:IsPaused()
		or (ModConfigMenu and ModConfigMenu.IsVisible)
		or (DeadSeaScrollsMenu and DeadSeaScrollsMenu.OpenedMenu)
end

function script.queueItemDisplay(player, item)
	player = player or Isaac.GetPlayer()

	if not item
	or type(item) ~= "number"
	or item % 1 ~= 0
	then
		error("[ERROR] - ItemDisplay.queueItemDisplay - CollectibleType expected, got " .. type(item), 2)
	end

	local data = getPlayerData(player)

	data._lostItemQueue = data._lostItemQueue or {}

	table.insert(data._lostItemQueue, {
		sprite = itemConfig:GetCollectible(item).GfxFileName,
		duration = ITEM_DISPLAY_DURATION,
	})
end

local function renderLostItem(player, layer)
	layer = layer or 1
	local data = getPlayerData(player)
	local item = data._lostItemQueue[layer]
	local sprite = data["_lostItemSpr" .. layer]

	if not item then
		return
	end

	if not sprite then
		data["_lostItemSpr" .. layer] = createSprite("gfx/item display lib/32x32.anm2", "Idle")
		sprite = data["_lostItemSpr" .. layer]
	end

	if not item.init then
		local targetSprite = item.sprite

		if targetSprite == "" then
			local randomVariant = random(MAX_TMTRAINER_VARIANTS)
			targetSprite = "gfx/item display lib/tmtrainer/variant" .. tostring(randomVariant) .. ".png"
		end

		sprite.Offset = ITEM_OFFSET + (SEC_OFFSET * math.abs(item.duration - ITEM_DISPLAY_DURATION))
		sprite:ReplaceSpritesheet(0, targetSprite)
		sprite:LoadGraphics()

		item.init = true
	end

	local clr = WHITE_COLOR
	sprite.Scale = OUTLINE_SCALE * SETTINGS.SCALE
	sprite.Color = Color(clr.R, clr.G, clr.B, math.min(1, item.duration / 80), clr.RO, clr.GO, clr.BO)
	sprite:Render(Isaac.WorldToScreen(player.Position), zeroV, zeroV)
	clr = NORMAL_COLOR
	sprite.Scale = Vector.One * SETTINGS.SCALE
	sprite.Color = Color(clr.R, clr.G, clr.B, math.min(1, item.duration / 50), clr.RO, clr.GO, clr.BO)
	sprite:Render(Isaac.WorldToScreen(player.Position), zeroV, zeroV)

	if item.duration <= 0 then
		return true
	elseif not isPaused() then
		if game:GetRoom():HasWater() then
			item.duration = item.duration - (0.5 * SETTINGS.SPEED_MULTI)
			sprite.Offset = sprite.Offset + ((SEC_OFFSET / 2) * SETTINGS.SPEED_MULTI)
		else
			item.duration = item.duration - (1 * SETTINGS.SPEED_MULTI)
			sprite.Offset = sprite.Offset + (SEC_OFFSET * SETTINGS.SPEED_MULTI)
		end
	end
end

local function postPlayerRender(_, player)
	local data = getPlayerData(player)

	if not data._lostItemQueue
	or not data._lostItemQueue[1]
	then
		data._lostItemQueue = nil
		return
	end

	local index = 1
	local item = data._lostItemQueue[index]
	local spacerDelay = ITEM_DISPLAY_DURATION / SETTINGS.MAX_DISPLAY
	local shouldDequeue = false

	while item do
		if SETTINGS.PLAY_SOUND
		and item.duration == ITEM_DISPLAY_DURATION
		and not isPaused()
		then
			sound:Play(SoundEffect.SOUND_MENU_RIP, 1.5, 0, false, randomfloat(0.85, 1.3))
		end

		local inverseDuration = math.abs(item.duration - ITEM_DISPLAY_DURATION)
		local finished = renderLostItem(player, index)
		shouldDequeue = shouldDequeue or finished

		if inverseDuration > spacerDelay then
			index = index + 1
			item = data._lostItemQueue[index]
		else
			break
		end
	end

	if not shouldDequeue then
		return
	end

	table.remove(data._lostItemQueue, 1)

	for _, item in ipairs(data._lostItemQueue) do
		if not item.init then
			break
		end

		item.init = nil
	end
end
CCO.ItemDisplay:AddCallback(ModCallbacks.MC_POST_PLAYER_RENDER, postPlayerRender)

local function postNewLevel()
	playerData = {}
end
CCO.ItemDisplay:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, postNewLevel)

CCO.ItemDisplay.API = copyTable(script)

Isaac.DebugString("Item Display Library: Loaded Successfully! Version: " .. CCO.ItemDisplay.VERSION)
print("Item Display Library: Loaded Successfully! Version: " .. CCO.ItemDisplay.VERSION)

return script

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\console\testing.ts`:

```````ts
import {
  CollectibleType,
  EntityType,
  GridEntityType,
} from "isaac-typescript-definitions";
import {
  getEnumValues,
  getCollectibleName,
  getRandomArrayElement,
  getClosestEntityTo,
  getEntities,
  removeGridEntities,
  spawnGridEntity,
} from "isaacscript-common";
import {
  freezeAllNPCsInRoom,
  unfreezeAllNPCsInRoom,
} from "../../classes/facets/entityModifiers.ts/NPCModifiers/FreezeNPCFacet";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { PlayerTypeCustom } from "../../enums/general/PlayerTypeCustom";
import { getRandomCollectibleType } from "../../helper/collectibleHelper";
import { fprint } from "../../helper/printHelper";
import { legibleString } from "../../helper/stringHelper";
import { mod } from "../../mod";
import { spawnNewInvertedCollectible } from "../../helper/deletedSpecific/inversion/spawnInverted";
import { InvertedActiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { getQuickAccessiblePosition } from "../../helper/positionHelper";
import { InvertedPassiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import {
  getAllEmptyGridIndexes,
  positionToClampedGridIndex,
} from "../../helper/gridEntityHelper/gridEntityHelper";
import { OnRoomAction } from "../../classes/corruption/actions/OnRoomAction";
import { SpawnHybridNPCResponse } from "../../classes/corruption/responses/SpawnHybridNPCResponse";
import type { NPCAttribute } from "../../interfaces/general/NPCAttribute";
import { OnPurchaseAction } from "../../classes/corruption/actions/OnPurchaseAction";
import { SpawnNPCResponse } from "../../classes/corruption/responses/SpawnNPCResponse";
import { OnRoomClearAction } from "../../classes/corruption/actions/OnRoomClearAction";

/** Test player */
const player = () => Isaac.GetPlayer(0);
const player2 = () => Isaac.GetPlayer(1);

/** Add all the testing commands. */
export function addTestingCommands(): void {
  mod.addConsoleCommand("del1", () => {
    testingFunction1();
  });
  mod.addConsoleCommand("del2", () => {
    testingFunction2();
  });
  mod.addConsoleCommand("del3", () => {
    testingFunction3();
  });
  mod.addConsoleCommand("del4", () => {
    testingFunction4();
  });
  mod.addConsoleCommand("del5", () => {
    testingFunction5();
  });
  mod.addConsoleCommand("pindex", () => {
    getClosestPickupIndex();
  });
  mod.addConsoleCommand("pause", () => {
    freezeAllNPCsInRoom();
  });
  mod.addConsoleCommand("unpause", () => {
    unfreezeAllNPCsInRoom();
  });
}

const responseToAdd = new SpawnHybridNPCResponse().construct({
  boss: false,
  flying: true,
} as NPCAttribute);
const actionToAdd = new OnRoomAction().setResponse(responseToAdd);

const actionSetToAdd = new InvertedActiveActionSet().addEffects(responseToAdd);

/** Test stuff as the developer with command 'del'. */
export function testingFunction1(): void {
  fprint("Testing function 1");
  spawnNewInvertedCollectible(
    getQuickAccessiblePosition(),
    new InvertedPassiveActionSet().addEffects(
      new OnRoomClearAction().setResponse(new SpawnNPCResponse()),
    ),
  );
}

/** Test stuff as the developer with command 'eted'. */
export function testingFunction2(): void {
  const emptyGridIndices = getAllEmptyGridIndexes();
  const randomEmptyGridIndex = getRandomArrayElement(
    emptyGridIndices,
    undefined,
  );

  // Spawn rock at random empty grid index.
  const gridEntity = spawnGridEntity(GridEntityType.ROCK, randomEmptyGridIndex);

  if (gridEntity === undefined) {
    return;
  }

  // Remove rock.
  removeGridEntities([gridEntity], false);

  // Function.
  const func = () =>
    spawnGridEntity(
      GridEntityType.LOCK,
      positionToClampedGridIndex(gridEntity.Position),
      false,
    );

  // Spawn a lock at same position.
  mod.runInNGameFrames(func, 1);
}

/** Test stuff as the developer with command 'eted'. */
export function testingFunction3(): void {
  mod.runInNGameFrames(testingFunction2, 30);
}

/** Test stuff as the developer with command 'eted'. */
export function testingFunction4(): void {
  const item1 = getRandomCollectibleType() ?? CollectibleTypeCustom.BITFLIP;
  const item2 = getRandomCollectibleType() ?? CollectibleType.ABADDON;
  fprint(
    `Combining ${getCollectibleName(item1)} and ${getCollectibleName(item2)}:`,
  );
  fprint(
    `-----> ${legibleString(
      combineWords(
        getCollectibleName(item1),
        getCollectibleName(item2),
      ).toLowerCase(),
    )}`,
  );
}

/** Test stuff as the developer with command 'eted'. */
export function testingFunction5(): void {
  const customPlayerTypes = getEnumValues(PlayerTypeCustom);
  const randomPlayerType = getRandomArrayElement(customPlayerTypes, undefined);
  player().ChangePlayerType(randomPlayerType);
}

/** Test stuff as the developer with command 'eted'. */
function getClosestPickupIndex(): number | undefined {
  const closestEntity = getClosestEntityTo(
    player(),
    getEntities(EntityType.PICKUP),
  );
  if (closestEntity === undefined) {
    fprint("No entity found");
    return;
  }
  const pickupIndex = mod.getPickupIndex(closestEntity as EntityPickup);
  return pickupIndex;
}

function combineWords(word1: string, word2: string): string {
  // Split words into arrays of characters
  const chars1 = word1.split("");
  const chars2 = word2.split("");

  // Find vowel and consonant indices in each word
  const vowels1 = chars1.reduce<number[]>((indices, char, index) => {
    if ("aeiouAEIOU".includes(char)) {
      indices.push(index);
    }
    return indices;
  }, []);
  const consonants1 = chars1.reduce<number[]>((indices, char, index) => {
    if (!"aeiouAEIOU".includes(char)) {
      indices.push(index);
    }
    return indices;
  }, []);
  const vowels2 = chars2.reduce<number[]>((indices, char, index) => {
    if ("aeiouAEIOU".includes(char)) {
      indices.push(index);
    }
    return indices;
  }, []);
  const consonants2 = chars2.reduce<number[]>((indices, char, index) => {
    if (!"aeiouAEIOU".includes(char)) {
      indices.push(index);
    }
    return indices;
  }, []);

  // Choose random indices to split the words.
  let splitIndex1 = Math.floor(Math.random() * chars1.length);
  let splitIndex2 = Math.floor(Math.random() * chars2.length);
  let joinedChar1 = chars1[splitIndex1];
  let joinedChar2 = chars2[splitIndex2];

  // Ensure that the resulting word doesn't have more than three consonants in a row.
  let combinedWord: string | undefined;

  let iterations = 0;
  while (
    combinedWord === undefined ||
    consonantsInARow(combinedWord) > 2 ||
    combinedWord.length < Math.ceil((chars1.length + chars2.length) / 2)
  ) {
    iterations++;
    if (iterations > 100_000 && combinedWord !== undefined) {
      break;
    }

    splitIndex1 = Math.floor(Math.random() * chars1.length);
    joinedChar1 = chars1[splitIndex1];
    splitIndex2 = Math.floor(Math.random() * chars2.length);
    joinedChar2 = chars2[splitIndex2];

    // Combine words at chosen indices.
    combinedWord =
      word1.slice(0, Math.max(0, splitIndex1)) +
      word2.slice(Math.max(0, splitIndex2));
  }

  return combinedWord;
}

// Helper function to count the number of consonants in a row in a given string.
function consonantsInARow(str: string): number {
  let maxConsonantsInARow = 0;
  let currentConsonantsInARow = 0;

  for (const element of str) {
    if ("aeiouAEIOU".includes(element)) {
      currentConsonantsInARow = 0;
    } else {
      currentConsonantsInARow++;
      maxConsonantsInARow = Math.max(
        maxConsonantsInARow,
        currentConsonantsInARow,
      );
    }
  }
  return maxConsonantsInARow;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\corruptionGeneration.ts`:

```````ts
/** Responsible for creating populated InvertedActionSets, Actions and Responses. */

import type { PlayerIndex } from "isaacscript-common";
import {
  DefaultMap,
  defaultMapGetPlayer,
  defaultMapSetPlayer,
} from "isaacscript-common";
import type { InvertedActiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { DEFAULT_INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE } from "../../constants/corruptionConstants";
import type { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import type { ActionSetBuilderInput } from "../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import { getInvertedItemActionSetBuilderFromReference } from "../../maps/builders/actionSetBuilderMap";
import { mod } from "../../mod";
import type { InvertedItemActionSetBuilder } from "../../types/general/Builder";

const v = {
  run: {
    actionSetBuilderReference: new DefaultMap<
      PlayerIndex,
      InvertedItemActionSetBuilderReference
    >(DEFAULT_INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE),
  },
};

export function corruptionGenerationInit(): void {
  mod.saveDataManager("corruptionGeneration", v);
}

/**
 * Set the players' ActionSetBuilderReference. This will be used when the game is inverted and an
 * inverted item is looking for an ActionSet.
 */
export function setPlayerInvertedItemActionSetBuilderReference(
  player: EntityPlayer,
  reference: InvertedItemActionSetBuilderReference,
): void {
  defaultMapSetPlayer(v.run.actionSetBuilderReference, player, reference);
}

/**
 * Gets the players' ActionSetBuilderReference. This will be used when the game is inverted and an
 * inverted item is looking for an ActionSet. You should probably use generateActionSetFromPlayer()
 * instead.
 */
function getPlayerInvertedItemActionSetBuilderReference(
  player: EntityPlayer,
): InvertedItemActionSetBuilderReference {
  return defaultMapGetPlayer(v.run.actionSetBuilderReference, player);
}

/** Generates an InvertedActiveActionSet from an InvertedItemActionSetBuilderReference. */
function generateInvertedItemActionSetFromReference(
  actionSetBuilder: InvertedItemActionSetBuilderReference,
  inputs?: ActionSetBuilderInput,
): InvertedActiveActionSet {
  return getInvertedItemActionSetBuilderFromReference(actionSetBuilder)(inputs);
}

/**
 * Generates an InvertedActiveActionSet depending on if the input is an
 * InvertedItemActionSetBuilderReference or InvertedItemActionSetBuilder.
 */
function generateInvertedItemActionSetFromReferenceOrBuilder(
  referenceOrBuilder:
    | InvertedItemActionSetBuilderReference
    | InvertedItemActionSetBuilder,
  inputs?: ActionSetBuilderInput,
): InvertedActiveActionSet {
  if (typeof referenceOrBuilder === "function") {
    return referenceOrBuilder(inputs);
  }
  return generateInvertedItemActionSetFromReference(referenceOrBuilder, inputs);
}

/**
 * Generates an ActionSet based on the players' ActionSetBuilderReference. Will always include the
 * player as an Input.
 */
export function generateInvertedItemActionSetFromPlayer(
  player: EntityPlayer,
  inputs: ActionSetBuilderInput = {},
): InvertedActiveActionSet {
  inputs.player ??= player;
  return generateInvertedItemActionSetFromReference(
    defaultMapGetPlayer(v.run.actionSetBuilderReference, player),
    inputs,
  );
}

/** Generates an ActionSet from the default ActionSetBuilderReference. */
export function generateDefaultInvertedItemActionSet(
  inputs?: ActionSetBuilderInput,
): InvertedActiveActionSet {
  return generateInvertedItemActionSetFromReference(
    DEFAULT_INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE,
    inputs,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\effects\activeItemTracker.ts`:

```````ts
/**
 * This feature keeps track active items on the floor and their charge status. Once an Inverted
 * Active item has been placed on the ground, it will be tracked by this feature.
 */

import type { PickupIndex } from "isaacscript-common";
import type { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { mod } from "../../../mod";

const v = {
  level: {
    activeItems: new Map<PickupIndex, number>(),
    invertedActiveItems: new Map<PickupIndex, InvertedActiveActionSet>(),
  },
};

export function activeItemTrackerInit(): void {
  mod.saveDataManager("activeItemTracker", v);
}

/** Get the charge of the tracked non-Inverted active item. */
export function getTrackedPedestalChargeFromPickupIndex(
  pickupIndex: PickupIndex,
): number | undefined {
  return v.level.activeItems.get(pickupIndex) ?? undefined;
}

/** Set the charge of the tracked non-Inverted active item. */
export function setTrackedPedestalChargeFromPickupIndex(
  pickupIndex: PickupIndex,
  charge: number,
): void {
  v.level.activeItems.set(pickupIndex, charge);
}

export function removeTrackedPedestalChargeFromPickupIndex(
  pickupIndex: PickupIndex,
): void {
  v.level.activeItems.delete(pickupIndex);
}

/** Get the charge of the tracked non-Inverted active item. */
export function getTrackedPedestalCharge(
  pedestal: EntityPickupCollectible,
): number | undefined {
  return v.level.activeItems.get(mod.getPickupIndex(pedestal)) ?? undefined;
}

/** Set the charge of the tracked non-Inverted active item. */
export function setTrackedPedestalCharge(
  pedestal: EntityPickupCollectible,
  charge: number,
): void {
  v.level.activeItems.set(mod.getPickupIndex(pedestal), charge);
}

export function removeTrackedPedestalInvertedActive(
  pedestal: EntityPickupCollectible,
): void {
  v.level.invertedActiveItems.delete(mod.getPickupIndex(pedestal));
}

/**
 * Track a Custom Active / Inverted Active that has been dropped onto a pedestal.
 *
 * @param pedestal The pedestal the item was dropped onto.
 * @param actionSet The InvertedActiveActionSet associated with the pedestal. If undefined, the
 *                  pedestal will be removed from the tracker.
 */
export function setTrackedPedestalInvertedActive(
  pedestal: EntityPickupCollectible,
  actionSet: InvertedActiveActionSet,
): void {
  v.level.invertedActiveItems.set(mod.getPickupIndex(pedestal), actionSet);
}

/**
 * Get the InvertedActiveActionSet associated with a pedestal, if it exists. This will still return
 * the action set if the pedestal is not inverted. Does not deepCopy.
 *
 * Note that 'getAndSetInvertedPedestalActionSet' should probably be used instead of this.
 */
export function getTrackedPedestalInvertedActive(
  pedestal: EntityPickupCollectible,
): InvertedActiveActionSet | undefined {
  return v.level.invertedActiveItems.get(mod.getPickupIndex(pedestal));
}

/**
 * Get the InvertedActiveActionSet associated with a pickup index, if it exists. This will still
 * return the action set if the pedestal is not inverted. Does not deepCopy.
 */
export function getTrackedPedestalInvertedActiveFromPickupIndex(
  pickupIndex: PickupIndex,
): InvertedActiveActionSet | undefined {
  return v.level.invertedActiveItems.get(pickupIndex);
}

/**
 * Get the tracked InvertedActiveActionSet associated with a pedestal, removing it if it exists.
 * This will still return the action set if the pedestal is not inverted. Does not deepCopy.
 */
export function getAndRemoveTrackedPedestalInvertedActive(
  pedestal: EntityPickupCollectible,
): InvertedActiveActionSet | undefined {
  const actionSet = getTrackedPedestalInvertedActive(pedestal);
  if (actionSet === undefined) {
    return undefined;
  }

  removeTrackedPedestalInvertedActive(pedestal);
  return actionSet;
}

/**
 * Get the tracked InvertedActiveActionSet associated with a pickup Index, removing it if it exists.
 * This will still return the action set if the pedestal is not inverted. Does not deepCopy.
 */
export function getAndRemoveTrackedPedestalInvertedActiveFromPickupIndex(
  pickupIndex: PickupIndex,
): InvertedActiveActionSet | undefined {
  const actionSet = v.level.invertedActiveItems.get(pickupIndex);
  if (actionSet === undefined) {
    return undefined;
  }

  v.level.invertedActiveItems.delete(pickupIndex);
  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\effects\callbacks\postZazzRemoved.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { addRemovedInvertedItemToTracker } from "../../inventory/removedInvertedItems";
import { removePlayerMostRecentInvertedPassive } from "../../../../helper/deletedSpecific/inventory/invertedInventoryHelper";

// PLAYER_COLLECTIBLE_REMOVED
export function invertedItemEffectsPostZazzPassiveCollectibleRemoved(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  /** Remove the Zazz item. */
  const collectibleTypeRemoved = removePlayerMostRecentInvertedPassive(
    player,
    collectibleType,
    false,
  );
  if (collectibleTypeRemoved === undefined) {
    return;
  }

  /** Track the item that was removed. */
  addRemovedInvertedItemToTracker(
    player,
    collectibleType,
    collectibleTypeRemoved,
  );
}

// PLAYER_COLLECTIBLE_REMOVED
export function invertedItemEffectsPostZazzActiveCollectibleRemoved(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  // removePlayerMostRecentInvertedActiveItem(player, false);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\effects\itemEffects.ts`:

```````ts
/**
 * Tracks ActionSets (and hence Actions) associated with Inverted CollectibleType. Inverted
 * collectibles of the same CollectibleType share the same ActionSet and will always have an
 * ActionSet.
 */

import type { CollectibleType } from "isaac-typescript-definitions";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { ActionSetType } from "../../../enums/corruption/actionSets/ActionSetType";
import { getGameInvertedItemActionSet } from "../../../helper/deletedSpecific/generation/corruptionGeneration";
import { fprint } from "../../../helper/printHelper";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import { mod } from "../../../mod";

const v = {
  run: {
    /**
     * ActionSets attached to collectibles which are on an inverted pedestal. Inverted collectibles
     * spawned with no ActionSets are automatically assigned an ActionSet by looking at the inverted
     * players. Inverted collectibles with empty ActionSets are not modified.
     *
     * Two inverted pedestals of the same CollectibleType will share the same ActionSet.
     */
    invertedItems: new Map<CollectibleType, InvertedItemActionSet>(),
  },
};

export function itemEffectsInit(): void {
  mod.saveDataManager("itemEffects", v);
}

/**
 * Get the ActionSet attached to the inverted collectibleType. If there is none, will generate a
 * fresh one with the provided inputs (if any). Does not deepCopy!
 */
export function getAndSetInvertedItemActionSet(
  collectibleType: CollectibleType,
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const invertedActionSet = v.run.invertedItems.get(collectibleType);
  if (invertedActionSet !== undefined) {
    return invertedActionSet;
  }

  fprint(
    `Inverted item action set not found, creating one for collectibleType: ${collectibleType}`,
  );
  inputs ??= {};
  inputs.collectible = collectibleType;
  const newInvertedActionSet = getGameInvertedItemActionSet(inputs);
  v.run.invertedItems.set(collectibleType, newInvertedActionSet);
  return newInvertedActionSet;
}

/**
 * Get the ActionSet attached to the inverted collectibleType (will return undefined if one doesn't
 * exist). If you need to always return an ActionSet, use getAndSetInvertedItemActionSet().
 */
export function getInvertedItemActionSet(
  collectibleType: CollectibleType,
): InvertedItemActionSet | undefined {
  return v.run.invertedItems.get(collectibleType);
}

/** Returns true if the Inverted Item is a passive item. */
export function isInvertedItemPassive(
  collectibleType: CollectibleType,
): boolean {
  const invertedItemActionSet = getAndSetInvertedItemActionSet(collectibleType);
  return (
    invertedItemActionSet.actionSetType === ActionSetType.INVERTED_PASSIVE_ITEM
  );
}

/** Returns true if the Inverted Item is an active item. */
export function isInvertedItemActive(
  collectibleType: CollectibleType,
): boolean {
  const invertedItemActionSet = getAndSetInvertedItemActionSet(collectibleType);
  return (
    invertedItemActionSet.actionSetType === ActionSetType.INVERTED_ACTIVE_ITEM
  );
}

/** Returns true if the Inverted CollectibleType is registered with an ActionSet. */
export function doesInvertedItemHaveActionSet(
  collectibleType: CollectibleType,
): boolean {
  return v.run.invertedItems.has(collectibleType);
}

/** Do not use. */

export function _setInvertedItemActionSet(
  collectible: CollectibleType,
  actionSet: InvertedItemActionSet,
): void {
  v.run.invertedItems.set(collectible, actionSet);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\effects\pickupEffects.ts`:

```````ts
import type { PickupIndex } from "isaacscript-common";
import type { NonInvertedPickupActionSet } from "../../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import { mod } from "../../../mod";

const v = {
  run: {
    /**
     * Non-inverted pickups with corrupted effects attached. Pickups do not spawn with default
     * ActionSets, and need to have them added manually through other means.
     *
     * These effects do not affect inverted pickups.
     */
    pickup: new Map<PickupIndex, NonInvertedPickupActionSet>(),
  },
};

export function pickupEffectsInit(): void {
  mod.saveDataManager("pickupEffects", v);
}

/**
 * Retrieves the non-inverted pickup ActionSet (which is unique per PickupIndex). This will still
 * work as intended if called on an inverted pickup.
 */
export function getNonInvertedPickupActionSet(
  pickup: EntityPickup,
): NonInvertedPickupActionSet | undefined {
  return v.run.pickup.get(mod.getPickupIndex(pickup));
}

/** Don't use this function. */

export function _setPickupIndexActionSet(
  pickupIndex: PickupIndex,
  actionSet: NonInvertedPickupActionSet,
): void {
  v.run.pickup.set(pickupIndex, actionSet);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\effects\playerEffects.ts`:

```````ts
import type { PlayerIndex } from "isaacscript-common";
import {
  DefaultMap,
  defaultMapGetPlayer,
  getPlayers,
  isActiveCollectible,
} from "isaacscript-common";
import type { Action } from "../../../classes/corruption/actions/Action";
import { isAction } from "../../../classes/corruption/actions/Action";
import type { Response } from "../../../classes/corruption/responses/Response";
import type { ActionType } from "../../../enums/corruption/actions/ActionType";
import { fprint } from "../../../helper/printHelper";
import type { TriggerData } from "../../../interfaces/corruption/actions/TriggerData";
import { mod } from "../../../mod";
import { _removeActionFromCorruptInventory } from "../inventory/passiveItemInventory";
import { _removeActionFromCustomActive } from "../inversion/customActives";

const playerActionsCreateMap = () => new Map<ActionType, Action[]>();

const v = {
  run: {
    /**
     * Actions stored on a player are categorized into Action arrays separated by their ActionType.
     * This is to make it less resource intensive to trigger all actions of a specific type at once
     * (as that is the purpose of actions, to trigger at a specific point or game event).
     */
    playerActions: new DefaultMap<PlayerIndex, Map<ActionType, Action[]>>(
      playerActionsCreateMap,
    ),

    /**
     * Temporary Action ID - For Actions added to the tracker that are independent of ActionSets and
     * are permanent, they need a unique ID so they can be retrieved for removal.
     */
    temporaryActionID: 0,
  },
};

/**
 * Actions are saved to disk. However, to prevent redundancy, Actions which belong to an ActionSet
 * that belongs to an item are wiped from disk upon exiting the game. They are re-added every time
 * the game starts up again. This allows us easier management of the players inverted items, while
 * also allowing us to save individual effects here for increased performance.
 *
 * Currently temporary actions are removed in the PRE_GAME_EXIT callback, but note that we're saving
 * data on the last POST_ENTITY_REMOVE callback, which is called after the PRE_GAME_EXIT callback.
 * Actions should not be added in any of these callbacks.
 *
 * When an ActionSet is added to the player, we also add its Actions here. They both share the same
 * space in memory, so we can easily access them from either place without having to worry about
 * syncing them.
 *
 * To add an Action that is saved to disk, the 'permanent' flag should be set to true.
 */
export function playerEffectsInit(): void {
  mod.saveDataManager("playerEffects", v);
}

/**
 * Adds the specified Action to the player. This will be saved to disk. This will not deepCopy!
 *
 * Use this function when you want to add an action to the player, independent of an ActionSet.
 * Despite being named 'temporary', this does not handle removing the action. To do so, you should
 * probably use the 'TemporaryActionResponse' Response.
 *
 * @param player The player to add the action to.
 * @param action The action to add.
 *
 * @returns The unique TemporaryActionID of the action. To remove the action, use
 *          'removeTemporaryActionFromPlayer' with this ID.
 */
export function addTemporaryActionToPlayer(
  player: EntityPlayer,
  action: Action,
): int {
  // Create a unique ID for the action.
  const newTemporaryActionID = v.run.temporaryActionID++;
  action.setTemporaryActionID(newTemporaryActionID);
  _addActionsToTracker(player, action);
  return newTemporaryActionID;
}

/**
 * Removes a temporary action from the player using the unique TemporaryActionID.
 *
 * @param player The player entity.
 * @param temporaryActionID The ID of the temporary action to remove.
 *
 * @param actionType
 * @returns The removed action, if found.
 */
export function removeTemporaryActionFromPlayer(
  player: EntityPlayer,
  temporaryActionID: int,
  actionType?: ActionType,
): Action | undefined {
  return removeActionWithPredicate(
    (action) => action.getTemporaryActionID() === temporaryActionID,
    player,
    actionType,
  );
}

/**
 * Removes the specified Action from the tracker, by checking if they reference the same object.
 * This shouldn't get called outside of specific circumstances.
 */
export function _removeActionFromTracker(
  player: EntityPlayer,
  action: Action,
): void {
  removeActionWithPredicate(
    (actionLoop) => actionLoop === action,
    player,
    action.actionType,
  );
}

/** Get the total number of Actions between all players. */
export function getTotalNumActions(): int {
  let totalNumActions = 0;
  for (const player of getPlayers()) {
    totalNumActions += getNumActions(player);
  }
  return totalNumActions;
}

/** Get the total number of Actions the player has. */
export function getNumActions(player: EntityPlayer): int {
  let numActions = 0;
  for (const [, actionsOfType] of defaultMapGetPlayer(
    v.run.playerActions,
    player,
  )) {
    numActions += actionsOfType.length;
  }
  return numActions;
}

/**
 * Add actions to the tracker. These actions should be references to the Actions in player-held
 * ActionSets, and hence will be removed upon exiting the game. They should be re-added every time
 * the game starts up again. As they need to point to the same object, this does not deepCopy.
 *
 * Actions added through this method that are not saved upon exiting, and should generally only be
 * used upon adding an ActionSet!
 *
 * This should not be used outside of specific scenarios, use 'addPermanentActionsToPlayer' instead,
 * as this will not save the actions to disk.
 */
export function _addActionsToTracker(
  player: EntityPlayer,
  ...actions: Action[]
): void {
  for (const action of actions) {
    const playerActionsOfType = getAndSetActionArray(player, action.actionType);
    playerActionsOfType.push(action);
  }
}

/**
 * This will add any Actions to the player, and trigger any Responses, without adding them. Does not
 * deepCopy!
 *
 * Actions added through this method that are not saved upon exiting, and should generally only be
 * used upon adding an ActionSet!
 */
export function _addActionOrResponseToTracker(
  player: EntityPlayer,
  ...effects: Array<Action | Response>
): void {
  for (const effect of effects) {
    if (isAction(effect)) {
      _addActionsToTracker(player, effect);
    } else {
      effect.trigger({ player });
    }
  }
}

/** Removes actions that are flagged for removal from the player. */
export function _removeFlaggedActionsOfType(
  player: EntityPlayer,
  actionType: ActionType,
): void {
  _removeAllActionsWithPredicate(
    (action: Action) => action.getFlagForRemoval(),
    player,
    actionType,
  );
}

/** Get an array of ActionTypes that the player has Actions of. */
export function getPlayerActionTypes(
  player: EntityPlayer,
): readonly ActionType[] {
  return [...defaultMapGetPlayer(v.run.playerActions, player).keys()];
}

/**
 * Removes one Action that matches the predicate, player and ActionType. If an Action is found, the
 * function returns it. If not, it returns undefined. If a player is not specified, it looks through
 * all players. If an actionType is not specified, it looks through all actionTypes.
 *
 * Note that this will not remove the action from the ActionSet it belongs to, only from the
 * tracker.
 */
export function removeActionWithPredicate(
  predicate: (action: Action) => boolean,
  player?: EntityPlayer,
  actionType?: ActionType,
): Action | undefined {
  const playersLoop = player === undefined ? getPlayers() : [player];

  for (const playerLoop of playersLoop) {
    const actionTypesLoop =
      actionType === undefined
        ? getPlayerActionTypes(playerLoop)
        : [actionType];
    for (const actionTypeLoop of actionTypesLoop) {
      const playerActionsOfType = getAndSetActionArray(
        playerLoop,
        actionTypeLoop,
      );
      let index = playerActionsOfType.length - 1;
      while (index >= 0) {
        const action = playerActionsOfType[index];
        if (action !== undefined && predicate(action)) {
          playerActionsOfType.splice(index, 1); // TODO: Remove from ActionSet?
          return action;
        }
        index--;
      }
    }
  }
  return undefined;
}

/**
 * Removes all actions that match the predicate, player and actionType specified. If no player is
 * mentioned, will remove from all players. If no actionType is mentioned, will remove from all
 * actionTypes. Returns an array of the removed actions, which will be empty if nothing matches.
 */
export function _removeAllActionsWithPredicate(
  predicate: (action: Action) => boolean,
  player?: EntityPlayer,
  actionType?: ActionType,
): readonly Action[] {
  const playersLoop = player === undefined ? getPlayers() : [player];
  const removedActions: Action[] = [];

  for (const playerLoop of playersLoop) {
    const actionTypesLoop =
      actionType === undefined
        ? getPlayerActionTypes(playerLoop)
        : [actionType];
    for (const actionTypeLoop of actionTypesLoop) {
      const playerActionsOfType = getAndSetActionArray(
        playerLoop,
        actionTypeLoop,
      );
      let index = playerActionsOfType.length - 1;
      while (index >= 0) {
        const action = playerActionsOfType[index];
        if (action !== undefined && predicate(action)) {
          playerActionsOfType.splice(index, 1); // TODO: Remove from ActionSet?
          removedActions.push(action);
        }
        index--;
      }
    }
  }
  return removedActions;
}

/** Triggers all Actions of the specified actionType for all Players. */
export function triggerPlayersActionsByType(
  actionType: ActionType,
  triggerData: TriggerData,
): void {
  for (const player of getPlayers()) {
    triggerPlayerActionsByType(player, actionType, { ...triggerData });
  }
}

/**
 * Iterates all functions in the players' action array of the specified ActionType. Will also remove
 * actions which are 'flaggedForRemoval' after triggering them.
 */
export function triggerPlayerActionsByType(
  player: EntityPlayer,
  actionType: ActionType,
  triggerData: TriggerData,
): readonly unknown[] {
  triggerData.player ??= player;
  const playerActionsOfType = getAndSetActionArray(player, actionType);
  const returnValues: unknown[] = [];
  for (const action of playerActionsOfType) {
    fprint(`Triggering: ${action.getText()}`);
    triggerData.action = action;
    const returnValue = action.trigger({ ...triggerData });
    returnValues.push(returnValue);

    // Remove the action if it's flagged for removal.
    if (action.getFlagForRemoval()) {
      _removeActionFromTracker(player, action);

      // If the Action is from an inverted collectible, remove it from the ActionSet.
      const collectibleOrigin = action.getInvertedCollectibleOrigin();
      if (collectibleOrigin !== undefined) {
        if (isActiveCollectible(collectibleOrigin)) {
          _removeActionFromCustomActive(player, collectibleOrigin, action);
        } else {
          _removeActionFromCorruptInventory(player, collectibleOrigin, action);
        }
      }
    }
  }

  return returnValues;
}

/**
 * Function to simulate DefaultMap functionality for the Map<ActionType, Action[]> map, as you
 * cannot save nested DefaultMaps. Returns array of actions for player, creating one if necessary.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
function getAndSetActionArray(
  player: EntityPlayer,
  actionType: ActionType,
): Action[] {
  const actionTypeMap = defaultMapGetPlayer(v.run.playerActions, player).get(
    actionType,
  );
  if (actionTypeMap === undefined) {
    defaultMapGetPlayer(v.run.playerActions, player).set(actionType, []);
  }
  const actions = defaultMapGetPlayer(v.run.playerActions, player).get(
    actionType,
  );
  if (actions === undefined) {
    error("getAndSetActionArray: Something went wrong!");
  } else {
    return actions;
  }
}

/** Removes actions that are from inverted collectibles. */
export function _preGameExitRemoveInvertedCollectibleActions(): void {
  const { playerActions } = v.run;
  // Loop through playerActions, and remove any actions that are from inverted collectibles.
  for (const playerActionsOfType of playerActions.values()) {
    for (const actions of playerActionsOfType.values()) {
      let index = actions.length - 1;
      while (index >= 0) {
        const action = actions[index];
        if (action !== undefined && action.isFromInvertedCollectible()) {
          actions.splice(index, 1);
        }
        index--;
      }
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inventory\bombInventory.ts`:

```````ts
import { SoundEffect } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  deepCopy,
  DefaultMap,
  defaultMapGetPlayer,
  getPlayerFromIndex,
  getPlayerIndex,
  mapSetHash,
  sfxManager,
} from "isaacscript-common";
import type { NonInvertedPickupActionSet } from "../../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import type { Response } from "../../../classes/corruption/responses/Response";
import { fprint } from "../../../helper/printHelper";
import { mod } from "../../../mod";

const v = {
  run: {
    /**
     * A cache of corrupted bombs the player currently has. When a new corrupted bomb is added, it
     * will be added to the back of the list. When a bomb is used, it will be removed from the
     * front.
     */
    bombInventory: new DefaultMap<PlayerIndex, NonInvertedPickupActionSet[]>(
      () => [],
    ),
  },
  room: {
    liveBombs: new Map<PtrHash, PlayerIndex>(),
  },
};

export function bombInventoryInit(): void {
  mod.saveDataManager("bombInventory", v);
}

/**
 * Queue a corrupted bomb for the player, with the specified NonInvertedActionSet. If there are
 * already corrupted bombs queued, it will go to the end of the queue.
 *
 * Does Deep Copy.
 */
export function addCorruptedBombToPlayer(
  player: EntityPlayer,
  actionSet: NonInvertedPickupActionSet,
): void {
  const bombInventory = defaultMapGetPlayer(v.run.bombInventory, player);
  bombInventory.push(deepCopy(actionSet));
}

// POST_BOMB_INIT_LATE
export function postCorruptBombInitLate(bomb: EntityBomb): void {
  const player = bomb.SpawnerEntity?.ToPlayer();

  if (player === undefined) {
    return;
  }

  mapSetHash(v.room.liveBombs, bomb, getPlayerIndex(player));

  // Set the bomb colour.
  const bombInventory = v.run.bombInventory.getAndSetDefault(
    getPlayerIndex(player),
  );
  const corruptedBomb = bombInventory.at(-1);
  if (corruptedBomb === undefined) {
    return;
  }
  const color = corruptedBomb.getColor();
  if (color === undefined) {
    return;
  }
  bomb.SetColor(color, 0, 1);
}

// POST_BOMB_UPDATE
export function postCorruptBombUpdate(bomb: EntityBomb): void {}

// POST_BOMB_EXPLODED
export function bombInventoryPostBombExploded(bomb: EntityBomb): void {
  const playerIndex = v.room.liveBombs.get(GetPtrHash(bomb));
  if (playerIndex === undefined) {
    return;
  }
  const bombInventory = v.run.bombInventory.getAndSetDefault(playerIndex);

  const currentBombActionSet = bombInventory.shift();
  if (currentBombActionSet === undefined) {
    return;
  }

  // Silence the bomb sound.
  mod.runNextGameFrame(() => {
    sfxManager.Stop(SoundEffect.BOSS_1_EXPLOSIONS);
  });

  fprint("bombInventory: Firing corrupted bomb!");
  currentBombActionSet.getResponses().forEach((response: Response) => {
    response.trigger({
      player: getPlayerFromIndex(playerIndex),
      onBombExplodedAction: { bomb },
      spawnPosition: bomb.Position,
      spawnVelocity: bomb.Velocity,
    });
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inventory\callbacks\itemInventoryPostGameContinuedReordered.ts`:

```````ts
import { getPlayers } from "isaacscript-common";
import { ActionType } from "../../../../enums/corruption/actions/ActionType";
import { _addActionsToTracker } from "../../effects/playerEffects";
import { getPlayerInvertedPassiveItemActionSets } from "../passiveItemInventory";

// POST_GAME_CONTINUED, isContinued: TRUE. This is called when the game is exited and then
// continued, and used to re-add Actions to the Action tracker from saved item ActionSets.
export function _itemInventoryPostGameContinuedReordered(): void {
  for (const player of getPlayers()) {
    const actionSets = getPlayerInvertedPassiveItemActionSets(player);
    for (const actionSet of actionSets) {
      const actions = actionSet
        .getActions()
        .filter((action) => action.actionType !== ActionType.ON_OBTAIN);
      _addActionsToTracker(player, ...actions);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inventory\callbacks\postPickupChangedToInverted.ts`:

```````ts
/**
 * If Zazzinator item is not in PreGetPedestal stage, it means it has somehow spawned some other
 * way, and should be morphed into a non-Zazzinator item. There are a few ways it could spawn, for
 * example after swapping a Zazzinator active item out of your inventory, or through a modded item
 * which can spawn a Zazzinator item, or through an item in which items from your inventory are
 * removed onto the floor.
 */

import { setZazzinatorToRemovedItem } from "../../../../helper/deletedSpecific/inventory/removedItems";
import { fprint } from "../../../../helper/printHelper";
import { isPedestalInPreGetPedestalStage } from "../../inversion/lastPickedUpInverted";

// POST_PICKUP_CHANGED
export function postPickupChangedZazzinator(
  pickup: EntityPickupCollectible,
): void {
  if (isPedestalInPreGetPedestalStage(pickup)) {
    fprint("Zazzinator item is PreGetPedestalStage, doing nothing...");
  } else {
    fprint("Zazzinator item is not PreGetPedestalStage, dealing with it...");
    setZazzinatorToRemovedItem(pickup);
  }
}

// POST_PICKUP_INIT_LATE, PickupVariant.COLLECTIBLE
export function postCollectibleInitLateZazzinator(pickup: EntityPickup): void {
  fprint("Zazzinator item postCollectibleInitFirst....");
  if (!isPedestalInPreGetPedestalStage(pickup as EntityPickupCollectible)) {
    fprint("Zazzinator item is not PreGetPedestalStage, dealing with it...");
    setZazzinatorToRemovedItem(pickup as EntityPickupCollectible);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inventory\passiveItemInventory.ts`:

```````ts
/**
 * This file contains functions and data structures related to the passive item inventory in the
 * game. It provides functionality to track and manipulate the inverted passive items of players.
 * The inventory is implemented using a DefaultMap, which maps player indices to arrays of
 * [CollectibleType, ActionSet] tuples. The functions in this file allow retrieving and modifying
 * the inventory, as well as performing various operations on the items. Additionally, there is a
 * function to re-add the actions associated with the inverted passive items to the action tracker
 * after the game is continued.
 */

import type { CollectibleType } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  DefaultMap,
  defaultMapGetPlayer,
  getPlayerIndex,
} from "isaacscript-common";
import type { ActionSet } from "../../../classes/corruption/actionSets/ActionSet";
import { findLastIndexOfArray } from "../../../helper/arrayHelper";
import { mod } from "../../../mod";
import type { Action } from "../../../classes/corruption/actions/Action";

/**
 * We use this inventory to track a players' inverted passive items (in order). Inverted active
 * items are tracked through the 'CustomActiveFacet'. Two inverted passives of the same type will
 * have different ActionSet objects.
 */
const v = {
  run: {
    /** Ordered list of inverted passive items added to the player. */
    items: new DefaultMap<PlayerIndex, Array<[CollectibleType, ActionSet]>>(
      () => [],
    ),
  },
};

export function invertedItemCorruptInit(): void {
  mod.saveDataManager("CorruptInventory", v);
}

/**
 * Returns an ordered array of [CollectibleType, ActionSet] for the passive inverted items a player
 * has.
 */
export function getPlayerInvertedPassiveItems(
  player: EntityPlayer,
): ReadonlyArray<[CollectibleType, ActionSet]> {
  return defaultMapGetPlayer(v.run.items, player);
}

/**
 * Returns the most recently added inverted passive item a player has along with its ActionSet, or
 * undefined if they have none.
 */
export function getPlayerMostRecentInvertedPassiveItem(
  player: EntityPlayer,
): [CollectibleType, ActionSet] | undefined {
  return defaultMapGetPlayer(v.run.items, player).at(-1);
}

/**
 * Returns the most recently added inverted passive item a player has, or undefined if they have
 * none.
 */
export function getPlayerMostRecentInvertedPassiveItemCollectibleType(
  player: EntityPlayer,
): CollectibleType | undefined {
  return defaultMapGetPlayer(v.run.items, player).at(-1)?.[0];
}

/** Returns an ordered array of CollectibleType for the passive inverted items a player has. */
export function getPlayerInvertedPassiveItemCollectibleTypes(
  player: EntityPlayer,
): readonly CollectibleType[] {
  return defaultMapGetPlayer(v.run.items, player).map(([item]) => item);
}

/** Returns an ordered array of ActionSets for the passive inverted items a player has. */
export function getPlayerInvertedPassiveItemActionSets(
  player: EntityPlayer,
): readonly ActionSet[] {
  return defaultMapGetPlayer(v.run.items, player).map(
    ([, actionSet]) => actionSet,
  );
}

/** Returns true if the player has at least one inverted item of the provided CollectibleType. */
export function _doesPlayerHaveInvertedPassiveItem(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): boolean {
  return defaultMapGetPlayer(v.run.items, player).some(
    ([item]) => item === collectibleType,
  );
}

/**
 * Get the amount of inverted passive items a player has. Can specify a certain CollectibleType to
 * filter results.
 */
export function _getPlayerAmountOfInvertedPassiveItems(
  player: EntityPlayer,
  collectibleType?: CollectibleType,
): number {
  if (collectibleType === undefined) {
    return defaultMapGetPlayer(v.run.items, player).length;
  }
  return defaultMapGetPlayer(v.run.items, player).filter(
    ([item]) => item === collectibleType,
  ).length;
}

/**
 * Add an inverted passive item to the inventory. This function shouldn't be called outside certain
 * circumstances.
 */
export function _addInvertedPassiveItemToCorruptInventory(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  actionSet: ActionSet,
): void {
  defaultMapGetPlayer(v.run.items, player).push([collectibleType, actionSet]);
}

/**
 * Remove the most recently added inverted passive item from the inventory. This function shouldn't
 * be called outside certain circumstances.
 */
export function _removeInvertedPassiveItemFromCorruptInventory(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  const playerInventory = defaultMapGetPlayer(v.run.items, player);
  const index = findLastIndexOfArray(
    playerInventory,
    ([item]) => item === collectibleType,
  );
  if (index !== -1) {
    playerInventory.splice(index, 1);
  }
}

/**
 * Removes a specific action from an ActionSet for a given player and collectible type. This should
 * only be used in certain circumstances.
 */
export function _removeActionFromCorruptInventory(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  actionToRemove: Action,
): boolean {
  const playerInventory = v.run.items.getAndSetDefault(getPlayerIndex(player));

  for (const [item, actionSet] of playerInventory) {
    if (item === collectibleType) {
      const actions = actionSet.getActions();
      const actionIndex = actions.indexOf(actionToRemove);
      if (actionIndex !== -1) {
        actions.splice(actionIndex, 1);
        // Return the action that was removed.
        return true;
      }
    }
  }

  return false;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inventory\removedInvertedItems.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import { getPlayerIndex } from "isaacscript-common";
import { mod } from "../../../mod";
import type { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";

/**
 * This feature tracks corrupted items that have been removed from the player in the room, in the
 * hopes that when a rogue dummy-zazzinator item is spawned, we can identify which player it came
 * from and properly transform it into its corrupted item.
 *
 * Each removed item will have...
 *
 * @property dummyItem - The physical item that was removed from the player. Passive zazzinator
 *           dummy items are unique to each quality, giving another clue to what the reference item
 *           is. Active items are unique to the slot they are in.
 * @property referenceCollectible - The inverted collectible that the dummy item represents. This
 *           should be set when adding collectibles to the removedItemTracker.
 * @property InvertedActiveActionSet - If the removed item is an active item, this will be the
 *           ActionSet for that item. The activeItemTracker can then register the pedestal as having
 *           a pre-existing inverted active item.
 */
interface RemovedZazzItem {
  playerIndex: PlayerIndex;
  dummyItem: CollectibleType;
  referenceCollectible: CollectibleType;
  InvertedActiveActionSet?: InvertedActiveActionSet;
}

const v = {
  room: {
    removedItems: [] as RemovedZazzItem[],
  },
};

export function removedItemTrackerInit(): void {
  mod.saveDataManager("RemovedItemTracker", v);
}

/**
 * Add a removed item to the removed inverted item tracker. This will be used when rogue zazzinator
 * items spawn on the ground (e.g when swapping an active item out of your inventory).
 */
export function addRemovedInvertedItemToTracker(
  player: EntityPlayer,
  dummyItem: CollectibleType,
  referenceCollectible: CollectibleType,
  actionSet?: InvertedActiveActionSet,
): void {
  const playerIndex = getPlayerIndex(player);
  v.room.removedItems.push({
    playerIndex,
    dummyItem,
    referenceCollectible,
    InvertedActiveActionSet: actionSet,
  });
}

// Get list of removed inverted items in chronological order (oldest first). Mutable as we want to
// be able to remove items from the list.
// eslint-disable-next-line isaacscript/no-mutable-return
export function _getRemovedInvertedItems(): RemovedZazzItem[] {
  return v.room.removedItems;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\bombCollection.ts`:

```````ts
// POST_PICKUP_COLLECT.

import { BombSubType } from "isaac-typescript-definitions";
import { fprint } from "../../../../helper/printHelper";
import { getNonInvertedPickupActionSet } from "../../effects/pickupEffects";
import { addCorruptedBombToPlayer } from "../../inventory/bombInventory";

/**
 * Non-Inverted Bomb with corrupted effects. Corrupted bombs get added to the end of the corrupted
 * bomb queue, that cycles when the player uses a bomb.
 *
 * @example Responses: Responses will be triggered upon the bomb exploding.
 * @example Actions: Actions will be triggered upon the bomb being next in the queue, and be
 *          deactivated upon the bomb being used. You can tell which bomb is currently equipped by
 *          looking at its color.
 */
export function nonInvertedBombPostPickupCollect(
  pickup: EntityPickup,
  player: EntityPlayer,
): void {
  const pickupActionSet = getNonInvertedPickupActionSet(pickup);
  if (pickupActionSet === undefined) {
    return;
  }
  // Trigger Responses immediately.
  if ((pickup.SubType as BombSubType) === BombSubType.NORMAL) {
    addCorruptedBombToPlayer(player, pickupActionSet);
  } else if ((pickup.SubType as BombSubType) === BombSubType.DOUBLE_PACK) {
    addCorruptedBombToPlayer(player, pickupActionSet);
    addCorruptedBombToPlayer(player, pickupActionSet);
  } else if ((pickup.SubType as BombSubType) === BombSubType.GIGA) {
    addCorruptedBombToPlayer(player, pickupActionSet);
  }
  // const actions = pickupActionSet.getActions();

  fprint("Bomb collected with corrupted effects!");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\coinCollection.ts`:

```````ts
// POST_PICKUP_COLLECT.

import { fprint } from "../../../../helper/printHelper";
import { getNonInvertedPickupActionSet } from "../../effects/pickupEffects";

// eslint-disable-next-line isaacscript/complete-sentences-jsdoc
/**
 * Non-Inverted Coins with corrupted effects.
 *
 * @example Responses: Responses will be triggered upon the coin being collected.
 * @example Actions: Actions will be triggered upon the coin being collected, and be deactivated
 *          upon the coin/s being spent. This means a penny will have its actions deactivated after
 *          spending one cent, while a nickel will have its actions deactivated after spending five
 *          cents.
 */
export function nonInvertedCoinPostPickupCollect(
  pickup: EntityPickup,
  player: EntityPlayer,
): void {
  const pickupActionSet = getNonInvertedPickupActionSet(pickup);
  if (pickupActionSet === undefined) {
    return;
  }
  const responses = pickupActionSet.getResponses();
  // Trigger Responses immediately.
  responses.forEach((response) => {
    response.trigger({ player, nonInvertedPickup: pickup });
  });
  // const actions = pickupActionSet.getActions();

  fprint("Coin collected with corrupted effects!");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\invertedPostItemPickupCollectible.ts`:

```````ts
import type { PickingUpItemCollectible } from "isaacscript-common";
import { getPlayerIndex } from "isaacscript-common";
import { fprint } from "../../../../helper/printHelper";
import { isZazzinatorAny } from "../../../../sets/zazzSets";
import {
  getLastPickedUpCollectibleData,
  getLastPickedUpNonInvertedCollectibleActionSet,
  setLastPickedUpCollectibleData,
} from "../lastPickedUpInverted";
import { addInvertedItemToPlayer } from "../../../../helper/deletedSpecific/inventory/invertedInventoryHelper";
import { ActiveSlot } from "isaac-typescript-definitions";
import { PickupStage } from "../../../../enums/general/PickupStage";

/**
 * When the item leaves ItemQueue. If it is ZAZZ, it's an inverted item. Passive items get their
 * ActionSet triggered immediately, while Active item ActionSets go into the players' active slot
 * and can be triggered by the player.
 *
 * If it is not an inverted item, it still may have an ActionSet, which is triggered here.
 */
// ModCallbackCustom.MC_POST_ITEM_PICKUP_COLLECTIBLE
export function invertedPostItemPickupCollectible(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemCollectible,
): void {
  if (isZazzinatorAny(pickingUpItem.subType)) {
    const pickedUpCollectibleType = getLastPickedUpCollectibleData(player);

    // TODO: Error Handling.
    if (
      pickedUpCollectibleType === undefined ||
      pickedUpCollectibleType.pickupStage !== PickupStage.PRE_ITEM_PICKUP
    ) {
      return;
    }
    fprint(
      `invertedPostItemPickupCollectible: ${getPlayerIndex(
        player,
      )} picked up inverted item of subType: ${
        pickedUpCollectibleType.collectibleType
      }`,
    );
    addInvertedItemToPlayer(
      player,
      pickedUpCollectibleType.collectibleType,
      false,
      ActiveSlot.PRIMARY,
      pickedUpCollectibleType.actionSet,
    );

    /** Item is finished being picked up. */
    setLastPickedUpCollectibleData(player, undefined);
  } else {
    // This is a regular item.
    const lastPickedUpCollectibleActionSet =
      getLastPickedUpNonInvertedCollectibleActionSet(player);
    if (lastPickedUpCollectibleActionSet !== undefined) {
      lastPickedUpCollectibleActionSet.addToPlayer(player);
    }

    /** Item is finished being picked up. */
    setLastPickedUpCollectibleData(player, undefined);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\invertedPostPickupChanged.ts`:

```````ts
import type { PickupVariant } from "isaac-typescript-definitions";
import { updatePickup } from "../../../../helper/deletedSpecific/inversion/updateInverted";
import { fprint } from "../../../../helper/printHelper";

/**
 * This function runs when a pickup is rerolled, morphed or otherwise had its subType or variant
 * changed.
 */
export function invertedPostPickupChanged(
  pickup: EntityPickup,
  oldVariant: PickupVariant,
  oldSubType: int,
  newVariant: PickupVariant,
  newSubType: int,
): void {
  fprint(
    `pickup: 5.${oldVariant}.${oldSubType} changed to 5.${newVariant}.${newSubType}, updating it.`,
  );
  updatePickup(pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\invertedPreGetPedestalCollectible.ts`:

```````ts
/**
 * This file tracks provides the logic for what happens when an inverted pedestal is picked up by
 * the player.
 */

import {
  clearCollectibleSprite,
  ColorDefault,
  getCollectibleName,
  getPlayerIndex,
} from "isaacscript-common";
import { ActionSetType } from "../../../../enums/corruption/actionSets/ActionSetType";
import { fprint } from "../../../../helper/printHelper";
import { stopPickupSounds } from "../../../../helper/soundHelper";
import { isGlitchedCollectibleSubType } from "../../../../helper/tmtrainerHelper";
import { mod } from "../../../../mod";
import { isZazzinatorAny } from "../../../../sets/zazzSets";
import { getNonInvertedPickupActionSet } from "../../effects/pickupEffects";
import {
  getLastPickedUpCollectibleData,
  setLastPickedUpCollectibleData,
  setLastPickedUpNonInvertedCollectibleActionSet,
  updateLastPickedUpCollectible,
} from "../lastPickedUpInverted";
import { isPickupInverted } from "../pickupInversion";
import { PickupStage } from "../../../../enums/general/PickupStage";
import type { LastPickedUpCollectibleData } from "../../../../interfaces/corruption/inversion/LastPickedUpCollectibleData";
import { removeTrackedPedestalInvertedActive } from "../../effects/activeItemTracker";
import { getAndSetInvertedPedestalActionSet } from "../../../../helper/deletedSpecific/effects/pedestalEffects";

/**
 * Upon picking up an item, but before it is added to ItemQueue. If the item pedestal is inverted,
 * swap it for 'ZAZZ' right before its picked up.
 */
// ModCallbacksCustom.MC_PRE_GET_PEDESTAL_COLLECTIBLE
export function pickupInversionPreGetPedestalCollectible(
  player: EntityPlayer,
  pickup: EntityPickupCollectible,
): boolean | undefined {
  const isInverted = isPickupInverted(pickup);

  // PickupStage.PRE_GET_PEDESTAL_ZAZZ.
  if (isZazzinatorAny(pickup.SubType)) {
    return preGetPedestalZazz(player, pickup);
  }

  // PickupStage.PRE_GET_PEDESTAL.
  return preGetPedestalNormal(player, pickup, isInverted);
}

/**
 * This function handles the logic for when a player picks up a normal (non-ZAZZ) item from a
 * pedestal. It checks if the item is inverted and updates the game state accordingly. It also
 * tracks the last picked up item and handles special cases like glitched items.
 */
function preGetPedestalNormal(
  player: EntityPlayer,
  pickup: EntityPickupCollectible,
  isInverted: boolean,
): boolean | undefined {
  // Update pickup tracking.
  const lastPickedUpCollectibleData: LastPickedUpCollectibleData = {
    collectibleType: pickup.SubType,
    pickupStage: PickupStage.PRE_GET_PEDESTAL,
    pickupIndex: mod.getPickupIndex(pickup),
    inverted: false,
    pedestal: pickup,
    nonInvertedCharge: pickup.Charge,
  };

  fprint(
    `PreGetPedestalNormal: ${pickup.SubType} name: ${getCollectibleName(
      pickup.SubType,
    )} player: ${getPlayerIndex(player)} inversion: ${isInverted}`,
  );

  if (isInverted) {
    // Get ActionSet so we can know what ZAZZ to modify to.
    const itemActionSet = getAndSetInvertedPedestalActionSet(pickup);

    // We can set the pedestal tracker to undefined for now. If the put down item should be tracked,
    // it will be set in the next callback.
    removeTrackedPedestalInvertedActive(pickup);

    // Save last picked up collectible data.
    lastPickedUpCollectibleData.inverted = true;
    lastPickedUpCollectibleData.actionSet = itemActionSet;
    setLastPickedUpCollectibleData(player, lastPickedUpCollectibleData);

    fprint(
      `   Inverted Active: ${
        itemActionSet.actionSetType === ActionSetType.INVERTED_ACTIVE_ITEM
      }
      ActionSet: ${itemActionSet.getText()}`,
    );
    return itemActionSet.preGetPedestal(player, pickup);
  }

  setLastPickedUpCollectibleData(player, lastPickedUpCollectibleData);

  const itemActionSet = getNonInvertedPickupActionSet(pickup);
  if (itemActionSet !== undefined) {
    setLastPickedUpNonInvertedCollectibleActionSet(player, itemActionSet);
    fprint(`NonInverted ActionSet: ${itemActionSet.getText()}`);
    return undefined;
  }
  return undefined;
}

// PickupStage.PRE_GET_PEDESTAL_ZAZZ.
function preGetPedestalZazz(
  player: EntityPlayer,
  pickup: EntityPickupCollectible,
): boolean | undefined {
  const lastPickedUpCollectible = getLastPickedUpCollectibleData(player);

  /**
   * We don't care about it if it's not inverted.
   * TODO: Deal with useless zazz item.
   */
  if (
    lastPickedUpCollectible === undefined ||
    !lastPickedUpCollectible.inverted
  ) {
    return undefined;
  }

  // Stop pickup sound. We will play our own sound effect later.
  mod.runNextGameFrame(() => {
    stopPickupSounds();
    pickup.GetSprite().Color = ColorDefault;
  });

  /**
   * If it was a TMTRAINER item, need to temporarily turn it invisible so the original TMTRAINER
   * sprite doesn't render behind it.
   */
  if (isGlitchedCollectibleSubType(lastPickedUpCollectible.collectibleType)) {
    pickup.GetSprite().Color = Color(0, 0, 0, 0);
  } else {
    clearCollectibleSprite(pickup);
  }

  /** Update pickup stage. */
  updateLastPickedUpCollectible(player, PickupStage.PRE_GET_PEDESTAL_ZAZZ);

  fprint(
    `PreGetPedestalZazz: ${pickup.SubType} name: ${getCollectibleName(
      pickup.SubType,
    )} player: ${getPlayerIndex(player)} inversion: ${
      lastPickedUpCollectible.inverted
    }`,
  );

  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\callbacks\invertedPreItemPickupCollectible.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import type { PickingUpItemCollectible } from "isaacscript-common";
import { setPedestalInversion } from "../../../../helper/deletedSpecific/inversion/pedestalInversion";
import { setZazzinatorToRemovedItem } from "../../../../helper/deletedSpecific/inventory/removedItems";
import { mod } from "../../../../mod";
import { isZazzinatorAny } from "../../../../sets/zazzSets";
import { getAndSetInvertedItemActionSet } from "../../effects/itemEffects";
import {
  getLastPickedUpCollectibleData,
  getLastPickedUpPedestal,
  updateLastPickedUpCollectible,
} from "../lastPickedUpInverted";
import { PickupStage } from "../../../../enums/general/PickupStage";
import { fprint } from "../../../../helper/printHelper";
import { getAndSetInvertedPedestalActionSet } from "../../../../helper/deletedSpecific/effects/pedestalEffects";

/**
 * When the item goes into ItemQueue. Despite its name, tracks both inverted and non-inverted items.
 *
 * This is used to render the inverted item's name onto the HUD, which only happens when picking up
 * an inverted item from a pedestal (not when an inverted item is manually added).
 */
// ModCallbackCustom.MC_POST_ITEM_PICKUP_COLLECTIBLE
export function invertedPreItemPickupCollectible(
  player: EntityPlayer,
  pickingUpItem: PickingUpItemCollectible,
): void {
  const pickingUpItemInverted = isZazzinatorAny(pickingUpItem.subType);

  /** Call inverted item ActionSet 'prePickupCollectible' function. */
  if (pickingUpItemInverted) {
    const pickedUpItemData = getLastPickedUpCollectibleData(player);

    /** TODO: Error handling. */
    if (
      pickedUpItemData === undefined ||
      pickedUpItemData.pickupStage !== PickupStage.PRE_GET_PEDESTAL_ZAZZ
    ) {
      return;
    }
    const invertedActionSet =
      pickedUpItemData.actionSet ??
      getAndSetInvertedPedestalActionSet(pickedUpItemData.pedestal);
    invertedActionSet.prePickupCollectible(player, pickingUpItem);
  }

  /** Update pickup tracking. */
  updateLastPickedUpCollectible(player, PickupStage.PRE_ITEM_PICKUP);

  /**
   * Regardless of the picked up item inversion, we need to check if the pedestal houses a new item.
   * When this is the case, an active item has been swapped out.
   *
   * Normal active -> Normal active ---> Do nothing.
   *
   * Normal active -> Inverted active ---> Turn pedestal to normal.
   *
   * Inverted active -> Normal active ---> Turn pedestal inverted & morph zazz item.
   *
   * Inverted active -> Inverted active ---> Morph zazz item.
   */
  const pedestal = getLastPickedUpPedestal(player);
  fprint(" sorting out pedestal during preItemPickup...");
  if (pedestal === undefined || pedestal.SubType === CollectibleType.NULL) {
    fprint(` pedestal with type ${pedestal?.SubType}, returning...`);
    return;
  }

  const putDownItemInverted = isZazzinatorAny(pedestal.SubType);

  setPedestalInversion(putDownItemInverted, pedestal);
  if (putDownItemInverted) {
    mod.runInNRenderFrames(() => {
      setZazzinatorToRemovedItem(pedestal);
    }, 1);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\customActivePostGameContinuedReordered.ts`:

```````ts
import { getPlayers } from "isaacscript-common";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { _addActionsToTracker } from "../effects/playerEffects";
import { getAllCustomActivesWithSlot } from "./customActives";

// POST_GAME_CONTINUED, isContinued: TRUE. This is called when the game is exited and then
// continued, and used to re-add Actions to the Action tracker from saved item ActionSets.
export function _customActiveInventoryPostGameContinuedReordered(): void {
  for (const player of getPlayers()) {
    const customActives = getAllCustomActivesWithSlot(player);
    for (const [_slot, customActive] of customActives) {
      const actions = customActive
        .getActions()
        .filter((action) => action.actionType !== ActionType.ON_OBTAIN);
      _addActionsToTracker(player, ...actions);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\customActives.ts`:

```````ts
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { getPlayerIndex, getPlayers } from "isaacscript-common";
import type { PlayerIndex } from "isaacscript-common";
import type { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { mod } from "../../../mod";
import type { CollectibleType } from "isaac-typescript-definitions";
import { ActiveSlot } from "isaac-typescript-definitions";
import type { Action } from "../../../classes/corruption/actions/Action";

/**
 * This file stores data regarding players' currently held custom active items. It is used by the
 * CustomActiveFacet. A custom active item is essentially an InvertedActiveActionSet that mimics a
 * normal active item.
 *
 * A player can have a custom active item in one of four slots:
 * - PrimarySlot (always the larger active item)
 * - SecondarySlot (always the smaller active item)
 * - PocketSlot
 * - SingleUsePocketSlot
 */
const v = {
  run: {
    primarySlot: new Map<PlayerIndex, InvertedActiveActionSet | undefined>(),
    secondarySlot: new Map<PlayerIndex, InvertedActiveActionSet | undefined>(),
    pocketSlot: new Map<PlayerIndex, InvertedActiveActionSet | undefined>(),
    singleUsePocketSlot: new Map<
      PlayerIndex,
      InvertedActiveActionSet | undefined
    >(),
  },
};

export function customActivesInit(): void {
  mod.saveDataManager("customActives", v);
}

/**
 * Gets the custom active in the selected ActiveSlot:
 *
 * - PrimarySlot (always the larger active item)
 * - SecondarySlot (always the smaller active item)
 * - PocketSlot
 * - SingleUsePocketSlot
 *
 * If the player does not have a custom active in the selected slot, returns undefined.
 */
export function getCustomActiveInSlot(
  player: EntityPlayer,
  slot: ActiveSlot,
): InvertedActiveActionSet | undefined {
  const playerIndex = getPlayerIndex(player);
  switch (slot) {
    case ActiveSlot.PRIMARY: {
      return v.run.primarySlot.get(playerIndex);
    }

    case ActiveSlot.SECONDARY: {
      return v.run.secondarySlot.get(playerIndex);
    }

    case ActiveSlot.POCKET: {
      return v.run.pocketSlot.get(playerIndex);
    }

    case ActiveSlot.POCKET_SINGLE_USE: {
      return v.run.singleUsePocketSlot.get(playerIndex);
    }
  }
}

/**
 * Returns a list (ordered primary > secondary > pocket > singleUsePocket) of a players custom
 * actives (if any).
 */
export function getAllCustomActives(
  player: EntityPlayer,
): readonly InvertedActiveActionSet[] {
  const playerIndex = getPlayerIndex(player);
  return [
    v.run.primarySlot.get(playerIndex),
    v.run.secondarySlot.get(playerIndex),
    v.run.pocketSlot.get(playerIndex),
    v.run.singleUsePocketSlot.get(playerIndex),
  ].filter(
    (customActive) => customActive !== undefined,
  ) as InvertedActiveActionSet[];
}

/**
 * Retrieve all custom actives the player has in an array of tuples [ActiveSlot,
 * InvertedActiveActionSet].
 */
export function getAllCustomActivesWithSlot(
  player: EntityPlayer,
): ReadonlyArray<[ActiveSlot, InvertedActiveActionSet]> {
  const playerIndex = getPlayerIndex(player);
  const customActives: Array<[ActiveSlot, InvertedActiveActionSet]> = [];
  if (v.run.primarySlot.get(playerIndex) !== undefined) {
    customActives.push([
      ActiveSlot.PRIMARY,
      v.run.primarySlot.get(playerIndex)!,
    ]);
  }
  if (v.run.secondarySlot.get(playerIndex) !== undefined) {
    customActives.push([
      ActiveSlot.SECONDARY,
      v.run.secondarySlot.get(playerIndex)!,
    ]);
  }
  if (v.run.pocketSlot.get(playerIndex) !== undefined) {
    customActives.push([ActiveSlot.POCKET, v.run.pocketSlot.get(playerIndex)!]);
  }
  if (v.run.singleUsePocketSlot.get(playerIndex) !== undefined) {
    customActives.push([
      ActiveSlot.POCKET_SINGLE_USE,
      v.run.singleUsePocketSlot.get(playerIndex)!,
    ]);
  }
  return customActives;
}

/**
 * Sets the Custom Active in the ActiveSlot:
 *
 * - PrimarySlot (always the larger active item)
 * - SecondarySlot (always the smaller active item)
 * - PocketSlot
 * - SingleUsePocketSlot
 *
 * Will override existing CustomActiveSlot data. Does not actually add the CustomActive, use
 * addNewInvertedActiveToPlayer() for that. Does not deepCopy!
 */
export function _setCustomActiveInSlot(
  player: EntityPlayer,
  slot: ActiveSlot,
  customActive: InvertedActiveActionSet | undefined,
): void {
  const playerIndex = getPlayerIndex(player);
  switch (slot) {
    case ActiveSlot.PRIMARY: {
      v.run.primarySlot.set(playerIndex, customActive);
      break;
    }

    case ActiveSlot.SECONDARY: {
      v.run.secondarySlot.set(playerIndex, customActive);
      break;
    }

    case ActiveSlot.POCKET: {
      v.run.pocketSlot.set(playerIndex, customActive);
      break;
    }

    case ActiveSlot.POCKET_SINGLE_USE: {
      v.run.singleUsePocketSlot.set(playerIndex, customActive);
      break;
    }
  }
}

/**
 * Returns true if the player has the inverted active of the specified type, otherwise returns
 * false.
 */
export function doesPlayerHaveCustomActive(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): boolean {
  const playerIndex = getPlayerIndex(player);
  return (
    v.run.primarySlot.get(playerIndex)?.getCollectibleType() ===
      collectibleType ||
    v.run.secondarySlot.get(playerIndex)?.getCollectibleType() ===
      collectibleType ||
    v.run.pocketSlot.get(playerIndex)?.getCollectibleType() ===
      collectibleType ||
    v.run.singleUsePocketSlot.get(playerIndex)?.getCollectibleType() ===
      collectibleType
  );
}

/**
 * Returns true if the player has a custom active in the specified slot, otherwise returns false.
 */
export function doesPlayerHaveCustomActiveInSlot(
  player: EntityPlayer,
  slot: ActiveSlot,
): boolean {
  const playerIndex = getPlayerIndex(player);
  switch (slot) {
    case ActiveSlot.PRIMARY: {
      return v.run.primarySlot.get(playerIndex) !== undefined;
    }

    case ActiveSlot.SECONDARY: {
      return v.run.secondarySlot.get(playerIndex) !== undefined;
    }

    case ActiveSlot.POCKET: {
      return v.run.pocketSlot.get(playerIndex) !== undefined;
    }

    case ActiveSlot.POCKET_SINGLE_USE: {
      return v.run.singleUsePocketSlot.get(playerIndex) !== undefined;
    }
  }
}

/** Returns true if the player has any custom actives. */
export function doesPlayerHaveAnyCustomActives(player: EntityPlayer): boolean {
  const playerIndex = getPlayerIndex(player);
  return (
    v.run.primarySlot.get(playerIndex) !== undefined ||
    v.run.secondarySlot.get(playerIndex) !== undefined ||
    v.run.pocketSlot.get(playerIndex) !== undefined ||
    v.run.singleUsePocketSlot.get(playerIndex) !== undefined
  );
}

/** Returns true if any player is currently holding a custom active. */
export function doesAnyPlayerHaveAnyCustomActives(): boolean {
  for (const player of getPlayers()) {
    if (doesPlayerHaveAnyCustomActives(player)) {
      return true;
    }
  }
  return false;
}

/**
 * Get the 'current charge' (the internally tracked current charge of the custom active), returns
 * undefined if the player does not have a custom active in the specified slot.
 */
export function getCustomActiveCurrentCharge(
  player: EntityPlayer,
  slot: ActiveSlot,
): number | undefined {
  const customActive = getCustomActiveInSlot(player, slot);
  if (customActive === undefined) {
    return undefined;
  }
  return customActive._getCurrentCharge();
}

/**
 * Removes an action from the custom active items of a player.
 *
 * @param player The player entity.
 * @param collectibleType The type of inverted collectible to remove the action from.
 * @param action The action to remove.
 * @returns True if the action was successfully removed, false otherwise.
 */
export function _removeActionFromCustomActive(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  action: Action,
): boolean {
  const playerIndex = getPlayerIndex(player);
  const customActives = [
    v.run.primarySlot.get(playerIndex),
    v.run.secondarySlot.get(playerIndex),
    v.run.pocketSlot.get(playerIndex),
    v.run.singleUsePocketSlot.get(playerIndex),
  ];
  for (const customActive of customActives) {
    if (customActive?.getCollectibleType() === collectibleType) {
      // Check if the action exists by reference, and if so, remove it.
      const actions = customActive.getActions();
      const actionIndex = actions.indexOf(action);
      if (actionIndex !== -1) {
        actions.splice(actionIndex, 1);
        return true;
      }
    }
  }
  return false;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\lastPickedUpInverted.ts`:

```````ts
/** This file tracks the last picked up inverted collectible that each player has picked up. */

import type { PlayerIndex } from "isaacscript-common";
import { getPlayerIndex } from "isaacscript-common";
import type { NonInvertedPickupActionSet } from "../../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import { fprint } from "../../../helper/printHelper";
import { mod } from "../../../mod";
import { PickupStage } from "../../../enums/general/PickupStage";
import type { LastPickedUpCollectibleData } from "../../../interfaces/corruption/inversion/LastPickedUpCollectibleData";

const v = {
  run: {
    lastPickedUpCollectible: new Map<
      PlayerIndex,
      LastPickedUpCollectibleData
    >(),

    /**
     * Non-Inverted Pickup ActionSets Attached to collectibles need to be tracked, as they are
     * unique to the specific PickupIndex.
     */
    lastPickedUpNonInvertedCollectibleActionSet: new Map<
      PlayerIndex,
      NonInvertedPickupActionSet
    >(),
  },
};

export function lastPickedUpInvertedCollectibleInit(): void {
  mod.saveDataManager("lastPickedUpInvertedCollectible", v, false);
}

/**
 * Get the last collectible that the player picked up, plus additional data.
 *
 * CollectibleType - The Collectible the player is in the process of picking up.
 *
 * PickupStage - What stage of the inverted pickup process the player is in.
 *
 * PickupIndex - The index of the pedestal the player is picking up from.
 *
 * Inverted - Whether or not the pickup is inverted.
 */
export function getLastPickedUpCollectibleData(
  player: EntityPlayer,
): LastPickedUpCollectibleData | undefined {
  return v.run.lastPickedUpCollectible.get(getPlayerIndex(player));
}

/**
 * Set the last collectible that the player picked up, plus additional data.
 *
 * CollectibleType - The Collectible the player is in the process of picking up.
 *
 * PickupStage - What stage of the pickup process the player is in.
 *
 * PickupIndex - The index of the pedestal the player is picking up from.
 *
 * Inverted - Whether or not the pickup is inverted.
 */

export function setLastPickedUpCollectibleData(
  player: EntityPlayer,
  collectible: LastPickedUpCollectibleData | undefined,
): void {
  if (collectible === undefined) {
    v.run.lastPickedUpCollectible.delete(getPlayerIndex(player));
    return;
  }
  v.run.lastPickedUpCollectible.set(getPlayerIndex(player), collectible);
}

/**
 * Checks if the specified pedestal is in the 'PRE_GET_PEDESTAL' stage. For non-Inverted pedestals,
 * this will only consist of the 'PRE_GET_PEDESTAL' stage. For Inverted pedestals, this will consist
 * of the 'PRE_GET_PEDESTAL' and 'PRE_GET_PEDESTAL_ZAZZ' stages, as the pedestal needs to be first
 * transformed into a dummy zazz item before pickup.
 */
export function isPedestalInPreGetPedestalStage(
  pedestal: EntityPickupCollectible,
): boolean {
  const pickupData = getPedestalPickingUpData(pedestal);
  if (pickupData === undefined) {
    return false;
  }

  return (
    pickupData.pickupStage === PickupStage.PRE_GET_PEDESTAL ||
    pickupData.pickupStage === PickupStage.PRE_GET_PEDESTAL_ZAZZ
  );
}

/**
 * When the item on the pedestal has been picked up and is being held up by the player (but not in
 * the players inventory yet). Note that a new item may be on the pedestal in this stage, if the
 * player is swapping an active item for an active item.
 */
export function isPedestalInPreItemPickupStage(
  pedestal: EntityPickupCollectible,
): boolean {
  const pickupData = getPedestalPickingUpData(pedestal);
  if (pickupData === undefined) {
    return false;
  }

  return pickupData.pickupStage === PickupStage.PRE_ITEM_PICKUP;
}

/**
 * If a pedestal is in the process of being used for an Inverted Collectible pickup, the PickupData
 * will be returned. Otherwise, this returns undefined.
 */
export function getPedestalPickingUpData(
  pedestal: EntityPickupCollectible,
): LastPickedUpCollectibleData | undefined {
  const pickupDatas = [...v.run.lastPickedUpCollectible.values()];
  // eslint-disable-next-line isaacscript/no-let-any
  let match;
  for (const pickupData of pickupDatas) {
    if (
      pickupData !== undefined &&
      pickupData.pickupIndex === mod["getPickupIndex"](pedestal)
    ) {
      match = pickupData;
    }
  }

  return match;
}

/**
 * If the player is in the process of picking up an item, update the stage its in. Alternatively,
 * set it to undefined if the player is not picking up an item.
 */
export function updateLastPickedUpCollectible(
  player: EntityPlayer,
  pickupStage: PickupStage,
): void {
  const playerIndex = getPlayerIndex(player);
  if (v.run.lastPickedUpCollectible.has(playerIndex)) {
    const pickupData = v.run.lastPickedUpCollectible.get(playerIndex);

    if (pickupData === undefined) {
      fprint("Failed to get the last picked up collectible for the player.");
      return;
    }
    pickupData.pickupStage = pickupStage;
  }
}

/**
 * Gets the last pedestal the player has picked up an item from, or undefined if it cannot find one.
 * The player may be in the process of picking up an item from it.
 */
export function getLastPickedUpPedestal(
  player: EntityPlayer,
): EntityPickupCollectible | undefined {
  const pickupData = getLastPickedUpCollectibleData(player);
  if (pickupData === undefined) {
    fprint("Failed to get the last picked up pedestal for the player.");
    return undefined;
  }

  return pickupData.pedestal;
}

/**
 * Get the NonInvertedPickupActionSet attached to the last non-inverted collectible the player
 * picked up, if any.
 */
export function getLastPickedUpNonInvertedCollectibleActionSet(
  player: EntityPlayer,
): NonInvertedPickupActionSet | undefined {
  return v.run.lastPickedUpNonInvertedCollectibleActionSet.get(
    getPlayerIndex(player),
  );
}

/**
 * Set the NonInvertedPickupActionSet attached to the last non-inverted collectible the player
 * picked up, if any.
 */
export function setLastPickedUpNonInvertedCollectibleActionSet(
  player: EntityPlayer,
  actionSet: NonInvertedPickupActionSet,
): void {
  v.run.lastPickedUpNonInvertedCollectibleActionSet.set(
    getPlayerIndex(player),
    actionSet,
  );
}

/** Checks if the player is picking up a collectible using the 'lastPickedUpItem' functionality. */
export function isPlayerPickingUpItem(player: EntityPlayer): boolean {
  return v.run.lastPickedUpCollectible.has(getPlayerIndex(player));
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\pickupInversion.ts`:

```````ts
/**
 * Keeps track of and manages the inversion status of pickups, more specifically pedestals. If a
 * pedestal spawns of unknown inversion status (e.g when first loading in), it is defaulted to the
 * current game inversion status.
 */

import { CollectibleType } from "isaac-typescript-definitions";
import type { PickupIndex } from "isaacscript-common";
import { DefaultMap } from "isaacscript-common";
import { mod } from "../../../mod";
import { isGameInverted } from "./playerInversion";

/**
 * Keeps track of and manages 'inverted items'. When an item spawns, the game checks if it should be
 * inverted or not by looking at the game inversion status. If the item should be inverted, inverts
 * it.
 *
 * Non-pedestal inverted items do not automatically invert when the game is inverted. They must be
 * inverted manually and have unique properties depending on the pickup type.
 */
// TODO: Update to track all pickup inversions.

const v = {
  level: {
    /** Default pedestal inversion status is the current game inversion status. */
    isInverted: new DefaultMap<PickupIndex, boolean>(() => isGameInverted()),
  },
};

export function pickupInversionInit(): void {
  mod.saveDataManager("pickupInversion", v);
}

/** Check if the pickup is inverted. */
export function isPickupInverted(pickup: EntityPickup): boolean {
  // if (isUselessPickup(pickup)) { return false; }

  return v.level.isInverted.getAndSetDefault(mod.getPickupIndex(pickup));
}

/** Do not use. */
export function _setPedestalInversion(
  inverted: boolean,
  collectible: EntityPickupCollectible,
): void {
  if (collectible.SubType === CollectibleType.NULL) {
    return;
  }

  v.level.isInverted.set(mod.getPickupIndex(collectible), inverted);
}

/** Do not use. */
export function _setAllPedestalInversion(inverted: boolean): void {
  for (const [key, _value] of v.level.isInverted.entries()) {
    v.level.isInverted.set(key, inverted);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\playerInversion.ts`:

```````ts
/** Functions related to player and hence game inversion status. */

import type { PlayerIndex } from "isaacscript-common";
import { DefaultMap, getPlayerIndex, getPlayers } from "isaacscript-common";
import { mod } from "../../../mod";

/**
 * Tracks player inversion status. Non-Deleted's always start off un-inverted, while some Deleted
 * modes start inverted. If any one player is inverted, the game will be in an 'inverted' state.
 * Depending on the mode, the inverted state does different things. If there are more than one
 * players inverted, the game will randomly swap between inversion effects of the modes.
 * Non-deleted's can turn inverted through items or soul stones. Deleted's that are supposed to be
 * inverted-only (e.g SPYWIPER) can turn normal if they somehow get an item such as bitflip.
 */

const v = {
  run: {
    /** Describes if the player is in corrupted form. */
    inversionStatus: new DefaultMap<PlayerIndex, boolean>(false),
  },
};

export function inversionInit(): void {
  mod.saveDataManager("inversion", v);
}

/** Returns the specified players' inversion status. */
export function isPlayerInverted(player: EntityPlayer): boolean {
  return v.run.inversionStatus.getAndSetDefault(getPlayerIndex(player));
}

/**
 * Set the specified players' inversion status. This should NOT be used as a general function to
 * invert the player as it does not update the world. Should use 'invertPlayer' instead.
 */

export function _setPlayerInversion(
  player: EntityPlayer,
  inversion: boolean,
): void {
  v.run.inversionStatus.set(getPlayerIndex(player), inversion);
}

/** Returns array of inverted players. */
export function getInvertedPlayers(): EntityPlayer[] {
  const invertedPlayers: EntityPlayer[] = [];
  for (const player of getPlayers()) {
    if (isPlayerInverted(player)) {
      invertedPlayers.push(player);
    }
  }
  return invertedPlayers;
}

/** Returns true if the Game is in an inverted state. */
export function isGameInverted(): boolean {
  return getInvertedPlayers().length > 0;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\corruption\inversion\seenInvertedPickups.ts`:

```````ts
import type { PickupIndex } from "isaacscript-common";
import { mod } from "../../../mod";

const v = {
  level: {
    /** Default pedestal inversion status is the current game inversion status. */
    seenInverted: new Map<PickupIndex, boolean>(),
  },
};

export function seenInvertedPickupInit(): void {
  mod.saveDataManager("seenInvertedPickup", v);
}

/**
 * If the passed pickup has an inverted version, and the inverted version has been seen once
 * (meaning the player has been in the same room as it), this will return true.
 */
export function hasInvertedPickupBeenSeen(pickup: EntityPickup): boolean {
  return v.level.seenInverted.has(mod["getPickupIndex"](pickup));
}

export function _invertedPickupHasBeenSeen(pickup: EntityPickup): void {
  v.level.seenInverted.set(mod["getPickupIndex"](pickup), true);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\data\gameSets\callbacks\gameSetsPostGameStartedReordered.ts`:

```````ts
import { populateGameEntitySets } from "../gameEntitySetBuilder";

// POST_GAME_STARTED_REORDERED, isContinued: FALSE. Used to initialize game entity sets.
export function postGameStartedReorderedGameEntitySetBuilder(): void {
  populateGameEntitySets();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\data\gameSets\gameEntitySetBuilder.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { game, getEnumValues } from "isaacscript-common";
import type { Mods } from "../../../enums/compatibility/Mods";
import { EntityCategory } from "../../../enums/general/EntityCategory";
import {
  _clearModdedEntityIDToModMap,
  _addModdedEntityIDToModMap,
} from "../../../maps/data/moddedEntityIDToModMap";
import {
  _clearModdedEntityIDToNameSubTypeMap,
  _addModdedEntityIDToNameSubTypeMap,
} from "../../../maps/data/moddedEntityIDToNameSubType";
import type { NameSubType } from "../../../types/data/nameSubType";
import { getModdedEntityNameSubTypesFromCategory } from "../../../helper/compatibility/XML/moddedXMLParserHelper";
import { getActiveMods } from "../../../helper/compatibility/externalModHelper";
import {
  getBaseEntityIDSetFromCategory,
  getEntityIDFromNameSubType,
} from "../../../helper/entityHelper/entityIDHelper";
import { fprint } from "../../../helper/printHelper";
import {
  _getEntityIDSetEditable,
  _getEntityIDSetEditableFromCategory,
  _getMapOfCategoryToEntityIDSetFromMod,
  _getModdedEntityIDSetEditable,
  _getModdedEntityIDSetEditableFromCategory,
  _getModdedEntityIDSetEditableFromMod,
  _getModdedPickupIDSetEditableOfPickupType,
  _getNonModdedEntityIDSetEditable,
  _getNonModdedEntityIDSetEditableFromCategory,
  _getNonModdedPickupIDSetEditableOfPickupType,
  _getPickupIDSetEditableOfPickupType,
} from "./gameEntitySets";
import { getPickupTypeFromPickupID } from "../../../helper/entityHelper/pickupIDHelper";
import type { PickupID } from "../../../enums/data/ID/PickupID";
import { ModCallbackRepentogon } from "isaac-typescript-definitions";

/**
 * Upon starting or continuing a game, re-populate the game EntityID sets
 * (e.g. gameNPCIDSet, gamePickupIDSet, etc.). These sets hold reference to all non-modded and known
 * modded entities in the game for easy access.
 */
export function populateGameEntitySets(): void {
  fprint("Populating game EntityID sets..");

  // Add non-modded NPCs:
  populateNonModdedEntities();

  // Add to modded sets / maps. Sets will already be populated with base entities.
  populateModdedEntities();
}

/** Populate non-modded + modded & non-modded sets. */
function populateNonModdedEntities() {
  for (const category of getEnumValues(EntityCategory)) {
    const entityIDSet = getBaseEntityIDSetFromCategory(category);
    for (const entityID of entityIDSet) {
      addNonModdedEntityIDToSets(entityID, category);
    }
  }
}

function populateModdedEntities() {
  _clearModdedEntityIDToNameSubTypeMap();
  _clearModdedEntityIDToModMap();

  for (const activeMod of getActiveMods()) {
    for (const category of getEnumValues(EntityCategory)) {
      const moddedNameSubTypesOfCategory =
        getModdedEntityNameSubTypesFromCategory(activeMod, category);

      // If no modded nameSubTypes exist for this mod and category, skip.
      if (moddedNameSubTypesOfCategory === undefined) {
        continue;
      }

      // Go through each modded nameSubType and add it to the sets.
      for (const nameSubType of moddedNameSubTypesOfCategory) {
        const entityID = getEntityIDFromNameSubType(nameSubType);
        if (entityID === undefined) {
          continue;
        }
        addModdedEntityIDToSets(entityID, category, activeMod, nameSubType);
      }
    }
  }
}

function addModdedEntityIDToSets(
  entityID: EntityID,
  category: EntityCategory,
  activeMod: Mods,
  nameSubType: NameSubType,
) {
  // Add to entity sets.
  _getModdedEntityIDSetEditable().add(entityID);
  _getEntityIDSetEditable().add(entityID);

  // Add to category sets, creating a new set if it doesn't exist.
  _getEntityIDSetEditableFromCategory(category).add(entityID);
  _getModdedEntityIDSetEditableFromCategory(category).add(entityID);

  // Add to mod sets, creating a new set if it doesn't exist.
  _getModdedEntityIDSetEditableFromMod(activeMod).add(entityID);
  const categoryToEntityIDSetMap =
    _getMapOfCategoryToEntityIDSetFromMod(activeMod);
  let modCategorySet = categoryToEntityIDSetMap.get(category);
  if (modCategorySet === undefined) {
    modCategorySet = new Set();
    categoryToEntityIDSetMap.set(category, modCategorySet);
  }
  modCategorySet.add(entityID);

  // Add to maps.
  _addModdedEntityIDToNameSubTypeMap(entityID, nameSubType);
  _addModdedEntityIDToModMap(entityID, activeMod);

  // If it's a pickup, add to pickup sets.
  if (category === EntityCategory.PICKUP) {
    const pickupType = getPickupTypeFromPickupID(entityID as PickupID);
    _getPickupIDSetEditableOfPickupType(pickupType).add(entityID as PickupID);
    _getModdedPickupIDSetEditableOfPickupType(pickupType).add(
      entityID as PickupID,
    );
  }
}

function addNonModdedEntityIDToSets(
  entityID: EntityID,
  category: EntityCategory,
) {
  // Add to entity sets.
  _getEntityIDSetEditable().add(entityID);
  _getNonModdedEntityIDSetEditable().add(entityID);

  // Add to category sets, creating a new set if it doesn't exist.
  _getEntityIDSetEditableFromCategory(category).add(entityID);
  _getNonModdedEntityIDSetEditableFromCategory(category).add(entityID);

  // If it's a pickup, add to pickup sets.
  if (category === EntityCategory.PICKUP) {
    const pickupType = getPickupTypeFromPickupID(entityID as PickupID);
    _getPickupIDSetEditableOfPickupType(pickupType).add(entityID as PickupID);
    _getNonModdedPickupIDSetEditableOfPickupType(pickupType).add(
      entityID as PickupID,
    );
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\data\gameSets\gameEntitySets.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { DefaultMap } from "isaacscript-common";
import type { EntityCategory } from "../../../enums/general/EntityCategory";
import {
  _addModdedEntityIDToNameSubTypeMap,
  _clearModdedEntityIDToNameSubTypeMap,
} from "../../../maps/data/moddedEntityIDToNameSubType";
import {
  _addModdedEntityIDToModMap,
  _clearModdedEntityIDToModMap,
} from "../../../maps/data/moddedEntityIDToModMap";
import { mod } from "../../../mod";
import type { Mods } from "../../../enums/compatibility/Mods";
import type { PickupID } from "../../../enums/data/ID/PickupID";
import type { EntityIDTypeUnion } from "../../../types/data/IDTypes";
import type { PickupType } from "../../../enums/general/PickupType";

/**
 * This feature is responsible for generating sets filled with EntityIDs for easy access (e.g for
 * random entity spawning). It will reset per run, as the user may have disabled mods, or enabled
 * new ones.
 */
const v = {
  run: {
    /** Entity sets. */
    nonModdedEntities: new Set<EntityID>(),
    moddedEntities: new Set<EntityID>(),
    entities: new Set<EntityID>(),

    /** Entity sets for each EntityCategory. */
    entityCategorySets: new DefaultMap<EntityCategory, Set<EntityID>>(
      () => new Set<EntityID>(),
    ),
    moddedEntityCategorySets: new DefaultMap<EntityCategory, Set<EntityID>>(
      () => new Set<EntityID>(),
    ),
    nonModdedEntityCategorySets: new DefaultMap<EntityCategory, Set<EntityID>>(
      () => new Set<EntityID>(),
    ),

    /** Sets specific to mods. */
    modSets: new DefaultMap<Mods, Set<EntityID>>(() => new Set<EntityID>()),
    modCategorySets: new DefaultMap<Mods, Map<EntityCategory, Set<EntityID>>>(
      () => new Map<EntityCategory, Set<EntityID>>(),
    ),

    /** Sets specific to pickups. */
    pickupIDOfPickupTypeMap: new DefaultMap<PickupType, Set<PickupID>>(
      () => new Set<PickupID>(),
    ),
    nonModdedPickupIDOfPickupTypeMap: new DefaultMap<PickupType, Set<PickupID>>(
      () => new Set<PickupID>(),
    ),
    moddedPickupIDOfPickupTypeMap: new DefaultMap<PickupType, Set<PickupID>>(
      () => new Set<PickupID>(),
    ),
  },
};

export function gameEntitySetBuilderInit(): void {
  mod.saveDataManager("gameEntitySetBuilder", v);
}

/** Returns a set of non-modded EntityID's. */
export function getNonModdedEntityIDSet(): ReadonlySet<EntityID> {
  return v.run.nonModdedEntities;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getNonModdedEntityIDSetEditable(): Set<EntityID> {
  return v.run.nonModdedEntities;
}

/**
 * Returns a set of modded EntityIDs. Entities will only be added to this set if the mod is active
 * and tracked by this mod.
 */
export function getModdedEntityIDSet(): ReadonlySet<EntityID> {
  return v.run.moddedEntities;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getModdedEntityIDSetEditable(): Set<EntityID> {
  return v.run.moddedEntities;
}

/**
 * Returns a set of all EntityID's, modded and non-Modded. Entities will only be added to this set
 * if the mod is active and tracked by this mod.
 */
export function getEntityIDSet(): ReadonlySet<EntityID> {
  return v.run.entities;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getEntityIDSetEditable(): Set<EntityID> {
  return v.run.entities;
}

/**
 * Returns a set of non-modded EntityIDs for the given EntityCategory. Will return undefined if
 * there are no non-modded entities for the given category.
 */
export function getNonModdedEntityIDSetFromCategory<
  Type extends EntityIDTypeUnion = EntityID,
>(category: EntityCategory): ReadonlySet<Type> {
  return v.run.nonModdedEntityCategorySets.get(
    category,
  ) as unknown as ReadonlySet<Type>;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getNonModdedEntityIDSetEditableFromCategory(
  category: EntityCategory,
): Set<EntityID> {
  return v.run.nonModdedEntityCategorySets.getAndSetDefault(category);
}

/**
 * Returns a set of modded EntityIDs for the given EntityCategory. Will return undefined if there
 * are no modded entities for the given category.
 */
export function getModdedEntityIDSetFromCategory<
  Type extends EntityIDTypeUnion = EntityID,
>(category: EntityCategory): ReadonlySet<Type> {
  return v.run.moddedEntityCategorySets.getAndSetDefault(
    category,
  ) as unknown as ReadonlySet<Type>;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getModdedEntityIDSetEditableFromCategory(
  category: EntityCategory,
): Set<EntityID> {
  return v.run.moddedEntityCategorySets.getAndSetDefault(category);
}

/** Returns a set of EntityIDs for the given EntityCategory. */
export function getEntityIDSetFromCategory<
  Type extends EntityIDTypeUnion = EntityID,
>(category: EntityCategory): ReadonlySet<Type> {
  return v.run.entityCategorySets.getAndSetDefault(
    category,
  ) as unknown as ReadonlySet<Type>;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getEntityIDSetEditableFromCategory(
  category: EntityCategory,
): Set<EntityID> {
  return v.run.entityCategorySets.getAndSetDefault(category);
}

/**
 * Returns a set of modded EntityIDs for the given mod. Will return undefined if there are no modded
 * entities for the given mod.
 */
export function getModdedEntityIDSetFromMod(
  activeMod: Mods,
): ReadonlySet<EntityID> | undefined {
  return v.run.modSets.get(activeMod);
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getModdedEntityIDSetEditableFromMod(
  activeMod: Mods,
): Set<EntityID> {
  return v.run.modSets.getAndSetDefault(activeMod);
}

/**
 * Returns a set of modded EntityIDs for the given mod and EntityCategory. Will return undefined if
 * there are no modded entities for the given mod and category.
 */
export function getModdedEntityIDSetFromModAndCategory<
  Type extends EntityIDTypeUnion = EntityID,
>(activeMod: Mods, category: EntityCategory): ReadonlySet<Type> {
  return (v.run.modCategorySets.getAndSetDefault(activeMod).get(category) ??
    new Set()) as ReadonlySet<Type>;
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getMapOfCategoryToEntityIDSetFromMod(
  activeMod: Mods,
): Map<EntityCategory, Set<EntityID>> {
  return v.run.modCategorySets.getAndSetDefault(activeMod);
}

export function getPickupIDSetOfPickupType(
  pickupType: PickupType,
): ReadonlySet<PickupID> {
  return v.run.pickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getPickupIDSetEditableOfPickupType(
  pickupType: PickupType,
): Set<PickupID> {
  return v.run.pickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

export function getNonModdedPickupIDSetOfPickupType(
  pickupType: PickupType,
): ReadonlySet<PickupID> {
  return v.run.nonModdedPickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getNonModdedPickupIDSetEditableOfPickupType(
  pickupType: PickupType,
): Set<PickupID> {
  return v.run.nonModdedPickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

export function getModdedPickupIDSetOfPickupType(
  pickupType: PickupType,
): ReadonlySet<PickupID> {
  return v.run.moddedPickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

// eslint-disable-next-line isaacscript/no-mutable-return
export function _getModdedPickupIDSetEditableOfPickupType(
  pickupType: PickupType,
): Set<PickupID> {
  return v.run.moddedPickupIDOfPickupTypeMap.getAndSetDefault(pickupType);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\backdropHelper.ts`:

```````ts
import { BackdropType } from "isaac-typescript-definitions";
import { game, setBackdrop } from "isaacscript-common";
import { mod } from "../../mod";
import { hasEnteredSameRoomTwice } from "./lastRoomVisited";

const v = {
  run: {
    /** Overrides the overridden backdrop, used for the corrupted world. */
    corruptedBackdrop: false,
    realBackdrop: BackdropType.CAVES,
  },
};

export function backdropHelperInit(): void {
  mod.saveDataManager("backdropHelper", v);
}

/**
 * Permanently set the backdrop to the 'error room' backdrop. Should not use outside turning the
 * world corrupted. Will also set the corrupted floor color.
 */

export function _setCorruptedBackdrop(): void {
  if (v.run.corruptedBackdrop) {
    return;
  }

  v.run.realBackdrop = getBackdrop();
  v.run.corruptedBackdrop = true;
  setBackdrop(BackdropType.ERROR_ROOM);
}

/**
 * Remove the permanent corrupted backdrop set by 'setCorruptedBackdrop()'. Should not use outside
 * removing the corrupted status of the world.
 */

export function _removeCorruptedBackdrop(): void {
  if (!v.run.corruptedBackdrop) {
    return;
  }
  v.run.corruptedBackdrop = false;
  setBackdrop(v.run.realBackdrop);
}

/** Returns the BackdropType of the room. */
export function getBackdrop(): BackdropType {
  return game.GetRoom().GetBackdropType();
}

// POST_NEW_ROOM_REORDERED
export function backdropHelperPostNewRoomReordered(): void {
  if (!hasEnteredSameRoomTwice()) {
    v.run.realBackdrop = getBackdrop();
  }

  if (v.run.corruptedBackdrop) {
    setBackdrop(BackdropType.ERROR_ROOM);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\floorColorHelper.ts`:

```````ts
import {
  copyColor,
  deepCopy,
  getPlayerIndex,
  getPlayers,
  getRoomListIndex,
  isColor,
} from "isaacscript-common";
import { CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE } from "../../constants/corruptionConstants";
import { simplifyAndCopyColor } from "../../helper/advancedColorHelper";
import { getPlayerMainColor } from "../../helper/deletedSpecific/deletedHelper";
import {
  isWorldInverted,
  shouldInvertedWorldHaveCorruptFloorColor,
} from "../../helper/deletedSpecific/inversion/worldInversionHelper";
import { setTemporaryFloorColor } from "../../helper/floorHelper";
import type { AdvancedColor } from "../../interfaces/general/AdvancedColor";
import { mod } from "../../mod";
import { getInvertedPlayers } from "../corruption/inversion/playerInversion";
import { fprint } from "../../helper/printHelper";

const v = {
  run: {
    floorColor: new Map<number, Color | AdvancedColor | undefined>(),
  },
  room: {
    /** The 'ladder' object used to color the current floor. */
    currentFloorColorObject: undefined as EntityPtr | undefined,

    /** The 'ladder' object which is used to color the floor. */
    corruptedFloorColorObject: new Map<number, EntityEffect>(),
  },
};

export function floorColorHelper(): void {
  mod.saveDataManager("floorColorHelper", v);
}

/**
 * Sets the floor color, by rendering a white sprite on the floor layer. This is better than the
 * setFloorColor() function from the Room class as it actually does something. The floor color will
 * be specific to that room and work even after leaving the game. Use 'setTemporaryFloorColor()' to
 * temporarily change the floor color or 'removeFloorColor()' to remove the floor color for that
 * room.
 *
 * @param color The color to set the floor to, can be an AdvancedColor or Color.
 * @param roomListIndex The room list index to set the floor color for. If undefined, will use the
 *                      current room.
 * @param overrideTransparency If true, will override the transparency of the color to make it
 *                             barely visible with the default value.
 * @returns The floor EntityEffect used to color the floor. Disappears upon leaving the room or the
 *          game.
 */
export function setFloorColor(
  color: Color | AdvancedColor,
  roomListIndex?: number,
  overrideTransparency = true,
): void {
  roomListIndex ??= getRoomListIndex();
  color = deepCopy(color);
  if (overrideTransparency) {
    if (isColor(color)) {
      color.A = CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE;
    } else {
      color.color.A = CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE;
    }
  }
  v.run.floorColor.set(roomListIndex, color);
  if (v.room.currentFloorColorObject !== undefined) {
    const ladderObject = v.room.currentFloorColorObject.Ref;
    if (ladderObject !== undefined) {
      const sprite = ladderObject.GetSprite();
      const newColor = simplifyAndCopyColor(color);
      sprite.Color = newColor;
      return;
    }
  }

  // Could not find the ladder object, so we will create a new one.
  const newLadderObject = setTemporaryFloorColor(color, overrideTransparency);
  v.room.currentFloorColorObject = EntityPtr(newLadderObject);
}

/**
 * Removes the floor color set through the 'setFloorColor()' function for the specified room.
 *
 * @param roomListIndex The room list index to remove the floor color for. If undefined, will use
 *                      the current room.
 */
export function removeFloorColor(roomListIndex?: number): void {
  if (roomListIndex === undefined || roomListIndex === getRoomListIndex()) {
    v.room.currentFloorColorObject?.Ref?.Remove();
    v.room.currentFloorColorObject = undefined;
  }
  roomListIndex ??= getRoomListIndex();
  v.run.floorColor.delete(roomListIndex);
}

export function _updateCorruptedFloorColorForPlayer(
  player: EntityPlayer,
): void {
  if (!isWorldInverted()) {
    return;
  }

  const mainColor = getPlayerMainColor(player);
  const playerIndex = getPlayerIndex(player);
  v.room.corruptedFloorColorObject.get(playerIndex)?.Remove();
  if (mainColor !== undefined) {
    v.room.corruptedFloorColorObject.set(
      playerIndex,
      setTemporaryFloorColor(copyColor(mainColor)),
    );
  }
}

/**
 * Update the floor color using the new 'setTemporaryFloorColor()' function. Every inverted player
 * will cast a tint on the floor, that will overlap when multiple players are inverted. There will
 * be no corrupted floor color if the world is not corrupted.
 */
export function _updateCorruptedFloorColor(): void {
  const shouldHaveFloorColor = shouldInvertedWorldHaveCorruptFloorColor();
  if (!shouldHaveFloorColor || !isWorldInverted()) {
    removeAllCorruptedFloorColor();
    return;
  }

  // World is inverted and players should have corrupted floor colors.
  for (const invertedPlayer of getInvertedPlayers()) {
    const mainColor = getPlayerMainColor(invertedPlayer);
    if (mainColor === undefined) {
      continue;
    }
    const playerIndex = getPlayerIndex(invertedPlayer);
    v.room.corruptedFloorColorObject.get(playerIndex)?.Remove();
    v.room.corruptedFloorColorObject.set(
      playerIndex,
      setTemporaryFloorColor(copyColor(mainColor)),
    );
  }
}

/** Removes all corrupted floor color effects. */
function removeAllCorruptedFloorColor() {
  fprint("Removing all corrupted floor color effects.");
  for (const effect of v.room.corruptedFloorColorObject) {
    effect[1].Remove();
  }
  v.room.corruptedFloorColorObject.clear();
}

// POST_NEW_ROOM_REORDERED
export function floorColorHelperPostNewRoomReordered(): void {
  const roomListIndex = getRoomListIndex();
  const currentRoomFloorColor = v.run.floorColor.get(roomListIndex);
  if (currentRoomFloorColor !== undefined) {
    // Do not override transparency as that is already filtered through the initialization.
    const newLadderObject = setTemporaryFloorColor(
      currentRoomFloorColor,
      false,
    );
    v.room.currentFloorColorObject = EntityPtr(newLadderObject);
  }

  // if (isWorldInverted()) { updateCorruptedFloorColorForAllPlayers(); }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\isLeavingGame.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  room: {
    isLeaving: false,
  },
};

export function isLeavingGameInit(): void {
  mod.saveDataManager("isLeavingGame", v);
}

/**
 * Determines if the player is in the process of leaving the game (determined through PRE_GAME_EXIT
 * with a priority of Early). This is useful as certain callbacks (e.g POST_ENTITY_REMOVE) are
 * called after PRE_GAME_EXIT, so we can use this to determine if the entity is unloading due to
 * game exit or not.
 */
export function isLeavingGame(): boolean {
  return v.room.isLeaving;
}

export function isLeavingGamePreGameExitEarly(_shouldSave: boolean): void {
  v.room.isLeaving = true;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\lastRoomVisited.ts`:

```````ts
import { getRoomListIndex } from "isaacscript-common";
import { mod } from "../../mod";

const v = {
  run: {
    lastRoomVisited: undefined as number | undefined,
    currentRoom: 0 as number,
    hasEnteredSameRoomTwice: false,
  },
};

export function lastRoomVisitedInit(): void {
  mod.saveDataManager("lastRoomVisited", v);
}

/** Get the last unique room that the player has visited as the RoomListIndex. */
export function getLastRoomVisited(): number | undefined {
  return v.run.lastRoomVisited;
}

/**
 * Checks if the player has entered the current room more than once without visiting any other
 * rooms. This is great to check if the POST_NEW_ROOM_REORDERED callback should be ignored.
 */
export function hasEnteredSameRoomTwice(): boolean {
  return v.run.hasEnteredSameRoomTwice;
}

// POST_NEW_ROOM_REORDERED
export function lastRoomVisitedPostNewRoomReordered(): void {
  const currentRoomIndex = getRoomListIndex();
  v.run.currentRoom = currentRoomIndex;

  if (v.run.lastRoomVisited === currentRoomIndex) {
    v.run.hasEnteredSameRoomTwice = true;
  } else {
    v.run.hasEnteredSameRoomTwice = false;
    v.run.lastRoomVisited = v.run.currentRoom;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\lateSave.ts`:

```````ts
import { mod } from "../../mod";
import { isLeavingGame } from "./isLeavingGame";

/**
 * This feature saves save data during the POST_ENTITY_REMOVE callback with a priority of 'Late'.
 * This is useful as isaacscript saves data during the PRE_GAME_EXIT callback, which is called
 * before POST_ENTITY_REMOVE, allowing us to make changes to SaveData during the POST_ENTITY_REMOVE
 * callback. The downside is that this feature will save data every time an entity is removed after
 * a game exit, potentially causing a lag spike.
 */
export function lateSavePostEntityRemoveLate(_entity: Entity): void {
  if (isLeavingGame()) {
    mod.saveDataManagerSave();
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\playerStats.ts`:

```````ts
import { CacheFlag } from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  DefaultMap,
  defaultMapGetPlayer,
  defaultMapSetPlayer,
} from "isaacscript-common";
import { triggerCacheUpdate } from "../../helper/statHelper";
import { mod } from "../../mod";

const STAT_CACHE_FLAGS_SET: ReadonlySet<CacheFlag> = new Set([
  CacheFlag.DAMAGE, // 1 << 0
  CacheFlag.FIRE_DELAY, // 1 << 1
  CacheFlag.SHOT_SPEED, // 1 << 2
  CacheFlag.RANGE, // 1 << 3
  CacheFlag.SPEED, // 1 << 4
  CacheFlag.LUCK, // 1 << 10
]);

/**
 * Responsible for the tracking of player stats during a run. These stats are additional stat
 * changes unique to this mod that will be applied in the EVALUATE_CACHE callback.
 *
 * These stat changes are not dynamic, so if an item gives +1 damage and you use this feature to
 * give damage, the damage will not be removed if the item is removed.
 */

const v = {
  run: {
    damage: new DefaultMap<PlayerIndex, number>(0),
    speed: new DefaultMap<PlayerIndex, number>(0),
    tears: new DefaultMap<PlayerIndex, number>(0),
    luck: new DefaultMap<PlayerIndex, number>(0),
    range: new DefaultMap<PlayerIndex, number>(0),
    shotSpeed: new DefaultMap<PlayerIndex, number>(0),
  },
};

export function playerStatsInit(): void {
  mod.saveDataManager("playerStats", v);
}

export function getStaticStat(
  player: EntityPlayer,
  cacheFlag: CacheFlag,
): number {
  if (!STAT_CACHE_FLAGS_SET.has(cacheFlag)) {
    error(
      `You cannot get a static player stat with the cache flag of: ${cacheFlag}`,
    );
  }

  switch (cacheFlag) {
    // 1 << 0
    case CacheFlag.DAMAGE: {
      return defaultMapGetPlayer(v.run.damage, player);
    }

    // 1 << 1
    case CacheFlag.FIRE_DELAY: {
      return defaultMapGetPlayer(v.run.tears, player);
    }

    // 1 << 2
    case CacheFlag.SHOT_SPEED: {
      return defaultMapGetPlayer(v.run.shotSpeed, player);
    }

    // 1 << 3
    case CacheFlag.RANGE: {
      return defaultMapGetPlayer(v.run.range, player);
    }

    // 1 << 4
    case CacheFlag.SPEED: {
      return defaultMapGetPlayer(v.run.speed, player);
    }

    // 1 << 10
    case CacheFlag.LUCK: {
      return defaultMapGetPlayer(v.run.luck, player);
    }
  }
  error("PlayerStats: CacheFlag does not exist!");
}

/**
 * Add a static stat to the player, which can be positive or negative. Call this function in any
 * callback, which will also trigger a cache evaluation. This only includes:
 *
 * CacheFlag.DAMAGE, // 1 << 0 CacheFlag.FIRE_DELAY, // 1 << 1 CacheFlag.SHOT_SPEED, // 1 << 2
 * CacheFlag.RANGE, // 1 << 3 CacheFlag.SPEED, // 1 << 4 CacheFlag.LUCK, // 1 << 10.
 *
 * To set tearColor, use addTearColorToPlayer().
 */
export function addStatToPlayer(
  player: EntityPlayer,
  cacheFlag: CacheFlag,
  amount: number,
): void {
  switch (cacheFlag) {
    // 1 << 0
    case CacheFlag.DAMAGE: {
      const newValue = defaultMapGetPlayer(v.run.damage, player) + amount;
      defaultMapSetPlayer(v.run.damage, player, newValue);
      break;
    }

    // 1 << 1
    case CacheFlag.FIRE_DELAY: {
      const newValue = defaultMapGetPlayer(v.run.tears, player) + amount;
      defaultMapSetPlayer(v.run.tears, player, newValue);
      break;
    }

    // 1 << 2
    case CacheFlag.SHOT_SPEED: {
      const newValue = defaultMapGetPlayer(v.run.shotSpeed, player) + amount;
      defaultMapSetPlayer(v.run.shotSpeed, player, newValue);
      break;
    }

    // 1 << 3
    case CacheFlag.RANGE: {
      const newValue = defaultMapGetPlayer(v.run.range, player) + amount;
      defaultMapSetPlayer(v.run.range, player, newValue);
      break;
    }

    // 1 << 4
    case CacheFlag.SPEED: {
      const newValue = defaultMapGetPlayer(v.run.speed, player) + amount;
      defaultMapSetPlayer(v.run.speed, player, newValue);
      break;
    }

    // 1 << 10
    case CacheFlag.LUCK: {
      const newValue = defaultMapGetPlayer(v.run.luck, player) + amount;
      defaultMapSetPlayer(v.run.luck, player, newValue);
      break;
    }
  }
  triggerCacheUpdate(player, cacheFlag);
}

// EVALUATE_CACHE
export function playerStatsEvaluateCache(
  player: EntityPlayer,
  cacheFlag: CacheFlag,
): void {
  if (STAT_CACHE_FLAGS_SET.has(cacheFlag)) {
    // addStat(player, cacheFlag, getStaticStat(player, cacheFlag));
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\RNGHelper.ts`:

```````ts
import { game, newRNG } from "isaacscript-common";
import { mod } from "../../mod";

const v = {
  run: {
    RNG: undefined as RNG | undefined,
  },
};

export function RNGHelperInit(): void {
  mod.saveDataManager("RNGHelper", v);
}

export function getRunRNG(): RNG {
  const startingSeed = game.GetSeeds().GetStartSeed();
  if (v.run.RNG === undefined) {
    v.run.RNG = newRNG(startingSeed);
  }
  return v.run.RNG;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\spriteCache.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { newCollectibleSprite } from "isaacscript-common";

const spriteCache = new Map<CollectibleType, Sprite>();

/**
 * Returns a collectible sprite from the collectible sprite cache, and if one does not exist yet,
 * creates it using 'newCollectibleSprite()'. These sprites should be static and not used for
 * animations.
 */
export function getCollectibleSpriteFromCache(
  collectibleType: CollectibleType,
): Sprite {
  const sprite = spriteCache.get(collectibleType);

  if (sprite !== undefined) {
    return sprite;
  }

  const newSprite = newCollectibleSprite(collectibleType);
  spriteCache.set(collectibleType, newSprite);

  return newSprite;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\general\temporaryItems.ts`:

```````ts
/**
 * This file aids in giving players temporary or permanent 'invisible' collectibles and trinkets
 * using the TemporaryEffects class.
 *
 * Temporary effects added to the player are removed upon leaving the room or exiting/continuing, so
 * this should be accounted for.
 *
 * Additionally, some effects do not work correctly, so the player should be given the item instead.
 *
 * Temporary effects can last the room or floor, or other lengths defined in TemporaryEffectType
 * enum.
 */

import type {
  CollectibleType,
  DamageFlag,
  TrinketType,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  arrayRemove,
  DefaultMap,
  defaultMapGetPlayer,
  defaultMapSetPlayer,
  game,
  getPlayerFromIndex,
  smeltTrinket,
} from "isaacscript-common";
import { TemporaryEffectType } from "../../enums/general/TemporaryEffectType";
import { mod } from "../../mod";
import { doesCollectibleEffectWork } from "../../sets/workingCollectibleEffects";

const INCLUDE_PARTLY_WORKING = true;
const FIRST_TIME_PICKING_UP = false;

const v = {
  run: {
    permanentCollectibleEffects: new DefaultMap<PlayerIndex, CollectibleType[]>(
      () => [],
    ),
    temporaryOnHitCollectibleEffects: new DefaultMap<
      PlayerIndex,
      CollectibleType[]
    >(() => []),
    temporaryOnHitCollectibles: new DefaultMap<PlayerIndex, CollectibleType[]>(
      () => [],
    ),
    temporaryOnHitTrinkets: new DefaultMap<PlayerIndex, TrinketType[]>(
      () => [],
    ),
    temporaryLevelCollectibleEffects: new DefaultMap<
      PlayerIndex,
      CollectibleType[]
    >(() => []),
    temporaryLevelCollectibles: new DefaultMap<PlayerIndex, CollectibleType[]>(
      () => [],
    ),
    temporaryLevelTrinkets: new DefaultMap<PlayerIndex, TrinketType[]>(
      () => [],
    ),

    /** Temporary effects which automatically are removed next room. */
    temporaryRoomCollectibleEffects: new DefaultMap<
      PlayerIndex,
      CollectibleType[]
    >(() => []),

    /** Collectibles that are actually given to the player and removed next room. */
    temporaryRoomCollectibles: new DefaultMap<PlayerIndex, CollectibleType[]>(
      () => [],
    ),
    temporaryRoomTrinkets: new DefaultMap<PlayerIndex, TrinketType[]>(() => []),

    /**
     * Used to check if POST_NEW_ROOM_REORDERED firing is on save/continue, or actually going to a
     * new room.
     */
    roomIndex: 0,
  },
};

export function temporaryItemsInit(): void {
  mod.saveDataManager("temporaryItems", v);
}

// TODO: Make function to check if Damage is from a 'hostile' source (e.g Blood Banks shouldn't remove temp items).
export function temporaryItemsPlayerTakeDMG(
  entity: Entity,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  const player = entity.ToPlayer();
  if (player === undefined) {
    return;
  }

  // Remove temporary collectibles that are on hit.
  removeTemporaryCollectiblesFromPlayer(
    v.run.temporaryOnHitCollectibles,
    player,
  );

  // Remove temporary trinkets that are on hit.
  removeTemporaryTrinketsFromPlayer(v.run.temporaryOnHitTrinkets, player);

  // Remove temporary collectible effects that are on hit.
  removeTemporaryCollectibleEffectsFromPlayer(
    v.run.temporaryOnHitCollectibleEffects,
    player,
  );
  return undefined;
}

export function temporaryItemsPreNewLevel(player: EntityPlayer): void {
  removeTemporaryCollectibles(v.run.temporaryLevelCollectibles);
  removeTemporaryTrinkets(v.run.temporaryLevelTrinkets);
  for (const value of v.run.temporaryLevelCollectibleEffects) {
    value.splice(0);
  }
}

export function temporaryItemsPostNewRoomReordered(): void {
  const currentRoomIndex = game.GetLevel().GetCurrentRoomIndex();

  if (currentRoomIndex === v.run.roomIndex) {
    // If the room is the same (e.g save & continue), reapply temporary effects.
    reapplyTemporaryCollectibleEffects(v.run.temporaryRoomCollectibleEffects);
  } else {
    // If the room is different, remove temporary collectibles and trinkets.
    removeTemporaryCollectibles(v.run.temporaryRoomCollectibles);
    removeTemporaryTrinkets(v.run.temporaryRoomTrinkets);
    // Temporary effects automatically disappear so we only have to remove them from the arrays.
    for (const value of v.run.temporaryRoomCollectibleEffects) {
      value.splice(0);
    }
  }

  // Floor temporary effects need to be reapplied in every new room instance (they are removed
  // before this callback is called for the new floor).
  reapplyTemporaryCollectibleEffects(v.run.temporaryLevelCollectibleEffects);
  // On hit effects need to be reapplied.
  reapplyTemporaryCollectibleEffects(v.run.temporaryOnHitCollectibleEffects);

  /** Permanent effects need to be reapplied. */
  reapplyTemporaryCollectibleEffects(v.run.permanentCollectibleEffects);

  v.run.roomIndex = currentRoomIndex;
}

/**
 * Add a temporary trinket to the player. This will be in the form of a smelted trinket (I don't
 * think TrinketEffects work). A duration can be specified, dictating when the collectible will be
 * removed.
 *
 * Default duration is 'room'.
 */
export function playerAddTemporaryTrinket(
  player: EntityPlayer,
  trinket: TrinketType,
  duration: TemporaryEffectType = TemporaryEffectType.ROOM,
): void {
  smeltTrinket(player, trinket);
  switch (duration) {
    case TemporaryEffectType.ROOM: {
      defaultMapGetPlayer(v.run.temporaryRoomTrinkets, player).push(trinket);

      break;
    }

    case TemporaryEffectType.LEVEL: {
      defaultMapGetPlayer(v.run.temporaryLevelTrinkets, player).push(trinket);

      break;
    }

    case TemporaryEffectType.ON_HIT: {
      defaultMapGetPlayer(v.run.temporaryOnHitTrinkets, player).push(trinket);

      break;
    }
    // No default
  }
}

/**
 * Add a temporary collectible to the player. This will either be an actual collectible, or a
 * collectible effect. A duration can be specified, dictating when the collectible will be removed.
 *
 * Default duration is 'room'. Returns true if added a collectible effect, false if added a
 * collectible.
 */
export function playerAddTemporaryCollectible(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  duration: TemporaryEffectType = TemporaryEffectType.ROOM,
): boolean {
  const isEffectWorking = doesCollectibleEffectWork(
    collectibleType,
    INCLUDE_PARTLY_WORKING,
  );
  if (isEffectWorking) {
    player
      .GetEffects()
      .AddCollectibleEffect(collectibleType as TemporaryCollectibleType);
    switch (duration) {
      case TemporaryEffectType.ROOM: {
        defaultMapGetPlayer(v.run.temporaryRoomCollectibleEffects, player).push(
          collectibleType,
        );

        break;
      }

      case TemporaryEffectType.LEVEL: {
        defaultMapGetPlayer(
          v.run.temporaryLevelCollectibleEffects,
          player,
        ).push(collectibleType);

        break;
      }

      case TemporaryEffectType.ON_HIT: {
        defaultMapGetPlayer(
          v.run.temporaryOnHitCollectibleEffects,
          player,
        ).push(collectibleType);

        break;
      }

      case TemporaryEffectType.PERMANENT: {
        defaultMapGetPlayer(v.run.permanentCollectibleEffects, player).push(
          collectibleType,
        );

        break;
      }
      // No default
    }
    return true;
  }
  player.AddCollectible(collectibleType, undefined, FIRST_TIME_PICKING_UP);
  switch (duration) {
    case TemporaryEffectType.ROOM: {
      defaultMapGetPlayer(v.run.temporaryRoomCollectibles, player).push(
        collectibleType,
      );

      break;
    }

    case TemporaryEffectType.LEVEL: {
      defaultMapGetPlayer(v.run.temporaryLevelCollectibles, player).push(
        collectibleType,
      );

      break;
    }

    case TemporaryEffectType.ON_HIT: {
      defaultMapGetPlayer(v.run.temporaryOnHitCollectibles, player).push(
        collectibleType,
      );

      break;
    }
    // No default
  }

  return false;
}

/**
 * Remove a permanent collectible effect from the player (that is set to reapply every room). If the
 * player does not have one of the specified collectibleType, does nothing. Will only remove one if
 * the player has multiple of the same type.
 *
 * Use 'addCollectibleOrEffect()' to add.
 */
export function playerRemovePermanentCollectibleEffect(
  player: EntityPlayer,
  collectible: CollectibleType,
): void {
  const permCollectibles = defaultMapGetPlayer(
    v.run.permanentCollectibleEffects,
    player,
  );
  player.GetEffects().RemoveCollectibleEffect(collectible);
  const newArray = arrayRemove<CollectibleType>(permCollectibles, collectible);
  defaultMapSetPlayer(v.run.permanentCollectibleEffects, player, newArray);
}

/** Temporary effects disappear upon saving and continuing, so this function reapplies them. */
function reapplyTemporaryCollectibleEffects(
  map: DefaultMap<PlayerIndex, CollectibleType[]>,
) {
  for (const [playerIndex, temporaryCollectibles] of map.entries()) {
    if (temporaryCollectibles.length > 0) {
      const player = getPlayerFromIndex(playerIndex);
      if (player !== undefined) {
        for (const collectibleType of temporaryCollectibles) {
          player
            .GetEffects()
            .AddCollectibleEffect(collectibleType as TemporaryCollectibleType);
        }
      }
    }
  }
}

/**
 * Removes temporary collectibles from all players in the specified map (e.g upon going to the next
 * room), also updating the map.
 */
function removeTemporaryCollectibles(
  map: DefaultMap<PlayerIndex, CollectibleType[]>,
) {
  for (const [playerIndex, collectibleTypes] of map.entries()) {
    if (collectibleTypes.length > 0) {
      const player = getPlayerFromIndex(playerIndex);
      if (player !== undefined) {
        for (const collectibleType of collectibleTypes) {
          player.RemoveCollectible(collectibleType);
        }
      }
      collectibleTypes.splice(0);
    }
  }
}

/**
 * Removes temporary trinkets from all players in the specified map (e.g upon going to the next
 * room), also updating the map.
 */
function removeTemporaryTrinkets(map: DefaultMap<PlayerIndex, TrinketType[]>) {
  for (const [playerIndex, trinketTypes] of map.entries()) {
    if (trinketTypes.length > 0) {
      const player = getPlayerFromIndex(playerIndex);
      if (player !== undefined) {
        for (const trinketType of trinketTypes) {
          player.TryRemoveTrinket(trinketType);
        }
      }
      trinketTypes.splice(0);
    }
  }
}

/**
 * Removes temporary collectibles from specified players in the specified map (e.g upon being hit),
 * also updating the map.
 */
function removeTemporaryCollectiblesFromPlayer(
  map: DefaultMap<PlayerIndex, CollectibleType[]>,
  player: EntityPlayer,
) {
  const collectibleTypes = defaultMapGetPlayer(map, player);
  if (collectibleTypes.length > 0) {
    for (const collectibleType of collectibleTypes) {
      player.RemoveCollectible(collectibleType);
    }
    collectibleTypes.splice(0);
  }
}

/**
 * Removes temporary trinkets from specified players in the specified map (e.g upon being hit), also
 * updating the map.
 */
function removeTemporaryTrinketsFromPlayer(
  map: DefaultMap<PlayerIndex, TrinketType[]>,
  player: EntityPlayer,
) {
  const trinketTypes = defaultMapGetPlayer(map, player);
  if (trinketTypes.length > 0) {
    for (const trinketType of trinketTypes) {
      player.TryRemoveTrinket(trinketType);
    }
    trinketTypes.splice(0);
  }
}

function removeTemporaryCollectibleEffectsFromPlayer(
  map: DefaultMap<PlayerIndex, CollectibleType[]>,
  player: EntityPlayer,
) {
  const playerTemporaryCollectibles = defaultMapGetPlayer(map, player);
  if (playerTemporaryCollectibles.length > 0) {
    const playerEffects = player.GetEffects();
    for (const collectibleType of playerTemporaryCollectibles) {
      playerEffects.RemoveCollectibleEffect(collectibleType);
    }
    playerTemporaryCollectibles.splice(0);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\bitflip.ts`:

```````ts
import { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import { invertPlayer } from "../../helper/deletedSpecific/inversion/playerInversion";

export function bitflipPostUseItem(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
): boolean {
  return bitFlipUse(player);
}

/**
 * On bitflip, invert the players' inversion status. Additionally, change inversion status of all
 * pre-existing items on the floor to that of the players' new inversion status.
 */
function bitFlipUse(player: EntityPlayer): boolean {
  invertPlayer(player);
  return false;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\d14.ts`:

```````ts
import { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import { getCollectibles } from "isaacscript-common";
import { SoundEffectCustom } from "../../enums/general/SoundEffectCustom";
import {
  setAllPedestalsOnLevelInversion,
  setPedestalInversion,
} from "../../helper/deletedSpecific/inversion/pedestalInversion";
import { fprint } from "../../helper/printHelper";
import { generateInvertedItemActionSetFromPlayer } from "../corruption/corruptionGeneration";

const D14_SFX = SoundEffectCustom.ROLL_DICE;

export function d14PostUseItem(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  return d14Use(player);
}

/**
 * On D-14 use, reroll all items in the room and make them inverted. If they are already inverted
 * they will just be rerolled.
 */
function d14Use(
  player: EntityPlayer,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  /**
   * We need to set all pedestals in the room to not be inverted, as the D6 use on inverted
   * pedestals will trigger default InvertedActionSet generation before the D14 triggers its own
   * InvertedActionSet generation.
   */
  setAllPedestalsOnLevelInversion(false);
  fprint("D-14 used.");
  player.UseActiveItem(CollectibleType.D6, UseFlag.NO_ANIMATION);
  getCollectibles().forEach((collectible) => {
    setPedestalInversion(
      true,
      collectible,
      generateInvertedItemActionSetFromPlayer(player),
    );
  });
  SFXManager().Play(D14_SFX);
  return { Discharge: true, Remove: false, ShowAnim: true };
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\extract.ts`:

```````ts
import { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import { extractPickup } from "../../helper/deletedSpecific/items/extractHelper";
import { getClosestPickupTo } from "../../helper/entityHelper";
import { fprint } from "../../helper/printHelper";

// POST_USE_ITEM
export function extractPostUseItem(
  _collectibleType: CollectibleType,
  _rng: RNG,
  player: EntityPlayer,
  _useFlags: BitFlags<UseFlag>,
  _activeSlot: int,
  _customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  /** Extract targets the closest pickup. */
  const closestPickup = getClosestPickupTo(player.Position);
  if (closestPickup === undefined) {
    fprint("No pickups to extract.");
    return;
  }

  extractPickup(closestPickup);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\extractVariants\extractFire.ts`:

```````ts
import { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import {
  getClosestEntityTo,
  getNPCs,
  getPickups,
  isPickup,
} from "isaacscript-common";
import { extractPickup } from "../../../helper/deletedSpecific/items/extractHelper";
import { fprint } from "../../../helper/printHelper";

// POST_USE_ITEM
export function extractFirePostUseItem(
  _collectibleType: CollectibleType,
  _rng: RNG,
  player: EntityPlayer,
  _useFlags: BitFlags<UseFlag>,
  _activeSlot: int,
  _customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  /** Extract targets the closest pickup. */
  const closestPickup = getClosestEntityTo(player, [
    ...getPickups(),
    ...getNPCs(),
  ]);
  if (closestPickup === undefined) {
    fprint("Nothing to extract_fire.");
    return;
  }

  if (isPickup(closestPickup)) {
    extractPickup(closestPickup);
  } else {
  }
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\eyes\eye1.ts`:

```````ts
import {
  ActiveSlot,
  CollectibleType,
  UseFlag,
} from "isaac-typescript-definitions";
import { fprint } from "../../../helper/printHelper";
import { eyeBlink, shouldEyeDegrade } from "./eyeGeneral";

export function eye1PostUseItem(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  return eye1Use(player, activeSlot);
}

function eye1Use(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  fprint("Using MYDOOM eye which is in stage 1...");
  if (shouldEyeDegrade()) {
    fprint("MYDOOM eye has degraded! (destroyed)");
    return {
      Discharge: false,
      Remove: false,
      ShowAnim: false,
    };
  }

  eyeBlink();

  return { Discharge: false, Remove: false, ShowAnim: false };
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\eyes\eye2.ts`:

```````ts
import {
  ActiveSlot,
  CollectibleType,
  UseFlag,
} from "isaac-typescript-definitions";
import { CollectibleTypeCustom } from "../../../enums/general/CollectibleTypeCustom";
import { replaceActiveItem } from "../../../helper/collectibleHelper";
import { fprint } from "../../../helper/printHelper";
import { eyeBlink, shouldEyeDegrade } from "./eyeGeneral";

export function eye2PostUseItem(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  return eye2Use(player, activeSlot);
}

function eye2Use(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  fprint("Using MYDOOM eye which is in stage 2...");
  if (shouldEyeDegrade()) {
    fprint("MYDOOM eye has degraded! (stage 2 -> stage 1)");
    replaceActiveItem(
      player,
      activeSlot,
      CollectibleTypeCustom.MYDOOM_EYE_STAGE_1,
    );
    return {
      Discharge: false,
      Remove: false,
      ShowAnim: false,
    };
  }

  eyeBlink();

  return { Discharge: false, Remove: false, ShowAnim: false };
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\eyes\eye3.ts`:

```````ts
import {
  ActiveSlot,
  CollectibleType,
  UseFlag,
} from "isaac-typescript-definitions";
import { CollectibleTypeCustom } from "../../../enums/general/CollectibleTypeCustom";
import { replaceActiveItem } from "../../../helper/collectibleHelper";
import { fprint } from "../../../helper/printHelper";
import { eyeBlink, shouldEyeDegrade } from "./eyeGeneral";

export function eye3PostUseItem(
  collectibleType: CollectibleType,
  rng: RNG,
  player: EntityPlayer,
  useFlags: BitFlags<UseFlag>,
  activeSlot: int,
  customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  return eye3Use(player, activeSlot);
}

function eye3Use(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  fprint("Using MYDOOM eye which is in stage 3...");
  if (shouldEyeDegrade()) {
    fprint("MYDOOM eye has degraded! (stage 3 -> stage 2)");
    replaceActiveItem(
      player,
      activeSlot,
      CollectibleTypeCustom.MYDOOM_EYE_STAGE_2,
    );
    return {
      Discharge: false,
      Remove: false,
      ShowAnim: false,
    };
  }

  eyeBlink();

  return { Discharge: false, Remove: false, ShowAnim: false };
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\eyes\eyeGeneral.ts`:

```````ts
import { getNPCs, getProjectiles } from "isaacscript-common";
import { MYDOOM_EYE_CHANCE_TO_DEGRADE } from "../../../constants/items/MYDOOMEyeConstants";
import { rollPercentage } from "../../../types/general/Percentage";

/** General function called from POST_USE_ITEM that is shared between all MYDOOM eye stages. */
export function shouldEyeDegrade(): boolean {
  if (rollPercentage(MYDOOM_EYE_CHANCE_TO_DEGRADE)) {
    return true;
  }

  return false;
}

/** The physical and visual effect from a blink of any stage of the MYDOOM eye. */
export function eyeBlink(): void {
  getProjectiles().forEach((projectile) => {
    projectile.Remove();
  });
  getNPCs().forEach((npc) => {
    if (npc.HitPoints <= 100) {
      npc.Remove();
    } else {
      npc.HitPoints -= 100;
    }
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\items\trash.ts`:

```````ts
import { CollectibleType, UseFlag } from "isaac-typescript-definitions";
import { sfxManager } from "isaacscript-common";
import { SoundEffectCustom } from "../../enums/general/SoundEffectCustom";
import {
  getLatestItemInPlayerInventory,
  isPlayerInventoryEmpty,
} from "../../helper/inventoryHelper";

const SUCCESSFUL_TRASH_SFX = SoundEffectCustom.TRASH;

export function trashPostUseItem(
  _collectibleType: CollectibleType,
  _rng: RNG,
  player: EntityPlayer,
  _useFlags: BitFlags<UseFlag>,
  _activeSlot: int,
  _customVarData: int,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  return trashUse(player);
}

/**
 * Trashes the latest item the player has picked up. This can include active items.
 *
 * TODO?: Stop it removing pocket items, and add rewards.
 */
function trashUse(
  player: EntityPlayer,
):
  | boolean
  | { Discharge: boolean; Remove: boolean; ShowAnim: boolean }
  | undefined {
  if (isPlayerInventoryEmpty(player)) {
    return;
  }

  const latestItemInInventory = getLatestItemInPlayerInventory(player);
  if (latestItemInInventory === undefined) {
    return;
  }
  player.RemoveCollectible(latestItemInInventory);
  sfxManager.Play(SUCCESSFUL_TRASH_SFX);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\BATTLEYE\BATTLEYE.ts`:

```````ts
/** Initiate the player to the BATTLEYE mode. */
export function battleyeModeSetup(player: EntityPlayer): void {}

/** When the player swaps out from BATTLEYE mode. */
export function battleyeModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\CRYPTOLOCKER\CRYPTOLOCKER.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.CRYPTOLOCKER;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function cryptolockerInit(): void {
  mod.saveDataManager("cryptolocker", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function cryptolockerModeSetup(player: EntityPlayer): void {
  fprint(`CRYPTOLOCKER: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function cryptolockerModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\HAPPY99\HAPPY99.ts`:

```````ts
import { EffectVariant } from "isaac-typescript-definitions";
import { getPlayerIndex, spawnEffect } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.HAPPY99;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function happy99Init(): void {
  mod.saveDataManager("happy99", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function happy99ModeSetup(player: EntityPlayer): void {
  fprint(`HAPPY99: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function happy99ModeFin(player: EntityPlayer): void {}

/** Death fireworks effect */
export function happy99PostPlayerFatalDamage(
  player: EntityPlayer,
): boolean | undefined {
  spawnEffect(EffectVariant.FIREWORKS, 0, player.Position);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\HICURDISMOS\HICURDISMOS.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.HICURDISMOS;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function hicurdismosInit(): void {
  mod.saveDataManager("hicurdismos", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function hicurdismosModeSetup(player: EntityPlayer): void {
  fprint(`HICURDISMOS: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function hicurdismosModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\ILOVEYOU\ILOVEYOU.ts`:

```````ts
import type { DamageFlag } from "isaac-typescript-definitions";
import { CollectibleType, SoundEffect } from "isaac-typescript-definitions";
import {
  getPlayerIndex,
  getPlayersOfType,
  sfxManager,
} from "isaacscript-common";
import { PlayerTypeCustom } from "../../../enums/general/PlayerTypeCustom";
import { SoundEffectCustom } from "../../../enums/general/SoundEffectCustom";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.ILOVEYOU;
const MODE_DATA = getModeData(MODE);

const PERSISTENT_COLLECTIBLE_EFFECT = CollectibleType.MOMS_EYESHADOW;

export function iLoveYouInit(): void {
  mod.saveDataManager("iLoveYou", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function iLoveYouModeSetup(player: EntityPlayer): void {
  fprint(`ILOVEYOU: Mode init for player: ${getPlayerIndex(player)}`);
  player
    .GetEffects()
    .AddCollectibleEffect(PERSISTENT_COLLECTIBLE_EFFECT, false);
}

/** When the player swaps out from ILOVEYOU mode. */
export function iLoveYouModeFin(player: EntityPlayer): void {
  player.GetEffects().RemoveCollectibleEffect(PERSISTENT_COLLECTIBLE_EFFECT);
}

/** Make sure ILOVEYOU player keeps collectible effect. */
// TODO: Fix
export function iLoveYouPostNewRoom(): void {
  const iLoveYouPlayers = getPlayersOfType(PlayerTypeCustom.DELETED_ILOVEYOU);
  for (const player of iLoveYouPlayers) {
    player
      .GetEffects()
      .AddCollectibleEffect(PERSISTENT_COLLECTIBLE_EFFECT, false);
  }
}

export function iloveyouPlayerCollision(
  player: EntityPlayer,
  collider: Entity,
): boolean | undefined {
  sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 1);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 2);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 3);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 4);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 5);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 6);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 7);
  return undefined;
}

export function iloveyouPlayerTakeDMG(
  player: EntityPlayer,
  amount: float,
  damageFlags: BitFlags<DamageFlag>,
  source: EntityRef,
  countdownFrames: int,
): boolean | undefined {
  sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  sfxManager.Play(SoundEffect.KISS_LIPS);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 1);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 2);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 3);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 4);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 5);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 6);
  mod.runInNRenderFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_HURT_GRUNT);
  }, 7);
  return undefined;
}

/** Death kiss effect */
// TODO: Make it audible.
export function iloveyouPostPlayerFatalDamage(
  player: EntityPlayer,
): boolean | undefined {
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
    sfxManager.Play(SoundEffectCustom.KISS);
  }, 5);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 6);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 7);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 8);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 9);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 10);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 11);
  mod.runInNGameFrames(() => {
    sfxManager.Stop(SoundEffect.ISAAC_DIES);
  }, 12);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\JERUSALEM\JERUSALEM.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.JERUSALEM;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function jerusalemInit(): void {
  mod.saveDataManager("jerusalem", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function jerusalemModeSetup(player: EntityPlayer): void {
  fprint(`JERUSALEM: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function jerusalemModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\MEMZ\MEMZ.ts`:

```````ts
import { mod } from "../../../mod";

const v = {};

export function memzInit(): void {
  mod.saveDataManager("memz", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function memzModeInit(player: EntityPlayer): void {}

/** Initiate the player to be HAPPY99 in the MEMZ mode. */
export function memzModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\mode.ts`:

```````ts
import type { PlayerType } from "isaac-typescript-definitions";
import { ActiveSlot } from "isaac-typescript-definitions";
import {
  addCollectible,
  getPlayerIndex,
  setActiveItem,
  setPlayerHealth,
  sfxManager,
} from "isaacscript-common";
import { Mode } from "../../enums/modes/Mode";
import {
  isModeTainted,
  isPlayerDeleted,
} from "../../helper/deletedSpecific/deletedHelper";
import {
  invertPlayerToInversion,
  updateWorldInversion,
} from "../../helper/deletedSpecific/inversion/playerInversion";
import {
  setPlayerBombs,
  setPlayerCoins,
  setPlayerKeys,
} from "../../helper/playerHelper";
import { fprint } from "../../helper/printHelper";
import { getModeFin, getModeInit } from "../../maps/modes/modeInitMap";
import {
  getModeData,
  getModeFromPlayerType,
  getModePlayerType,
  getModeVoiceover,
} from "../../maps/modes/modeMap";
import { mod } from "../../mod";
import { setPlayerInvertedItemActionSetBuilderReference } from "../corruption/corruptionGeneration";

/** Responsible for keeping track of Deleted's modes. */

const v = {
  persistent: {
    /** The mode N.Deleted will be upon starting a run. */
    normalMode: Mode.HAPPY99,

    /** The mode T.Deleted will be upon starting a run. */
    taintedMode: Mode.SOPHOS,
  }, // NOTE: There are currently no checks in place to
};

export function modeInit(): void {
  mod.saveDataManager("mode", v);
}

/**
 * Get the real mode of the deleted player. Returns undefined if player is not a PlayerType which
 * corresponds to a mode (e.g not a Deleted).
 */
export function getCurrentPlayerMode(player: EntityPlayer): Mode | undefined {
  return getModeFromPlayerType(player.GetPlayerType());
}

/**
 * Set the current mode of the Deleted player. Set up any mode specific settings. If the player is
 * not Deleted, does nothing.
 */
export function setPlayerMode(player: EntityPlayer, mode: Mode): void {
  if (!isPlayerDeleted(player)) {
    return;
  }
  if (getModePlayerType(mode) !== player.GetPlayerType()) {
    player.ChangePlayerType(getModePlayerType(mode));
    return;
  }
  // TODO:
  setPersistentMode(mode);
  // Setup player.
  const modeData = getModeData(mode);
  // Load anm2:
  if (modeData.anm2File !== undefined) {
    player.GetSprite().Load(modeData.anm2File, true);
    // We have to play an animation to prevent body from temporarily disappearing.
    player.PlayExtraAnimation("Glitch");
  }
  // Consumables:
  setPlayerBombs(player, modeData.startingBombs);
  setPlayerKeys(player, modeData.startingKeys);
  setPlayerCoins(player, modeData.startingCoins);
  // Health:
  setPlayerHealth(player, modeData.startingHealth);
  // Items:
  if (modeData.startingPocket !== undefined) {
    setActiveItem(player, modeData.startingPocket, ActiveSlot.POCKET);
  }
  if (modeData.startingItems !== undefined) {
    addCollectible(player, ...modeData.startingItems);
  }
  if (modeData.itemActionSetBuilderReference !== undefined) {
    setPlayerInvertedItemActionSetBuilderReference(
      player,
      modeData.itemActionSetBuilderReference,
    );
  }
  // Voiceover
  const vo = getModeVoiceover(mode);
  if (vo !== undefined) {
    fprint(`Playing voiceover: ${vo}`);
    sfxManager.Play(vo);
  }
  // Player Inversion:
  invertPlayerToInversion(player, modeData.startInverted ?? false, true);
  // Game Inversion:
  updateWorldInversion(true);
  // Init mode:
  getModeInit(mode)(player);
}

/** Get the persistent normal-Deleted mode. */
export function getPersistentNormalMode(): Mode {
  return v.persistent.normalMode;
}

/**
 * Set the persistent Deleted mode. This will determine whether the mode is for Deleted or Tainted
 * Deleted and modify the appropriate value, so next time a run is started the most recent mode is
 * loaded (for the appropriate CharacterType).
 */
export function setPersistentMode(mode: Mode): void {
  if (isModeTainted(mode)) {
    v.persistent.taintedMode = mode;
  } else {
    v.persistent.normalMode = mode;
  }
}

/** Get the persistent tainted-Deleted mode. */
export function getPersistentTaintedMode(): Mode {
  return v.persistent.taintedMode;
}

/** When the player first loads in as a Mode, set it up. */
export function modePostPlayerInitFirst(player: EntityPlayer): void {
  const mode = getModeFromPlayerType(player.GetPlayerType());
  if (mode !== undefined) {
    fprint(`Starting up mode: ${mode} for player ${getPlayerIndex(player)}`);
    setPlayerMode(player, mode);
  }
}

/**
 * If changing to a deleted PlayerType, sets them up appropriately. Also handles calling a mode's
 * finalization function upon switching from that mode.
 */
export function postPlayerChangeTypeMode(
  player: EntityPlayer,
  oldCharacter: PlayerType,
  newCharacter: PlayerType,
): void {
  const oldMode = getModeFromPlayerType(oldCharacter);
  if (oldMode !== undefined) {
    fprint(
      `Finishing up mode: ${oldMode} for player ${getPlayerIndex(player)}`,
    );
    getModeFin(oldMode)(player);
  }
  const newMode = getModeFromPlayerType(newCharacter);
  if (newMode === undefined) {
    invertPlayerToInversion(player, false, true);
  } else {
    fprint(`Starting up mode: ${newMode} for player ${getPlayerIndex(player)}`);
    setPlayerMode(player, newMode);
  }
}

/** Sets the Deleted Mode's tear color. */
// CACHE_UPDATE, CacheFlag.TEAR_COLOR
export function modeEvaluateCacheTearColor(player: EntityPlayer): void {
  const mode = getCurrentPlayerMode(player);
  if (mode !== undefined) {
    const { mainColor } = getModeData(mode);
    if (mainColor !== undefined) {
      player.TearColor = mainColor;
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\MORRIS\MORRIS.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.MORRIS;
const MODE_DATA = getModeData(MODE);

export function happy99Init(): void {
  mod.saveDataManager("morris", v);
}

/** Initiate the player to the MORRIS mode. Give the player a starting worm. */
export function morrisModeSetup(player: EntityPlayer): void {
  fprint(`MORRIS: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from MORRIS mode. */
export function morrisModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\MYDOOM\MYDOOM.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.MYDOOM;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function mydoomInit(): void {
  mod.saveDataManager("mydoom", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function mydoomModeSetup(player: EntityPlayer): void {
  fprint(`MYDOOM: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function mydoomModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\REVETON\REVETON.ts`:

```````ts
import { getPlayerIndex, isEven } from "isaacscript-common";
import { DeletedColor } from "../../../enums/general/DeletedColor";
import { Mode } from "../../../enums/modes/Mode";
import { isPlayerDeleted } from "../../../helper/deletedSpecific/deletedHelper";
import { fprint } from "../../../helper/printHelper";
import {
  getModeData,
  getModeFromPlayerType,
} from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.REVETON;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

let tearsFired = 0;

export function revetonInit(): void {
  mod.saveDataManager("reveton", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function revetonModeSetup(player: EntityPlayer): void {
  fprint(`REVETON: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function revetonModeFin(player: EntityPlayer): void {}

export function revetonPostFireTear(tear: EntityTear): void {
  const player = tear.Parent?.ToPlayer();
  if (player === undefined) {
    return;
  }

  if (!isPlayerDeleted(player)) {
    return;
  }

  if (getModeFromPlayerType(player.GetPlayerType()) !== MODE) {
    return;
  }

  tearsFired++;
  if (isEven(tearsFired)) {
    tear.SetColor(DeletedColor.REVETON_BLUE, 0, 1);
  } else {
    tear.SetColor(DeletedColor.REVETON_RED, 0, 1);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\SOPHOS\SOPHOS.ts`:

```````ts
/** The traditional Tainted Deleted mode. */

import { getPlayersOfType, setCollectibleGlitched } from "isaacscript-common";
import { PlayerTypeCustom } from "../../../enums/general/PlayerTypeCustom";
import { fprint } from "../../../helper/printHelper";
import { rollPercentage } from "../../../types/general/Percentage";
import { Range, randomInRange } from "../../../types/general/Range";
import { getSOPHOSChanceForNormalItemSetting } from "../../settings/SOPHOSSettings";

const PLAYER_TYPE = PlayerTypeCustom.T_DELETED_SOPHOS;
// eslint-disable-next-line isaacscript/require-capital-const-assertions
const SHOP_PRICE_RANGE: Range = [1, 30];

/** Initiate the player to the SOPHOS mode. */
export function sophosModeSetup(player: EntityPlayer): void {}

/** When the player swaps out from SOPHOS mode. */
export function sophosModeFin(player: EntityPlayer): void {}

/**
 * When a pedestal spawns and a SOPHOS player exists, make it a TMTRAINER item. There's a chance it
 * will not become a glitched item, specified by SOPHOSChanceForNormalItemSetting.
 */
// POST_PICKUP_INIT_LATE, PickupVariant.COLLECTIBLE
export function sophosPostCollectibleInitFirst(
  collectible: EntityPickupCollectible,
): void {
  if (getPlayersOfType(PLAYER_TYPE).length === 0) {
    return;
  }
  // Chance for normal item setting.
  if (!rollPercentage(getSOPHOSChanceForNormalItemSetting())) {
    setCollectibleGlitched(collectible);
    fprint(
      `Glitched collectible ${collectible.SubType} is of price: ${collectible.Price}`,
    );
    collectible.AutoUpdatePrice = false;
    if (collectible.Price > SHOP_PRICE_RANGE[1]) {
      fprint("SOPHOS: Price too high, setting lower...");
      collectible.Price = randomInRange(SHOP_PRICE_RANGE);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\SPYWIPER\SPYWIPER.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.SPYWIPER;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function spywiperInit(): void {
  mod.saveDataManager("spywiper", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function spywiperModeSetup(player: EntityPlayer): void {
  fprint(`SPYWIPER: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function spywiperModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\VCS\VCS.ts`:

```````ts
import { getPlayerIndex } from "isaacscript-common";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.VCS;
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const MODE_DATA = getModeData(MODE)!;

export function vcsInit(): void {
  mod.saveDataManager("vcs", v);
}

/** Initiate the player to the HAPPY99 mode. */
export function vcsModeSetup(player: EntityPlayer): void {
  fprint(`VCS: Mode init for player: ${getPlayerIndex(player)}`);
}

/** When the player swaps out from HAPPY99 mode. */
export function vcsModeFin(player: EntityPlayer): void {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\modes\ZIPBOMBER\ZIPBOMBER.ts`:

```````ts
import { PickupVariant } from "isaac-typescript-definitions";
import { getPlayerIndex } from "isaacscript-common";
import {
  removePlayerCantPickup,
  setPlayerCantPickup,
} from "../../../classes/facets/gameModifiers.ts/CantPickupFacet";
import { Mode } from "../../../enums/modes/Mode";
import { fprint } from "../../../helper/printHelper";
import { getModeData } from "../../../maps/modes/modeMap";
import { mod } from "../../../mod";

const v = {};
const MODE = Mode.ZIPBOMBER;
const MODE_DATA = getModeData(MODE);
const cantPickupVariant = PickupVariant.BOMB;

export function zipbomberInit(): void {
  mod.saveDataManager("zipbomber", v);
}

/** Initiate the player to the MORRIS mode. */
export function zipbomberModeSetup(player: EntityPlayer): void {
  fprint(`ZIP BOMBER: Mode init for player: ${getPlayerIndex(player)}`);

  setPlayerCantPickup(player, cantPickupVariant);
}

/** When the player swaps out from MORRIS mode. */
export function zipbomberModeFin(player: EntityPlayer): void {
  removePlayerCantPickup(player, cantPickupVariant);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\pc\callbacks\pcPostPlayerInitFirst.ts`:

```````ts
import { setupPC } from "../../../classes/facets/pc/PCFacet";

/** Sets up the PC when Deleted spawns in. */
export function mainPCPostPlayerInitDeletedFirst(_player: EntityPlayer): void {
  setupPC();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\pc\uiPC.ts`:

```````ts
import { isPCActive } from "../../classes/facets/pc/PCFacet";
import { mod } from "../../mod";

/**
 * This file is responsible for the UI of the PC:
 * TODO: Separate into multiple UI files.
 */

const v = {};

export function uiPCInit(): void {
  mod.saveDataManager("uiPC", v);
}

/** Render the PC UI. */
export function uiPCPostRender(): void {
  if (isPCActive()) {
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\runIndex.ts`:

```````ts
import { mod } from "../mod";

const RUN_INDEX_LIMIT = 100;

const v = {
  persistent: {
    runIndex: 1,
  },
};

export function runIndexInit(): void {
  mod.saveDataManager("runIndex", v);
}

export function runIndexPostGameContinuedFacet(): void {
  if (v.persistent.runIndex > RUN_INDEX_LIMIT) {
    v.persistent.runIndex = 0;
  }
  v.persistent.runIndex++;
}

/** A random number that is different each run. */
export function getRunIndex(): number {
  return v.persistent.runIndex;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\ActionSetThemeSetting.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    themedActionSet: true,
  },
};

export function EIDSettingsInit(): void {
  mod.saveDataManager("EIDSettings", v);
}

/**
 * If set to true, the ActionSet color theme will match the Deleted players' main color. If set to
 * false, will use default white/yellow/red colors to indicate Morality of effects.
 */
export function setActionSetThemeSetting(themedActionSet: boolean): void {
  v.persistent.themedActionSet = themedActionSet;
}

/**
 * If set to true, the ActionSet color theme will match the Deleted players' main color. If set to
 * false, will use default white/yellow/red colors to indicate Morality of effects.
 */
export function getActionSetThemeSetting(): boolean {
  return v.persistent.themedActionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\EIDSettings.ts`:

```````ts
import { EIDObjectDisplaySetting } from "../../enums/settings/EIDObjectDisplaySetting";
import { mod } from "../../mod";

const v = {
  persistent: {
    EIDTextSetting:
      EIDObjectDisplaySetting.TEXT_AND_ICON as EIDObjectDisplaySetting,
  },
};

export function EIDSettingsInit(): void {
  mod.saveDataManager("EIDSettings", v);
}

/**
 * The method of displaying 'things' (collectibles, trinkets, monsters, etc) in an External Item
 * Description. Note not all things may have icons, so they will resort to text.
 */
export function setEIDTextSetting(setting: EIDObjectDisplaySetting): void {
  v.persistent.EIDTextSetting = setting;
}

/**
 * The method of displaying 'things' (collectibles, trinkets, monsters, etc) in an External Item
 * Description. Note not all things may have icons, so they will resort to text.
 */
export function getEIDTextSetting(): EIDObjectDisplaySetting {
  return v.persistent.EIDTextSetting;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\GeneralSettings.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    advancedInvertedItemIcons: true,
  },
};

export function GeneralSettingsInit(): void {
  mod.saveDataManager("GeneralSettings", v);
}

/**
 * If set to True, corrupted icons will be TMTRAINER-like amalgamations, which will take more
 * resources. If set to False, they will be the original icons but modified. Note that even if set
 * to False, TMTRAINER-like items can be forced.
 */
export function setAdvancedInvertedItemIconSetting(setting: boolean): void {
  v.persistent.advancedInvertedItemIcons = setting;
}

/**
 * If set to True, corrupted icons will be TMTRAINER-like amalgamations, which will take more
 * resources. If set to False, they will be the original icons but modified. Note that even if set
 * to False, TMTRAINER-like items can be forced.
 */
export function getAdvancedInvertedItemIconSetting(): boolean {
  return v.persistent.advancedInvertedItemIcons;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\HAPPY99Settings.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    negativePersist: true,
  },
};

export function happy99SettingsInit(): void {
  mod.saveDataManager("happy99Settings", v);
}

/** Whether negative effects of an inverted item carry over to the normal item. */
export function setHAPPY99NegativePersistSetting(
  negativeEffectsPersist: boolean,
): void {
  v.persistent.negativePersist = negativeEffectsPersist;
}

/** Whether negative effects of an inverted item carry over to the normal item. */
export function getHAPPY99NegativePersistSetting(): boolean {
  return v.persistent.negativePersist;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\ModdedEffectSettings.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    IncludeModdedEffectsInGeneration: true,
  },
};

export function moddedEffectSettingsInit(): void {
  mod.saveDataManager("ModdedEffectSettings", v);
}

/**
 * If set to true (default), will consider modded effects upon generating corrupted effects for
 * items. If set to false, will not consider modded effects. Note not all mods may be registered.
 */
export function setIncludeModdedEffectsInGenerationSetting(
  setting: boolean,
): void {
  v.persistent.IncludeModdedEffectsInGeneration = setting;
}

/**
 * If set to true (default), will consider modded effects upon generating corrupted effects for
 * items. If set to false, will not consider modded effects. Note not all mods may be registered.
 */
export function getIncludeModdedEffectsInGenerationSetting(): boolean {
  return v.persistent.IncludeModdedEffectsInGeneration;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\ModdedNPCSettings.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    IncludeModdedNPCInGeneration: true,
  },
};

export function moddedNPCSettingsInit(): void {
  mod.saveDataManager("ModdedNPCSettings", v);
}

/**
 * If set to true (default), will consider modded NPCs upon generating corrupted effects for items.
 * If set to false, will not consider modded NPCs. Note not all mods may be registered.
 */
export function setIncludeModdedNPCInGenerationSetting(setting: boolean): void {
  v.persistent.IncludeModdedNPCInGeneration = setting;
}

/**
 * If set to true (default), will consider modded NPCs upon generating corrupted effects for items.
 * If set to false, will not consider modded NPCs. Note not all mods may be registered.
 */
export function getIncludeModdedNPCInGenerationSetting(): boolean {
  return v.persistent.IncludeModdedNPCInGeneration;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\ModdedPickupSettings.ts`:

```````ts
import { mod } from "../../mod";

const v = {
  persistent: {
    IncludeModdedPickupsInGeneration: true,
  },
};

export function moddedPickupSettingsInit(): void {
  mod.saveDataManager("ModdedPickupSettings", v);
}

/**
 * If set to true (default), will consider modded pickups upon generating corrupted effects for
 * items. If set to false, will not consider modded pickups. Note not all mods may be registered.
 */
export function setIncludeModdedPickupsInGenerationSetting(
  setting: boolean,
): void {
  v.persistent.IncludeModdedPickupsInGeneration = setting;
}

/**
 * If set to true (default), will consider modded pickups upon generating corrupted effects for
 * items. If set to false, will not consider modded pickups. Note not all mods may be registered.
 */
export function getIncludeModdedPickupsInGenerationSetting(): boolean {
  return v.persistent.IncludeModdedPickupsInGeneration;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features\settings\SOPHOSSettings.ts`:

```````ts
import { mod } from "../../mod";
import type { Percentage } from "../../types/general/Percentage";
import { createPercentage } from "../../types/general/Percentage";

const v = {
  persistent: {
    chanceForNormalItem: 10,
  },
};

export function sophosSettingsInit(): void {
  mod.saveDataManager("SOPHOSSettings", v);
}

/**
 * The chance that an item pedestal spawns as a non-TMTRAINER corrupted item as SOPHOS. Throws error
 * if percentage is not 0-100.
 */
export function setSOPHOSChanceForNormalItemSetting(
  percentage: Percentage,
): void {
  v.persistent.chanceForNormalItem = createPercentage(percentage);
}

/** The chance that an item pedestal spawns as a non-TMTRAINER corrupted item as SOPHOS. */
export function getSOPHOSChanceForNormalItemSetting(): Percentage {
  return v.persistent.chanceForNormalItem;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\features.ts`:

```````ts
import { temporaryActionResponseInit } from "./classes/corruption/responses/TemporaryActionResponse";
import { facetInit } from "./classes/Facet";
import { corruptionGenerationInit } from "./features/corruption/corruptionGeneration";
import { activeItemTrackerInit } from "./features/corruption/effects/activeItemTracker";
import { itemEffectsInit } from "./features/corruption/effects/itemEffects";
import { pickupEffectsInit } from "./features/corruption/effects/pickupEffects";
import { playerEffectsInit } from "./features/corruption/effects/playerEffects";
import { bombInventoryInit } from "./features/corruption/inventory/bombInventory";
import { invertedItemCorruptInit } from "./features/corruption/inventory/passiveItemInventory";
import { removedItemTrackerInit } from "./features/corruption/inventory/removedInvertedItems";
import { customActivesInit } from "./features/corruption/inversion/customActives";
import { lastPickedUpInvertedCollectibleInit } from "./features/corruption/inversion/lastPickedUpInverted";
import { pickupInversionInit } from "./features/corruption/inversion/pickupInversion";
import { inversionInit } from "./features/corruption/inversion/playerInversion";
import { gameEntitySetBuilderInit } from "./features/data/gameSets/gameEntitySets";
import { backdropHelperInit } from "./features/general/backdropHelper";
import { floorColorHelper } from "./features/general/floorColorHelper";
import { isLeavingGameInit } from "./features/general/isLeavingGame";
import { playerStatsInit } from "./features/general/playerStats";
import { RNGHelperInit } from "./features/general/RNGHelper";
import { temporaryItemsInit } from "./features/general/temporaryItems";
import { happy99Init } from "./features/modes/HAPPY99/HAPPY99";
import { iLoveYouInit } from "./features/modes/ILOVEYOU/ILOVEYOU";
import { modeInit } from "./features/modes/mode";
import { mydoomInit } from "./features/modes/MYDOOM/MYDOOM";
import { zipbomberInit } from "./features/modes/ZIPBOMBER/ZIPBOMBER";
import { uiPCInit } from "./features/pc/uiPC";
import { runIndexInit } from "./features/runIndex";
import { EIDSettingsInit } from "./features/settings/ActionSetThemeSetting";
import { GeneralSettingsInit } from "./features/settings/GeneralSettings";
import { happy99SettingsInit } from "./features/settings/HAPPY99Settings";
import { moddedEffectSettingsInit } from "./features/settings/ModdedEffectSettings";
import { moddedNPCSettingsInit } from "./features/settings/ModdedNPCSettings";
import { moddedPickupSettingsInit } from "./features/settings/ModdedPickupSettings";
import { sophosSettingsInit } from "./features/settings/SOPHOSSettings";
import { glitchyReplacePlayerSpritesheetInit } from "./helper/deletedSpecific/glitchyPlayerTransform";

// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
export const FEATURE_INIT_FUNCTIONS: Array<() => void> = [
  uiPCInit,
  inversionInit,
  modeInit,
  happy99Init,
  iLoveYouInit,
  mydoomInit,
  pickupInversionInit,
  playerEffectsInit,
  itemEffectsInit,
  corruptionGenerationInit,
  EIDSettingsInit,
  runIndexInit,
  temporaryItemsInit,
  playerStatsInit,
  happy99SettingsInit,
  sophosSettingsInit,
  pickupEffectsInit,
  invertedItemCorruptInit,
  zipbomberInit,
  bombInventoryInit,
  RNGHelperInit,
  GeneralSettingsInit,
  lastPickedUpInvertedCollectibleInit,
  facetInit,
  backdropHelperInit,
  removedItemTrackerInit,
  glitchyReplacePlayerSpritesheetInit,
  floorColorHelper,
  customActivesInit,
  activeItemTrackerInit,
  moddedNPCSettingsInit,
  gameEntitySetBuilderInit,
  isLeavingGameInit,
  moddedPickupSettingsInit,
  moddedEffectSettingsInit,
];

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\globals.d.ts`:

```````ts
declare let FiendFolio: undefined | unknown;
declare let ANDROMEDA: undefined | unknown;

/** Exported Object for this mod. */
declare let TheDeleted: undefined | unknown;
declare let CCO: undefined | unknown;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\activeHelper.ts`:

```````ts
import type { ActiveSlot } from "isaac-typescript-definitions";
import { fprint } from "./printHelper";

/**
 * Get the total charges of a players' active item, including any overcharged charges with the
 * Battery. Max charges possible is total charges * 2.
 */
export function getTotalCharges(player: EntityPlayer, slot: ActiveSlot): int {
  return player.GetActiveCharge(slot) + player.GetBatteryCharge(slot);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\advancedColorHelper.ts`:

```````ts
import { copyColor, isColor } from "isaacscript-common";
import { AdvancedColor } from "../interfaces/general/AdvancedColor";

/**
 * Generate a Color from an AdvancedColor object. If deepCopy is true, will create a new Color,
 * otherwise will share the same Color object used in the AdvancedColor object. The reason behind
 * 'AdvancedColor' existing is that it allows saving the colorize and tint values, which are not
 * saved in the Color object.
 */
export function generateColorFromAdvancedColor(
  advancedColor: AdvancedColor,
  deepCopy = true,
): Color {
  const color = deepCopy ? copyColor(advancedColor.color) : advancedColor.color;
  if (advancedColor.colorize !== undefined) {
    color.SetColorize(...advancedColor.colorize);
  }

  if (advancedColor.tint !== undefined) {
    color.SetTint(...advancedColor.tint);
  }
  return color;
}

/**
 * If the input is an advancedColor, will convert it to a Color. Otherwise, returns the Color. Will
 * NOT create a new Color object no matter what it is. Use 'simplifyAndCopyColor()' to create a new
 * Color object.
 */
export function simplifyColor(color: AdvancedColor | Color): Color {
  if (isColor(color)) {
    return color;
  }
  return generateColorFromAdvancedColor(color, false);
}

/**
 * If the input is an advancedColor, will convert it to a Color. Otherwise, returns the Color. Will
 * create a new Color object no matter what it is.
 */
export function simplifyAndCopyColor(
  advancedColorOrColor: AdvancedColor | Color,
): Color {
  if (isColor(advancedColorOrColor)) {
    return copyColor(advancedColorOrColor);
  }
  return generateColorFromAdvancedColor(advancedColorOrColor);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\arrayHelper.ts`:

```````ts
import { getRandomArrayIndex, getRandomSeed } from "isaacscript-common";

/**
 * Returns the element with the most frequent occurrence in the provided Array. If the array is
 * empty, returns undefined. If there are equal occurrences, returns the first found.
 *
 * @example [1, 2, 2, 3] => returns 2.
 */
export function getMostFrequentElementInArray<T>(arr: T[]): T | undefined {
  if (arr.length === 0) {
    return undefined;
  }
  const hashmap = arr.reduce<Record<string, number>>((acc, _val, index) => {
    const v = acc[index.toString()];
    if (v === undefined) {
      acc[index.toString()] = 0;
    } else {
      acc[index.toString()]++;
    }
    return acc;
  }, {});
  const mf = Object.keys(hashmap).reduce((a, b) =>
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    hashmap[a]! > hashmap[b]! ? a : b,
  );
  return arr[+mf] as T;
}

/**
 * Checks if 'Value' of type 'T' is equal to or part of 'ArrayOfTOrT' depending on whether it is an
 * array or singular value.
 */
export function isInArrayOrEquals<T>(value: T, arrayOfTOrT: T | T[]): boolean {
  if (Array.isArray(arrayOfTOrT)) {
    return arrayOfTOrT.includes(value);
  }
  return value === arrayOfTOrT;
}

// eslint-disable-next-line isaacscript/complete-sentences-jsdoc
/**
 * Returns the index of the last element in the array where predicate is true, and -1 otherwise.
 *
 * @param array The source array to search in.
 * @param predicate find calls predicate once for each element of the array, in descending order,
 *                  until it finds one where predicate returns true. If such an element is found,
 *                  findLastIndex immediately returns that element index. Otherwise, findLastIndex
 *                  returns -1.
 */
export function findLastIndexOfArray<T>(
  array: T[],
  predicate: (value: T, index: number, obj: T[]) => boolean,
): number {
  let l = array.length;
  // eslint-disable-next-line isaacscript/no-unsafe-plusplus
  while (l-- !== 0) {
    const current = array[l];
    if (current === undefined) {
      return -1;
    }

    if (predicate(current, l, array)) {
      return l;
    }
  }
  return -1;
}

export function getRandomArrayElementFast<T>(
  array: T[] | readonly T[],
  seedOrRNG: Seed | RNG = getRandomSeed(),
): T {
  const randomIndex = getRandomArrayIndex(array, seedOrRNG);
  const randomElement = array[randomIndex];
  if (randomElement === undefined) {
    error(
      `Failed to get a random array element fast since the random index of ${randomIndex} was not valid.`,
    );
  }
  return randomElement;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\bitflagHelper.ts`:

```````ts
import { getEnumValues } from "isaacscript-common";

/** Determine if a BitFlags object contains a BitFlag. */
export function bitFlagsContainsValue<T extends BitFlag>(
  bitFlagsObject: BitFlags<T>,
  value: BitFlag,
): boolean {
  return value === (bitFlagsObject & value);
}

/** Determines if the BitFlags object contains all the bitflags in an array. */
export function bitFlagsContainsAllBitflags<T extends BitFlag>(
  bitFlagsObject: BitFlags<T>,
  bitflags: BitFlag[],
): boolean {
  return bitflags.every((bitFlag) =>
    bitFlagsContainsValue(bitFlagsObject, bitFlag),
  );
}

/** Determines if the BitFlags object contains one of the bitflags in an array. */
export function bitFlagsContainsAtLeastOneBitflags<T extends BitFlag>(
  bitFlagsObject: BitFlags<T>,
  bitflags: BitFlag[],
): boolean {
  return bitflags.some((bitFlag) =>
    bitFlagsContainsValue(bitFlagsObject, bitFlag),
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\actionSetBuilders.ts`:

```````ts
/** Generalized ActionSetBuilders which return an ActionSet. */

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\extra\hybridActiveBuilders.ts`:

```````ts
import {
  CollectibleType,
  ItemConfigChargeType,
  ItemType,
} from "isaac-typescript-definitions";
import {
  getCollectibleChargeType,
  getCollectibleMaxCharges,
} from "isaacscript-common";
import { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { UseActiveItemResponse } from "../../../classes/corruption/responses/UseActiveItemResponse";
import { getRandomCollectibleType } from "../../collectibleHelper";

/**
 * Generates a Hybrid Inverted Active ActionSet which contains multiple Active Items in one. Upon
 * triggering, all Active Items will be used at once.
 *
 * @param amountOfActives The amount of Active Items to include.
 * @param itemConfigChargeType
 */
export function generateHybridActiveActionSet(
  amountOfActives = 2,
): InvertedActiveActionSet {
  const actionSet = new InvertedActiveActionSet();
  let totalCharges = 0;
  let overallChargeType: ItemConfigChargeType | undefined;
  for (let i = 0; i < amountOfActives; i++) {
    // Get the random active item.
    const randomActive =
      getRandomCollectibleType({
        itemType: ItemType.ACTIVE,
      }) ?? CollectibleType.POOP;

    const chargeType = getCollectibleChargeType(randomActive);
    const charges = getCollectibleMaxCharges(randomActive);

    // Rally up the total charges.
    if (overallChargeType === undefined) {
      overallChargeType = chargeType;
      totalCharges = charges;
    } else if (overallChargeType === chargeType) {
      totalCharges += charges;
    } else if (overallChargeType === ItemConfigChargeType.TIMED) {
      if (chargeType === ItemConfigChargeType.NORMAL) {
        overallChargeType = ItemConfigChargeType.NORMAL;
        totalCharges = charges + i;
      }
    }

    // Add the active to the action set.
    actionSet.addEffects(new UseActiveItemResponse().construct(randomActive));
  }

  actionSet.setChargeType(overallChargeType ?? ItemConfigChargeType.NORMAL);
  actionSet.setTotalCharges(totalCharges);

  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\genericBuilders.ts`:

```````ts
import {
  CollectibleType,
  ItemConfigChargeType,
  ItemType,
  NPCID,
} from "isaac-typescript-definitions";
import {
  getRandomArrayElement,
  getRandomFromWeightedArray,
  getRandomSeed,
  shuffleArrayInPlace,
} from "isaacscript-common";
import { InvertedActiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import type { InvertedItemActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { InvertedPassiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import type { Action } from "../../classes/corruption/actions/Action";
import { OnDamageAction } from "../../classes/corruption/actions/OnDamageAction";
import { OnFloorAction } from "../../classes/corruption/actions/OnFloorAction";
import { OnKillAction } from "../../classes/corruption/actions/OnKillAction";
import { OnObtainAction } from "../../classes/corruption/actions/OnObtainAction";
import { OnRoomAction } from "../../classes/corruption/actions/OnRoomAction";
import type { Response } from "../../classes/corruption/responses/Response";
import { SpawnNPCResponse } from "../../classes/corruption/responses/SpawnNPCResponse";
import { TriggerInSequenceResponse } from "../../classes/corruption/responses/TriggerInSequenceResponse";
import { TriggerOverTimeResponse } from "../../classes/corruption/responses/TriggerOverTimeResponse";
import { TriggerRandomResponse } from "../../classes/corruption/responses/TriggerRandomResponse";
import { UseActiveItemResponse } from "../../classes/corruption/responses/UseActiveItemResponse";
import { WaitThenTriggerResponse } from "../../classes/corruption/responses/WaitThenTriggerResponse";
import { INVERTED_COLLECTIBLE_CUSTOM_SPRITE_SEGMENT_AMOUNT_SPREAD } from "../../constants/corruptionConstants";
import { Morality } from "../../enums/corruption/Morality";
import type { ActionSetBuilderInput } from "../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import type { CorruptedCollectibleSprite } from "../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import { rollPercentage } from "../../types/general/Percentage";
import { getRandomCollectibleType } from "../collectibleHelper";
import { getObjectValues } from "../objectHelper";
import { fprint } from "../printHelper";
import { getRandomInteger } from "../randomHelper";

/**
 * Generates a CustomCollectibleSprite from the provided ActionSet. If 'Advanced Icons' setting is
 * turned off, will instead simply make the sprite a color and flip it. Color defaulted to random,
 * but can be set to a specific color afterwards.
 */
export function generateDefaultCorruptedCollectibleSprite(
  actionSet: InvertedPassiveActionSet,
  inputs?: ActionSetBuilderInput,
): CorruptedCollectibleSprite {
  const amountOfSegments = getRandomFromWeightedArray(
    INVERTED_COLLECTIBLE_CUSTOM_SPRITE_SEGMENT_AMOUNT_SPREAD,
    undefined,
  );
  const involvedCollectibles = actionSet.getInvolvedCollectibles();
  if (inputs?.collectible !== undefined) {
    involvedCollectibles.push(inputs.collectible);
  }
  if (involvedCollectibles.length < amountOfSegments) {
    for (let i = 0; i < amountOfSegments - involvedCollectibles.length; i++) {
      involvedCollectibles.push(
        getRandomCollectibleType() ?? CollectibleType.POOP,
      );
    }
  } else if (involvedCollectibles.length > amountOfSegments) {
    involvedCollectibles.splice(
      getRandomInteger(0, involvedCollectibles.length - 1),
      involvedCollectibles.length - amountOfSegments,
    );
  }
  shuffleArrayInPlace(involvedCollectibles, undefined);
  return {
    collectibles: involvedCollectibles,
    color: "random",
    seed: getRandomSeed(),
    horizontal: getRandomInteger(0, 1) === 0,
  };
}

export function defaultInvertedItemActionSetBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = inputs?.forceActiveOrPassive ?? getRandomInteger(0, 1) === 0;

  /** Generate the ActionSet using default properties. */
  const actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`GENERIC ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("GENERIC DESCRIPTION");

  return actionSet;
}

/**
 * Generates a default actionSet for an inverted active item. Will not add name, description and
 * icon properties, these can be added afterwards or left blank to be auto-generated.
 */
export function defaultInvertedActiveActionSetBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedActiveActionSet {
  fprint(`defaultInvertedActiveActionSetBuilder. inputs: (${inputs})`);

  const amountOfEffects = getRandomInteger(1, 3);
  const effectArray: Array<Action | Response> = [];
  for (let i = 0; i < amountOfEffects; i++) {
    const responses = [
      () =>
        new UseActiveItemResponse()
          .construct(
            getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
              CollectibleType.POOP,
          )
          .setMorality(Morality.POSITIVE),
      () =>
        new UseActiveItemResponse()
          .construct(
            getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
              CollectibleType.POOP,
          )
          .setChanceToActivate(getRandomInteger(1, 100))
          .setAmountOfActivations(getRandomInteger(1, 3))
          .setMorality(Morality.POSITIVE),
      () =>
        new SpawnNPCResponse()
          .construct(getRandomArrayElement(getObjectValues(NPCID), undefined))
          .setMorality(Morality.NEGATIVE),
      () =>
        new SpawnNPCResponse()
          .construct(getRandomArrayElement(getObjectValues(NPCID), undefined))
          .setChanceToActivate(getRandomInteger(1, 100))
          .setAmountOfActivations(getRandomInteger(1, 3))
          .setMorality(Morality.NEGATIVE),
    ];
    const randomAction: () => Action = getRandomFromWeightedArray<() => Action>(
      [
        [() => new OnDamageAction(), 1],
        [() => new OnFloorAction(), 1],
        [() => new OnObtainAction(), 1],
        [() => new OnRoomAction(), 1],
      ],
      undefined,
    );
    const randomResponse: Response = getRandomFromWeightedArray<Response>(
      [
        [getRandomArrayElement(responses, undefined)(), 1],
        [
          new WaitThenTriggerResponse().construct(
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerInSequenceResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerRandomResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerOverTimeResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomInteger(1, 4),
            getRandomInteger(1, 3),
          ),
          1,
        ],
      ],
      undefined,
    );

    /** % Chance of Action/Response. */
    if (rollPercentage(10)) {
      effectArray.push(randomAction().setResponse(randomResponse));
    } else {
      effectArray.push(randomResponse);
    }
  }
  const invertedActiveActionSet = new InvertedActiveActionSet()
    .addEffects(...effectArray)
    .setQuality(3)
    .setChargeType(ItemConfigChargeType.NORMAL)
    .setTotalCharges(getRandomInteger(1, 6));
  return invertedActiveActionSet;
}

/**
 * Generates a default actionSet for an inverted passive item. Will not add name, description and
 * icon properties, these can be added afterwards or left black to be auto-generated.
 */
export function defaultInvertedPassiveActionSetBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedPassiveActionSet {
  fprint(`defaultInvertedPassiveActionSetBuilder. inputs: (${inputs})`);

  const amountOfEffects = getRandomInteger(1, 3);
  const effectArray: Action[] = [];
  const randomActions: Action = getRandomFromWeightedArray(
    [
      [new OnDamageAction(), 1],
      [new OnFloorAction(), 1],
      [new OnObtainAction(), 1],
      [new OnRoomAction(), 1],
      [new OnKillAction(), 1],
    ],
    undefined,
  );
  for (let i = 0; i < amountOfEffects; i++) {
    const responses = [
      () =>
        new UseActiveItemResponse()
          .construct(
            getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
              CollectibleType.POOP,
          )
          .setMorality(Morality.POSITIVE),
      () =>
        new UseActiveItemResponse()
          .construct(
            getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
              CollectibleType.POOP,
          )
          .setChanceToActivate(getRandomInteger(1, 100))
          .setAmountOfActivations(getRandomInteger(1, 3))
          .setMorality(Morality.POSITIVE),
      () =>
        new SpawnNPCResponse()
          .construct(getRandomArrayElement(getObjectValues(NPCID), undefined))
          .setMorality(Morality.NEGATIVE),
      () =>
        new SpawnNPCResponse()
          .construct(getRandomArrayElement(getObjectValues(NPCID), undefined))
          .setChanceToActivate(getRandomInteger(1, 100))
          .setAmountOfActivations(getRandomInteger(1, 3))
          .setMorality(Morality.NEGATIVE),
    ];
    const randomAction: () => Action = getRandomFromWeightedArray<() => Action>(
      [
        [() => new OnDamageAction(), 1],
        [() => new OnFloorAction(), 1],
        [() => new OnObtainAction(), 1],
        [() => new OnRoomAction(), 1],
      ],
      undefined,
    );
    const randomResponse: Response = getRandomFromWeightedArray<Response>(
      [
        [getRandomArrayElement(responses, undefined)(), 1],
        [
          new WaitThenTriggerResponse().construct(
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerInSequenceResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerRandomResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomArrayElement(responses, undefined)(),
          ),
          1,
        ],
        [
          new TriggerOverTimeResponse().construct(
            getRandomArrayElement(responses, undefined)(),
            getRandomInteger(1, 4),
            getRandomInteger(1, 3),
          ),
          1,
        ],
      ],
      undefined,
    );
    effectArray.push(
      randomAction().setResponse(randomResponse.setMorality(Morality.POSITIVE)),
    );
  }
  const invertedPassiveActionSet = new InvertedPassiveActionSet()
    .addEffects(...effectArray)
    .setQuality(3);
  return invertedPassiveActionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\items\EXTRACTBuilders.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { Response } from "../../../classes/corruption/responses/Response";
import { UseActiveItemResponse } from "../../../classes/corruption/responses/UseActiveItemResponse";
import { Morality } from "../../../enums/corruption/Morality";

/** Generates a new Response to be used while rerolling items with the EXTRACT item. */
export function extractResponseBuilder(): Response {
  return new UseActiveItemResponse()
    .construct(CollectibleType.POOP)
    .setMorality(Morality.NEGATIVE);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\HAPPY99Builders.ts`:

```````ts
import { getRandomInt, isColor } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { HAPPY99InvertedItemSpriteColor } from "../../../constants/modes/HAPPY99Constants";
import { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import {
  defaultInvertedActiveActionSetBuilder,
  defaultInvertedPassiveActionSetBuilder,
  generateDefaultCorruptedCollectibleSprite,
} from "../genericBuilders";
import { fprint } from "../../printHelper";
import { rollPercentage } from "../../../types/general/Percentage";
import { DEFAULT_INVERTED_ACTIVE_GENERATION_PERCENTAGE } from "../../../constants/corruptionConstants";

export function happy99DefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  fprint("HAPPY99 DEFAULT BUILDER");
  const active =
    inputs?.forceActiveOrPassive ??
    rollPercentage(DEFAULT_INVERTED_ACTIVE_GENERATION_PERCENTAGE);

  /** Generate the ActionSet using default properties. */
  const actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`HAPPY99 ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("HAPPY99 DESCRIPTION");

  /** Set the icon. */
  const sprite = generateDefaultCorruptedCollectibleSprite(actionSet, inputs);
  if (!isColor(sprite)) {
    sprite.color = HAPPY99InvertedItemSpriteColor;
  }
  actionSet.setIcon(sprite);

  /** Set the text color. */
  actionSet.setTheme(EIDColorTriplet.HAPPY99_TRIPLET);

  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\HICURDISMOSBuilders.ts`:

```````ts
import { colorEquals, getRandomInt, isColor } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import { DeletedColor } from "../../../enums/general/DeletedColor";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import {
  defaultInvertedActiveActionSetBuilder,
  defaultInvertedPassiveActionSetBuilder,
  generateDefaultCorruptedCollectibleSprite,
} from "../genericBuilders";
import { getRandomInteger } from "../../randomHelper";

const SPRITE_COLOR_1 = DeletedColor.WINDOWS_BLUE;
const SPRITE_COLOR_2 = DeletedColor.WINDOWS_WHITE;

export function hicurdismosDefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = inputs?.forceActiveOrPassive ?? getRandomInteger(0, 1) === 0;
  let actionSet: InvertedItemActionSet | undefined;

  /** Generate the ActionSet using default properties. */
  actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`HICURDISMOS ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("HICURDISMOS DESCRIPTION");

  /** Set the icon. */
  const sprite = generateDefaultCorruptedCollectibleSprite(actionSet, inputs);
  if (!isColor(sprite)) {
    const color1 =
      getRandomInteger(0, 1) === 0 ? SPRITE_COLOR_1 : SPRITE_COLOR_2;
    const color2 = colorEquals(color1, SPRITE_COLOR_2)
      ? SPRITE_COLOR_2
      : SPRITE_COLOR_1;
    sprite.color = [color1, color2];
  }
  actionSet.setIcon(sprite);

  /** Set the text color. */
  actionSet.setTheme(EIDColorTriplet.HICURDISMOS_TRIPLET);

  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\ILOVEYOUBuilders.ts`:

```````ts
import { getRandomInt, isColor } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { ILOVEYOUInvertedItemSpriteColor } from "../../../constants/modes/ILOVEYOUConstants";
import { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import {
  defaultInvertedActiveActionSetBuilder,
  defaultInvertedPassiveActionSetBuilder,
  generateDefaultCorruptedCollectibleSprite,
} from "../genericBuilders";
import { getRandomInteger } from "../../randomHelper";

export function iLoveYouDefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = getRandomInteger(0, 1) === 0;
  let actionSet: InvertedItemActionSet | undefined;

  /** Generate the ActionSet using default properties. */
  actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`ILOVEYOU ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("ILOVEYOU DESCRIPTION");

  /** Set the icon. */
  const sprite = generateDefaultCorruptedCollectibleSprite(actionSet, inputs);
  if (!isColor(sprite)) {
    sprite.color = ILOVEYOUInvertedItemSpriteColor;
  }
  actionSet.setIcon(sprite);

  /** Set the text color. */
  actionSet.setTheme(EIDColorTriplet.ILOVEYOU_TRIPLET);

  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\MORRISBuilders.ts`:

```````ts
import { getRandomInt, isColor } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { MORRISInvertedItemSpriteColor } from "../../../constants/modes/MORRISConstants";
import { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import {
  defaultInvertedActiveActionSetBuilder,
  defaultInvertedPassiveActionSetBuilder,
  generateDefaultCorruptedCollectibleSprite,
} from "../genericBuilders";
import { getRandomInteger } from "../../randomHelper";

export function morrisDefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = getRandomInteger(0, 1) === 0;
  let actionSet: InvertedItemActionSet | undefined;

  /** Generate the ActionSet using default properties. */
  actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`MORRIS ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("MORRIS DESCRIPTION");

  /** Set the icon. */
  const sprite = generateDefaultCorruptedCollectibleSprite(actionSet, inputs);
  if (!isColor(sprite)) {
    sprite.color = MORRISInvertedItemSpriteColor;
  }
  actionSet.setIcon(sprite);

  /** Set the text color. */
  actionSet.setTheme(EIDColorTriplet.MORRIS_TRIPLET);

  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\MYDOOMBuilders.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import {
  COLORS,
  getRandomInt,
  getRandomSeed,
  isColor,
} from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { EIDColorTriplet } from "../../../enums/compatibility/EID/EIDColorTriplet";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import type { CorruptedCollectibleSprite } from "../../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import { getRandomCollectibleType } from "../../collectibleHelper";
import {
  defaultInvertedActiveActionSetBuilder,
  defaultInvertedPassiveActionSetBuilder,
} from "../genericBuilders";
import { getRandomInteger } from "../../randomHelper";

export function mydoomDefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = getRandomInteger(0, 1) === 0;
  let actionSet: InvertedItemActionSet | undefined;

  /** Generate the ActionSet using default properties. */
  actionSet = active
    ? defaultInvertedActiveActionSetBuilder(inputs)
    : defaultInvertedPassiveActionSetBuilder(inputs);

  /** Set the name and description. */
  actionSet
    .setName(`MYDOOM ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("MYDOOM DESCRIPTION");

  /** Set the icon. */
  const sprite = generateMydoomCorruptedCollectibleSprite(actionSet, inputs);
  if (!isColor(sprite)) {
    sprite.flipX = getRandomInteger(0, 1) === 0;
    sprite.flipY = getRandomInteger(0, 1) === 0;
  }
  actionSet.setIcon(sprite);

  /** Set the text color. */
  actionSet.setTheme(EIDColorTriplet.MYDOOM_TRIPLET);

  return actionSet;
}

function generateMydoomCorruptedCollectibleSprite(
  actionSet: InvertedItemActionSet,
  inputs?: ActionSetBuilderInput,
): CorruptedCollectibleSprite {
  const sprite: CorruptedCollectibleSprite = {
    collectibles: [
      inputs?.collectible ?? getRandomCollectibleType() ?? CollectibleType.POOP,
    ],
    seed: getRandomSeed(),
    color: COLORS.Black,
  };
  const multipleSegments = getRandomInteger(0, 1) === 0;
  if (multipleSegments) {
    sprite.flipX = undefined;
    sprite.flipY = undefined;

    const mirror = getRandomInteger(0, 1) === 0;
    if (mirror) {
      sprite.collectibles.push(
        inputs?.collectible ??
          getRandomCollectibleType() ??
          CollectibleType.POOP,
      );
    }

    const confusion = getRandomInteger(0, 1) === 0;
    if (confusion) {
      sprite.collectibles.push(
        getRandomCollectibleType() ?? CollectibleType.POOP,
      );
      // Randomize the order of the collectibles.
      sprite.collectibles.sort(() => Math.random() - 0.5);
    }
  } else {
    sprite.flipX = getRandomInteger(0, 1) === 0;
    sprite.flipY = getRandomInteger(0, 1) === 0;
  }
  return sprite;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\builders\modes\REVETONBuilders.ts`:

```````ts
import { CollectibleType, ItemType } from "isaac-typescript-definitions";
import { COLORS, getRandomInt, getRandomSeed } from "isaacscript-common";
import { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { InvertedPassiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import {
  GetCollectibleResponse,
  isGetCollectibleResponse,
} from "../../../classes/corruption/responses/GetCollectibleResponse";
import type { Response } from "../../../classes/corruption/responses/Response";
import { UseActiveItemResponse } from "../../../classes/corruption/responses/UseActiveItemResponse";
import {
  REVETONInvertedItemBlueSpriteColor,
  REVETONInvertedItemRedSpriteColor,
} from "../../../constants/modes/REVETONConstants";
import { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import { ActionSetType } from "../../../enums/corruption/actionSets/ActionSetType";
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";
import { DeletedColor } from "../../../enums/general/DeletedColor";
import { getAdvancedInvertedItemIconSetting } from "../../../features/settings/GeneralSettings";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import type { CorruptedCollectibleSprite } from "../../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import { getRandomCollectibleType } from "../../collectibleHelper";
import { getRandomInteger } from "../../randomHelper";

/** Default Builder to generate a REVETON ActionSet. */
export function revetonDefaultBuilder(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const active = getRandomInteger(0, 1) === 0;
  let actionSet: InvertedItemActionSet | undefined;

  /** Determines the sprite & EID text red/blue color order. */
  const colorOrder: [
    typeof DeletedColor.REVETON_BLUE,
    typeof DeletedColor.REVETON_BLUE,
  ] =
    getRandomInteger(0, 1) === 0
      ? [DeletedColor.REVETON_BLUE, DeletedColor.REVETON_RED]
      : [DeletedColor.REVETON_RED, DeletedColor.REVETON_BLUE];
  const colorOrderEIDShortcut: [
    EIDColorShortcut.REVETON_BLUE | EIDColorShortcut.REVETON_RED,
    EIDColorShortcut.REVETON_BLUE | EIDColorShortcut.REVETON_RED,
  ] = [
    colorOrder[0] === DeletedColor.REVETON_BLUE
      ? EIDColorShortcut.REVETON_BLUE
      : EIDColorShortcut.REVETON_RED,
    colorOrder[1] === DeletedColor.REVETON_BLUE
      ? EIDColorShortcut.REVETON_BLUE
      : EIDColorShortcut.REVETON_RED,
  ];

  /** Generate the ActionSet using default properties. */
  actionSet = active
    ? new InvertedActiveActionSet().addEffects(
        ...generateRevetonActiveEffects(inputs, colorOrderEIDShortcut),
      )
    : new InvertedPassiveActionSet().addEffects(
        ...generateRevetonPassiveEffects(inputs, colorOrderEIDShortcut),
      );

  /** Set the name and description. */
  actionSet
    .setName(`REVETON ${active ? "ACTIVE" : "PASSIVE"}`)
    .setDescription("REVETON DESCRIPTION");

  /** Set the icon. */
  const sprite = generateRevetonCorruptedCollectibleSprite(
    actionSet,
    inputs,
    colorOrder,
  );
  actionSet.setIcon(sprite);

  return actionSet;
}

/** Effects to be added to a new REVETON InvertedPassiveActionSet. */
function generateRevetonPassiveEffects(
  _inputs?: ActionSetBuilderInput,
  colorOrder: [
    typeof EIDColorShortcut.REVETON_BLUE | typeof EIDColorShortcut.REVETON_RED,
    typeof EIDColorShortcut.REVETON_BLUE | typeof EIDColorShortcut.REVETON_RED,
  ] = [EIDColorShortcut.REVETON_BLUE, EIDColorShortcut.REVETON_RED],
): Response[] {
  return [
    new GetCollectibleResponse()
      .construct(
        getRandomCollectibleType({
          itemType: [ItemType.PASSIVE, ItemType.FAMILIAR],
        }) ?? CollectibleType.POOP,
      )
      .overrideTextColor(colorOrder[0]),
    new GetCollectibleResponse()
      .construct(
        getRandomCollectibleType({
          itemType: [ItemType.PASSIVE, ItemType.FAMILIAR],
        }) ?? CollectibleType.POOP,
      )
      .overrideTextColor(colorOrder[1]),
  ];
}

/** Effects to be added to a new REVETON InvertedActiveActionSet. */
function generateRevetonActiveEffects(
  _inputs?: ActionSetBuilderInput,
  colorOrder: [
    typeof EIDColorShortcut.REVETON_BLUE | typeof EIDColorShortcut.REVETON_RED,
    typeof EIDColorShortcut.REVETON_BLUE | typeof EIDColorShortcut.REVETON_RED,
  ] = [EIDColorShortcut.REVETON_BLUE, EIDColorShortcut.REVETON_RED],
): Response[] {
  return [
    new UseActiveItemResponse()
      .construct(
        getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
          CollectibleType.POOP,
      )
      .overrideTextColor(colorOrder[0]),
    new UseActiveItemResponse()
      .construct(
        getRandomCollectibleType({ itemType: ItemType.ACTIVE }) ??
          CollectibleType.POOP,
      )
      .overrideTextColor(colorOrder[1]),
  ];
}

function generateRevetonCorruptedCollectibleSprite(
  actionSet: InvertedItemActionSet,
  _inputs?: ActionSetBuilderInput,
  colorOrder: [
    typeof DeletedColor.REVETON_BLUE,
    typeof DeletedColor.REVETON_BLUE,
  ] = [DeletedColor.REVETON_BLUE, DeletedColor.REVETON_RED],
): CorruptedCollectibleSprite {
  const responses = actionSet.getResponses();
  let collectibles: Array<[CollectibleType, EIDColorShortcut]> = [];

  /**
   * For passive items, filter out for 'GetCollectibleResponses'. If it is an Active item, filter
   * for 'UseActiveItemResponses'.
   */
  collectibles =
    actionSet.actionSetType === ActionSetType.INVERTED_ACTIVE_ITEM
      ? (
          responses.filter(
            (response) =>
              response.responseType === ResponseType.USE_ACTIVE_ITEM,
          ) as UseActiveItemResponse[]
        )
          .filter((response) => {
            const collectible = response.getActiveItem();
            return typeof collectible === "number";
          })
          .map((response) => {
            const collectible = response.getActiveItem();
            return [
              collectible as CollectibleType,
              response.getTextColor() ?? EIDColorShortcut.REVETON_RED,
            ];
          })
      : (
          responses.filter((response) =>
            isGetCollectibleResponse(response),
          ) as GetCollectibleResponse[]
        )
          .filter((response) => {
            const c = response.getCollectible();
            return typeof c === "number";
          })
          .map((response) => {
            const c = response.getCollectible();
            return [
              c as CollectibleType,
              response.getTextColor() ?? EIDColorShortcut.REVETON_BLUE,
            ];
          });

  /** Rearrange collectibles array to match colorOrder. */
  collectibles.sort((a, b) => {
    if (
      a[1] === EIDColorShortcut.REVETON_RED &&
      colorOrder[0] === DeletedColor.REVETON_RED
    ) {
      return -1;
    }
    if (
      a[1] === EIDColorShortcut.REVETON_BLUE &&
      colorOrder[0] === DeletedColor.REVETON_BLUE
    ) {
      return -1;
    }
    if (
      b[1] === EIDColorShortcut.REVETON_RED &&
      colorOrder[0] === DeletedColor.REVETON_RED
    ) {
      return 1;
    }
    if (
      b[1] === EIDColorShortcut.REVETON_BLUE &&
      colorOrder[0] === DeletedColor.REVETON_BLUE
    ) {
      return 1;
    }
    return 0;
  });

  const sprite: CorruptedCollectibleSprite = {
    color: collectibles.map((c) =>
      c[1] === EIDColorShortcut.REVETON_BLUE
        ? REVETONInvertedItemBlueSpriteColor
        : REVETONInvertedItemRedSpriteColor,
    ),
    collectibles: collectibles.map((c) => c[0]),
    horizontal: false,
    flipX: false,
    flipY: false,
    seed: getRandomSeed(),
  };

  return sprite;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\collectibleHelper.ts`:

```````ts
import type { TrinketType, ItemType } from "isaac-typescript-definitions";
import {
  ActiveSlot,
  CollectibleType,
  ItemPoolType,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";
import {
  VectorZero,
  arrayRemove,
  game,
  getCollectibleChargeType,
  getCollectibleItemType,
  getCollectibleMaxCharges,
  getCollectibleName,
  getCollectibleQuality,
  getCollectibleTags,
  getEntityID,
  getPlayerIndex,
  getPlayersWithCollectible,
  getRandomArrayElement,
  getRandomSeed,
  getRoomItemPoolType,
  isHiddenCollectible,
  isRNG,
  newRNG,
  setCollectibleGlitched,
  setCollectibleSubType,
  spawnCollectible,
} from "isaacscript-common";
import { SHOP_ITEM_RENDER_OFFSET } from "../constants/renderConstants";
import { TemporaryEffectType } from "../enums/general/TemporaryEffectType";
import { playerAddTemporaryCollectible } from "../features/general/temporaryItems";
import type { CollectibleAttribute } from "../interfaces/general/CollectibleAttribute";
import { mod } from "../mod";
import type { Range } from "../types/general/Range";
import { randomInRange } from "../types/general/Range";
import { isInArrayOrEquals } from "./arrayHelper";
import {
  bitFlagsContainsAllBitflags,
  bitFlagsContainsAtLeastOneBitflags,
} from "./bitflagHelper";
import { isCollectibleFree } from "./priceHelper";
import { worldToRenderPosition } from "./renderHelper";
import { copySprite } from "./spriteHelper";
import { itemTypeToString } from "../maps/data/name/itemTypeNameMap";
import {
  addTheS,
  joinWith,
  joinWithOr,
  legibleString,
  removeUnnecessaryWhiteSpace,
  uncapitalizeFirstLetter,
} from "./stringHelper";
import { itemPoolTypeToString } from "../maps/data/name/itemPoolTypeNameMap";
import { itemConfigChargeTypeToString } from "../maps/data/name/itemConfigChargeTypeNameMap";
import { itemConfigTagToString } from "../maps/data/name/itemTagNameMap";

const CURRENT_ROOM_POOL_TEXT = "from the current room pool";

/** Replace an active item with another in a specific ActiveSlot. */
export function replaceActiveItem(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
  replaceWith: CollectibleType,
  keepInPoolsIfApplicable = true,
  firstTimePickingUpIfApplicable = true,
): void {
  if (player.GetActiveItem(activeSlot) === CollectibleType.NULL) {
    return;
  }

  if (
    activeSlot === ActiveSlot.POCKET ||
    activeSlot === ActiveSlot.POCKET_SINGLE_USE
  ) {
    player.SetPocketActiveItem(
      replaceWith,
      activeSlot,
      keepInPoolsIfApplicable,
    );
  } else {
    player.RemoveCollectible(
      player.GetActiveItem(activeSlot),
      true,
      activeSlot,
    );
    player.AddCollectible(
      replaceWith,
      0,
      firstTimePickingUpIfApplicable,
      activeSlot,
    );
  }
}

/**
 * Add a collectible to the player. If the collectible is a working collectible effect, add that
 * instead (it reapplies every room). Returns 'true' if it added a collectible effect, and 'false'
 * if it added a collectible.
 */
export function addCollectibleOrEffect(
  player: EntityPlayer,
  collectible: CollectibleType,
): boolean {
  return playerAddTemporaryCollectible(
    player,
    collectible,
    TemporaryEffectType.PERMANENT,
  );
}

/**
 * Returns the offset when rendering an item sprite. For example, shop items are rendered at a
 * different Y coordinate than pedestal items.
 */
export function getCollectibleRenderOffset(
  collectible: EntityPickupCollectible,
): Vector {
  if (!isCollectibleFree(collectible)) {
    return SHOP_ITEM_RENDER_OFFSET;
  }

  return VectorZero;
}

export function getRandomTrinketType(): TrinketType {
  const trinketArray = mod.getTrinketTypes();
  return getRandomArrayElement(trinketArray, getRandomSeed());
}

/** Get a random amount of random collectibles. */
export function getRandomAssortmentOfCollectibles(
  range: Range = [1, 5],
  collectibleAttributes: CollectibleAttribute | undefined = undefined,
  seedOrRNG: Seed | RNG = getRandomSeed(),
): readonly CollectibleType[] {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);
  const amount = randomInRange(range, rng);
  const collectibles: CollectibleType[] = [];
  for (let i = 0; i < amount; i++) {
    collectibles.push(
      getRandomCollectibleType(collectibleAttributes, rng) ??
        CollectibleType.SAD_ONION,
    );
  }
  return collectibles;
}

/**
 * Makes a Pedestal's Collectible sprite invisible, while still being able to be picked up. Use this
 * instead of 'clearSprite()' as this does not replace the spritesheet, allowing TMTRAINER sprites
 * to not disappear. This function should only be called in the 'PostRender' callback!
 */
export function renderCollectibleInvisible(
  pedestal: EntityPickupCollectible,
): void {
  const copiedSprite = copySprite(pedestal.GetSprite());
  pedestal.GetSprite().Color = Color(0, 0, 0, 0);
  copiedSprite.Play("Alternates", true);
  copiedSprite.Render(worldToRenderPosition(pedestal.Position));
}

/** Spawns a TMTRAINER item. */
export function spawnGlitchedCollectible(
  positionOrGridIndex: Vector,
): EntityPickupCollectible {
  const glitchedCollectible = spawnCollectible(
    CollectibleType.SAD_ONION,
    positionOrGridIndex,
    undefined,
  );
  setCollectibleGlitched(glitchedCollectible);
  return glitchedCollectible;
}

/** Reroll a pedestal from the ItemPool its Collectible is from. */
export function rerollCollectible(
  collectible: EntityPickupCollectible,
): EntityPickupCollectible {
  const collectiblePoolType = mod.getCollectibleItemPoolType(collectible);
  const newCollectibleType = game
    .GetItemPool()
    .GetCollectible(
      collectiblePoolType,
      undefined,
      undefined,
      getRandomCollectibleType({}) ?? CollectibleType.POOP,
    );
  setCollectibleSubType(collectible, newCollectibleType);
  return collectible;
}

/**
 * Checks if a specified CollectibleType matches all attributes set through the CollectibleAttribute
 * object.
 */
export function doesCollectibleTypeMatchAttributes(
  collectibleType: CollectibleType,
  collectibleAttributes: CollectibleAttribute,
): boolean {
  // Item Type.
  const { itemType } = collectibleAttributes;

  // Forced.
  const { forced } = collectibleAttributes;
  if (forced !== undefined && forced.includes(collectibleType)) {
    return true;
  }

  // Item Type.
  if (
    itemType !== undefined &&
    !isInArrayOrEquals<ItemType>(
      getCollectibleItemType(collectibleType),
      itemType,
    )
  ) {
    return false;
  }

  // Pool Type.
  /** Needs fixing. */
  const { poolType } = collectibleAttributes;
  if (poolType !== undefined) {
    const currentCollectiblePoolType = ItemPoolType.ANGEL;
    if ((poolType as string) === "room") {
      if (getRoomItemPoolType() !== currentCollectiblePoolType) {
        return false;
      }
    } else if (!isInArrayOrEquals(currentCollectiblePoolType, poolType)) {
      return false;
    }
  }

  // Item quality.
  const { quality } = collectibleAttributes;
  if (
    quality !== undefined &&
    !isInArrayOrEquals<number>(getCollectibleQuality(collectibleType), quality)
  ) {
    return false;
  }

  // Charge type (passive collectibles return 'normal').
  const { chargeType } = collectibleAttributes;
  if (
    chargeType !== undefined &&
    !isInArrayOrEquals(getCollectibleChargeType(collectibleType), chargeType)
  ) {
    return false;
  }

  // Max charges (passive collectibles return '0').
  const { maxCharges } = collectibleAttributes;
  if (
    maxCharges !== undefined &&
    !isInArrayOrEquals(getCollectibleMaxCharges(collectibleType), maxCharges)
  ) {
    return false;
  }

  // Player has.
  const { playerHas } = collectibleAttributes;
  if (playerHas !== undefined) {
    const doSomeHave = getPlayersWithCollectible(collectibleType).some(
      (player) => {
        // Prevent it including player pocket items.
        if (player.GetActiveItem(ActiveSlot.POCKET) === collectibleType) {
          return false;
        }
        return true;
      },
    );
    if (playerHas !== doSomeHave) {
      return false;
    }
    return true;
  }

  // Starts with (capitalization doesn't matter).
  const { startsWith } = collectibleAttributes;
  if (startsWith !== undefined) {
    const lcCurrentCollectibleName =
      getCollectibleName(collectibleType).toLowerCase();
    const lcStartsWith = startsWith.toLowerCase();
    if (!lcCurrentCollectibleName.startsWith(lcStartsWith)) {
      return false;
    }
  }

  // Starts with (capitalization doesn't matter).
  const { endsWith } = collectibleAttributes;
  if (endsWith !== undefined) {
    const lcCurrentCollectibleName =
      getCollectibleName(collectibleType).toLowerCase();
    const lcEndsWith = endsWith.toLowerCase();
    if (!lcCurrentCollectibleName.endsWith(lcEndsWith)) {
      return false;
    }
  }

  // Item tags (contains ALL).
  const { itemTagAll } = collectibleAttributes;
  if (itemTagAll !== undefined) {
    const currentCollectibleTags = getCollectibleTags(collectibleType);
    if (!bitFlagsContainsAllBitflags(currentCollectibleTags, itemTagAll)) {
      return false;
    }
  }

  // Item tags (contains AT LEAST ONE).
  const { itemTagOne } = collectibleAttributes;
  if (itemTagOne !== undefined) {
    const currentCollectibleTags = getCollectibleTags(collectibleType);
    if (
      !bitFlagsContainsAtLeastOneBitflags(currentCollectibleTags, itemTagOne)
    ) {
      return false;
    }
  }

  // Banned Collectibles.
  const { banned } = collectibleAttributes;
  if (banned !== undefined && banned.includes(collectibleType)) {
    return false;
  }

  // Hidden.
  const { hidden } = collectibleAttributes;
  if (
    (hidden === undefined || !hidden) &&
    isHiddenCollectible(collectibleType)
  ) {
    return false;
  }

  return true;
}

/**
 * Returns a random CollectibleType following the properties defined in the CollectibleAttribute
 * object.
 *
 * @param collectibleAttributes The CollectibleAttribute object to follow, or undefined for a random
 *                              CollectibleType.
 * @param seedOrRNG The seed or RNG to use.
 * @param collectibleArray The array of CollectibleTypes to choose from, or undefined for all
 *                         CollectibleTypes (including modded).
 * @returns The CollectibleType, or undefined if no CollectibleType was found.
 */
export function getRandomCollectibleType(
  collectibleAttributes?: CollectibleAttribute,
  seedOrRNG: Seed | RNG = getRandomSeed(),
  collectibleArray:
    | CollectibleType[]
    | readonly CollectibleType[] = mod.getCollectibleTypes(),
): CollectibleType | undefined {
  let filteredCollectibles = [...collectibleArray];
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);
  let currentCollectible: CollectibleType | undefined;
  let i = 0;

  while (filteredCollectibles.length > 0) {
    currentCollectible = getRandomArrayElement(filteredCollectibles, rng);
    if (collectibleAttributes === undefined) {
      break;
    }

    filteredCollectibles = arrayRemove(
      filteredCollectibles,
      currentCollectible,
    );
    i++;

    if (
      doesCollectibleTypeMatchAttributes(
        currentCollectible,
        collectibleAttributes,
      )
    ) {
      break;
    }
  }

  return filteredCollectibles.length === 0 ? undefined : currentCollectible;
}

/**
 * Convert a CollectibleAttribute object to the appropriate text.
 *
 * @example { quality: 4, itemType: ItemType.ACTIVE } -> "a random quality 4 active item".
 */
export function collectibleAttributeToText(
  collectibleAttribute: CollectibleAttribute,
  plural = false,
): string {
  let text = plural ? "random " : "a random ";

  // Item Type.
  if (collectibleAttribute.itemType !== undefined) {
    text +=
      typeof collectibleAttribute.itemType === "number"
        ? `${itemTypeToString(collectibleAttribute.itemType)} `
        : `${joinWithOr(
            collectibleAttribute.itemType.flatMap((q) => itemTypeToString(q)),
          )}`;
  }

  // Item.
  text = `${text} ${addTheS("item", plural)} `;

  // We set up a textArray, so we can join it with 'and' later, and for greater flexibility.
  const textArray = [] as string[];

  // Quality.
  if (collectibleAttribute.quality !== undefined) {
    textArray.push(
      typeof collectibleAttribute.quality === "number"
        ? `of quality ${collectibleAttribute.quality}`
        : `of quality ${joinWithOr(
            collectibleAttribute.quality.flatMap((q) => tostring(q)),
          )}`,
    );
  }

  // PoolType.
  if (collectibleAttribute.poolType !== undefined) {
    if (collectibleAttribute.poolType === "room") {
      textArray.push(` ${CURRENT_ROOM_POOL_TEXT}`);
    } else if (typeof collectibleAttribute.poolType === "number") {
      textArray.push(
        `from the ${itemPoolTypeToString(collectibleAttribute.poolType)} pool`,
      );
    } else {
      textArray.push(
        `from the ${joinWithOr(
          collectibleAttribute.poolType.flatMap((q) => itemPoolTypeToString(q)),
        )} pool`,
      );
    }
  }

  // ChargeType.
  if (collectibleAttribute.chargeType !== undefined) {
    textArray.push(
      typeof collectibleAttribute.chargeType === "number"
        ? `with has a '${itemConfigChargeTypeToString(
            collectibleAttribute.chargeType,
          )} charge'`
        : `with a ${joinWithOr(
            collectibleAttribute.chargeType.flatMap(
              (q) => `${itemConfigChargeTypeToString(q)}`,
            ),
          )} charge`,
    );
  }

  // MaxCharges
  if (collectibleAttribute.maxCharges !== undefined) {
    textArray.push(
      typeof collectibleAttribute.maxCharges === "number"
        ? `which has a charge count of ${collectibleAttribute.maxCharges}`
        : `which has a charge count of ${joinWithOr(
            collectibleAttribute.maxCharges.flatMap((q) => tostring(q)),
          )}`,
    );
  }

  // Owned by player.
  if (collectibleAttribute.playerHas !== undefined) {
    textArray.push(
      collectibleAttribute.playerHas
        ? "that a player already owns"
        : "that a player doesn't already own",
    );
  }

  // Starts with (capitalization doesn't matter).
  if (collectibleAttribute.startsWith !== undefined) {
    textArray.push(
      `that starts with '${collectibleAttribute.startsWith.toUpperCase()}'`,
    );
  }

  // Ends with (capitalization doesn't matter).
  if (collectibleAttribute.endsWith !== undefined) {
    textArray.push(
      `that ends with '${collectibleAttribute.endsWith.toUpperCase()}'`,
    );
  }

  // Item tags (contains ALL).
  if (collectibleAttribute.itemTagAll !== undefined) {
    textArray.push(
      `that ${joinWith(
        "and",
        collectibleAttribute.itemTagAll.flatMap((q) =>
          uncapitalizeFirstLetter(itemConfigTagToString(q)),
        ),
      )}`,
    );
  }

  // Item tags (contains AT LEAST ONE).
  if (collectibleAttribute.itemTagOne !== undefined) {
    textArray.push(
      `that ${joinWith(
        "or",
        collectibleAttribute.itemTagOne.flatMap((q) =>
          uncapitalizeFirstLetter(itemConfigTagToString(q)),
        ),
      )}`,
    );
  }

  // If the textArray is empty or has one element.
  text += ` ${textArray[0]} `;

  // If the textArray has more than one elements.
  if (textArray.length > 1) {
    textArray.shift();
    text += textArray.join(", ");
  }

  return text;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\colorHelper.ts`:

```````ts
import { ColorDefault, round } from "isaacscript-common";

/** Sets a Sprite to the DefaultColor (Color(1, 1, 1, 1)). */
export function setEntityDefaultColor(entity: Entity): void {
  const sprite = entity.GetSprite();

  sprite.Color = ColorDefault;
}

/** Converts a Color object into a KColor object. */
export function colorToKColor(color: Color): KColor {
  return KColor(color.R, color.G, color.B, color.A);
}

/** Makes a Color slightly redder. */
export function reddenColor(color: Color, a = 1): Color {
  /** Reduce 'G' value by 0.1, but not less than 0. */
  color.G = color.G - 0.2 < 0 ? 0 : color.G - 0.1;

  /** Reduce 'B' value by 0.1, but not less than 0. */
  color.B = color.B - 0.2 < 0 ? 0 : color.B - 0.1;

  /** Increase Red offset by a small amount. */
  color.RO = color.RO + 0.01 * a > 1 ? 1 : color.RO + 0.01 * a;
  return color;
}

/** Makes a Color slightly bluer. */
export function bluenColor(color: Color, a = 1): Color {
  /** Reduce 'R' value by 0.1, but not less than 0. */
  color.R = color.R - 0.2 < 0 ? 0 : color.R - 0.1;

  /** Reduce 'G' value by 0.1, but not less than 0. */
  color.G = color.G - 0.2 < 0 ? 0 : color.G - 0.1;

  /** Increase Blue offset by a small amount. */
  color.BO = color.BO + 0.01 * a > 1 ? 1 : color.BO + 0.01 * a;
  return color;
}

/** Very simple color mixing. Mix any amount of Colors. */
export function mixColors(...colors: Color[]): Color {
  const mixedColor = Color(0, 0, 0, 0);
  for (const color of colors) {
    mixedColor.R += color.R;
    mixedColor.G += color.G;
    mixedColor.B += color.B;
    mixedColor.A += color.A;
  }
  mixedColor.R /= colors.length;
  mixedColor.G /= colors.length;
  mixedColor.B /= colors.length;
  mixedColor.A /= colors.length;
  return mixedColor;
}

/** Converts a Color object into a Colorize array. */
export function colorToColorize(
  color: Color,
): [number, number, number, number] {
  return [color.R, color.G, color.B, color.A];
}

/** Convert a KColor to a string using its rounded RGBA values. */
export function kColorToString(color: KColor): string {
  return `${round(color.Red, 2)},${round(color.Green, 2)},${round(
    color.Blue,
    2,
  )},${round(color.Alpha, 2)}`;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\Andromeda\andromedaHelper.ts`:

```````ts
/** Returns true if the 'Andromeda' mod is currently active. */
export function isAndromedaActive(): boolean {
  return ANDROMEDA !== undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\EID\EIDHelper.ts`:

```````ts
import type {
  CollectibleType,
  TrinketType,
} from "isaac-typescript-definitions";
import type { EntityID } from "isaacscript-common";
import {
  getCollectibleName,
  getConstituentsFromEntityID,
  getEntityID,
  getTrinketName,
} from "isaacscript-common";
import { EID_ENTITY_DATA_KEY } from "../../../constants/eidConstants";
import type { EIDColorShortcut } from "../../../enums/compatibility/EID/EIDColor";
import type { Morality } from "../../../enums/corruption/Morality";
import type { EIDDescObject } from "../../../interfaces/compatibility/EIDDescObject";
import { getEIDColorShortcutFromMorality } from "../../../maps/compatibility/EIDColorMap";
import { getEIDTextSetting } from "../../../features/settings/EIDSettings";
import { EIDObjectDisplaySetting } from "../../../enums/settings/EIDObjectDisplaySetting";
import { addTheS } from "../../stringHelper";

/** Returns the Collectible icon for EID. */
export function getEIDIconFromCollectible(
  collectibleType: CollectibleType,
): string {
  return `{{Collectible${collectibleType}}}`;
}

/** Returns the Trinket icon for EID. */
export function getEIDIconFromTrinket(trinketType: TrinketType): string {
  return `{{Trinket${trinketType}}}`;
}

/** Convert a shortcut string to an EID Markup Object. */
export function getEIDMarkupFromShortcut(shortcut: string): string {
  return `{{${shortcut}}}`;
}

/**
 * Convert a shortcut string to an EID Markup Object. This may be a KColor or a function which
 * returns a KColor.
 */
export function getEIDMarkupFromEIDColorShortcut(
  shortcut: EIDColorShortcut,
): string {
  return `{{${shortcut}}}`;
}

/** Get the recommended EID Markup shortcut from Morality. */
export function getEIDMarkupFromMorality(morality: Morality): string {
  return getEIDMarkupFromShortcut(getEIDColorShortcutFromMorality(morality));
}

/**
 * Sets an EID description unique to a specific entity (with a unique index). This will override
 * more generic EID descriptions.
 */
export function setSpecificEntityEIDDescriptionObject(
  entity: Entity,
  object: EIDDescObject,
): void {
  if (EID === undefined) {
    return;
  }
  entity.GetData()[EID_ENTITY_DATA_KEY] = object;
}

/**
 * Obtain the generic EID Description of the entity. This EID Description will be prevalent on all
 * entities of the same type. It does not get overridden by specific EID Descriptions.
 */
export function getGenericEntityEIDDescriptionObject(
  entity: Entity | EntityID,
): EIDDescObject | undefined {
  if (EID === undefined) {
    return undefined;
  }
  if (typeof entity !== "string") {
    entity = getEntityID(entity);
  }
  const constituents = getConstituentsFromEntityID(entity);
  return EID.getDescriptionObj(...constituents) as unknown as EIDDescObject;
}

/**
 * Get the specified collectible's name, icon, or both, aligning with the current EIDTextSetting.
 */
export function getCollectibleNameWithEIDSetting(
  collectibleType: CollectibleType,
  plural = false,
  eid = true,
): string {
  const EIDSetting = eid
    ? getEIDTextSetting()
    : EIDObjectDisplaySetting.TEXT_ONLY;
  let text = "";

  if (EIDSetting !== EIDObjectDisplaySetting.ICON_ONLY) {
    text += getCollectibleName(collectibleType);
  }

  if (EIDSetting === EIDObjectDisplaySetting.TEXT_AND_ICON) {
    text += " ";
  }

  if (EIDSetting !== EIDObjectDisplaySetting.TEXT_ONLY) {
    text += addTheS(getEIDIconFromCollectible(collectibleType), plural);
  }

  return text;
}

/**
 * Get the specified trinket's name, icon, or both, aligning with the current EIDTextSetting.
 *
 * @example "Match Stick" or "{{TrinketMatchStick}}" or "Match Stick {{TrinketMatchStick}}".
 *
 * @param trinketType The trinket type to get the name of.
 * @param plural Whether or not to pluralize the name (default false).
 * @param eid If false, will default to EIDObjectDisplaySetting.TEXT_ONLY (default true).
 */
export function getTrinketNameWithEIDSetting(
  trinketType: TrinketType,
  plural = false,
  eid = true,
): string {
  const EIDSetting = eid
    ? getEIDTextSetting()
    : EIDObjectDisplaySetting.TEXT_ONLY;
  let text = "";

  if (EIDSetting !== EIDObjectDisplaySetting.ICON_ONLY) {
    text += getTrinketName(trinketType);
  }

  if (EIDSetting === EIDObjectDisplaySetting.TEXT_AND_ICON) {
    text += " ";
  }

  if (EIDSetting !== EIDObjectDisplaySetting.TEXT_ONLY) {
    text += addTheS(getEIDIconFromTrinket(trinketType), plural);
  }

  return text;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\externalModHelper.ts`:

```````ts
import { getEnumValues, log } from "isaacscript-common";
import { Mods } from "../../enums/compatibility/Mods";
import { isFiendFolioActive } from "./FiendFolio/fiendFolioHelper";
import { isAndromedaActive } from "./Andromeda/andromedaHelper";

/** Retrieve a list of all known active mods. */
export function getActiveMods(): Mods[] {
  const modList = [];
  for (const mod of getEnumValues(Mods)) {
    if (mod === Mods.FIEND_FOLIO && isFiendFolioActive()) {
      modList.push(mod);
    } else if (mod === Mods.ANDROMEDA && isAndromedaActive()) {
      modList.push(mod);
    }
  }
  return modList;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\FiendFolio\fiendFolioHelper.ts`:

```````ts
export function isFiendFolioActive(): boolean {
  return FiendFolio !== undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\XML\entities2XMLHelper.ts`:

```````ts
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
import type { EntityID } from "isaacscript-common";
import {
  getEnumKeys,
  getEnumValues,
  log,
  spawnEntityID,
} from "isaacscript-common";
import { getEntityCategory } from "../../entityHelper";
import type { EntityCategory } from "../../../enums/general/EntityCategory";
import { getEntityIDFromNameSubType } from "../../entityHelper/entityIDHelper";
import { splitString } from "../../stringHelper";
import { fprint } from "../../printHelper";
import { ItemPoolType, CollectibleType } from "isaac-typescript-definitions";
import { getQuickAccessiblePosition } from "../../positionHelper";

/** 1. First, 'entities2Parser.py' is run to generate the */

/**
 * For a pool of entities, returns a map of entities that match the entityCategory, in the form of
 * Key = [name, subType]
 */
export function filterEntities2Map(
  entityMap:
    | Map<string, [string, number]>
    | ReadonlyMap<string, [string, number]>,
  entityCategory: EntityCategory,
): Map<string, [string, number]> {
  const filteredMap = new Map<string, [string, number]>();
  for (const [key, [name, subType]] of entityMap) {
    const type = Isaac.GetEntityTypeByName(name) as number;
    const variant = Isaac.GetEntityVariantByName(name);
    if (type === -1 || variant === -1) {
      fprint(
        `Could not find entity: ${name}, type: ${type}, variant: ${variant}`,
      );
      continue;
    }
    const idToSpawn = `${type}.${variant}.${subType}`;
    log(`Found entity ID: ${idToSpawn}, with name: ${name}`);
    const entity = spawnEntityID(
      idToSpawn as EntityID,
      getQuickAccessiblePosition(),
    );
    if (entity === undefined) {
      fprint(`Could not spawn entity: ${idToSpawn}`);
      continue;
    }
    const category = getEntityCategory(entity);
    if (category === entityCategory) {
      filteredMap.set(key, [name, subType]);
    }
    entity.Remove();
  }
  return filteredMap;
}

export function logEntities2Map(
  effectMap: Map<string, [string, number]>,
): void {
  log(`logging effect map of size: ${effectMap.size}`);

  // Log the result in the format of a typescript enum entry:
  let stringToPrint = "";
  for (const [key, nameSubType] of effectMap) {
    const name = nameSubType[0];
    const subType = nameSubType[1];

    const str = `${key}: "${subType}.${name}",`;
    stringToPrint += str;
  }

  // Split string in two:
  for (const str of splitString(stringToPrint, 4)) {
    log(str);
  }
}

export function logModNPCFlyingAsSet(
  nameSubTypeEnum: any,
  nameOfEnum: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const modNameSubTypeEnumKeys = getEnumKeys(nameSubTypeEnum);

  // Get subset up to 'FiendFolioNameSubType.FIEND_FOLIO_SHOPKEEPER'.
  const modNameSubTypeEnumKeysSubset = modNameSubTypeEnumKeys.slice(
    sliceStart ?? 0,
    sliceEnd ?? modNameSubTypeEnumKeys.length,
  );

  let str = "";
  for (const modNameSubTypeKey of modNameSubTypeEnumKeysSubset) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const nameSubType =
      nameSubTypeEnum[modNameSubTypeKey as keyof typeof nameSubTypeEnum];
    const npcID = getEntityIDFromNameSubType(nameSubType);
    if (npcID === undefined) {
      continue;
    }
    const ent = spawnEntityID(npcID, getQuickAccessiblePosition());
    if (ent.IsFlying()) {
      str += `${nameOfEnum}.${modNameSubTypeKey},`;
    }
    ent.Remove();
  }

  log(str);
}

export function logModNPCBossesAsSet(
  nameSubTypeEnum: any,
  nameOfEnum: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const modNameSubTypeEnumKeys = getEnumKeys(nameSubTypeEnum);

  // Get subset up to 'FiendFolioNameSubType.FIEND_FOLIO_SHOPKEEPER'.
  const modNameSubTypeEnumKeysSubset = modNameSubTypeEnumKeys.slice(
    sliceStart ?? 0,
    sliceEnd ?? modNameSubTypeEnumKeys.length,
  );

  let str = "";
  for (const modNameSubTypeKey of modNameSubTypeEnumKeysSubset) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const nameSubType =
      nameSubTypeEnum[modNameSubTypeKey as keyof typeof nameSubTypeEnum];
    const npcID = getEntityIDFromNameSubType(nameSubType);
    if (npcID === undefined) {
      continue;
    }
    const ent = spawnEntityID(npcID, getQuickAccessiblePosition());
    if (ent.IsBoss()) {
      str += `${nameOfEnum}.${modNameSubTypeKey},`;
    }
    ent.Remove();
  }

  log(str);
}

export function logModEntitySizesAsObjects(
  nameSubTypeEnum: any,
  nameOfEnum: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const modNameSubTypeEnumKeys = getEnumKeys(nameSubTypeEnum);

  // Get subset up to 'FiendFolioNameSubType.FIEND_FOLIO_SHOPKEEPER'.
  const modNameSubTypeEnumKeysSubset = modNameSubTypeEnumKeys.slice(
    sliceStart ?? 0,
    sliceEnd ?? modNameSubTypeEnumKeys.length,
  );

  let str = "";
  for (const modNameSubTypeKey of modNameSubTypeEnumKeysSubset) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const nameSubType =
      nameSubTypeEnum[modNameSubTypeKey as keyof typeof nameSubTypeEnum];
    const npcID = getEntityIDFromNameSubType(nameSubType);
    if (npcID === undefined) {
      continue;
    }
    const ent = spawnEntityID(npcID, getQuickAccessiblePosition());
    const size = ent.Size;
    str += `[${nameOfEnum}.${modNameSubTypeKey}]: ${size},`;
    ent.Remove();
  }

  log(str);
}

export function logModEntityMassesAsObjects(
  nameSubTypeEnum: any,
  nameOfEnum: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const modNameSubTypeEnumKeys = getEnumKeys(nameSubTypeEnum);

  // Get subset up to 'FiendFolioNameSubType.FIEND_FOLIO_SHOPKEEPER'.
  const modNameSubTypeEnumKeysSubset = modNameSubTypeEnumKeys.slice(
    sliceStart ?? 0,
    sliceEnd ?? modNameSubTypeEnumKeys.length,
  );

  let str = "";
  for (const modNameSubTypeKey of modNameSubTypeEnumKeysSubset) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const nameSubType =
      nameSubTypeEnum[modNameSubTypeKey as keyof typeof nameSubTypeEnum];
    const npcID = getEntityIDFromNameSubType(nameSubType);
    if (npcID === undefined) {
      continue;
    }
    const ent = spawnEntityID(npcID, getQuickAccessiblePosition());
    const size = ent.Mass;
    str += `[${nameOfEnum}.${modNameSubTypeKey}]: ${size},`;
    ent.Remove();
  }

  log(str);
}

export function logModEntityMaxHitPointsAsObject(
  nameSubTypeEnum: any,
  nameOfEnum: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const modNameSubTypeEnumKeys = getEnumKeys(nameSubTypeEnum);

  // Get subset up to 'FiendFolioNameSubType.FIEND_FOLIO_SHOPKEEPER'.
  const modNameSubTypeEnumKeysSubset = modNameSubTypeEnumKeys.slice(
    sliceStart ?? 0,
    sliceEnd ?? modNameSubTypeEnumKeys.length,
  );

  let str = "";
  for (const modNameSubTypeKey of modNameSubTypeEnumKeysSubset) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const nameSubType =
      nameSubTypeEnum[modNameSubTypeKey as keyof typeof nameSubTypeEnum];
    const npcID = getEntityIDFromNameSubType(nameSubType);
    if (npcID === undefined) {
      continue;
    }
    const ent = spawnEntityID(npcID, getQuickAccessiblePosition());
    const size = ent.MaxHitPoints;
    str += `[${nameOfEnum}.${modNameSubTypeKey}]: ${size},`;
    ent.Remove();
  }

  log(`logModEntityMaxHitPointsAsObject: ${str}`);
}

export function logNonModdedEntitiesAttributes(
  nonModdedEnum: any,
  nonModdedEnumName: string,
  sliceStart?: number,
  sliceEnd?: number,
): void {
  const enumValuesNonSliced = getEnumValues(nonModdedEnum);
  const enumValues = enumValuesNonSliced.slice(
    sliceStart ?? 0,
    sliceEnd ?? enumValuesNonSliced.length,
  );
  let str = "";

  for (const enumValue of enumValues) {
    const entity = spawnEntityID(
      enumValue as EntityID,
      getQuickAccessiblePosition(),
    );
    const key = getEnumKeys(nonModdedEnum).find(
      (key) => nonModdedEnum[key as keyof typeof nonModdedEnum] === enumValue,
    );

    if (entity === undefined) {
      continue;
    }

    // Attribute.
    const maxHitPoints = entity.MaxHitPoints;

    entity.Remove();

    // Log.
    str += `[${nonModdedEnumName}.${key}, ${maxHitPoints}],`;
  }

  log(`nonModdedLog: ${str}`);
}

export function logNonModdedCollectibleTypeItemPoolMap(
  map: Map<number, ItemPoolType[]>,
): void {
  let str = "";
  for (const [key, value] of map) {
    const keyAsString = getEnumKeys(CollectibleType).find(
      (k) => CollectibleType[k as keyof typeof CollectibleType] === key,
    );
    const valueAsString: string[] = [];
    for (const itemPoolType of value) {
      const itemPoolTypeAsString = getEnumKeys(ItemPoolType).find(
        (k) => ItemPoolType[k as keyof typeof ItemPoolType] === itemPoolType,
      );
      if (itemPoolTypeAsString === undefined) {
        continue;
      }
      valueAsString.push(`ItemPoolType.${itemPoolTypeAsString}`);
    }
    log(`[CollectibleType.${keyAsString}, [${valueAsString.join(",")}]],`);
  }

  // // Split into multiple lines. for (const strSplit of splitString(str, 20)) { log(strSplit); }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\compatibility\XML\moddedXMLParserHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import type { Mods } from "../../../enums/compatibility/Mods";
import { EntityCategory } from "../../../enums/general/EntityCategory";
import type {
  Entities2XML,
  EntityXML,
} from "../../../interfaces/xml/entities2XML";
import * as moddedXMLParser from "../../../lua/moddedXMLParser";
import { getModFromModdedEntityID } from "../../../maps/data/moddedEntityIDToModMap";
import { getNameSubTypeFromModdedEntityID } from "../../../maps/data/moddedEntityIDToNameSubType";
import type { NameSubType } from "../../../types/data/nameSubType";
import { getEntityCategoryFromEntityID } from "../../entityHelper/entityIDHelper";

/**
 * Gets an array of NameSubTypes for the specified entity category and mod. If there are no entities
 * for the specified category, then undefined is returned. These NameSubTypes can then be used to
 * get the entity ID.
 */
export function getModdedEntityNameSubTypesFromCategory(
  mod: Mods,
  entityCategory: EntityCategory,
): readonly NameSubType[] | undefined {
  const entityData = getModdedEntityDataFromCategory(mod, entityCategory);
  if (entityData === undefined) {
    return undefined;
  }
  return Object.keys(entityData) as NameSubType[];
}

/**
 * Get an array of modded entity data for the specified entity category. If the mod does not have
 * any entity data for the specified category (in entities2.xml), then undefined is returned.
 */
export function getModdedEntityDataFromCategory(
  mod: Mods,
  entityCategory: EntityCategory,
): Entities2XML | undefined {
  switch (entityCategory) {
    case EntityCategory.FAMILIAR: {
      return moddedXMLParser.getEntityFamiliars(mod);
    }

    case EntityCategory.PICKUP: {
      return moddedXMLParser.getEntityPickups(mod);
    }

    case EntityCategory.TEAR: {
      return moddedXMLParser.getEntityTears(mod);
    }

    case EntityCategory.BOMB: {
      return moddedXMLParser.getEntityBombs(mod);
    }

    case EntityCategory.KNIFE: {
      return moddedXMLParser.getEntityKnives(mod);
    }

    case EntityCategory.LASER: {
      return moddedXMLParser.getEntityLasers(mod);
    }

    case EntityCategory.NPC: {
      return moddedXMLParser.getEntityNPCs(mod);
    }

    case EntityCategory.PROJECTILE: {
      return moddedXMLParser.getEntityProjectiles(mod);
    }

    case EntityCategory.PLAYER: {
      return moddedXMLParser.getEntityPlayers(mod);
    }

    case EntityCategory.EFFECT: {
      return moddedXMLParser.getEntityEffects(mod);
    }

    case EntityCategory.SLOT: {
      return moddedXMLParser.getEntitySlots(mod);
    }

    default: {
      return undefined;
    }
  }
}

/**
 * Get the entity data for the specified entity category and NameSubType. If the mod does not have
 * any entity data for the specified category (in entities2.xml), then undefined is returned.
 */
export function getModdedEntityDataFromCategoryAndNameSubType(
  mod: Mods,
  entityCategory: EntityCategory,
  nameSubType: NameSubType,
): EntityXML | undefined {
  const entityData = getModdedEntityDataFromCategory(mod, entityCategory);
  if (entityData === undefined) {
    return undefined;
  }
  return entityData[nameSubType];
}

/** Get the modded entity's EntityXML data from only the EntityID. */
export function getModdedEntityDataFromEntityID(
  entityID: EntityID,
): EntityXML | undefined {
  const modFrom = getModFromModdedEntityID(entityID);
  if (modFrom === undefined) {
    return undefined;
  }
  const nameSubType = getNameSubTypeFromModdedEntityID(entityID);
  if (nameSubType === undefined) {
    return undefined;
  }
  const entityCategory = getEntityCategoryFromEntityID(entityID);
  return getModdedEntityDataFromCategoryAndNameSubType(
    modFrom,
    entityCategory,
    nameSubType,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\costumeHelper.ts`:

```````ts
import {
  addCollectibleCostume,
  removeCollectibleCostume,
} from "isaacscript-common";
import { mod } from "../mod";

/** Restores all item costumes. */
export function restoreAllCostumes(player: EntityPlayer): void {
  mod.getPlayerCollectibleTypes(player).forEach((collectibleType) => {
    addCollectibleCostume(player, collectibleType);
  });
}

/** Removes all item costumes the player has. */
export function removeAllCostumes(player: EntityPlayer): void {
  mod.getPlayerCollectibleTypes(player).forEach((collectibleType) => {
    removeCollectibleCostume(player, collectibleType);
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\curseHelper.ts`:

```````ts
import type { LevelCurse } from "isaac-typescript-definitions";
import { game } from "isaacscript-common";

/** Get all active curses. */
export function getCurses(): BitFlags<LevelCurse> {
  return game.GetLevel().GetCurses();
}

/** Determine if the floor has any curses active. */
export function hasAnyCurse(): boolean {
  return getCurses() !== 0;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\damageHelper.ts`:

```````ts
import { DamageFlag } from "isaac-typescript-definitions";
import { bitFlagsContainsAtLeastOneBitflags } from "./bitflagHelper";

/** Damage that makes sense when triggering effects. */
export function isSensibleDamage(damageFlags: BitFlags<DamageFlag>): boolean {
  return !bitFlagsContainsAtLeastOneBitflags(damageFlags, [
    DamageFlag.DEVIL,
    DamageFlag.CHEST,
    DamageFlag.IV_BAG,
    DamageFlag.NO_PENALTIES,
    DamageFlag.CURSED_DOOR,
    DamageFlag.RED_HEARTS,
  ]);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\actionSetHelper.ts`:

```````ts
import type { InvertedActiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import type { InvertedPassiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import type { NonInvertedPickupActionSet } from "../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import { ActionSetType } from "../../enums/corruption/actionSets/ActionSetType";

/** Type guard to check if ActionSet is for an Inverted Active Item. */
export function isInvertedActiveActionSet(
  actionSet:
    | InvertedActiveActionSet
    | InvertedPassiveActionSet
    | NonInvertedPickupActionSet,
): actionSet is InvertedActiveActionSet {
  return actionSet.actionSetType === ActionSetType.INVERTED_ACTIVE_ITEM;
}

/** Type guard to check if ActionSet is for an Inverted Passive Item. */
export function isInvertedPassiveActionSet(
  actionSet:
    | InvertedActiveActionSet
    | InvertedPassiveActionSet
    | NonInvertedPickupActionSet,
): actionSet is InvertedPassiveActionSet {
  return actionSet.actionSetType === ActionSetType.INVERTED_PASSIVE_ITEM;
}

/** Type guard to check if ActionSet is for an Non-Inverted Pickup. */
export function isNonInvertedPickupActionSet(
  actionSet:
    | InvertedActiveActionSet
    | InvertedPassiveActionSet
    | NonInvertedPickupActionSet,
): actionSet is NonInvertedPickupActionSet {
  return actionSet.actionSetType === ActionSetType.NON_INVERTED_PICKUP;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\deletedHelper.ts`:

```````ts
import { getPlayers } from "isaacscript-common";
import { CharacterType } from "../../enums/general/CharacterType";
import { Mode } from "../../enums/modes/Mode";
import { getModeData, PLAYERTYPE_MODE_MAP } from "../../maps/modes/modeMap";

/** Determines if the player is of type Deleted or Tainted Deleted. */
export function isPlayerDeleted(player: EntityPlayer): boolean {
  return PLAYERTYPE_MODE_MAP.get(player.GetPlayerType()) !== undefined;
}

/** Determines if the player is of type non-Tainted Deleted. */
export function isPlayerNormalDeleted(player: EntityPlayer): boolean {
  const mode = PLAYERTYPE_MODE_MAP.get(player.GetPlayerType());
  if (mode !== undefined) {
    return CharacterType.NORMAL === getModeData(mode).characterType;
  }
  return false;
}

/** Determines if the player is of type Tainted Deleted. */
export function isPlayerTaintedDeleted(player: EntityPlayer): boolean {
  return !isPlayerNormalDeleted(player);
}

/** Determines if the mode is for Tainted Deleted or not. */
export function isModeTainted(mode: Mode): boolean {
  return getModeData(mode).characterType === CharacterType.TAINTED;
}

/** Get all the players currently in game that are of type normal or tainted Deleted. */
export function getDeletedPlayers(): EntityPlayer[] {
  return getPlayers().filter((player) => isPlayerDeleted(player));
}

/**
 * Get the color associated with the Deleted mode. If the player is not a Deleted or the mode does
 * not have a main color, returns undefined.
 */
export function getPlayerMainColor(player: EntityPlayer): Color | undefined {
  const mode = PLAYERTYPE_MODE_MAP.get(player.GetPlayerType());
  if (mode !== undefined) {
    return getModeData(mode).mainColor;
  }
  return undefined;
}

export function getDeletedInvertedSprite(player: EntityPlayer): string {
  const mode = PLAYERTYPE_MODE_MAP.get(player.GetPlayerType());
  if (mode === undefined) {
    error("Failed to get the deleted inverted sprite for the player.");
  }
  return "";
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\effects\itemEffects.ts`:

```````ts
/** Functions related to inverted item ActionSets (not player inventory passive ActionSets). */

import type { CollectibleType } from "isaac-typescript-definitions";
import type { Action } from "../../../classes/corruption/actions/Action";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import type { Response } from "../../../classes/corruption/responses/Response";
import {
  doesInvertedItemHaveActionSet,
  getAndSetInvertedItemActionSet,
  _setInvertedItemActionSet,
} from "../../../features/corruption/effects/itemEffects";
import { updatePedestalsInRoom } from "../inversion/updateInverted";

/**
 * If the inverted item does not already have an ActionSet attached to it, this function will attach
 * one.
 */
export function setInvertedItemActionSetIfNone(
  collectible: CollectibleType,
  actionSet: InvertedItemActionSet,
): void {
  if (!doesInvertedItemHaveActionSet(collectible)) {
    setInvertedItemActionSet(collectible, actionSet);
  }
}

/**
 * Add Actions or Responses to an Inverted Item. This will update all the pedestals in the room, as
 * inverted collectible ActionSets are shared between CollectibleTypes. This will NOT update
 * inverted items the player already has. Does not deepCopy!
 */
export function addEffectsToInvertedItem(
  collectible: CollectibleType,
  ...effects: Array<Response | Action>
): void {
  const invertedItemActionSet = getAndSetInvertedItemActionSet(collectible);
  invertedItemActionSet.addEffects(...effects);
  updatePedestalsInRoom();
}

/**
 * Sets the ActionSet for the inverted item. If the item already has an ActionSet, this will
 * override it. This will update all pedestals in the room, as inverted collectible ActionSets are
 * shared between CollectibleTypes.
 */
export function setInvertedItemActionSet(
  collectible: CollectibleType,
  actionSet: InvertedItemActionSet,
): void {
  _setInvertedItemActionSet(collectible, actionSet);
  updatePedestalsInRoom();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\effects\moralityHelper.ts`:

```````ts
import type { Action } from "../../../classes/corruption/actions/Action";
import type { Response } from "../../../classes/corruption/responses/Response";
import { Morality } from "../../../enums/corruption/Morality";

/**
 * Given an array of Actions and Responses, sorts them by Morality, where positive effects are
 * first, then neutral, then negative.
 */
export function sortEffectsByMorality(
  effects: Array<Action | Response>,
): Array<Action | Response> {
  return effects.sort((a, b) => {
    const aMorality = a.getMorality();
    const bMorality = b.getMorality();
    if (aMorality === bMorality) {
      return 0;
    }
    if (aMorality === Morality.POSITIVE) {
      return -1;
    }
    if (bMorality === Morality.POSITIVE || bMorality === Morality.NEUTRAL) {
      return 1;
    }
    return -1;
  });
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\effects\pedestalEffects.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { getTrackedPedestalInvertedActive } from "../../../features/corruption/effects/activeItemTracker";
import { getAndSetInvertedItemActionSet } from "../../../features/corruption/effects/itemEffects";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";

/**
 * Get the ActionSet attached to the inverted pedestal. If there is none, will generate a fresh one
 * with the provided builder or inputs (if any). If the inverted pedestal has a tracked active item,
 * will return the tracked active item's ActionSet. This will still work on non-Inverted pedestals.
 *
 * This will still work if the pedestal is not inverted.
 *
 * Does not deepCopy!
 *
 * @returns The inverted pedestal's ActionSet.
 */
export function getAndSetInvertedPedestalActionSet(
  collectible: EntityPickupCollectible,
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  if (collectible.SubType === CollectibleType.NULL) {
    error("getAndSetInvertedPedestalActionSet: Pedestal is null.");
  }

  const trackedActiveItemActionSet =
    getTrackedPedestalInvertedActive(collectible);
  if (trackedActiveItemActionSet !== undefined) {
    return trackedActiveItemActionSet;
  }

  return getAndSetInvertedItemActionSet(collectible.SubType, inputs);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\effects\pickupEffects.ts`:

```````ts
/** Functions related to non-inverted pickup corrupted effects. */

import { PickupVariant } from "isaac-typescript-definitions";
import type { ActionSet } from "../../../classes/corruption/actionSets/ActionSet";
import { NonInvertedPickupActionSet } from "../../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import type { Action } from "../../../classes/corruption/actions/Action";
import type { Response } from "../../../classes/corruption/responses/Response";
import {
  _setPickupIndexActionSet,
  getNonInvertedPickupActionSet,
} from "../../../features/corruption/effects/pickupEffects";
import { isPickupInverted } from "../../../features/corruption/inversion/pickupInversion";
import { mod } from "../../../mod";
import { updatePickup } from "../inversion/updateInverted";
import { getAndSetInvertedPedestalActionSet } from "./pedestalEffects";

/**
 * Sets the ActionSet of the non-inverted pickup (which is unique per PickupIndex). Updates the
 * pickup.
 */
export function setNonInvertedPickupActionSet(
  pickup: EntityPickup,
  actionSet: NonInvertedPickupActionSet,
): void {
  _setPickupIndexActionSet(mod.getPickupIndex(pickup), actionSet);
  updatePickup(pickup);
  // if (isPickupInverted(pickup)) { }
}

/**
 * Retrieves the PickupActionSet of a non-inverted pickup. If one does not exist, an empty one will
 * be created.
 */
export function getAndSetNonInvertedPickupActionSet(
  pickup: EntityPickup,
): NonInvertedPickupActionSet {
  const actionSet = getNonInvertedPickupActionSet(pickup);
  if (actionSet !== undefined) {
    return actionSet;
  }
  const newActionSet = new NonInvertedPickupActionSet();
  setNonInvertedPickupActionSet(pickup, newActionSet);
  return newActionSet;
}

/**
 * Add Actions or Responses to the non-Inverted pickup. If a pickup is inverted, this will still add
 * them to the pickups non-inverted state. If a NonInvertedActionSet does not exist, it will be
 * created. Does not deepCopy!
 */
export function addEffectsToNonInvertedPickup(
  pickup: EntityPickup,
  ...effects: ReadonlyArray<Response | Action>
): void {
  const nonInvertedActionSet = getNonInvertedPickupActionSet(pickup);
  if (nonInvertedActionSet === undefined) {
    setNonInvertedPickupActionSet(
      pickup,
      new NonInvertedPickupActionSet().addEffects(...effects),
    );
  } else {
    nonInvertedActionSet.addEffects(...effects);
    updatePickup(pickup);
  }
}

/**
 * General function to get an ActionSet from an inverted or non-inverted pickup. Will take into
 * account if the pickup is inverted.
 *
 * @param pickup The pickup to get the ActionSet from.
 *
 * @returns The ActionSet of the pickup, or undefined if the pickup does not have an ActionSet.
 */
export function getPickupActionSet(
  pickup: EntityPickup,
): ActionSet | undefined {
  if (
    pickup.Variant === PickupVariant.COLLECTIBLE && // Inverted Items.
    isPickupInverted(pickup as EntityPickupCollectible)
  ) {
    // TODO: Change to getAndSetTrackedInvertedItemActionSet().
    return getAndSetInvertedPedestalActionSet(
      pickup as EntityPickupCollectible,
    );
  }
  return getNonInvertedPickupActionSet(pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\effects\responseHelper.ts`:

```````ts
import type { Response } from "../../../classes/corruption/responses/Response";
import { _addActionOrResponseToTracker } from "../../../features/corruption/effects/playerEffects";

/**
 * Add Responses to a player, which will be triggered immediately. Note: these will be wiped upon
 * save/load, unless they're saved elsewhere.
 */
export function addResponsesToTracker(
  player: EntityPlayer,
  ...response: Response[]
): void {
  _addActionOrResponseToTracker(player, ...response);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\funnyNames.ts`:

```````ts
// TODO: Get funny item name. Arguments (0-5) CollectibleType / TrinketType.

import { CollectibleType, TrinketType } from "isaac-typescript-definitions";

// TODO: Get funny description. Arguments (0-5) CollectibleType / TrinketType.

export function getCorruptedName(
  collectibleOrTrinket: Array<CollectibleType | TrinketType>,
): string {
  return "hi";
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\funnySounds.ts`:

```````ts
/** This file contains functions used to create glitched sound effects. */

import type { SoundEffect } from "isaac-typescript-definitions";
import { GAME_FRAMES_PER_SECOND, sfxManager } from "isaacscript-common";
import {
  DEFAULT_CORRUPTED_SOUND_EFFECT_AMOUNT,
  DEFAULT_CORRUPTED_SOUND_EFFECT_LENGTH,
} from "../../constants/corruptionConstants";
import { MILLISECONDS_IN_A_SECOND } from "../../constants/generalConstants";
import type { CorruptedSoundEffect } from "../../interfaces/corruption/funny/CorruptedSoundEffect";
import { mod } from "../../mod";
import type { Range } from "../../types/general/Range";
import {
  multiplyRangeConstituents,
  randomInRange,
  randomInRangeOrNumber,
} from "../../types/general/Range";
import { getRandomSoundEffect } from "../soundHelper";

/**
 * Generates a random soundEffect in the form of 'CorruptedSoundEffect'. This object can then be
 * passed to the 'playCorruptedSound' function. Alternatively, you can use the
 * 'playRandomCorruptedSound'.
 *
 * @param amountOfSoundEffects The amount of sound effects to play. Can be a range of numbers, in
 *                             which case a random amount will be chosen.
 * @param lengthInSeconds The length of the corrupted sound effect in seconds. Can be a range of
 *                        numbers, in which case a random time will be chosen in milliseconds. Can
 *                        be a decimal.
 */
export function generateCorruptedSound(
  amountOfSoundEffects: number | Range = DEFAULT_CORRUPTED_SOUND_EFFECT_AMOUNT,
  lengthInSeconds: number | Range = DEFAULT_CORRUPTED_SOUND_EFFECT_LENGTH,
): CorruptedSoundEffect {
  const soundEffects: Array<[SoundEffect, number]> = [];

  /**
   * We need to convert the range to milliseconds, find a random value, then convert it back to
   * seconds.
   */
  if (typeof lengthInSeconds !== "number") {
    lengthInSeconds =
      randomInRangeOrNumber(
        multiplyRangeConstituents(lengthInSeconds, MILLISECONDS_IN_A_SECOND),
      ) / MILLISECONDS_IN_A_SECOND;
  }

  const amount = randomInRangeOrNumber(amountOfSoundEffects);
  for (let i = 0; i < amount; i++) {
    const soundEffect = getRandomSoundEffect();
    soundEffects.push([soundEffect, lengthInSeconds / amount]);
  }
  return { soundEffects };
}

export function playCorruptedSound(
  corruptedSound: CorruptedSoundEffect,
  volume = 1,
  pitch = 1,
): void {
  let delay = 0;
  let currentlyPlaying: SoundEffect | undefined;
  for (const [soundEffect, lengthInSeconds] of corruptedSound.soundEffects) {
    mod.runInNGameFrames(() => {
      /** Stop previous sound. */
      if (currentlyPlaying !== undefined) {
        sfxManager.Stop(currentlyPlaying);
      }

      sfxManager.Play(
        soundEffect,
        volume,
        undefined,
        undefined,
        randomInRange([
          0.8 * MILLISECONDS_IN_A_SECOND,
          1.2 * MILLISECONDS_IN_A_SECOND,
        ]) / MILLISECONDS_IN_A_SECOND,
      );
      currentlyPlaying = soundEffect;
    }, delay * GAME_FRAMES_PER_SECOND);
    delay += lengthInSeconds;
  }
  mod.runInNGameFrames(() => {
    /** Stop final sound. */
    if (currentlyPlaying !== undefined) {
      sfxManager.Stop(currentlyPlaying);
    }
  }, delay * GAME_FRAMES_PER_SECOND);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\funnySprites.ts`:

```````ts
import {
  ActiveSlot,
  CollectibleType,
  PocketItemSlot,
} from "isaac-typescript-definitions";
import {
  ColorDefault,
  VectorOne,
  clamp,
  getActivePocketItemSlot,
  getRandomArrayElement,
  getRandomColor,
  getRandomInt,
  getRandomSeed,
  isArray,
} from "isaacscript-common";
import {
  PEDESTAL_HEIGHT,
  POCKET_SLOT_UNFOCUSSED_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1,
  SECONDARY_ACTIVE_SLOT_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1,
} from "../../constants/renderConstants";
import { getCollectibleSpriteFromCache } from "../../features/general/spriteCache";
import type { CorruptedCollectibleSprite } from "../../interfaces/corruption/funny/CorruptedCollectibleSprite";
import type { AdvancedColor } from "../../interfaces/general/AdvancedColor";
import type { Range } from "../../types/general/Range";
import { randomInRange } from "../../types/general/Range";
import {
  getActiveRenderPosition,
  getPocketActiveRenderPosition,
} from "../HUDHelper";
import { simplifyAndCopyColor } from "../advancedColorHelper";
import {
  getCollectibleRenderOffset,
  getRandomCollectibleType,
} from "../collectibleHelper";
import { worldToRenderPosition } from "../renderHelper";
import { nextSeeds } from "../rngHelper";
import { renderSprite } from "../spriteHelper";
import { getRandomInteger } from "../randomHelper";

const DEFAULT_CUSTOM_COLLECTIBLE_SPRITE_COLLECTIBLES = [1, 4] as const;

/** This function generates a default random CorruptedCollectibleSprite object. */
export function generateCorruptedCollectibleSprite(): CorruptedCollectibleSprite {
  const collectibles: CollectibleType[] = [];
  const numCollectibles = randomInRange(
    DEFAULT_CUSTOM_COLLECTIBLE_SPRITE_COLLECTIBLES as Range,
  );
  for (let i = 0; i < numCollectibles; i++) {
    collectibles.push(getRandomCollectibleType() ?? CollectibleType.POOP);
  }
  return {
    seed: getRandomSeed(),
    collectibles,
  };
}

/**
 * Renders a CorruptedCollectibleSprite over a pedestal, accounting for any offsets in pedestal type
 * (e.g shop item). Call this function in the render callback.
 */
export function renderCorruptedCollectibleSpriteOverCollectible(
  collectible: EntityPickupCollectible,
  customSprite: CorruptedCollectibleSprite,
  scale?: Vector,
): void {
  const position = worldToRenderPosition(
    collectible.Position.add(getCollectibleRenderOffset(collectible)),
  );
  renderCorruptedCollectibleSprite(position, customSprite, scale);
}

/**
 * Renders a CustomCollectibleSprite (TMTRAINER like sprite). If you are not using
 * CustomCollectibleSprite object, use renderTMTRAINERSprite() instead.
 */
export function renderCorruptedCollectibleSprite(
  position: Vector,
  customSprite: CorruptedCollectibleSprite,
  scale?: Vector,
): void {
  renderTMTRAINERSprite(
    position,
    customSprite.seed,
    customSprite.collectibles,
    customSprite.color ?? false,
    customSprite.horizontal ?? false,
    scale,
    customSprite.flipX,
    false,
    customSprite.rotation,
  );
}

/**
 * Render a generated TMTRAINER like sprite consisting of an amalgamation of collectibles.
 *
 * @param position The position to render the sprite at.
 * @param collectibles The collectibles to render, can be empty.
 * @param trinkets The trinkets to render, can be empty. Leave both 'collectibles' and 'trinkets'
 *                 empty to render a generic 'tmtrainer' sprite.
 * @param horizontal Whether the sprite should be rendered horizontally or vertically, leave
 *                   undefined to randomly choose.
 * @param color The color to render the sprite in, leave undefined to have a color, while true will
 *              render the sprite in random colors.
 * @param scale The scale to render the sprite at, leave undefined to render at 1x scale.
 * @param seed
 * @param attributes
 * @param flipX
 * @param flipY
 * @param rotation
 */
export function renderTMTRAINERSprite(
  position: Vector,
  seed: Seed,
  collectibles: CollectibleType[],
  color:
    | Color
    | Color[]
    | "random"
    | AdvancedColor
    | AdvancedColor[]
    | false = false,
  horizontal: boolean | undefined = undefined,
  scale: Vector | undefined = VectorOne,
  flipX: boolean | undefined = undefined,
  flipY: boolean | undefined = undefined,
  rotation = 0,
): void {
  // Check if empty
  const len = collectibles.length;
  if (len === 0) {
    error("Can't render TMTRAINER sprite with empty collectible set!");
  }
  const segmentLength = 30 / len;
  let currentLength = 0;

  horizontal ??= getRandomInteger(1, 2, seed) === 1;
  // if (flipX ?? false) { // Reverse the array without using array.reverse(). collectibles =
  // collectibles.reduce( (acc, val) => [val, ...acc], // eslint-disable-next-line
  // @typescript-eslint/prefer-reduce-type-parameter [] as CollectibleType[], ); }

  let i = 0;
  for (const collectible of collectibles) {
    i++;
    const renderPosition = position;
    const sprite = getCollectibleSpriteFromCache(collectible);

    if (color === false) {
      sprite.Color = ColorDefault;
    } else {
      // Get the color of the portion.
      let portionColor: Color;
      if (isArray(color)) {
        // If it is an array, use the color at the index. If the index is out of bounds, use a
        // random color from the index.
        portionColor = simplifyAndCopyColor(
          color[i - 1] ??
            getRandomArrayElement<Color | AdvancedColor>(color, seed),
        );
      } else if (typeof color === "string") {
        portionColor = getRandomColor(seed);
        portionColor.G = clamp(portionColor.G, 0.5, 1);
        portionColor.B = clamp(portionColor.B, 0.5, 1);
        portionColor.R = clamp(portionColor.R, 0.5, 1);
      } else {
        portionColor = simplifyAndCopyColor(color);
      }

      // Set the color of the sprite.
      sprite.Color = portionColor;
    }

    // sprite.FlipX = flipX ?? getRandomInteger(1, 2, nextSeeds(seed, i)) === 1; sprite.FlipY =
    // flipY ?? getRandomInteger(1, 2, nextSeeds(seed, i)) === 1;
    sprite.Scale = scale;
    sprite.Rotation = rotation;

    if (horizontal) {
      renderSprite(
        sprite,
        // Account for the pedestal offset.
        renderPosition.add(Vector(0, sprite.FlipY ? -PEDESTAL_HEIGHT : 0)),
        Vector(0, currentLength),
        Vector(0, 30 - (currentLength + segmentLength)),
      );
    } else {
      renderSprite(
        sprite,
        // Account for the pedestal offset.
        renderPosition.add(Vector(0, sprite.FlipY ? -PEDESTAL_HEIGHT : 0)),
        Vector(currentLength, 0),
        Vector(30 - (currentLength + segmentLength), 0),
      );
    }
    currentLength += segmentLength;
  }
}

/**
 * Render a CorruptedCollectibleSprite in an ActiveSlot. If ActiveSlot.POCKET is specified, will
 * adjust depending on currently selected pocket item. This function will also account for scaling
 * the sprite. Call this function in a render callback. TODO: Update for players.
 *
 * @param player The player to render the sprite for.
 * @param corruptedSprite The CorruptedCollectibleSprite to render.
 * @param slot The ActiveSlot to render the sprite in.
 */
export function renderCorruptedCollectibleSpriteInSlot(
  player: EntityPlayer,
  corruptedSprite: CorruptedCollectibleSprite,
  slot: ActiveSlot,
): void {
  if (slot === ActiveSlot.POCKET) {
    const pocketSlot = getActivePocketItemSlot(player);
    if (pocketSlot === undefined) {
      return;
    }
    const position = getPocketActiveRenderPosition(pocketSlot, player);
    renderCorruptedCollectibleSprite(
      position,
      corruptedSprite,
      pocketSlot === PocketItemSlot.SLOT_1
        ? VectorOne
        : POCKET_SLOT_UNFOCUSSED_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1,
    );
    return;
  }
  if (slot === ActiveSlot.POCKET_SINGLE_USE) {
    // Unimplemented.
    return;
  }
  const position = getActiveRenderPosition(slot, player);
  renderCorruptedCollectibleSprite(
    position,
    corruptedSprite,
    slot === ActiveSlot.SECONDARY
      ? SECONDARY_ACTIVE_SLOT_CORRUPTED_COLLECTIBLE_SCALE_PLAYER_1
      : VectorOne,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\generation\corruptionGeneration.ts`:

```````ts
import { getRandomArrayElement } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import {
  generateDefaultInvertedItemActionSet,
  generateInvertedItemActionSetFromPlayer,
} from "../../../features/corruption/corruptionGeneration";
import {
  getInvertedPlayers,
  isGameInverted,
} from "../../../features/corruption/inversion/playerInversion";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";

/**
 * Returns an InvertedItemActionSet based on the game circumstances. If the game is inverted,
 * randomly chooses between inverted players to generate an ActionSet based on their preferences.
 * Otherwise, uses a default ActionSetBuilder.
 */
export function getGameInvertedItemActionSet(
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  if (isGameInverted()) {
    const invertedPlayers = getInvertedPlayers();
    const chosenRandomPlayer = getRandomArrayElement(
      invertedPlayers,
      undefined,
    );
    return generateInvertedItemActionSetFromPlayer(chosenRandomPlayer, inputs);
  }
  return generateDefaultInvertedItemActionSet(inputs);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\glitchyPlayerTransform.ts`:

```````ts
import {
  DEFAULT_NORMAL_STARTING_SPRITESHEET_PATH,
  TRANSITIONAL_GLITCH_SPRITES_ARRAY,
} from "../../constants/fileConstants";
import { mod } from "../../mod";

const v = {
  run: {
    transforming: false,
    finalSpritesheetPath: DEFAULT_NORMAL_STARTING_SPRITESHEET_PATH,
    transitionalSpritesheetPaths: TRANSITIONAL_GLITCH_SPRITES_ARRAY,
  },
};

export function glitchyReplacePlayerSpritesheetInit(): void {
  mod.saveDataManager("glitchyPlayerTransform", v);
}

/**
 * Transforms the player into the specified character spritesheet with a glitchy transition. Can
 * pass through an array of spritesheet paths which will override the default transitional sprites.
 */
export function glitchyReplacePlayerSpritesheet(
  player: EntityPlayer,
  finalCostumePath: string,
  transitionalSpritesheetPaths?: string[],
): void {
  if (transitionalSpritesheetPaths !== undefined) {
    v.run.transitionalSpritesheetPaths = transitionalSpritesheetPaths;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inventory\custom actives\customActiveHelper.ts`:

```````ts
/** Functions that aid the CustomActiveHelper. */

import type { CollectibleType } from "isaac-typescript-definitions";
import { ActiveSlot } from "isaac-typescript-definitions";
import type { InvertedActiveActionSet } from "../../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { isZazzinatorActive } from "../../../../sets/zazzSets";
import {
  getCollectibleChargeType,
  getCollectibleMaxCharges,
} from "isaacscript-common";

/**
 * Checks if the InvertedActiveActionSet matches the Zazzinator dummy item by comparing the charge
 * type, charges, and whether or not it is a copy.
 */
export function doesInvertedActiveActionSetMatchZazzActive(
  actionSet: InvertedActiveActionSet,
  zazzActive: CollectibleType,
): boolean {
  const chargeType = actionSet.getChargeType();
  const charges = actionSet.getTotalCharges();

  if (!isZazzinatorActive(zazzActive)) {
    return false;
  }

  if (charges !== getCollectibleMaxCharges(zazzActive)) {
    return false;
  }

  if (chargeType !== getCollectibleChargeType(zazzActive)) {
    return false;
  }

  return true;
}

/**
 * Add the Zazzinator Active that correlates with the InvertedActiveActionSet to the desired slot.
 * Note: This shouldn't be used as it only adds a dead item to the player, use
 * 'addInvertedActionSetToPlayer()' instead.
 *
 * @param player The player to add the Zazzinator Active to.
 * @param actionSet The InvertedActiveActionSet to add.
 * @param slot The slot to add the Zazzinator Active to.
 */
export function _addZazzActiveToPlayer(
  player: EntityPlayer,
  actionSet: InvertedActiveActionSet,
  slot: ActiveSlot,
): void {
  if (slot === ActiveSlot.PRIMARY || slot === ActiveSlot.SECONDARY) {
    player.AddCollectible(
      actionSet.getZazzActive(actionSet),
      actionSet.getTotalCharges(),
      undefined,
      slot,
    );
  } else if (slot === ActiveSlot.POCKET) {
    player.SetPocketActiveItem(actionSet.getZazzActive(actionSet), slot);
  }
}

/**
 * Removes the physical Zazz Active that correlates with the provided InvertedActiveActionSet from
 * the player. Note: This shouldn't be used as it only removes a dead item from the player.
 */
export function _removeZazzActiveFromPlayer(
  player: EntityPlayer,
  actionSet: InvertedActiveActionSet,
  slot: ActiveSlot,
): void {
  const zazzActive = actionSet.getZazzActive(actionSet);
  if (player.GetActiveItem(slot) === zazzActive) {
    player.RemoveCollectible(zazzActive);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inventory\custom actives\invertedActives.ts`:

```````ts
/** General functions revolving around inverted active items. */

import { ActiveSlot } from "isaac-typescript-definitions";
import { VectorZero } from "isaacscript-common";
import type { InvertedActiveActionSet } from "../../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import type { InvertedItemActionSet } from "../../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { getAndSetInvertedItemActionSet } from "../../../../features/corruption/effects/itemEffects";
import type { ActionSetBuilderInput } from "../../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import { isInvertedPassiveActionSet } from "../../actionSetHelper";
import { spawnNewInvertedActiveCollectible } from "../../inversion/spawnInverted";
import { addInvertedItemToPlayer } from "../invertedInventoryHelper";

export function addNewInvertedActiveToPlayer(
  player: EntityPlayer,
  slot: ActiveSlot = ActiveSlot.PRIMARY,
  invertedActionSet?: InvertedActiveActionSet,
  inputs?: ActionSetBuilderInput,
): InvertedItemActionSet {
  const newInvertedPedestal = spawnNewInvertedActiveCollectible(
    VectorZero,
    invertedActionSet,
    inputs,
  );

  newInvertedPedestal.Remove();
  const actionSet = getAndSetInvertedItemActionSet(newInvertedPedestal.SubType);
  if (isInvertedPassiveActionSet(actionSet)) {
    error("Error: The new inverted item is a passive item..");
  }
  addInvertedItemToPlayer(player, newInvertedPedestal.SubType, true, slot);
  return actionSet;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inventory\invertedInventoryHelper.ts`:

```````ts
/** Core functions related to inverted actions and passives the player owns. */

import type { CollectibleType } from "isaac-typescript-definitions";
import { ActiveSlot } from "isaac-typescript-definitions";
import {
  getAndSetInvertedItemActionSet,
  isInvertedItemPassive,
} from "../../../features/corruption/effects/itemEffects";
import {
  _addInvertedPassiveItemToCorruptInventory,
  _doesPlayerHaveInvertedPassiveItem,
  _removeInvertedPassiveItemFromCorruptInventory,
  getPlayerMostRecentInvertedPassiveItemCollectibleType,
} from "../../../features/corruption/inventory/passiveItemInventory";
import {
  doesPlayerHaveCustomActive,
  getCustomActiveInSlot,
} from "../../../features/corruption/inversion/customActives";
import type { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { deepCopy } from "isaacscript-common";
import {
  _addZazzActiveToPlayer,
  _removeZazzActiveFromPlayer,
} from "./custom actives/customActiveHelper";
import { isInvertedActiveActionSet } from "../actionSetHelper";
import type { InvertedPassiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedPassiveActionSet";
import { isAction } from "../../../classes/corruption/actions/Action";
import {
  _addActionsToTracker,
  _removeActionFromTracker,
} from "../../../features/corruption/effects/playerEffects";
import { ActionType } from "../../../enums/corruption/actions/ActionType";
import { CollectibleTypeCustom } from "../../../enums/general/CollectibleTypeCustom";
import { _addInvertedActiveToPlayer } from "../../../classes/facets/CustomActiveFacet";
import { addRemovedInvertedItemToTracker } from "../../../features/corruption/inventory/removedInvertedItems";
import { fprint } from "../../printHelper";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { ActionOrigin } from "../../../enums/corruption/actions/ActionOrigin";

// Used to prevent endless loops with the 'postZazzRemoved' callback and the
// removePlayerMostRecentInvertedPassive function.
let preventUnnecessaryPostZazzRemovedCallbackFlag = false;

/**
 * Returns true if the player has at least one inverted item of the provided CollectibleType. Can be
 * either an inverted passive or an inverted active.
 */
export function doesPlayerHaveInvertedItem(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): boolean {
  const isInverted = isInvertedItemPassive(collectibleType);
  if (isInverted) {
    return _doesPlayerHaveInvertedPassiveItem(player, collectibleType);
  }
  return doesPlayerHaveCustomActive(player, collectibleType);
}

/**
 * Adds the ActionSet associated with the specified CollectibleType to the player. Also adds a logo
 * to the inventory and updates the inventory.
 *
 * For corrupted passives, actions will be added to the player, and effects will trigger
 * immediately.
 *
 * @param player The player to add the inverted item to.
 * @param collectibleType The inverted collectible you want to add. If no InvertedItemActionSet is
 *                        assigned, will generate a new one.
 * @param addLogo Whether to add the physical item. For passives, this will be the warning sign logo
 *                on the item tracker. For actives, this will be the physical Zazzinator active
 *                item. Default true.
 * @param slot The slot the inverted active item should go into (if it is an
 *             InvertedActiveActionSet). Default primary.
 * @param actionSet The ActionSet to add to the player. This will override the ActionSet attached to
 *                  the collectibleType. If undefined, will use the ActionSet attached to the
 *                  collectibleType (or generate a new one if none exists).
 */
export function addInvertedItemToPlayer(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  addLogo = true,
  slot: ActiveSlot = ActiveSlot.PRIMARY,
  actionSet?: InvertedItemActionSet,
): void {
  fprint(`addInvertedItemToPlayer: ${collectibleType}`);
  const invertedItemActionSet =
    actionSet ?? deepCopy(getAndSetInvertedItemActionSet(collectibleType));
  if (isInvertedActiveActionSet(invertedItemActionSet)) {
    addInvertedActiveToPlayer(
      player,
      invertedItemActionSet,
      collectibleType,
      addLogo,
      slot,
    );
  } else {
    addInvertedPassiveToPlayer(
      player,
      invertedItemActionSet,
      collectibleType,
      addLogo,
    );
  }
}

/**
 * Adds the InvertedActiveActionSet to the player, by using the CustomActiveFacet.
 *
 * @param player The player to add the InvertedActionSet to.
 * @param invertedActionSet The InvertedActionSet to add.
 * @param addLogo Whether to add the physical item (should be true).
 * @param collectible The collectible the InvertedActionSet refers to.
 * @param slot The slot the inverted active item should go into (default primary).
 * @param pickupIndex
 * @param actionSet
 */
function addInvertedActiveToPlayer(
  player: EntityPlayer,
  invertedActionSet: InvertedActiveActionSet,
  collectible: CollectibleType,
  addLogo = true,
  slot: ActiveSlot = ActiveSlot.PRIMARY,
) {
  invertedActionSet.oi = collectible;

  // Add actions to tracker.
  for (const action of invertedActionSet.getActions()) {
    // Set ActionOrigin.
    action.o = [ActionOrigin.INVERTED_COLLECTIBLE, collectible];
    if (action.actionType === ActionType.ON_OBTAIN) {
      action.trigger({ player });
    } else {
      _addActionsToTracker(player, action);
    }
  }

  // Add logo.
  if (addLogo) {
    _addZazzActiveToPlayer(player, invertedActionSet, slot);
  }

  _addInvertedActiveToPlayer(player, invertedActionSet, slot);
}

/**
 * Add the inverted passive ActionSet to the player by adding the Actions and triggering the
 * Responses.
 *
 * @param player The player to add the Active to.
 * @param invertedPassiveActionSet The InvertedActiveActionSet to add.
 * @param collectible The CollectibleType that the passive item refers to.
 * @param addLogo Whether to add the physical item to the inventory (default true).
 */
function addInvertedPassiveToPlayer(
  player: EntityPlayer,
  invertedPassiveActionSet: InvertedPassiveActionSet,
  collectible: CollectibleType,
  addLogo = true,
) {
  invertedPassiveActionSet.oi = collectible;

  // Add to the corrupt inventory.
  _addInvertedPassiveItemToCorruptInventory(
    player,
    collectible,
    invertedPassiveActionSet,
  );

  // Add actions to tracker for optimization. Trigger effects and 'on obtain' Actions.
  for (const actionOrResponse of invertedPassiveActionSet.getEffects()) {
    if (isAction(actionOrResponse)) {
      // Set ActionOrigin.
      actionOrResponse.o = [ActionOrigin.INVERTED_COLLECTIBLE, collectible];
      if (actionOrResponse.actionType === ActionType.ON_OBTAIN) {
        actionOrResponse.trigger({ player });
      } else {
        _addActionsToTracker(player, actionOrResponse);
      }
    } else {
      actionOrResponse.trigger({ player });
    }
  }

  if (addLogo) {
    /** Will be refined eventually. */
    player.AddCollectible(CollectibleTypeCustom.ZAZZ);
  }
}

/**
 * Removes the most recent passive item of the specified collectibleType (if the player has it). It
 * will achieve this by removing the Actions from the tracker, and removing the physical item from
 * the inventory (if removeLogo is true), then finally removing the item from the corrupt inventory.
 *
 * @param player The player to remove the item from.
 * @param collectibleType The CollectibleType of the item to remove. If undefined, will remove the
 *                        most recent item.
 * @param removeLogo Whether to remove the physical item from the inventory (default true).
 * @returns The CollectibleType of the item that was removed, or undefined if no item was removed.
 */
export function removePlayerMostRecentInvertedPassive(
  player: EntityPlayer,
  collectibleType?: CollectibleType,
  removeLogo = true,
): CollectibleType | undefined {
  if (preventUnnecessaryPostZazzRemovedCallbackFlag) {
    preventUnnecessaryPostZazzRemovedCallbackFlag = false;
    return undefined;
  }

  // If collectibleType is undefined, get the most recent item.
  if (collectibleType === undefined) {
    collectibleType =
      getPlayerMostRecentInvertedPassiveItemCollectibleType(player);
    if (collectibleType === undefined) {
      return undefined;
    }
  } else if (!_doesPlayerHaveInvertedPassiveItem(player, collectibleType)) {
    return undefined;
  }

  // Remove the Actions from the tracker.
  const actionSet = getAndSetInvertedItemActionSet(collectibleType);
  for (const action of actionSet.getActions()) {
    _removeActionFromTracker(player, action);
  }

  // Remove physical item.
  if (removeLogo && player.HasCollectible(CollectibleTypeCustom.ZAZZ)) {
    // Set a flag to prevent the 'postZazzRemoved' callback from triggering.
    preventUnnecessaryPostZazzRemovedCallbackFlag = true;
    player.RemoveCollectible(CollectibleTypeCustom.ZAZZ);
  }

  // Track the item that was removed.
  addRemovedInvertedItemToTracker(
    player,
    CollectibleTypeCustom.ZAZZ,
    collectibleType,
  );

  _removeInvertedPassiveItemFromCorruptInventory(player, collectibleType);
  return collectibleType;
}

/**
 * Removes an inverted active from the specified slot, if it exists (default primary).
 *
 * @returns True if an item was removed.
 */
export function removePlayerInvertedActive(
  player: EntityPlayer,
  slot = ActiveSlot.PRIMARY,
): boolean {
  const invertedActive = getCustomActiveInSlot(player, slot);
  if (invertedActive === undefined) {
    return false;
  }

  /**
   * Remove physical item. The CustomActiveFacet will detect this and perform the necessary actions.
   */
  _removeZazzActiveFromPlayer(player, invertedActive, slot);

  return true;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inventory\removedItems.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { getCollectibleName, setCollectibleSubType } from "isaacscript-common";
import { _getRemovedInvertedItems } from "../../../features/corruption/inventory/removedInvertedItems";
import { isZazzinatorAny } from "../../../sets/zazzSets";
import { fprint } from "../../printHelper";
import { setPedestalInversion } from "../inversion/pedestalInversion";
import { setTrackedPedestalInvertedActive } from "../../../features/corruption/effects/activeItemTracker";

/**
 * Morphs a Zazzinator pedestal into an inverted collectible using the RemovedInvertedItemTracker.
 * If no match can be found, it will be morphed into a random inverted item.
 *
 * @param zazzinatorItem The Zazzinator item that has spawned on the ground.
 */
export function setZazzinatorToRemovedItem(
  zazzinatorItem: EntityPickupCollectible,
): void {
  const zazzCollectibleType = zazzinatorItem.SubType;
  if (!isZazzinatorAny(zazzCollectibleType)) {
    return;
  }

  /** Search through removed items in reverse. */
  const removedItems = _getRemovedInvertedItems();
  fprint(
    `removedItems: Searching through ${removedItems.length} removed items to replace Zazzinator item ${zazzCollectibleType}..`,
  );

  for (let i = removedItems.length - 1; i >= 0; i--) {
    const removedItem = removedItems[i];
    if (removedItem === undefined) {
      continue;
    }

    const { dummyItem, referenceCollectible, InvertedActiveActionSet } =
      removedItem;
    if (dummyItem !== zazzCollectibleType) {
      continue;
    }

    // We found a match.
    fprint(
      `removedItems: Found a match for Zazzinator item ${zazzCollectibleType}! dummyItem: ${dummyItem}, referenceCollectible: ${referenceCollectible}, InvertedActiveActionSet: ${InvertedActiveActionSet}`,
    );
    setCollectibleSubType(zazzinatorItem, referenceCollectible);
    // Don't update as we will do that later.
    setPedestalInversion(true, zazzinatorItem);
    // Update the pedestal's active tracker if it is an active item.
    if (InvertedActiveActionSet !== undefined) {
      setTrackedPedestalInvertedActive(zazzinatorItem, InvertedActiveActionSet);
    }
    // Set the pedestal.charge if we know the charge of the non-Inverted active item.
    const charge = InvertedActiveActionSet?.getFlipCharge();
    if (charge !== undefined) {
      fprint(`removedItems: Setting pedestal charge to ${charge}`);
      zazzinatorItem.Charge = charge;
    }

    removedItems.splice(i, 1);
    fprint(
      `removedItems: Zazzinator item ${zazzCollectibleType} morphed into ${getCollectibleName(
        referenceCollectible,
      )}`,
    );
    return;
  }

  // We did not find a match.
  fprint(
    `Zazzinator item ${zazzCollectibleType} morphed into a random item due to not finding a match`,
  );
  setPedestalInversion(false, zazzinatorItem);
  setCollectibleSubType(zazzinatorItem, CollectibleType.SAD_ONION);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inversion\pedestalInversion.ts`:

```````ts
/**
 * This file contains functions related to setting the inversion status of pedestals in the game. It
 * provides the ability to set the inversion status of individual pedestals as well as all pedestals
 * on a level. The functions handle updating the pedestals and applying effects based on the
 * inversion status.
 */

import { CollectibleType } from "isaac-typescript-definitions";
import { getCollectibles } from "isaacscript-common";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { Morality } from "../../../enums/corruption/Morality";
import { doesInvertedItemHaveActionSet } from "../../../features/corruption/effects/itemEffects";
import {
  _setAllPedestalInversion,
  _setPedestalInversion,
  isPickupInverted,
} from "../../../features/corruption/inversion/pickupInversion";
import { hasInvertedPickupBeenSeen } from "../../../features/corruption/inversion/seenInvertedPickups";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import type { InvertedItemActionSetBuilder } from "../../../types/general/Builder";
import { setInvertedItemActionSetIfNone } from "../effects/itemEffects";
import { addEffectsToNonInvertedPickup } from "../effects/pickupEffects";
import { updatePedestal } from "./updateInverted";
import { fprint } from "../../printHelper";
import { getAndSetInvertedPedestalActionSet } from "../effects/pedestalEffects";

/**
 * Set one pedestal to a specific inversion status. This will also update the pedestal.
 *
 * @param toInverted If true, will set the pedestal to inverted.
 * @param collectible The pedestal to modify.
 * @param invertedItemActionSet Optional, will set the inverted items ActionSet if the item does not
 *                              have an ActionSet (does not DeepCopy).
 * @param inputs Optional inputs that will be used if a new InvertedItemActionSet is created.
 */
export function setPedestalInversion(
  toInverted: boolean,
  collectible: EntityPickupCollectible,
  invertedItemActionSet?: InvertedItemActionSet,
  inputs?: ActionSetBuilderInput,
): void {
  fprint(`Setting pedestal ${collectible.SubType} to inverted: ${toInverted}`);

  if (collectible.SubType === CollectibleType.NULL) {
    fprint("Cannot set pedestal inversion of NULL collectible.");
    return;
  }

  if (isPickupInverted(collectible) === toInverted) {
    fprint("Pedestal inversion is already set to the specified value.");
    return;
  }

  /** Force the inverted ActionSet if one is not set. */
  if (invertedItemActionSet !== undefined && toInverted) {
    fprint("Forcing inverted ActionSet..");
    setInvertedItemActionSetIfNone(collectible.SubType, invertedItemActionSet);
  }

  /**
   * Carry over the negative effects if the inverted ActionSet has carryOver attribute. Check if the
   * inverted item has an ActionSet, so we don't have to generate one if it doesn't.
   */
  if (
    !toInverted &&
    hasInvertedPickupBeenSeen(collectible) &&
    doesInvertedItemHaveActionSet(collectible.SubType)
  ) {
    fprint(`Carrying over negative effects for ${collectible.SubType}..`);
    const invertedActionSet = getAndSetInvertedPedestalActionSet(
      collectible,
      inputs,
    );
    if (invertedActionSet.getNegativesCarryOver()) {
      addEffectsToNonInvertedPickup(
        collectible,
        ...invertedActionSet
          .getEffects()
          .filter((effect) => effect.getMorality() === Morality.NEGATIVE),
      );
    }
  }

  _setPedestalInversion(toInverted, collectible);
  updatePedestal(collectible, inputs);
}

/**
 * Sets all pedestals on the floor to a specific inversion status. This will also update all
 * pedestals in the room.
 *
 * @param inverted If true, will set all pedestals to inverted.
 * @param generationIfEmpty Optional, sets items in room ActionSet using specified builder if item
 *                          does not already have an ActionSet.
 * @param inputs Optional, sets items in room ActionSet using specified builder if item does not
 *               already have an ActionSet.
 */
export function setAllPedestalsOnLevelInversion(
  inverted: boolean,
  generationIfEmpty?: InvertedItemActionSetBuilder,
  inputs?: ActionSetBuilderInput,
): void {
  for (const collectible of getCollectibles()) {
    if (inputs !== undefined) {
      inputs.collectible = collectible.SubType;
    }
    setPedestalInversion(inverted, collectible, generationIfEmpty?.(inputs));
  }
  _setAllPedestalInversion(inverted);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inversion\playerInversion.ts`:

```````ts
import { game, getPlayerIndex } from "isaacscript-common";
import { SoundEffectCustom } from "../../../enums/general/SoundEffectCustom";
import {
  _setPlayerInversion,
  getInvertedPlayers,
  isPlayerInverted,
} from "../../../features/corruption/inversion/playerInversion";
import {
  _removeCorruptedBackdrop,
  _setCorruptedBackdrop,
} from "../../../features/general/backdropHelper";
import {
  _updateCorruptedFloorColor,
  _updateCorruptedFloorColorForPlayer,
} from "../../../features/general/floorColorHelper";
import { removeAllCostumes, restoreAllCostumes } from "../../costumeHelper";
import { fprint } from "../../printHelper";
import { setAllPedestalsOnLevelInversion } from "./pedestalInversion";
import {
  isWorldInverted,
  shouldInvertedWorldHaveCorruptBackdrop,
} from "./worldInversionHelper";

const NORMAL_TO_INVERTED_SFX = SoundEffectCustom.BITFLIP_IN;
const INVERTED_TO_NORMAL_SFX = SoundEffectCustom.BITFLIP_OUT;
const SCREEN_SHAKE_TIMEOUT = 10;

/**
 * This is not exported as it should never be used outside this file - the world is only inverted
 * when at least one player is inverted.
 *
 * @param silent If true, will discreetly invert the world without flipping already seen pedestals
 *               or shaking the screen. Will still set the backdrop.
 */
function updateNormalWorldToInverted(silent = false) {
  fprint("World is flipping inversion to become inverted");
  if (!silent) {
    setAllPedestalsOnLevelInversion(true);
    game.ShakeScreen(SCREEN_SHAKE_TIMEOUT);
  }
  if (shouldInvertedWorldHaveCorruptBackdrop()) {
    _setCorruptedBackdrop();
  } else {
    // Remove the backdrop if switching from a mode that has a corrupted backdrop to one that
    // doesn't.
    _removeCorruptedBackdrop();
  }
}

function updateInvertedWorldToNormal(silent = false) {
  fprint("World is flipping inversion to become non-inverted");
  if (!silent) {
    setAllPedestalsOnLevelInversion(false);
    game.ShakeScreen(SCREEN_SHAKE_TIMEOUT);
  }
  _removeCorruptedBackdrop();
}

/**
 * Inverts the player if they are not the specified inversion.
 *
 * @param player
 * @param inversion If true, will invert the player. If false, will un-invert the player.
 * @param silent If true, will discreetly invert the world without flipping already seen pedestals,
 *               shaking the screen, or playing the sound effect. Will still set the backdrop and
 *               floor color.
 */
export function invertPlayerToInversion(
  player: EntityPlayer,
  inversion: boolean,
  silent = false,
): void {
  const isInverted = isPlayerInverted(player);
  if (isInverted === inversion) {
    _updateCorruptedFloorColorForPlayer(player);
  } else {
    invertPlayer(player, silent);
  }
}

/**
 * General function to change the players' inversion status, will update pedestals + backdrop.
 *
 * @param player
 * @param silent If true, will discreetly invert the world without flipping already seen pedestals,
 *               shaking the screen, or playing the sound effect. Will still set the backdrop and
 *               floor color.
 */
export function invertPlayer(player: EntityPlayer, silent = false): void {
  const isInverted = isPlayerInverted(player);
  const worldInvertedBefore = isWorldInverted();
  fprint(
    `${getPlayerIndex(player)} is flipping inversion to become ${
      isInverted ? "non-inverted" : "inverted"
    }`,
  );

  /** Player Inversion. */
  _setPlayerInversion(player, !isInverted);
  if (isInverted) {
    // INVERTED --> NON-INVERTED
    if (!silent) {
      SFXManager().Play(INVERTED_TO_NORMAL_SFX);
    }
    restoreAllCostumes(player);
  } else {
    // NON-INVERTED --> INVERTED
    if (!silent) {
      SFXManager().Play(NORMAL_TO_INVERTED_SFX);
    }
    removeAllCostumes(player);
  }

  /** World Inversion, does not happen every player inversion. */
  if (worldInvertedBefore !== isWorldInverted()) {
    updateWorldInversion(silent);
  }

  /** Update the floor color, happens every player inversion. */
  _updateCorruptedFloorColor();
}

/**
 * Update the world inversion in accordance to how many players are inverted.
 *
 * @param silent If true, will discreetly invert the world without flipping already seen pedestals
 *               or shaking the screen. Will still set the backdrop.
 */
export function updateWorldInversion(silent = false): void {
  const invertedPlayers = getInvertedPlayers();
  if (invertedPlayers.length === 0) {
    /** World is non-inverted. */
    updateInvertedWorldToNormal(silent);
  } else {
    /** World is inverted. */
    updateNormalWorldToInverted(silent);
  }
}

/**
 * When the player dies, reset them back to their original inversion status. This is so if one
 * player dies in a 4 player game - the world isn't stuck in inversion due to the dead player being
 * unable to bitflip.
 */
export function playerInversionPostPlayerFatalDamage(
  player: EntityPlayer,
): boolean | undefined {
  // const mode = getCurrentPlayerMode(player); invertPlayerToInversion( player, mode !== undefined
  // ? getModeData(mode).startInverted ?? false : false, true, );
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inversion\spawnInverted.ts`:

```````ts
import type {
  CollectibleType,
  PickupVariant,
} from "isaac-typescript-definitions";
import { spawnCollectible, spawnPickup } from "isaacscript-common";
import type { InvertedActiveActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import type { NonInvertedPickupActionSet } from "../../../classes/corruption/actionSets/NonInverted/NonInvertedPickupActionSet";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import { mod } from "../../../mod";
import { spawnGlitchedCollectible } from "../../collectibleHelper";
import { setPedestalInversion } from "./pedestalInversion";
import { setNonInvertedPickupActionSet } from "../effects/pickupEffects";
import { setInvertedItemActionSet } from "../effects/itemEffects";
import { getGameInvertedItemActionSet } from "../generation/corruptionGeneration";

/**
 * Spawns an Inverted collectible with a fresh TMTRAINER subType. This guarantees (mostly) that the
 * generated ActionSet will be completely new. Can specify an ActionSet to use for the item.
 *
 * Does not deepCopy! Once the game has generated >1024 tmtrainer collectibles, this will only
 * return repeat collectibles. The new repeat collectibles will automatically overwrite the old
 * ones.
 *
 * @param position The position to spawn the collectible at.
 * @param invertedActionSet The ActionSet to use for the item. If not specified, a new ActionSet
 *                          will be generated using the game generator.
 * @param inputs The inputs to use for the ActionSetBuilder. If an ActionSet is specified, this
 *               parameter is ignored.
 */
export function spawnNewInvertedCollectible(
  position: Vector,
  invertedActionSet?: InvertedItemActionSet,
  inputs?: ActionSetBuilderInput,
): EntityPickupCollectible {
  const tmtrainerCollectible = spawnGlitchedCollectible(position);

  // We create the ActionSet before inverting it, to ensure it always overrides the existing one.
  setInvertedItemActionSet(
    tmtrainerCollectible.SubType,
    invertedActionSet ?? getGameInvertedItemActionSet(inputs),
  );
  setPedestalInversion(true, tmtrainerCollectible);
  return tmtrainerCollectible;
}

/**
 * Spawns an Inverted Active item with a fresh TMTRAINER subType. This guarantees (mostly) that the
 * generated ActionSet will be completely new. Can specify an ActionSet to use for the item.
 *
 * Does not deepCopy!
 *
 * @param position The position to spawn the collectible at.
 * @param invertedActionSet The ActionSet to use for the item. If not specified, a new ActionSet
 *                          will be generated. Must be InvertedActiveActionSet.
 * @param inputs The inputs to use for the ActionSetBuilder. Will force 'forceActiveOrPassive' value
 *               to true if does not exist.
 */
export function spawnNewInvertedActiveCollectible(
  position: Vector,
  invertedActionSet?: InvertedActiveActionSet,
  inputs?: ActionSetBuilderInput,
): EntityPickupCollectible {
  inputs ??= {};
  inputs.forceActiveOrPassive = true;
  return spawnNewInvertedCollectible(position, invertedActionSet, inputs);
}

/**
 * Spawns an inverted pedestal, with an optional parameter for a custom ActionSet. Does not deepCopy
 * the ActionSet, or override an existing ActionSet associated with the collectible.
 *
 * @param position The position to spawn the collectible at.
 * @param collectibleType The inverted collectible you want to spawn.
 * @param invertedActionSet The ActionSet to use for the item if it does not already exist. If not
 *                          specified, a new ActionSet will be generated.
 * @param inputs The inputs to use for the ActionSetBuilder. If an ActionSet is specified, this
 *               parameter is ignored.
 */
export function spawnInvertedCollectible(
  position: Vector,
  collectibleType: CollectibleType,
  invertedActionSet?: InvertedItemActionSet,
  inputs?: ActionSetBuilderInput,
): EntityPickup {
  const pedestal = spawnCollectible(collectibleType, position, undefined);
  setPedestalInversion(true, pedestal, invertedActionSet, inputs);
  return pedestal;
}

/** Spawns a pickup with an ActionSet attached to it. */
export function spawnPickupWithEffects(
  pickupVariant: PickupVariant,
  subType: number,
  position: Vector,
  actionSet: NonInvertedPickupActionSet,
): EntityPickup {
  const pickup = spawnPickup(pickupVariant, subType, position);
  setNonInvertedPickupActionSet(pickup, actionSet);
  return pickup;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inversion\updateInverted.ts`:

```````ts
/**
 * This file contains functions useful for updating pickups so their appearance and EID description
 * matches their inversion status and ActionSets.
 */

import { CollectibleType } from "isaac-typescript-definitions";
import {
  ColorDefault,
  getCollectibleGfxFilename,
  getCollectibles,
  isCollectible,
  isGlitchedCollectible,
  setCollectibleSprite,
} from "isaacscript-common";
import { returnCorruptedCollectibleSpriteToNormal } from "../../../classes/facets/CorruptedCollectibleSpriteFacet";
import { getNonInvertedPickupActionSet } from "../../../features/corruption/effects/pickupEffects";
import { isPickupInverted } from "../../../features/corruption/inversion/pickupInversion";
import type { ActionSetBuilderInput } from "../../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import { isZazzinatorAny } from "../../../sets/zazzSets";
import {
  getGenericEntityEIDDescriptionObject,
  setSpecificEntityEIDDescriptionObject,
} from "../../compatibility/EID/EIDHelper";
import { fprint } from "../../printHelper";
import { getAndSetInvertedPedestalActionSet } from "../effects/pedestalEffects";

/**
 * Update pedestal is unique from the 'update pickup' function in that it needs to take into account
 * the inversion status of the pickup.
 *
 * If the pedestal is non-inverted, it needs to be set to default appearance in case it was
 * originally inverted.
 *
 * If a pedestal is inverted, it needs to be changed.
 */
export function updatePedestal(
  pedestal: EntityPickupCollectible,
  inputs?: ActionSetBuilderInput,
): void {
  fprint(
    `updatePedestal: ${pedestal.SubType}, is inverted: ${isPickupInverted(
      pedestal,
    )}`,
  );

  /** If pedestal has a custom sprite, return it to normal. */
  returnCorruptedCollectibleSpriteToNormal(pedestal);

  /** Update the appearance. */
  if (
    pedestal.SubType === CollectibleType.NULL ||
    isZazzinatorAny(pedestal.SubType)
  ) {
    return;
  }
  if (isPickupInverted(pedestal)) {
    fprint(`updatePedestal: ${pedestal.SubType} is inverted`);
    const invertedActionSet = getAndSetInvertedPedestalActionSet(
      pedestal,
      inputs,
    );
    invertedActionSet.updateAppearance(pedestal);
  } else {
    const nonInvertedActionSet = getNonInvertedPickupActionSet(pedestal);
    // TODO: ...
    if (nonInvertedActionSet === undefined) {
      returnPedestalAppearanceToNormal(pedestal);
    } else {
      nonInvertedActionSet.updateAppearance(pedestal);
    }
  }
}

/** Scans all pedestals in the room. */
export function updatePedestalsInRoom(): void {
  for (const pedestal of getCollectibles()) {
    updatePedestal(pedestal);
  }
}

/**
 * Returns a Pedestals EID and appearance to normal, for example after bitflipping back from the
 * corrupted realm.
 */
function returnPedestalAppearanceToNormal(pedestal: EntityPickupCollectible) {
  if (pedestal.SubType === CollectibleType.NULL) {
    return;
  }
  fprint(`returnPedestalAppearanceToNormal: ${pedestal.SubType}`);
  pedestal.FlipX = false;
  pedestal.SetColor(ColorDefault, 0, 1);
  returnCorruptedCollectibleSpriteToNormal(pedestal);

  if (!isGlitchedCollectible(pedestal)) {
    setCollectibleSprite(pedestal, getCollectibleGfxFilename(pedestal.SubType));
  }
  const genericEIDDesc = getGenericEntityEIDDescriptionObject(pedestal);
  if (genericEIDDesc === undefined) {
    return;
  }
  setSpecificEntityEIDDescriptionObject(pedestal, genericEIDDesc);
}

/**
 * This function is called whenever a pickup inits, or whenever a pickups inversion or subType or
 * ActionSet changes. For example upon bitflipping, all the pedestals in the room are updated to
 * account for the new EID description and change in pedestal appearance.
 */
export function updatePickup(pickup: EntityPickup): void {
  if (isCollectible(pickup)) {
    updatePedestal(pickup);
    return;
  }
  fprint(
    `Updating pickup: ${pickup.Type}, ${pickup.Variant}, ${pickup.SubType}.`,
  );
  const nonInvertedActionSet = getNonInvertedPickupActionSet(pickup);
  if (nonInvertedActionSet === undefined) {
    return;
  }
  nonInvertedActionSet.updateAppearance(pickup);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\inversion\worldInversionHelper.ts`:

```````ts
/** Helper functions related to the corrupted-world. */

import { getInvertedPlayers } from "../../../features/corruption/inversion/playerInversion";
import { getModeDataFromPlayer } from "../../../maps/modes/modeMap";
import { getDeletedPlayers } from "../deletedHelper";

/**
 * Checks if the 'inverted world' should be portrayed with the corrupted error room backdrop. As
 * some Deleted modes are stuck in the inverted world, it would be an eye sore to have the backdrop
 * constantly be the corrupted backdrop.
 */
export function shouldInvertedWorldHaveCorruptBackdrop(): boolean {
  return !getDeletedPlayers().some(
    (player) => getModeDataFromPlayer(player).startInverted,
  );
}

/**
 * Checks if the player should modify the floor color while inverted. No floor color is modified if
 * any player is in a mode that is stuck in the inverted world.
 */
export function shouldInvertedWorldHaveCorruptFloorColor(): boolean {
  return shouldInvertedWorldHaveCorruptBackdrop();
}

/** Checks if the world is in its inverted state. */
export function isWorldInverted(): boolean {
  return getInvertedPlayers().length > 0;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\items\extractHelper.ts`:

```````ts
import { CollectibleType, SoundEffect } from "isaac-typescript-definitions";
import type { WeightedArray } from "isaacscript-common";
import {
  DefaultMap,
  copyColor,
  getRandomFromWeightedArray,
  isCollectible,
  sfxManager,
} from "isaacscript-common";
import {
  isPickupUnstable,
  setEntityInstability,
} from "../../../classes/facets/entityModifiers.ts/UnstableEntityFacet";
import { isPickupInverted } from "../../../features/corruption/inversion/pickupInversion";
import { getPickupExtractExplosionDmg } from "../../../maps/modes/ZIPBOMBER/extractPickupBurnTimeMap";
import type { Percentage } from "../../../types/general/Percentage";
import { rollPercentage } from "../../../types/general/Percentage";
import type { Range } from "../../../types/general/Range";
import { randomInRangeOrNumber } from "../../../types/general/Range";
import { extractResponseBuilder } from "../../builders/items/EXTRACTBuilders";
import { rerollCollectible } from "../../collectibleHelper";
import { reddenColor } from "../../colorHelper";
import { explodeEntity } from "../../entityHelper/explodeEntity";
import { isUselessPickup } from "../../pickupHelper";
import { fprint } from "../../printHelper";
import { setPedestalInversion } from "../inversion/pedestalInversion";
import { getAndSetNonInvertedPickupActionSet } from "../effects/pickupEffects";

const BASE_PICKUP_EXPLOSION_DMG = 20;
const EXTRACT_COLLECTIBLE_SOUND = SoundEffect.MATCHSTICK;
const EXTRACT_SOUND_INCREMENT = 0.4;

const COLLECTIBLE_EXTRACTIONS_TIL_EXPLODE_CHANCE = new DefaultMap<
  number,
  Percentage
>(90, [
  [1, 5], // On the first extraction.
  [2, 25],
  [3, 40],
  [4, 50],
  [5, 65],
  [6, 80],
]);

// eslint-disable-next-line isaacscript/require-capital-const-assertions, isaacscript/require-capital-read-only
const SECONDS_TO_EXPLODE_AFTER_EXTRACTION: WeightedArray<number | Range> = [
  [1, 0.9],
  [[2, 9], 0.1],
  [[1, 60], 0.01],
];

/**
 * Rerolls the collectible, adding a negative effect to it. If the item is an inverted item, it will
 * reroll into another inverted item while still adding a negative effect.
 */
export function extractCollectible(collectible: EntityPickupCollectible): void {
  if (isPickupUnstable(collectible)) {
    return;
  }

  const isInverted = isPickupInverted(collectible);
  fprint(`Extracting a collectible. Is inverted: ${isInverted}.`);
  if (isInverted) {
    /** Set to non-inverted. */
    setPedestalInversion(false, collectible);
  }

  /** Shape the NonInvertedPickupActionSet. */
  const nonInvertedActionSet = getAndSetNonInvertedPickupActionSet(collectible);
  // Increment the number of times this item has been extracted.
  nonInvertedActionSet.ext =
    nonInvertedActionSet.ext === undefined ? 1 : nonInvertedActionSet.ext + 1;
  nonInvertedActionSet.addEffects(extractResponseBuilder());
  const color = copyColor(collectible.GetColor());
  nonInvertedActionSet.setColor(reddenColor(color));

  rerollCollectible(collectible);

  /** Play sound. */
  sfxManager.Play(
    EXTRACT_COLLECTIBLE_SOUND,
    1,
    0,
    false,
    nonInvertedActionSet.ext * EXTRACT_SOUND_INCREMENT + 1,
  );

  /** Explode pickup. */
  const chanceToExplode =
    COLLECTIBLE_EXTRACTIONS_TIL_EXPLODE_CHANCE.getAndSetDefault(
      nonInvertedActionSet.ext,
    );
  if (rollPercentage(chanceToExplode)) {
    fprint(
      `Exploding collectible after ${nonInvertedActionSet.ext} extractions, with a ${chanceToExplode}% chance.`,
    );
    setEntityInstability(
      collectible,
      randomInRangeOrNumber(
        getRandomFromWeightedArray(
          SECONDS_TO_EXPLODE_AFTER_EXTRACTION,
          undefined,
        ),
      ),
    );
  }
}

/** Explodes the pickup. Does different things depending on the pickup extracted. */
export function extractPickup(pickup: EntityPickup): void {
  if (isCollectible(pickup)) {
    /** Exception to blow up empty pedestals, which can help kill enemies. */
    if (pickup.SubType === CollectibleType.NULL) {
      explodeEntity(pickup, BASE_PICKUP_EXPLOSION_DMG);
      return;
    }
    extractCollectible(pickup);
    return;
  }

  if (isUselessPickup(pickup)) {
    fprint("Can't extract a useless pickup.");
    return;
  }

  fprint("Extracting a non-collectible pickup.");
  explodeEntity(pickup, getPickupExtractExplosionDmg(pickup));
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\modeHelper.ts`:

```````ts
/** Functions related to the players' 'Modes'. */

import {
  NormalModeCarousel,
  TaintedModeCarousel,
} from "../../constants/pcConstants";
import { getCurrentPlayerMode, setPlayerMode } from "../../features/modes/mode";
import { fprint } from "../printHelper";
import { isModeTainted } from "./deletedHelper";

export function switchToNextModeOnCarousel(player: EntityPlayer): void {
  const mode = getCurrentPlayerMode(player);
  if (mode === undefined) {
    fprint("Cannot switch modes on a non-Deleted player.");
    return;
  }

  let carousel = NormalModeCarousel;
  if (isModeTainted(mode)) {
    carousel = TaintedModeCarousel;
  }

  const nextMode = carousel[(carousel.indexOf(mode) + 1) % carousel.length];
  /** If the next mode is undefined, wrap around to the first mode. */
  if (nextMode === undefined) {
    const firstMode = carousel[0];
    if (firstMode === undefined) {
      error("The carousel is empty.");
    }
    setPlayerMode(player, firstMode);
    return;
  }

  setPlayerMode(player, nextMode);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\deletedSpecific\worlds\worldHelper.ts`:

```````ts
import type { World } from "../../../enums/worlds/Worlds";

// TODO.
export function isWorld(_world: World): boolean {
  return true;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\bombEntityHelper.ts`:

```````ts
import { getConstituentsFromEntityID } from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { getNonModdedEntityIDSetFromCategory } from "../../features/data/gameSets/gameEntitySets";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { getNonModdedBombEntityName } from "../../maps/data/name/bombEntityNameMap";

/**
 * Determines if a EntityID that refers to a live bomb is modded by checking it against the set of
 * all non-modded bombs.
 */
export function isBombEntityModded(entityID: EntityID): boolean {
  const nonModdedSlotSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.BOMB,
  );
  return !nonModdedSlotSet.has(entityID);
}

/**
 * Get the name of a Bomb from its EntityID. If it is modded, and the mod is not tracked, this will
 * return undefined. For modded bombs, this is the same as its 'name' xml attribute.
 */
export function getBombEntityIDName(entityID: EntityID): string | undefined {
  const modded = isBombEntityModded(entityID);
  if (!modded) {
    const constituents = getConstituentsFromEntityID(entityID);
    const variant = constituents[1];
    return getNonModdedBombEntityName(variant);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(entityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\effectHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { spawnEffect, spawnEntityID } from "isaacscript-common";
import type { EffectID } from "../../enums/data/ID/EffectID";
import { CardType } from "isaac-typescript-definitions";

/** Spawn an Entity Effect using their ID. */
export function spawnEffectID(
  effectID: EffectID,
  positionOrGridIndex: Vector | int,
  velocity?: Vector,
  spawner?: Entity | undefined,
  seedOrRNG?: Seed | RNG | undefined,
): EntityEffect {
  return spawnEntityID(
    effectID as EntityID,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityEffect;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\effectIDHelper.ts`:

```````ts
import { getRandomSeed, getRandomSetElement } from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import {
  getEntityIDSetFromCategory,
  getModdedEntityIDSetFromCategory,
  getNonModdedEntityIDSetFromCategory,
} from "../../features/data/gameSets/gameEntitySets";
import type { EffectID } from "../../enums/data/ID/EffectID";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { fprint } from "../printHelper";

/**
 * Determines if a EntityID that refers to an effect is modded by checking it against the set of all
 * non-modded EffectIDs.
 */
export function isEffectIDModded(effectID: EffectID): boolean {
  const nonModdedEffectSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.EFFECT,
  );
  return !nonModdedEffectSet.has(effectID as EntityID);
}

/**
 * Get the name of an EffectID. If it is modded, and the mod is not tracked, this will return
 * undefined. For modded effects, this is the same as its 'name' xml attribute.
 */
export function getEffectIDName(effectID: EffectID): string | undefined {
  const modded = isEffectIDModded(effectID);
  if (!modded) {
    return undefined;
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(effectID as EntityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

/**
 * Retrieves a random EffectID from the pool of available EffectID from the game set.
 *
 * @param modded Whether to get a modded or non-modded EffectID. If undefined, will get a random
 *               EffectID from either. If there are no modded EffectID with this set to true, this
 *               will return undefined.
 * @param seedOrRNG The seed or RNG to use for randomization. If undefined, will use a random Seed.
 */
export function getRandomEffectID(
  modded: boolean | undefined = undefined,
  seedOrRNG: Seed | RNG = getRandomSeed(),
): EffectID | undefined {
  if (modded === undefined) {
    const effectIDSet = getEntityIDSetFromCategory<EffectID>(
      EntityCategory.EFFECT,
    );
    return getRandomSetElement(effectIDSet, seedOrRNG);
  }

  if (modded) {
    const effectIDSet = getModdedEntityIDSetFromCategory<EffectID>(
      EntityCategory.EFFECT,
    );
    if (effectIDSet.size === 0) {
      fprint("No modded PickupIDs found!");
      return undefined;
    }
    return getRandomSetElement(effectIDSet, seedOrRNG);
  }

  const effectIDSet = getNonModdedEntityIDSetFromCategory<EffectID>(
    EntityCategory.EFFECT,
  );

  return getRandomSetElement(effectIDSet, seedOrRNG);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\entityIDHelper.ts`:

```````ts
import {
  getConstituentsFromEntityID,
  getEntities,
  getEntityIDFromConstituents,
  getEnumValues,
} from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import {
  EntityType,
  NPCID,
  PickupVariant,
  SlotVariant,
  TearVariant,
  BombVariant,
} from "isaac-typescript-definitions";
import { fprint } from "../printHelper";
import type { NameSubType } from "../../types/data/nameSubType";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { PickupID } from "../../enums/data/ID/PickupID";
import { EffectID } from "../../enums/data/ID/EffectID";
import { PICKUP_VARIANTS_WITH_AUTOGENERATED_SUBTYPES } from "../../constants/pickupConstants";

/** Determine if a variable is an EntityID (e.g '123.0.0'). */
export function isEntityID(variable: unknown): variable is EntityID {
  if (typeof variable !== "string") {
    return false;
  }
  const constituents = variable.split(".");
  if (constituents.length !== 3) {
    return false;
  }
  const [type, variant, subType] = constituents;
  return (
    type !== undefined &&
    variant !== undefined &&
    subType !== undefined &&
    !Number.isNaN(Number(type)) &&
    !Number.isNaN(Number(variant)) &&
    !Number.isNaN(Number(subType))
  );
}

/** Get an EntityID from an Entity. */
export function getEntityIDFromEntity(entity: Entity): EntityID {
  return getEntityIDFromConstituents(
    entity.Type,
    entity.Variant,
    entity.SubType,
  );
}

/** Get a set of EntityID's from the base game that match the provided EntityCategory. */
export function getBaseEntityIDSetFromCategory(
  category: EntityCategory,
): ReadonlySet<EntityID> {
  switch (category) {
    case EntityCategory.NPC: {
      return new Set(getEnumValues(NPCID)) as Set<EntityID>;
    }

    case EntityCategory.PICKUP: {
      return new Set(getEnumValues(PickupID)) as Set<EntityID>;
    }

    case EntityCategory.EFFECT: {
      return new Set(getEnumValues(EffectID)) as Set<EntityID>;
    }

    case EntityCategory.SLOT: {
      // There is no SlotID enum, so we have to manually create the set using the SlotVariant enum.
      const slotVariantSet = new Set<EntityID>();
      for (const slotVariant of getEnumValues(SlotVariant)) {
        slotVariantSet.add(`${EntityType.SLOT}.${slotVariant}.0` as EntityID);
      }
      return slotVariantSet;
    }

    case EntityCategory.TEAR: {
      // There is no TearID enum, so we have to manually create the set using the TearVariant enum.
      const tearVariantSet = new Set<EntityID>();
      for (const tearVariant of getEnumValues(TearVariant)) {
        tearVariantSet.add(`${EntityType.TEAR}.${tearVariant}.0` as EntityID);
      }
      return tearVariantSet;
    }

    case EntityCategory.BOMB: {
      // There is no BombID enum, so we have to manually create the set using the BombVariant enum.
      const bombVariantSet = new Set<EntityID>();
      for (const bombVariant of getEnumValues(BombVariant)) {
        bombVariantSet.add(`${EntityType.BOMB}.${bombVariant}.0` as EntityID);
      }
      return bombVariantSet;
    }

    default: {
      fprint(`Invalid category: ${category}, not yet implemented.`);
      return new Set<EntityID>();
    }
  }
}

/**
 * Get the modded Entity's name and subType from its Name + SubType string (e.g "0.HoneyFox") would
 * return { subType: 0, name: "HoneyFox" }.
 */
export function getModdedEntityNameAndSubTypeFromNameSubType(
  nameSubType: NameSubType,
): { name: string; subType: number } {
  // We can't use 'split' as names may contain '.'.
  const subTypeIndex = nameSubType.indexOf(".");
  if (subTypeIndex === -1) {
    error(`Invalid nameSubType: ${nameSubType}`);
  }
  const subType = nameSubType.slice(0, subTypeIndex);
  const name = nameSubType.slice(subTypeIndex + 1);
  return { name, subType: Number(subType) };
}

/**
 * Get an EntityID from a NameSubType string. If the game cannot find the entity name and hence its
 * type or variant, this will return undefined.
 */
export function getEntityIDFromNameSubType(
  nameSubType: NameSubType,
): EntityID | undefined {
  const nameAndSubType =
    getModdedEntityNameAndSubTypeFromNameSubType(nameSubType);
  const { name, subType } = nameAndSubType;
  const type = Isaac.GetEntityTypeByName(name);
  const variant = Isaac.GetEntityVariantByName(name);
  if ((type as number) === -1 || variant === -1) {
    fprint(`Invalid nameSubType: ${nameSubType}`);
    return undefined;
  }
  // If the entity is a card, pill, trinket, collectible, then the subType may be different due to
  // the game's internal logic.
  if (
    type === EntityType.PICKUP &&
    PICKUP_VARIANTS_WITH_AUTOGENERATED_SUBTYPES.has(variant)
  ) {
    let newSubType = subType;
    switch (variant) {
      case PickupVariant.CARD: {
        newSubType = Isaac.GetCardIdByName(name);
        break;
      }

      case PickupVariant.PILL: {
        newSubType = Isaac.GetPillEffectByName(name);
        break;
      }

      case PickupVariant.TRINKET: {
        newSubType = Isaac.GetTrinketIdByName(name);
        break;
      }

      case PickupVariant.COLLECTIBLE: {
        newSubType = Isaac.GetItemIdByName(name);
        break;
      }
    }

    // If the subType is still -1, then the entity name is invalid.
    if (newSubType === -1) {
      fprint(`Invalid nameSubType: ${nameSubType}`);
      return undefined;
    }

    return getEntityIDFromConstituents(type, variant, newSubType);
  }
  return getEntityIDFromConstituents(type, variant, subType);
}

/**
 * Determine an Entity's EntityCategory from its EntityID or EntityType.
 *
 * @param entityIDOrEntityType The EntityID or EntityType to determine the EntityCategory from.
 * @returns The EntityCategory of the EntityID or EntityType.
 */
export function getEntityCategoryFromEntityID(
  entityIDOrEntityType: EntityID | EntityType,
): EntityCategory {
  const typeNumber = isEntityID(entityIDOrEntityType)
    ? Number(entityIDOrEntityType.split(".")[0])
    : entityIDOrEntityType;
  if (typeNumber === 0) {
    error(
      `getEntityCategoryFromEntityID: Invalid entityID ${entityIDOrEntityType}`,
    );
  }
  if (typeNumber === 1) {
    return EntityCategory.PLAYER;
  }
  if (typeNumber === 2) {
    return EntityCategory.TEAR;
  }
  if (typeNumber === 3) {
    return EntityCategory.FAMILIAR;
  }
  if (typeNumber === 4) {
    return EntityCategory.BOMB;
  }
  if (typeNumber === 5) {
    return EntityCategory.PICKUP;
  }
  if (typeNumber === 6) {
    return EntityCategory.SLOT;
  }
  if (typeNumber === 7) {
    return EntityCategory.LASER;
  }
  if (typeNumber === 8) {
    return EntityCategory.KNIFE;
  }
  if (typeNumber === 9) {
    return EntityCategory.PROJECTILE;
  }
  if (typeNumber >= 1000) {
    return EntityCategory.EFFECT;
  }

  return EntityCategory.NPC;
}

/**
 * Helper function to get all of the entities in the room or all of the entities that match a
 * specific EntityID.
 *
 * Due to bugs with Isaac.FindInRadius, this function uses Isaac.GetRoomEntities, which is more
 * expensive but also more robust. (If a matching entity type is provided, then Isaac.FindByType
 * will be used instead.)
 *
 * @param entityID The EntityID to match. If a constituent is -1, will match all entities of that
 *                 type.
 * @param ignoreFriendly Whether to ignore friendly entities (default is false).
 */
export function getEntitiesFromEntityID(
  entityID: EntityID,
  ignoreFriendly = false,
): readonly Entity[] {
  const constituents = getConstituentsFromEntityID(entityID);
  return getEntities(
    constituents[0],
    constituents[1],
    constituents[2],
    ignoreFriendly,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\entityIDNameHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { getModdedEntityIDSet } from "../../features/data/gameSets/gameEntitySets";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import {
  getEntityCategoryFromEntityID,
  getModdedEntityNameAndSubTypeFromNameSubType,
} from "./entityIDHelper";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { getBombEntityIDName } from "./bombEntityHelper";
import { getEffectIDName } from "./effectIDHelper";
import type { EffectID } from "../../enums/data/ID/EffectID";
import { getPickupIDName } from "./pickupIDHelper";
import type { PickupID } from "../../enums/data/ID/PickupID";
import { getNPCIDName } from "./npcIDHelper";
import type { NPCID } from "isaac-typescript-definitions";
import { getSlotIDName } from "./slotHelper";
import { getFamiliarIDName } from "./familiarIDHelper";
import type { FamiliarID } from "../../enums/data/ID/FamiliarID";

/**
 * Get a modded entities' name from their EntityID. This is equivalent to their 'name' XML attribute
 * in the entities2.xml file. If the mod is not tracked, this will return undefined.
 */
export function getModdedEntityNameFromEntityID(
  entityID: EntityID,
): string | undefined {
  const nameSubType = getNameSubTypeFromModdedEntityID(entityID);
  if (nameSubType === undefined) {
    return undefined;
  }
  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

/**
 * Find the EntityID from the modded entities' name (equal to the 'name' XML attribute in
 * entities2.xml). Warning: Slow!
 */
export function getModdedEntityIDFromName(name: string): EntityID | undefined {
  // Loop through all modded entities in the 'moddedEntityIDToNameSubTypeMap' map and find the
  // matching name.
  const moddedEntities = getModdedEntityIDSet();
  for (const entityID of moddedEntities) {
    const entityName = getModdedEntityNameFromEntityID(entityID);
    if (entityName === undefined) {
      continue;
    }
    if (entityName === name) {
      return entityID;
    }
  }

  return undefined;
}

export function getEntityIDName(entityID: EntityID): string | undefined {
  const entityCategory = getEntityCategoryFromEntityID(entityID);
  switch (entityCategory) {
    case EntityCategory.BOMB: {
      return getBombEntityIDName(entityID);
    }

    case EntityCategory.EFFECT: {
      return getEffectIDName(entityID as EffectID);
    }

    case EntityCategory.PICKUP: {
      return getPickupIDName(entityID as PickupID);
    }

    case EntityCategory.NPC: {
      return getNPCIDName(entityID as NPCID);
    }

    case EntityCategory.SLOT: {
      return getSlotIDName(entityID);
    }

    case EntityCategory.FAMILIAR: {
      return getFamiliarIDName(entityID as FamiliarID);
    }

    // eslint-disable-next-line isaacscript/require-break
    default: {
      error(`Unimplemented entity category: ${entityCategory}`);
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\explodeEntity.ts`:

```````ts
import {
  Direction,
  EntityType,
  FireplaceVariant,
} from "isaac-typescript-definitions";
import { directionToVector, game, spawnNPC } from "isaacscript-common";
import { fprint } from "../printHelper";

const EXPLODE_ENTITY_SCREEN_SHAKE_DURATION = 10;

/**
 * Explodes an entity. This differentiates itself from Entity.Explode() by being able to hurt the
 * player.
 */
export function explodeEntity(entity: Entity, damage = 100): void {
  fprint(
    `Exploding entity: ${entity.Type} (${
      entity.Variant
    } GAME FRAMES: ${game.GetFrameCount()})`,
  );
  entity.Die();
  Isaac.Explode(entity.Position, undefined, damage);
  const fire = spawnNPC(
    EntityType.FIREPLACE,
    FireplaceVariant.MOVEABLE,
    0,
    entity.Position,
    directionToVector(Direction.LEFT).mul(entity.Velocity),
  );
  game.ShakeScreen(EXPLODE_ENTITY_SCREEN_SHAKE_DURATION);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\familiarHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { spawnEntityID } from "isaacscript-common";
import type { FamiliarID } from "../../enums/data/ID/FamiliarID";

/** Spawn an NPC by using their NPCID. */
export function spawnFamiliarID(
  familiarID: FamiliarID,
  positionOrGridIndex: Vector | int,
  velocity?: Vector,
  spawner?: Entity | undefined,
  seedOrRNG?: Seed | RNG | undefined,
): EntityNPC {
  return spawnEntityID(
    familiarID as EntityID,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityNPC;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\familiarIDHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { getNonModdedEntityIDSetFromCategory } from "../../features/data/gameSets/gameEntitySets";
import type { FamiliarID } from "../../enums/data/ID/FamiliarID";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";

/**
 * Determines if a EntityID that refers to a familiar is modded by checking it against the set of
 * all non-modded FamiliarIDs.
 */
export function isFamiliarIDModded(familiarID: FamiliarID): boolean {
  const nonModdedFamiliarSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.FAMILIAR,
  );
  return !nonModdedFamiliarSet.has(familiarID as EntityID);
}

/**
 * Get the name of a FamiliarID. If it is modded, and the mod is not tracked, this will return
 * undefined. For modded familiars, this is the same as its 'name' xml attribute.
 */
export function getFamiliarIDName(familiarID: FamiliarID): string | undefined {
  const modded = isFamiliarIDModded(familiarID);
  if (!modded) {
    return undefined;
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(familiarID as EntityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\npcFlagHelper.ts`:

```````ts
import {
  GAME_FRAMES_PER_SECOND,
  VectorZero,
  spawnTear,
} from "isaacscript-common";
import {
  bolsterNPC,
  isNPCBolstered,
  unbolsterNPC,
} from "../../classes/facets/entityModifiers.ts/NPCModifiers/BolsterNPCFacet";
import { censorNPC } from "../../classes/facets/entityModifiers.ts/NPCModifiers/CensoredNPCFacet";
import {
  freezeNPC,
  isNPCFrozen,
  unfreezeNPC,
} from "../../classes/facets/entityModifiers.ts/NPCModifiers/FreezeNPCFacet";
import {
  isNPCNonMandatory,
  makeNPCNonMandatory,
  removeNPCNonMandatoryEffect,
} from "../../classes/facets/entityModifiers.ts/NPCModifiers/NonMandatoryNPCFacet";
import {
  isNPCUnstable,
  setEntityInstability,
} from "../../classes/facets/entityModifiers.ts/UnstableEntityFacet";
import { NPCFlag } from "../../enums/general/NPCFlag";
import { fprint } from "../printHelper";
import {
  DamageFlag,
  DamageFlagZero,
  EntityFlag,
  TearVariant,
} from "isaac-typescript-definitions";
import { mod } from "../../mod";
import { addPermanentStatusEffectToNPC } from "../../classes/facets/entityModifiers.ts/NPCModifiers/PermanentNPCStatusEffectFacet";

const PERMANENT_STATUS_EFFECT_DURATION = -1;

/**
 * Add a custom NPCFlag to an NPC. If they already have the flag, nothing happens unless there is a
 * special effect that happens when multiple flags are added.
 *
 * @note For multi-segmented NPCs, this will add the flag to all segments.
 */
export function addNPCFlags(
  npc: EntityNPC,
  ...flags: readonly NPCFlag[]
): void {
  for (const flag of flags) {
    fprint(`Adding NPC flag ${NPCFlag[flag]} to npc: ${GetPtrHash(npc)}.`);
    switch (flag) {
      case NPCFlag.BOLSTERED: {
        bolsterNPC(npc);

        break;
      }

      case NPCFlag.FROZEN: {
        freezeNPC(npc);

        break;
      }

      case NPCFlag.NON_MANDATORY: {
        makeNPCNonMandatory(npc);

        break;
      }

      case NPCFlag.CENSORED: {
        censorNPC(npc);

        break;
      }

      case NPCFlag.UNSTABLE: {
        setEntityInstability(npc);

        break;
      }

      case NPCFlag.BURN: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.CHARMED: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.CONFUSED: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.FEAR: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.ICE_FREEZE: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.MIDAS_FREEZE: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.POISONED: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.SHRUNKEN: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.SLOWING: {
        addPermanentStatusEffectToNPC(npc, flag);

        break;
      }

      case NPCFlag.FRIENDLY: {
        npc.AddCharmed(EntityRef(undefined), PERMANENT_STATUS_EFFECT_DURATION);

        // We want to add the persistent flag as friendly bosses are not persistent by default.
        npc.AddEntityFlags(EntityFlag.PERSISTENT);

        break;
      }

      case NPCFlag.PERSISTENT: {
        npc.AddEntityFlags(EntityFlag.PERSISTENT);

        break;
      }

      // No default
    }
  }
}

/**
 * Checks if NPC has custom NPC flag.
 *
 * @note For multi-segmented NPCs, this will return true if any segment has the flag.
 */
export function doesNPCHaveFlag(npc: EntityNPC, flag: NPCFlag): boolean {
  if (flag === NPCFlag.BOLSTERED) {
    return isNPCBolstered(npc);
  }
  if (flag === NPCFlag.FROZEN) {
    return isNPCFrozen(npc);
  }
  if (flag === NPCFlag.NON_MANDATORY) {
    return isNPCNonMandatory(npc);
  }
  if (flag === NPCFlag.CENSORED) {
    // TODO.
    return false;
  }
  if (flag === NPCFlag.UNSTABLE) {
    isNPCUnstable(npc);
  }
  return false;
}

/**
 * Remove a custom NPCFlag from an NPC. If they don't have the flag, nothing happens.
 *
 * @note For multi-segmented NPCs, this will remove the flag from all segments.
 */
export function removeNPCFlags(npc: EntityNPC, ...flags: NPCFlag[]): void {
  for (const flag of flags) {
    switch (flag) {
      case NPCFlag.BOLSTERED: {
        unbolsterNPC(npc);

        break;
      }

      case NPCFlag.FROZEN: {
        unfreezeNPC(npc);

        break;
      }

      case NPCFlag.NON_MANDATORY: {
        removeNPCNonMandatoryEffect(npc);

        break;
      }

      case NPCFlag.CENSORED: {
        // TODO.

        break;
      }

      case NPCFlag.UNSTABLE: {
        // TODO.

        break;
      }
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\npcHelper.ts`:

```````ts
import { getNPCs, getRandomArrayElementAndRemove } from "isaacscript-common";
import { fprint } from "../printHelper";
import type { NPCAttribute } from "../../interfaces/general/NPCAttribute";
import {
  getNPCIDMaxHitPoints,
  getNPCIDName,
  getNPCIDSize,
  isNPCIDBoss,
  isNPCIDFlying,
  isNPCIDModded,
} from "./npcIDHelper";
import { getEntityIDFromEntity } from "./entityIDHelper";
import {
  getEntityIDSetFromCategory,
  getModdedEntityIDSetFromCategory,
  getModdedEntityIDSetFromModAndCategory,
  getNonModdedEntityIDSetFromCategory,
} from "../../features/data/gameSets/gameEntitySets";
import { EntityCategory } from "../../enums/general/EntityCategory";
import type { NPCID } from "isaac-typescript-definitions";
import { addArticle } from "../stringHelper";
import {
  randomInRange,
  randomInRangeOrNumber,
} from "../../types/general/Range";
import type { Range } from "../../types/general/Range";

/** Determines if an NPC is modded by checking it against the set of all non-Modded NPCs. */
export function isNPCModded(npc: EntityNPC): boolean {
  return isNPCIDModded(getEntityIDFromEntity(npc) as NPCID);
}

/**
 * Get an ordered list of NPCs children line, including the NPC itself, from specified NPC ->
 * youngest. An NPC may have a child but not have it tracked with the 'Child' property, so be
 * careful.
 *
 * @param npc The specified NPC to look for children.
 * @param children The array of children to add to, should leave this blank.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function getAllChildrenNPCs(
  npc: EntityNPC,
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  children: EntityNPC[] | undefined = [],
): EntityNPC[] {
  children ??= [];
  const child = npc.Child;

  children.push(npc);

  if (child === undefined) {
    return children;
  }

  if (!isEntityNPC(child)) {
    return children;
  }

  if (children.map((value) => GetPtrHash(value)).includes(GetPtrHash(child))) {
    return children;
  }

  children = getAllChildrenNPCs(child, children);
  return children;
}

/** Is the Entity an NPC. */
export function isEntityNPC(entity: Entity): entity is EntityNPC {
  return entity.ToNPC() !== undefined;
}

/**
 * Get an ordered list of all an NPCs parents, including the NPC itself, from specified NPC ->
 * oldest. If an NPC is recursive (e.g ring flies), this will return the uppermost parent until
 * reaching an NPC already in the chain. Note a parent may have a parent but not have it tracked
 * with the 'Parent' property, so be careful.
 *
 * @param npc The specified NPC to look for children.
 * @param parents The array of parents to add to, should leave this blank.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function getAllParentNPCs(
  npc: EntityNPC,
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  parents: EntityNPC[] | undefined = [],
): EntityNPC[] {
  parents ??= [];
  const parent = npc.Parent;

  parents.push(npc);

  if (parent === undefined) {
    return parents;
  }

  if (!isEntityNPC(parent)) {
    return parents;
  }

  if (parents.map((value) => GetPtrHash(value)).includes(GetPtrHash(parent))) {
    return parents;
  }

  parents = getAllParentNPCs(parent, parents);
  return parents;
}

/**
 * Retrieve the topmost parent NPC in the parent NPC chain. If the chain is recursive, this will
 * return the uppermost parent until reaching an NPC already in the chain. Note that some NPCs may
 * not track their parents, instead the parent may only track their children.
 */
export function getLastParentNPC(npc: EntityNPC): EntityNPC {
  const parentChain = getAllParentNPCs(npc);
  return parentChain.at(-1) ?? npc;
}

/** Looks through both NPCs lineages and sees if there are any common NPCs between them. */
export function areNPCsRelated(npc1: EntityNPC, npc2: EntityNPC): boolean {
  const npc1PtrHash = GetPtrHash(npc1);
  const npc2PtrHash = GetPtrHash(npc2);

  if (npc1PtrHash === npc2PtrHash) {
    return true;
  }

  const npc1Family = new Set(
    getNPCLineage(npc1).map((value) => GetPtrHash(value)),
  );
  const npc2Family = new Set(
    getNPCLineage(npc2).map((value) => GetPtrHash(value)),
  );

  const commonAncestors = new Set(
    [...npc1Family].filter((value) => npc2Family.has(value)),
  );

  if (commonAncestors.size > 0) {
    return true;
  }

  return false;
}

/**
 * Retrieve all of an NPCs in order from the upmost parent to the last child, which are directly in
 * the child/parent chain. The provided NPC will be included in the list. Note that some children in
 * the family will not be returned by this function, only the direct line to the parent, use
 * 'getNPCFamily()' instead.
 *
 * @example Larry Jr -> Call this function on any segment and it will return the an array like:
 *          [head, mid-body, end-body].
 * @example Ring Fly -> Only will return the last-non repeated parent.
 *
 * To find all children, use 'getNPCFamily()'.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function getNPCLineage(npc: EntityNPC): EntityNPC[] {
  const parentChain = getAllParentNPCs(npc).reverse();
  const childChain = getAllChildrenNPCs(npc);

  // Remove repeated NPC from childChain:
  childChain.shift();

  // Conjoin the two chains:
  const lineage = [...parentChain, ...childChain];

  return lineage;
}

/**
 * Retrieve all NPCs in the room that are in some way related to the specified NPC, through parent /
 * child attributes. This will also return the specified NPC. They are not in order.
 *
 * @example The Haunt -> [The Haunt, The Haunt's Ghost, The Haunt's Ghost, The Haunt's Ghost]
 * @example Larry Jr -> [Larry Jr, Larry Jr's Body, Larry Jr's Body, Larry Jr's Body]
 * @example Ring Fly -> [All ring flies in chain]
 *
 * This is different from getNPCLineage(), as it looks through all NPCs in the room and compares
 * NPC lineages, rather than following the parent / child chain.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function getNPCFamily(npc: EntityNPC): Set<EntityNPC> {
  const family = new Set<EntityNPC>();
  const tempPtrFamily = new Set<PtrHash>();
  const npcPtrHash = GetPtrHash(npc);
  family.add(npc);
  tempPtrFamily.add(npcPtrHash);

  // Get all the NPCs in the room.
  const npcs = getNPCs();
  for (const npcInRoom of npcs) {
    // If the NPC is related to the provided NPC, add it to the family.
    const npcInRoomPtrHash = GetPtrHash(npcInRoom);
    if (npcPtrHash === npcInRoomPtrHash) {
      continue;
    }
    if (
      areNPCsRelated(npcInRoom, npc) &&
      !tempPtrFamily.has(npcInRoomPtrHash)
    ) {
      family.add(npcInRoom);
      tempPtrFamily.add(npcInRoomPtrHash);
    }
  }

  return family;
}

/**
 * Get an assortment of random NPCIDs, matching the specified NPCAttribute (or any NPCs if
 * NPCAttribute is undefined).
 *
 * @param range The range of how many NPCs to get.
 * @param npcAttribute The NPC Attribute to match (optional).
 * @param seedOrRNG The seed or RNG you want to use (optional).
 * @param unique Whether to make sure the NPCs are unique. If false, the same NPCID may be returned
 *               multiple times. If true, the same NPCID will never be returned twice.
 *
 * @returns An array of NPCIDs or undefined if not enough NPCs were found to match the range.
 */
export function getRandomAssortmentOfNPCs(
  range: Range | number,
  npcAttribute?: NPCAttribute,
  seedOrRNG?: Seed | RNG,
  unique = true,
): readonly NPCID[] | undefined {
  const npcAttributeCopy = { ...npcAttribute };
  const amount = randomInRangeOrNumber(range, seedOrRNG);
  const npcIDs: NPCID[] = [];
  for (let i = 0; i < amount; i++) {
    const npcID = getRandomNPC(npcAttributeCopy, seedOrRNG);

    // If we can't find an NPC, return undefined.
    if (npcID === undefined) {
      return undefined;
    }

    // NPC found, if 'unique' is true add it to banned so we don't get it again.
    npcIDs.push(npcID);

    if (unique) {
      npcAttributeCopy.banned ??= [];
      npcAttributeCopy.banned.push(npcID);
    }
  }

  return npcIDs;
}

/**
 * Spawn a random NPC in the room, that matches the specified NPC Attributes.
 *
 * @param npcAttributes The NPC Attributes you want the random NPC to match (optional).
 * @param seedOrRNG The seed or RNG you want to use (optional).
 * @returns A random NPC or undefined.
 */
export function getRandomNPC(
  npcAttributes?: NPCAttribute,
  seedOrRNG?: Seed | RNG,
): NPCID | undefined {
  let setToUse: ReadonlySet<NPCID>;
  if (npcAttributes === undefined) {
    setToUse = getEntityIDSetFromCategory(EntityCategory.NPC);
    // eslint-disable-next-line unicorn/prefer-switch
  } else if (npcAttributes.modded === true) {
    setToUse = getModdedEntityIDSetFromCategory(EntityCategory.NPC);
  } else if (npcAttributes.modded === false) {
    setToUse = getNonModdedEntityIDSetFromCategory(EntityCategory.NPC);
  } else if (npcAttributes.modded === undefined) {
    setToUse = getEntityIDSetFromCategory(EntityCategory.NPC);
  } else {
    setToUse = getModdedEntityIDSetFromModAndCategory(
      npcAttributes.modded,
      EntityCategory.NPC,
    );
  }

  if (setToUse.size === 0) {
    fprint("getRandomNPC: No NPCs found in the set.");
    return undefined;
  }

  // Copy the set to an array.
  const npcIDArray = [...setToUse];

  // Get a random NPC from the array, that matches the attributes.
  let npcID = getRandomArrayElementAndRemove<NPCID | undefined>(
    npcIDArray,
    seedOrRNG,
  );

  // If there are no attributes, return the NPCID.
  if (npcAttributes === undefined) {
    fprint("No NPC attributes specified, returning random NPC.");
    return npcID;
  }

  // If there are attributes, loop through the array until we find an NPC that matches.
  while (npcID !== undefined) {
    if (doesNPCIDMatchNPCAttributes(npcID, npcAttributes)) {
      break;
    }
    if (npcIDArray.length === 0) {
      return undefined;
    }
    fprint(`NPCID with name ${getNPCIDName(npcID)} did not match attributes.`);
    npcID = getRandomArrayElementAndRemove(npcIDArray, seedOrRNG);
  }

  return npcID;
}

/**
 * Determines if an NPC matches the specified NPC Attributes.
 *
 * @param npcID The NPCID to check.
 * @param npcAttributes The NPC Attributes to check.
 * @returns Whether the NPC matches the attributes. Note that if the NPCID is modded, it will not be
 *          able to ascertain NPCID attributes if the mod is not tracked. In this case, it will
 *          always return false.
 */
export function doesNPCIDMatchNPCAttributes(
  npcID: NPCID,
  npcAttributes: NPCAttribute,
): boolean {
  // Forced match.
  const { forced } = npcAttributes;
  if (forced !== undefined && forced.includes(npcID)) {
    return true;
  }

  // Banned from being matched.
  const { banned } = npcAttributes;
  if (banned !== undefined && banned.includes(npcID)) {
    return false;
  }

  // Flying.
  const { flying } = npcAttributes;
  if (flying !== undefined) {
    const npcFlying = isNPCIDFlying(npcID);
    if (npcFlying !== flying) {
      return false;
    }
  }

  // Boss.
  const { boss } = npcAttributes;
  if (boss !== undefined) {
    const npcBoss = isNPCIDBoss(npcID);
    if (npcBoss !== boss) {
      return false;
    }
  }

  // Size.
  const { size } = npcAttributes;
  if (size !== undefined) {
    const npcSize = getNPCIDSize(npcID);
    if (npcSize === undefined) {
      return false;
    }
    if (!(npcSize >= size[0] && npcSize <= size[1])) {
      return false;
    }
  }

  // MaxHitPoints.
  const { health } = npcAttributes;
  if (health !== undefined) {
    const npcSize = getNPCIDMaxHitPoints(npcID);
    if (npcSize === undefined) {
      return false;
    }
    if (!(npcSize >= health[0] && npcSize <= health[1])) {
      return false;
    }
  }

  // Starts with (capitalization doesn't matter). If the NPC does not have a registered name, always
  // return false.
  const { startsWith } = npcAttributes;
  if (startsWith !== undefined) {
    const npcName = getNPCIDName(npcID)?.toLowerCase();
    if (npcName === undefined) {
      return false;
    }
    if (!npcName.startsWith(startsWith.toLowerCase())) {
      return false;
    }
  }

  // Starts with (capitalization doesn't matter). If the NPC does not have a registered name, always
  // return false.
  const { endsWith } = npcAttributes;
  if (endsWith !== undefined) {
    const npcName = getNPCIDName(npcID)?.toLowerCase();
    if (npcName === undefined) {
      return false;
    }
    if (!npcName.endsWith(endsWith.toLowerCase())) {
      return false;
    }
  }

  return true;
}

/**
 * Converts a NPCAttribute object to its appropriate text.
 *
 * @example { flying: true, boss: true } -> "a flying boss".
 * @param npcAttributes The NPC Attributes to convert.
 * @param plural Whether to make the text plural (e.g "enemies" instead of "enemy").
 * @param prefixTextBeforeEnemy Any text to add before the enemy (e.g "a random enemy" -> "a random
 *                              champion enemy").
 */
export function npcAttributesToText(
  npcAttributes: NPCAttribute,
  plural = false,
  prefixTextBeforeEnemy = "",
): string {
  let text = "";

  // Modded.
  const { modded } = npcAttributes;
  if (modded !== undefined) {
    if (modded === true) {
      text += "modded ";
    } else if (modded === false) {
      text += "non-modded ";
    }
    // If modded is a Mod, we add the mod name at the end.
  }

  // Flying.
  const { flying } = npcAttributes;
  if (flying !== undefined) {
    text += flying ? "flying " : "non-flying ";
  }

  // Size.
  const { size } = npcAttributes;
  if (size !== undefined) {
    text += `size: ${size}, `;
  }

  // MaxHitPoints.
  const { health } = npcAttributes;
  if (health !== undefined) {
    text += `health: ${health}, `;
  }

  // Add the prefix text before the enemy.
  text += ` ${prefixTextBeforeEnemy} `;

  // Add the 'enemy' at the end.
  const { boss } = npcAttributes;
  if (boss === undefined || !boss) {
    text += plural ? "enemies " : "enemy ";
  } else {
    text += plural ? "bosses " : "boss ";
  }

  // Starts with (capitalization doesn't matter). If the NPC does not have a registered name, always
  // return false.
  const { startsWith } = npcAttributes;
  if (startsWith !== undefined) {
    text += `starting with "${startsWith.toUpperCase()}" `;
  }

  // Ends with (capitalization doesn't matter). If the NPC does not have a registered name, always
  // return false.
  const { endsWith } = npcAttributes;
  if (endsWith !== undefined) {
    text += `ending with "${endsWith.toUpperCase()}" `;
  }

  // Add the mod name at the end if modded is a Mod.
  if (modded !== undefined && typeof modded === "string") {
    text += `from ${modded} `;
  }

  text = plural ? text : addArticle(text);
  return text;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\npcIDHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { getConstituentsFromEntityID, spawnNPC } from "isaacscript-common";
import { getNonModdedNPCName } from "../../maps/data/name/npcNameMap";
import { getNonModdedBossNPCIDSet } from "../../sets/data/npc/BossNPCSet";
import { getNonModdedFlyingNPCIDSet } from "../../sets/data/npc/FlyingNPCSet";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { _isModdedNPCIDFlying } from "../../sets/data/modded/ModdedFlyingNPCSet";
import { _getNonModdedNPCSize } from "../../maps/data/npc/NPCSizeMap";
import { _getNonModdedNPCIDMaxHitPoints } from "../../maps/data/npc/NPCMaxHitPointsMap";
import { getNonModdedEntityIDSetFromCategory } from "../../features/data/gameSets/gameEntitySets";
import { EntityCategory } from "../../enums/general/EntityCategory";
import type { NPCID } from "isaac-typescript-definitions";
import { getModdedEntityDataFromEntityID } from "../compatibility/XML/moddedXMLParserHelper";

/** Determines if an NPCID is modded by checking it against the set of all NPCs in the base game. */
export function isNPCIDModded(npcID: NPCID): boolean {
  const nonModdedNPCSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.NPC,
  );
  if (nonModdedNPCSet === undefined) {
    return false;
  }
  return !nonModdedNPCSet.has(npcID as EntityID);
}

/**
 * Determines if an NPC is flying from its NPCID. Note that if the NPC is modded, if the mod is not
 * tracked, this will return undefined.
 *
 * TODO: Fix.
 */
export function isNPCIDFlying(npcID: NPCID): boolean | undefined {
  const modded = isNPCIDModded(npcID);
  if (!modded) {
    return getNonModdedFlyingNPCIDSet().has(npcID);
  }

  return _isModdedNPCIDFlying(npcID as EntityID);
}

/**
 * Determines if an NPC is a boss from its NPCID. Note that if the NPC is modded, if the mod is not
 * tracked, this will return undefined.
 */
export function isNPCIDBoss(npcID: NPCID): boolean | undefined {
  const modded = isNPCIDModded(npcID);
  if (!modded) {
    return getNonModdedBossNPCIDSet().has(npcID);
  }

  const data = getModdedEntityDataFromEntityID(npcID as EntityID);
  if (data === undefined) {
    return undefined;
  }

  const { boss } = data._attr;
  if (boss === undefined) {
    return false;
  }

  return boss === "1";
}

/**
 * Get the name of an NPCID. If it is modded, and the mod is not tracked, this will return
 * undefined. For modded NPCs, this is the same as its 'name' xml attribute.
 */
export function getNPCIDName(npcID: NPCID): string | undefined {
  const modded = isNPCIDModded(npcID);
  if (!modded) {
    return getNonModdedNPCName(npcID);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(npcID as EntityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

/**
 * Get the size of an NPCID. If modded, and the mod is not tracked, returns undefined. This is
 * equivalent to the 'collisionRadius' xml attribute.
 */
export function getNPCIDSize(npcID: NPCID): number | undefined {
  const modded = isNPCIDModded(npcID);
  if (!modded) {
    return _getNonModdedNPCSize(npcID);
  }

  const data = getModdedEntityDataFromEntityID(npcID as EntityID);
  if (data === undefined) {
    return undefined;
  }

  const { collisionRadius } = data._attr;
  if (collisionRadius === undefined) {
    return undefined;
  }

  return Number(collisionRadius);
}

/**
 * Get the MaxHitPoints of an NPCID. If modded, and the mod is not tracked, returns undefined.
 * MaxHitPoints is the NPCs total health. This is equivalent to the 'baseHP' xml attribute.
 */
export function getNPCIDMaxHitPoints(npcID: NPCID): number | undefined {
  const modded = isNPCIDModded(npcID);
  if (!modded) {
    return _getNonModdedNPCIDMaxHitPoints(npcID);
  }

  const data = getModdedEntityDataFromEntityID(npcID as EntityID);
  if (data === undefined) {
    return undefined;
  }

  const { baseHP } = data._attr;
  if (baseHP === undefined) {
    return undefined;
  }

  return Number(baseHP);
}

/** Spawn an NPC by using their NPCID. */
export function spawnNPCID(
  npcID: NPCID,
  positionOrGridIndex: Vector | int,
  velocity?: Vector,
  spawner?: Entity | undefined,
  seedOrRNG?: Seed | RNG | undefined,
): EntityNPC {
  const constituents = getConstituentsFromEntityID(npcID as EntityID);
  return spawnNPC(
    constituents[0],
    constituents[1],
    constituents[2],
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\pickupIDHelper copy.ts`:

```````ts
import {
  getConstituentsFromEntityID,
  getRandomFromWeightedArray,
  getRandomSeed,
  getRandomSetElement,
  isRune,
  spawnPickup,
} from "isaacscript-common";
import type { ReadonlySet, EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import {
  getEntityIDSetFromCategory,
  getModdedEntityIDSetFromCategory,
  getModdedPickupIDSetOfPickupType,
  getNonModdedEntityIDSetFromCategory,
  getNonModdedPickupIDSetOfPickupType,
  getPickupIDSetOfPickupType,
} from "../../features/data/gameSets/gameEntitySets";
import type { PickupID } from "../../enums/data/ID/PickupID";
import { getNonModdedPickupName } from "../../maps/data/name/pickupNameMap";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { PickupType } from "../../enums/general/PickupType";
import { fprint } from "../printHelper";
import type { CardType } from "isaac-typescript-definitions";
import { EntityType, PickupVariant } from "isaac-typescript-definitions";
import {
  RANDOM_SOFT_NON_MODDED_MISCELLANEOUS_PICKUP_ID_SPREAD,
  RANDOM_SOFT_NON_MODDED_RUNE_PICKUP_ID_SPREAD,
  RANDOM_SOFT_NON_MODDED_SOUL_PICKUP_ID_SPREAD,
  SOUL_PREFIX,
} from "../../constants/pickupConstants";

/**
 * Determines if a EntityID that refers to a pickup is modded by checking it against the set of all
 * non-modded PickupIDs.
 */
export function isPickupIDModded(pickupID: PickupID): boolean {
  const nonModdedPickupSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.PICKUP,
  );
  return !nonModdedPickupSet.has(pickupID as EntityID);
}

/**
 * Get the name of a PickupID. If it is modded, and the mod is not tracked, this will return
 * undefined. For modded pickups, this is the same as its 'name' xml attribute.
 */
export function getPickupIDName(pickupID: PickupID): string | undefined {
  const modded = isPickupIDModded(pickupID);
  if (!modded) {
    return getNonModdedPickupName(pickupID);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(pickupID as EntityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

/**
 * Retrieves a random PickupID from the pool of available PickupIDs from the game set.
 *
 * @param modded Whether to get a modded or non-modded PickupID. If undefined, will get a random
 *               PickupID from either. If there are no modded PickupIDs with this set to true, this
 *               will return undefined.
 * @param seedOrRNG The seed or RNG to use for randomization. If undefined, will use a random Seed.
 */
export function getRandomPickupID(
  modded: boolean | undefined = undefined,
  seedOrRNG: Seed | RNG = getRandomSeed(),
): PickupID | undefined {
  if (modded === undefined) {
    const pickupIDSet = getEntityIDSetFromCategory<PickupID>(
      EntityCategory.PICKUP,
    );
    return getRandomSetElement(pickupIDSet, seedOrRNG);
  }

  if (modded) {
    const pickupIDSet = getModdedEntityIDSetFromCategory<PickupID>(
      EntityCategory.PICKUP,
    );
    if (pickupIDSet.size === 0) {
      fprint("No modded PickupIDs found!");
      return undefined;
    }
    return getRandomSetElement(pickupIDSet, seedOrRNG);
  }

  const pickupIDSet = getNonModdedEntityIDSetFromCategory<PickupID>(
    EntityCategory.PICKUP,
  );

  return getRandomSetElement(pickupIDSet, seedOrRNG);
}

/**
 * Retrieves a random PickupID that corresponds to the specified PickupType using the game PickupID
 * sets. If no PickupID is found, this will return undefined.
 *
 * @param pickupType The PickupType to get a random PickupID from.
 * @param seedOrRNG The seed or RNG to use for randomization.
 * @param modded Whether to get a modded or non-modded PickupID. If undefined, will get a random
 *               PickupID from either.
 */
export function getRandomPickupIDFromPickupType(
  pickupType: PickupType,
  seedOrRNG: Seed | RNG = getRandomSeed(),
  modded: boolean | undefined = undefined,
): PickupID | undefined {
  let pickupIDSet: ReadonlySet<PickupID> | undefined;
  if (modded === undefined) {
    pickupIDSet = getPickupIDSetOfPickupType(pickupType);
  } else if (modded) {
    pickupIDSet = getModdedPickupIDSetOfPickupType(pickupType);
  } else {
    pickupIDSet = getNonModdedPickupIDSetOfPickupType(pickupType);
  }

  if (pickupIDSet.size === 0) {
    fprint(
      `No PickupIDs found for PickupType ${PickupType[pickupType]}${
        modded === undefined ? "" : ` and modded = ${modded ? "true" : "false"}`
      }`,
    );
    return undefined;
  }

  return getRandomSetElement(pickupIDSet, seedOrRNG);
}

/**
 * Spawn an Pickup by using their PickupID. If the specified PickupID does not refer to a Pickup,
 * this will throw an error.
 */
export function spawnPickupID(
  pickupID: PickupID,
  positionOrGridIndex: Vector | int,
  velocity?: Vector,
  spawner?: Entity | undefined,
  seedOrRNG?: Seed | RNG | undefined,
): EntityPickup {
  const constituents = getConstituentsFromEntityID(pickupID as EntityID);
  if (constituents[0] !== EntityType.PICKUP) {
    error(`spawnPickupID: EntityID ${pickupID} is not a PickupID`);
  }

  return spawnPickup(
    constituents[1],
    constituents[2],
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Retrieves the PickupID that will spawn a random pickup of the specified type. If the specified
 * PickupType does not have a corresponding random PickupID, this will generate a random specific
 * PickupID of that type.
 */
export function getSoftRandomPickupIDFromPickupType(
  pickupType: PickupType,
  seedOrRNG: Seed | RNG | undefined = undefined,
): PickupID {
  switch (pickupType) {
    case PickupType.HEART: {
      return `${EntityType.PICKUP}.${PickupVariant.HEART}.0` as PickupID;
    }

    case PickupType.COIN: {
      return `${EntityType.PICKUP}.${PickupVariant.COIN}.0` as PickupID;
    }

    case PickupType.KEY: {
      return `${EntityType.PICKUP}.${PickupVariant.KEY}.0` as PickupID;
    }

    case PickupType.BOMB: {
      return `${EntityType.PICKUP}.${PickupVariant.BOMB}.0` as PickupID;
    }

    case PickupType.POOP: {
      return `${EntityType.PICKUP}.${PickupVariant.POOP}.0` as PickupID;
    }

    // This will spawn a random chest.
    case PickupType.CHEST: {
      return `${EntityType.PICKUP}.${PickupVariant.CHEST}.0` as PickupID;
    }

    case PickupType.SACK: {
      return `${EntityType.PICKUP}.${PickupVariant.SACK}.0` as PickupID;
    }

    case PickupType.PILL: {
      return `${EntityType.PICKUP}.${PickupVariant.PILL}.0` as PickupID;
    }

    case PickupType.BATTERY: {
      return `${EntityType.PICKUP}.${PickupVariant.LIL_BATTERY}.0` as PickupID;
    }

    case PickupType.COLLECTIBLE: {
      return `${EntityType.PICKUP}.${PickupVariant.COLLECTIBLE}.0` as PickupID;
    }

    case PickupType.TRINKET: {
      return `${EntityType.PICKUP}.${PickupVariant.TRINKET}.0` as PickupID;
    }

    case PickupType.SHOP_ITEM: {
      return `${EntityType.PICKUP}.${PickupVariant.SHOP_ITEM}.0` as PickupID;
    }

    // Can spawn runes and souls.
    case PickupType.CARD: {
      return `${EntityType.PICKUP}.${PickupVariant.CARD}.0` as PickupID;
    }

    case PickupType.SOUL: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_SOUL_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }

    case PickupType.RUNE: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_RUNE_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }

    case PickupType.MISCELLANEOUS: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_MISCELLANEOUS_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }
  }
}

export function getPickupTypeFromPickupID(pickupID: PickupID): PickupType {
  const constituents = getConstituentsFromEntityID(pickupID as EntityID);
  if (constituents[0] !== EntityType.PICKUP) {
    error(`EntityID ${pickupID} is not a PickupID`);
  }

  switch (constituents[1]) {
    case PickupVariant.HEART: {
      return PickupType.HEART;
    }

    case PickupVariant.COIN: {
      return PickupType.COIN;
    }

    case PickupVariant.KEY: {
      return PickupType.KEY;
    }

    case PickupVariant.BOMB: {
      return PickupType.BOMB;
    }

    case PickupVariant.THROWABLE_BOMB: {
      return PickupType.BOMB;
    }

    case PickupVariant.POOP: {
      return PickupType.POOP;
    }

    case PickupVariant.CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.SACK: {
      return PickupType.SACK;
    }

    case PickupVariant.PILL: {
      return PickupType.PILL;
    }

    case PickupVariant.BOMB_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.LOCKED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.ETERNAL_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.HAUNTED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.RED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.MIMIC_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.MEGA_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.BIG_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.SPIKED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.LIL_BATTERY: {
      return PickupType.BATTERY;
    }

    case PickupVariant.COLLECTIBLE: {
      return PickupType.COLLECTIBLE;
    }

    case PickupVariant.TRINKET: {
      return PickupType.TRINKET;
    }

    case PickupVariant.SHOP_ITEM: {
      return PickupType.SHOP_ITEM;
    }

    case PickupVariant.CARD: {
      const cardName = getPickupIDName(pickupID);
      if (cardName === undefined) {
        return PickupType.CARD;
      }

      // If the card name has 'Soul of' in it, it's a soul stone.
      if (cardName.toLowerCase().includes(SOUL_PREFIX.toLowerCase())) {
        return PickupType.SOUL;
      }

      if (isRune(constituents[2] as CardType)) {
        return PickupType.RUNE;
      }

      return PickupType.CARD;
    }

    default: {
      // Check if name contains 'Chest'.
      const pickupName = getPickupIDName(pickupID);
      if (
        pickupName !== undefined &&
        pickupName.toLowerCase().includes("chest")
      ) {
        return PickupType.CHEST;
      }
      return PickupType.MISCELLANEOUS;
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\pickupIDHelper.ts`:

```````ts
import {
  getConstituentsFromEntityID,
  getRandomFromWeightedArray,
  getRandomSeed,
  getRandomSetElement,
  isRune,
  spawnPickup,
} from "isaacscript-common";
import type { ReadonlySet, EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import {
  getEntityIDSetFromCategory,
  getModdedEntityIDSetFromCategory,
  getModdedPickupIDSetOfPickupType,
  getNonModdedEntityIDSetFromCategory,
  getNonModdedPickupIDSetOfPickupType,
  getPickupIDSetOfPickupType,
} from "../../features/data/gameSets/gameEntitySets";
import type { PickupID } from "../../enums/data/ID/PickupID";
import { getNonModdedPickupName } from "../../maps/data/name/pickupNameMap";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { PickupType } from "../../enums/general/PickupType";
import { fprint } from "../printHelper";
import type { CardType } from "isaac-typescript-definitions";
import { EntityType, PickupVariant } from "isaac-typescript-definitions";
import {
  RANDOM_SOFT_NON_MODDED_MISCELLANEOUS_PICKUP_ID_SPREAD,
  RANDOM_SOFT_NON_MODDED_RUNE_PICKUP_ID_SPREAD,
  RANDOM_SOFT_NON_MODDED_SOUL_PICKUP_ID_SPREAD,
  SOUL_PREFIX,
} from "../../constants/pickupConstants";

/**
 * Determines if a EntityID that refers to a pickup is modded by checking it against the set of all
 * non-modded PickupIDs.
 */
export function isPickupIDModded(pickupID: PickupID): boolean {
  const nonModdedPickupSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.PICKUP,
  );
  return !nonModdedPickupSet.has(pickupID as EntityID);
}

/**
 * Get the name of a PickupID. If it is modded, and the mod is not tracked, this will return
 * undefined. For modded pickups, this is the same as its 'name' xml attribute.
 */
export function getPickupIDName(pickupID: PickupID): string | undefined {
  const modded = isPickupIDModded(pickupID);
  if (!modded) {
    return getNonModdedPickupName(pickupID);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(pickupID as EntityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

/**
 * Retrieves a random PickupID from the pool of available PickupIDs from the game set.
 *
 * @param modded Whether to get a modded or non-modded PickupID. If undefined, will get a random
 *               PickupID from either. If there are no modded PickupIDs with this set to true, this
 *               will return undefined.
 * @param seedOrRNG The seed or RNG to use for randomization. If undefined, will use undefined.
 */
export function getRandomPickupID(
  modded: boolean | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): PickupID | undefined {
  if (modded === undefined) {
    const pickupIDSet = getEntityIDSetFromCategory<PickupID>(
      EntityCategory.PICKUP,
    );
    return getRandomSetElement(pickupIDSet, seedOrRNG);
  }

  if (modded) {
    const pickupIDSet = getModdedEntityIDSetFromCategory<PickupID>(
      EntityCategory.PICKUP,
    );
    if (pickupIDSet.size === 0) {
      fprint("No modded PickupIDs found!");
      return undefined;
    }
    return getRandomSetElement(pickupIDSet, seedOrRNG);
  }

  const pickupIDSet = getNonModdedEntityIDSetFromCategory<PickupID>(
    EntityCategory.PICKUP,
  );

  return getRandomSetElement(pickupIDSet, seedOrRNG);
}

/**
 * Retrieves a random PickupID that corresponds to the specified PickupType using the game PickupID
 * sets. If no PickupID is found, this will return undefined.
 *
 * @param pickupType The PickupType to get a random PickupID from.
 * @param seedOrRNG The seed or RNG to use for randomization.
 * @param modded Whether to get a modded or non-modded PickupID. If undefined, will get a random
 *               PickupID from either.
 */
export function getRandomPickupIDFromPickupType(
  pickupType: PickupType,
  seedOrRNG: Seed | RNG = getRandomSeed(),
  modded: boolean | undefined = undefined,
): PickupID | undefined {
  let pickupIDSet: ReadonlySet<PickupID> | undefined;
  if (modded === undefined) {
    pickupIDSet = getPickupIDSetOfPickupType(pickupType);
  } else if (modded) {
    pickupIDSet = getModdedPickupIDSetOfPickupType(pickupType);
  } else {
    pickupIDSet = getNonModdedPickupIDSetOfPickupType(pickupType);
  }

  if (pickupIDSet.size === 0) {
    fprint(
      `No PickupIDs found for PickupType ${PickupType[pickupType]}${
        modded === undefined ? "" : ` and modded = ${modded ? "true" : "false"}`
      }`,
    );
    return undefined;
  }

  return getRandomSetElement(pickupIDSet, seedOrRNG);
}

/**
 * Spawn an Pickup by using their PickupID. If the specified PickupID does not refer to a Pickup,
 * this will throw an error.
 */
export function spawnPickupID(
  pickupID: PickupID,
  positionOrGridIndex: Vector | int,
  velocity?: Vector,
  spawner?: Entity | undefined,
  seedOrRNG?: Seed | RNG | undefined,
): EntityPickup {
  const constituents = getConstituentsFromEntityID(pickupID as EntityID);
  if (constituents[0] !== EntityType.PICKUP) {
    error(`spawnPickupID: EntityID ${pickupID} is not a PickupID`);
  }

  return spawnPickup(
    constituents[1],
    constituents[2],
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Retrieves the PickupID that will spawn a random pickup of the specified type. If the specified
 * PickupType does not have a corresponding random PickupID, this will generate a random specific
 * PickupID of that type.
 */
export function getSoftRandomPickupIDFromPickupType(
  pickupType: PickupType,
  seedOrRNG: Seed | RNG | undefined = undefined,
): PickupID {
  switch (pickupType) {
    case PickupType.HEART: {
      return `${EntityType.PICKUP}.${PickupVariant.HEART}.0` as PickupID;
    }

    case PickupType.COIN: {
      return `${EntityType.PICKUP}.${PickupVariant.COIN}.0` as PickupID;
    }

    case PickupType.KEY: {
      return `${EntityType.PICKUP}.${PickupVariant.KEY}.0` as PickupID;
    }

    case PickupType.BOMB: {
      return `${EntityType.PICKUP}.${PickupVariant.BOMB}.0` as PickupID;
    }

    case PickupType.POOP: {
      return `${EntityType.PICKUP}.${PickupVariant.POOP}.0` as PickupID;
    }

    // This will spawn a random chest.
    case PickupType.CHEST: {
      return `${EntityType.PICKUP}.${PickupVariant.CHEST}.0` as PickupID;
    }

    case PickupType.SACK: {
      return `${EntityType.PICKUP}.${PickupVariant.SACK}.0` as PickupID;
    }

    case PickupType.PILL: {
      return `${EntityType.PICKUP}.${PickupVariant.PILL}.0` as PickupID;
    }

    case PickupType.BATTERY: {
      return `${EntityType.PICKUP}.${PickupVariant.LIL_BATTERY}.0` as PickupID;
    }

    case PickupType.COLLECTIBLE: {
      return `${EntityType.PICKUP}.${PickupVariant.COLLECTIBLE}.0` as PickupID;
    }

    case PickupType.TRINKET: {
      return `${EntityType.PICKUP}.${PickupVariant.TRINKET}.0` as PickupID;
    }

    case PickupType.SHOP_ITEM: {
      return `${EntityType.PICKUP}.${PickupVariant.SHOP_ITEM}.0` as PickupID;
    }

    // Can spawn runes and souls.
    case PickupType.CARD: {
      return `${EntityType.PICKUP}.${PickupVariant.CARD}.0` as PickupID;
    }

    case PickupType.SOUL: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_SOUL_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }

    case PickupType.RUNE: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_RUNE_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }

    case PickupType.MISCELLANEOUS: {
      return getRandomFromWeightedArray(
        RANDOM_SOFT_NON_MODDED_MISCELLANEOUS_PICKUP_ID_SPREAD,
        seedOrRNG,
      );
    }
  }
}

export function getPickupTypeFromPickupID(pickupID: PickupID): PickupType {
  const constituents = getConstituentsFromEntityID(pickupID as EntityID);
  if (constituents[0] !== EntityType.PICKUP) {
    error(`EntityID ${pickupID} is not a PickupID`);
  }

  switch (constituents[1]) {
    case PickupVariant.HEART: {
      return PickupType.HEART;
    }

    case PickupVariant.COIN: {
      return PickupType.COIN;
    }

    case PickupVariant.KEY: {
      return PickupType.KEY;
    }

    case PickupVariant.BOMB: {
      return PickupType.BOMB;
    }

    case PickupVariant.THROWABLE_BOMB: {
      return PickupType.BOMB;
    }

    case PickupVariant.POOP: {
      return PickupType.POOP;
    }

    case PickupVariant.CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.SACK: {
      return PickupType.SACK;
    }

    case PickupVariant.PILL: {
      return PickupType.PILL;
    }

    case PickupVariant.BOMB_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.LOCKED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.ETERNAL_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.HAUNTED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.RED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.MIMIC_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.MEGA_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.BIG_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.SPIKED_CHEST: {
      return PickupType.CHEST;
    }

    case PickupVariant.LIL_BATTERY: {
      return PickupType.BATTERY;
    }

    case PickupVariant.COLLECTIBLE: {
      return PickupType.COLLECTIBLE;
    }

    case PickupVariant.TRINKET: {
      return PickupType.TRINKET;
    }

    case PickupVariant.SHOP_ITEM: {
      return PickupType.SHOP_ITEM;
    }

    case PickupVariant.CARD: {
      const cardName = getPickupIDName(pickupID);
      if (cardName === undefined) {
        return PickupType.CARD;
      }

      // If the card name has 'Soul of' in it, it's a soul stone.
      if (cardName.toLowerCase().includes(SOUL_PREFIX.toLowerCase())) {
        return PickupType.SOUL;
      }

      if (isRune(constituents[2] as CardType)) {
        return PickupType.RUNE;
      }

      return PickupType.CARD;
    }

    default: {
      // Check if name contains 'Chest'.
      const pickupName = getPickupIDName(pickupID);
      if (
        pickupName !== undefined &&
        pickupName.toLowerCase().includes("chest")
      ) {
        return PickupType.CHEST;
      }
      return PickupType.MISCELLANEOUS;
    }
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\pickupIndexHelper.ts`:

```````ts
import type { PickupIndex } from "isaacscript-common";
import { getPickups } from "isaacscript-common";
import { mod } from "../../mod";

/**
 * Finds a pickup in the room which has the specified PickupIndex. If it can't find one, returns
 * undefined.
 */
export function getPickupWithPickupIndex(
  pickupIndex: PickupIndex,
): EntityPickup | undefined {
  for (const pickup of getPickups()) {
    if (mod["getPickupIndex"](pickup) === pickupIndex) {
      return pickup;
    }
  }

  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\slotHelper.ts`:

```````ts
import { getConstituentsFromEntityID, getSlotName } from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { getNonModdedEntityIDSetFromCategory } from "../../features/data/gameSets/gameEntitySets";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";

/**
 * Determines if a EntityID that refers to a slot is modded by checking it against the set of all
 * non-modded slots.
 */
export function isSlotIDModded(entityID: EntityID): boolean {
  const nonModdedSlotSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.SLOT,
  );
  return !nonModdedSlotSet.has(entityID);
}

/**
 * Get the name of a Slot from its EntityID. If it is modded, and the mod is not tracked, this will
 * return undefined. For modded slots, this is the same as its 'name' xml attribute.
 */
export function getSlotIDName(entityID: EntityID): string | undefined {
  const modded = isSlotIDModded(entityID);
  if (!modded) {
    const constituents = getConstituentsFromEntityID(entityID);
    const variant = constituents[1];
    return getSlotName(variant);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(entityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\tearHelper.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { getConstituentsFromEntityID, getSlotName } from "isaacscript-common";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { getNonModdedEntityIDSetFromCategory } from "../../features/data/gameSets/gameEntitySets";
import { getNameSubTypeFromModdedEntityID } from "../../maps/data/moddedEntityIDToNameSubType";
import { getModdedEntityNameAndSubTypeFromNameSubType } from "./entityIDHelper";
import { tearVariantToString } from "../../maps/data/name/tearVariantNameMap";

/**
 * Determines if a EntityID that refers to a tear is modded by checking it against the set of all
 * non-modded tears.
 */
export function isTearIDModded(entityID: EntityID): boolean {
  const nonModdedSlotSet = getNonModdedEntityIDSetFromCategory(
    EntityCategory.TEAR,
  );
  return !nonModdedSlotSet.has(entityID);
}

/**
 * Get the name of a Tear from its EntityID. If it is modded, and the mod is not tracked, this will
 * return undefined. For modded tears, this is the same as its 'name' xml attribute.
 *
 * @example EntityID.TEAR_BLOOD -> "Blood"
 */
export function getTearIDName(entityID: EntityID): string | undefined {
  const modded = isTearIDModded(entityID);
  if (!modded) {
    const constituents = getConstituentsFromEntityID(entityID);
    const variant = constituents[1];
    return tearVariantToString(variant);
  }

  const nameSubType = getNameSubTypeFromModdedEntityID(entityID);
  if (nameSubType === undefined) {
    return undefined;
  }

  return getModdedEntityNameAndSubTypeFromNameSubType(nameSubType).name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper\trinketHelper.ts`:

```````ts
import type { TrinketType } from "isaac-typescript-definitions";
import {
  getModdedPickupIDSetOfPickupType,
  getNonModdedPickupIDSetOfPickupType,
  getPickupIDSetOfPickupType,
} from "../../features/data/gameSets/gameEntitySets";
import { PickupType } from "../../enums/general/PickupType";
import type { EntityID } from "isaacscript-common";
import {
  anyPlayerHasTrinket,
  getConstituentsFromEntityID,
  getPlayerTrinkets,
  getRandomSetElement,
  log,
} from "isaacscript-common";
import type { PickupID } from "../../enums/data/ID/PickupID";
import { fprint } from "../printHelper";

/**
 * Gets a random TrinketType from the game set of all TrinketTypes.
 *
 * @param modded Whether to get a modded TrinketType (true), a non-modded TrinketType (false), or
 *               either (undefined). Defaults to undefined.
 * @param seedOrRNG The seed or RNG to use for randomness. Defaults to a random undefined.
 *
 * @returns A random TrinketType from the game set of all TrinketTypes, or undefined if there are no
 *          TrinketTypes in the game set (e.g if there are no mods and modded is true).
 */
export function getRandomTrinket(
  modded: boolean | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): TrinketType | undefined {
  let trinkets: ReadonlySet<PickupID> | undefined;
  if (modded === undefined) {
    trinkets = getPickupIDSetOfPickupType(PickupType.TRINKET);
  } else if (modded) {
    trinkets = getModdedPickupIDSetOfPickupType(PickupType.TRINKET);
  } else {
    trinkets = getNonModdedPickupIDSetOfPickupType(PickupType.TRINKET);
  }

  if (trinkets.size === 0) {
    fprint(`getRandomTrinket: No trinkets found for modded value ${modded}.`);
    return undefined;
  }

  const trinketEntityID = getRandomSetElement(trinkets, seedOrRNG);
  const constituents = getConstituentsFromEntityID(trinketEntityID as EntityID);
  return constituents[2];
}

/** Returns true if the player is holding any trinkets. Does not count gulped trinkets. */
export function isPlayerHoldingTrinkets(player: EntityPlayer): boolean {
  return getPlayerTrinkets(player).length > 0;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityHelper.ts`:

```````ts
import type { PickupVariant, EntityType } from "isaac-typescript-definitions";
import { EntityFlag } from "isaac-typescript-definitions";
import {
  getBombs,
  getEffects,
  getEntities,
  getFamiliars,
  getKnives,
  getLasers,
  getNPCs,
  getPickups,
  getPlayers,
  getProjectiles,
  getRandom,
  getRandomVector,
  getSlots,
  getTears,
  isSlot,
  spawn,
  spawnPickup,
} from "isaacscript-common";
import { mod } from "../mod";
import { EntityCategory } from "../enums/general/EntityCategory";
import { isLeavingGame } from "../features/general/isLeavingGame";

/** Retrieves the distance between two known entities. */
export function getDistanceBetweenEntities(
  entity1: Entity,
  entity2: Entity,
): number {
  return entity1.Position.Distance(entity2.Position);
}

/**
 * Get a random position within a circle.
 *
 * @param centerPos The center of the circle.
 * @param radius The radius of the circle.
 * @param excludeRadius Will add an area to the radius where the chosen position can not be. This
 *                      area originates from the origin point and increases the radius of the
 *                      circle.
 */
export function getRandomPositionInRadius(
  centerPos: Vector,
  radius: number,
  excludeRadius = 0,
): Vector {
  const displacement = getRandomVector(undefined)
    .Normalized()
    .mul(getRandom(undefined) * radius + excludeRadius);
  return centerPos.add(displacement);
}

/**
 * Spawn a pickup by spawning it in a radius around a position and 'throwing' it at the position.
 */
export function spawnPickupThrowToPos(
  variant: PickupVariant,
  subType: number,
  pos: Vector,
  radius = 100,
  speed = 4,
): EntityPickup {
  const spawnPos = getRandomVector(undefined).Normalized().mul(radius).add(pos);
  const displacement = pos.sub(spawnPos);
  const distance = spawnPos.Distance(pos);
  const time = distance / speed;
  const velocity = displacement.div(time);
  return spawnPickup(variant, subType, spawnPos, velocity);
}

/**
 * Spawn a pickup by spawning it in a radius around an entity and 'throwing' it at the entity,
 * taking into account the entities own velocity.
 */
export function spawnPickupThrowToEntity(
  variant: PickupVariant,
  subType: number,
  entity: Entity,
  radius = 100,
  speed = 4,
): EntityPickup {
  const pos = entity.Position;
  const spawnPos = getRandomVector(undefined).Normalized().mul(radius).add(pos);
  const displacement = pos.sub(spawnPos);
  const distance = spawnPos.Distance(pos);
  const time = distance / speed;
  const velocity = displacement.div(time).add(entity.Velocity);
  return spawnPickup(variant, subType, spawnPos, velocity);
}

/**
 * Spawn a pickup by 'throwing' it from a position. Note: Some pickups such as chests behave
 * differently to being thrown.
 */
export function spawnPickupThrowFromPos(
  variant: PickupVariant,
  subType: number,
  centerPos: Vector,
  maxSpeed = 15,
  minSpeed = 2,
): EntityPickup {
  const throwVector = getRandomVector(undefined)
    .Normalized()
    .mul(getRandom(undefined) * (maxSpeed - minSpeed) + minSpeed);
  const pickup = spawnPickup(variant, subType, centerPos, throwVector);
  return pickup;
}

/**
 * Spawn a pickup by 'throwing' it from a position. Note: Some pickups such as chests behave
 * differently to being thrown.
 */
export function spawnPickupThrowFromEntity(
  variant: PickupVariant,
  subType: number,
  entity: Entity,
  maxSpeed = 15,
  minSpeed = 2,
): EntityPickup {
  const centerPos = entity.Position;
  const throwVector = getRandomVector(undefined)
    .Normalized()
    .mul(getRandom(undefined) * (maxSpeed - minSpeed) + minSpeed);
  const pickup = spawnPickup(
    variant,
    subType,
    centerPos,
    throwVector.add(entity.Velocity),
  );
  return pickup;
}

/**
 * Spawns an Entity which is invisible. Note: This will not mute sounds, make it friendly or make it
 * be invisible upon exiting / entering game / room.
 */
export function spawnInvisibleEntity(
  entityType: EntityType,
  variant: number,
  subType: number,
  position: Vector,
  velocity?: Vector | undefined,
  spawner?: Entity | undefined,
): Entity {
  const entity = spawn(
    entityType,
    variant,
    subType,
    position,
    velocity,
    spawner,
  );
  entity.ClearEntityFlags(EntityFlag.APPEAR);
  entity.Visible = false;
  mod.runInNGameFrames(() => {
    entity.Visible = false;
  }, 5);
  return entity;
}

/**
 * Makes an entity invisible. Note that this will not mute sounds or make them friendly / invisible
 * upon exiting / entering game / room.
 */
export function makeEntityInvisible(entity: Entity): Entity {
  entity.ClearEntityFlags(EntityFlag.APPEAR);
  entity.Visible = false;
  return entity;
}

/** Return an Entity to visible after makeEntityInvisible(). */
export function makeEntityVisible(entity: Entity): Entity {
  entity.Visible = true;
  return entity;
}

/**
 * Retrieves the closest pickup to a reference position. If there are no pickups in the room,
 * returns undefined.
 */
export function getClosestPickupTo(
  referencePosition: Vector,
): EntityPickup | undefined {
  let closestPickup: undefined | EntityPickup;
  let closestDistance = 10_000;
  const pickupsInRoom = getPickups();
  // eslint-disable-next-line unicorn/no-array-for-each
  pickupsInRoom.forEach((pickup: EntityPickup) => {
    const pickupDistance = pickup.Position.Distance(referencePosition);
    if (pickupDistance < closestDistance) {
      closestPickup = pickup;
      closestDistance = pickupDistance;
    }
  });
  return closestPickup;
}

/**
 * Determine which EntityCategory a non-Grid Entity belongs to using the Entity class. Note: you
 * probably want to use 'getEntityCategoryFromEntityID' instead, as it should be faster.
 *
 * @returns EntityCategory or undefined (as the entity can somehow be undefined).
 */
export function getEntityCategory(entity: Entity): EntityCategory | undefined {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (entity === undefined) {
    return undefined;
  }

  if (isSlot(entity)) {
    return EntityCategory.SLOT;
  }

  if (entity.ToBomb() !== undefined) {
    return EntityCategory.BOMB;
  }

  if (entity.ToKnife() !== undefined) {
    return EntityCategory.KNIFE;
  }

  if (entity.ToLaser() !== undefined) {
    return EntityCategory.LASER;
  }

  if (entity.ToNPC() !== undefined) {
    return EntityCategory.NPC;
  }

  if (entity.ToProjectile() !== undefined) {
    return EntityCategory.PROJECTILE;
  }

  if (entity.ToPlayer() !== undefined) {
    return EntityCategory.PLAYER;
  }

  if (entity.ToEffect() !== undefined) {
    return EntityCategory.EFFECT;
  }

  if (entity.ToTear() !== undefined) {
    return EntityCategory.TEAR;
  }

  if (entity.ToPickup() !== undefined) {
    return EntityCategory.PICKUP;
  }

  if (entity.ToFamiliar() !== undefined) {
    return EntityCategory.FAMILIAR;
  }

  return undefined;
}

/**
 * Returns an array of all entities in the room that match the specified EntityCategory. If there
 * are no entities in the room, returns an empty array.
 *
 * @param category The EntityCategory to search for.
 * @param ignoreFriendly If true, will ignore friendly NPCs if the EntityCategory is
 *                       EntityCategory.NPC. Defaults to false.
 */
export function getAllEntitiesWithCategory(
  category: EntityCategory,
  ignoreFriendly?: boolean,
): readonly Entity[] {
  switch (category) {
    case EntityCategory.BOMB: {
      return getBombs();
    }

    case EntityCategory.EFFECT: {
      return getEffects();
    }

    case EntityCategory.FAMILIAR: {
      return getFamiliars();
    }

    case EntityCategory.KNIFE: {
      return getKnives();
    }

    case EntityCategory.LASER: {
      return getLasers();
    }

    case EntityCategory.NPC: {
      return getNPCs(undefined, undefined, undefined, ignoreFriendly);
    }

    case EntityCategory.PLAYER: {
      return getPlayers();
    }

    case EntityCategory.PICKUP: {
      return getPickups();
    }

    case EntityCategory.PROJECTILE: {
      return getProjectiles();
    }

    case EntityCategory.SLOT: {
      return getSlots();
    }

    case EntityCategory.TEAR: {
      return getTears();
    }

    default: {
      return [];
    }
  }
}

/** Find the first entity in the room that matches the initSeed. Warning: Slow. */
export function getEntityFromInitSeed(initSeed: Seed): Entity | undefined {
  return getEntities().find((entity) => entity.InitSeed === initSeed);
}

/**
 * Returns true if the entity is persistent and is being (or about to be) unloaded due to
 * PRE_GAME_EXIT. This is useful as persistent NPCs will return upon continue, so for features which
 * use 'NPCIndex', these NPCs shouldn't be unsubscribed from the feature.
 */
export function isPersistentEntityBeingUnloadedDueToGameExit(
  entity: Entity,
): boolean {
  return entity.HasEntityFlags(EntityFlag.PERSISTENT) && isLeavingGame();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\entityTypeHelper.ts`:

```````ts
import { EntityType } from "isaac-typescript-definitions";
import { FIRST_NPC_ENTITY_TYPE } from "../constants/npcConstants";

/** Does not work with modded Entities. */
export function isNPC(entityType: EntityType): boolean {
  return (
    entityType > FIRST_NPC_ENTITY_TYPE && entityType < EntityType.GENERIC_PROP
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\floorHelper.ts`:

```````ts
import { EffectVariant, SortingLayer } from "isaac-typescript-definitions";
import { VectorOne, VectorZero, spawnEffect } from "isaacscript-common";
import { CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE } from "../constants/corruptionConstants";
import {
  FILL_SPRITE_TO_SCREEN_VECTOR_SCALE,
  WHITE_CLEAR_SPRITE_PNG_PATH,
} from "../constants/spriteConstants";
import type { AdvancedColor } from "../interfaces/general/AdvancedColor";
import { simplifyAndCopyColor, simplifyColor } from "./advancedColorHelper";

/**
 * Spawns a ladder with its sorting layer set to 'Background'. This is used to render things on the
 * floor.
 */
export function spawnFloorEntity(position: Vector = VectorOne): EntityEffect {
  const floorEntity = spawnEffect(EffectVariant.LADDER, 0, position);
  floorEntity.SortingLayer = SortingLayer.BACKGROUND;
  return floorEntity;
}

/**
 * Will copy the provided Sprite to a floor Sprite. This floor sprite will belong to a 'ladder'
 * entity which lasts the duration of the room. Does not copy a Sprite's replaced spritesheets, you
 * will have to do that yourself with the returned Sprite object. The floor sprite will exist until
 * the player leaves the room or the game.
 *
 * @param sprite The Sprite to copy. If a string PNG is provided, will just replace the ladders
 *               spritesheet with that PNG. If undefined, will create an empty Sprite.
 * @param position World position you want to render at.
 * @returns An object containing the floor sprite and entity.
 */
export function copySpriteToFloor(
  sprite: Sprite | string | undefined = undefined,
  position: Vector = VectorZero,
): {
  sprite: Sprite;
  entity: EntityEffect;
} {
  /** The floor entity which we will replace our sprite with. */
  const floorEntity = spawnFloorEntity(position);
  const floorSprite = floorEntity.GetSprite();

  if (typeof sprite === "string") {
    floorSprite.ReplaceSpritesheet(0, sprite);
    floorSprite.LoadGraphics();
  } else if (sprite !== undefined) {
    floorSprite.Color = sprite.Color;
    floorSprite.FlipX = sprite.FlipX;
    floorSprite.FlipY = sprite.FlipY;
    floorSprite.Scale = sprite.Scale;
    floorSprite.Rotation = sprite.Rotation;
    floorSprite.Load(sprite.GetFilename(), false);
    floorSprite.Play(sprite.GetAnimation(), true);
    floorSprite.SetFrame(sprite.GetFrame());
    floorSprite.LoadGraphics();
  }

  return { sprite: floorSprite, entity: floorEntity };
}

/**
 * Sets the floor color, by rendering a white sprite on the floor layer. This is better than the
 * setFloorColor() function from the Room class as it actually does something. The floor color will
 * be reset upon exiting the room or the game. Use 'setFloorColor()' to permanently change the floor
 * color. Note: Will only deep copy the color if override transparency is set to true.
 *
 * @param color The color to set the floor to, can be an AdvancedColor or Color.
 * @param overrideTransparencyAndDeepCopy If true, will override the transparency of the color to
 *                                 make it barely visible with the default value.
 * @returns The floor EntityEffect used to color the floor. Disappears upon leaving the room or the
 *          game.
 */
export function setTemporaryFloorColor(
  color: Color | AdvancedColor,
  overrideTransparencyAndDeepCopy = true,
): EntityEffect {
  /**
   * We use a white sprite then color it using its .Color variable. We also need to size it up to
   * fill the screen.
   */
  const spriteAndEntity = copySpriteToFloor(
    WHITE_CLEAR_SPRITE_PNG_PATH,
    VectorZero,
  );
  const { sprite } = spriteAndEntity;
  const { entity } = spriteAndEntity;

  /** Make the color barely visible. */
  if (overrideTransparencyAndDeepCopy) {
    color = simplifyAndCopyColor(color);
    color.A = CORRUPTED_BACKDROP_COLOR_TRANSPARENCY_VALUE;
  } else {
    color = simplifyColor(color);
  }
  sprite.Color = color;
  sprite.Scale = FILL_SPRITE_TO_SCREEN_VECTOR_SCALE;
  return entity;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\gameHelper.ts`:

```````ts
import { game, GAME_FRAMES_PER_SECOND } from "isaacscript-common";
import { mod } from "../mod";

/**
 * Returns true if the pause menu is open, ISC 'pause' feature is enabled, ModConfigMenu or
 * DeadSeaScrollsMenu is open.
 */
export function isGamePaused(): boolean {
  return (
    game.IsPaused() ||
    mod.isPaused() ||
    (ModConfigMenu !== undefined && ModConfigMenu.IsVisible)
  );
}

/**
 * Fires a function every game frame, or every X game frames (specified by 'frameDelay'), until the
 * provided function returns true.
 */
export function fireFunctionConstantly(
  func: () => boolean,
  frameDelay = 1,
): void {
  mod.runInNGameFrames(() => {
    const shouldStop = func();
    if (!shouldStop) {
      fireFunctionConstantly(func, frameDelay);
    }
  }, frameDelay);
}

/** Converts seconds to game frames. */
export function secondsToGameFrames(seconds: number): int {
  return seconds * GAME_FRAMES_PER_SECOND;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\gridEntityHelper\gridEntityHelper.ts`:

```````ts
import { game, getAllGridIndexes, getGridEntityID } from "isaacscript-common";
import { GridID } from "../../enums/data/ID/GridID";
import { GridEntityType } from "isaac-typescript-definitions";

/**
 * Returns a random GridIndex in the room that:
 *
 * a) would not block the player from accessing all doors in the room b) would not spawn on top of a
 * player
 *
 * If no such GridIndex exists, returns undefined.
 */
export function getSafeRandomGridIndex(
  seedOrRandom: Seed | RNG | undefined = undefined,
): int | undefined {
  const gridIndices = getAllGridIndexes();
  if (gridIndices.length === 0) {
    error(
      "getSafeRandomGridIndex: Failed to get a random GridIndex since the room has no GridIndices.",
    );
  }

  return undefined;
}

/**
 * Returns an array of Grid Indices from the current room that do not have a grid entity on them.
 */
export function getAllEmptyGridIndexes(): readonly int[] {
  const gridIndices = getAllGridIndexes();
  if (gridIndices.length === 0) {
    return [];
  }

  // Filter out grid indices that have a grid entity.
  const filteredGridIndices = gridIndices.filter((gridIndex) => {
    const gridEntity = game.GetRoom().GetGridEntity(gridIndex);
    return gridEntity === undefined;
  });

  return filteredGridIndices;
}

/**
 * Returns an array of Grid Indices from the current room that do not have any of the provided grid
 * entity types on them. If GridEntityType.NULL is provided, will filter out grid indices that have
 * no grid entity.
 */
export function getAllGridIndexesWithExceptions(
  ...exceptions: readonly GridEntityType[]
): readonly int[] {
  const gridIndices = getAllGridIndexes();
  if (gridIndices.length === 0) {
    return [];
  }

  // Filter out grid indices that match the exceptions.
  const filteredGridIndices = gridIndices.filter((gridIndex) => {
    const gridEntity = game.GetRoom().GetGridEntity(gridIndex);
    if (gridEntity === undefined) {
      return !exceptions.includes(GridEntityType.NULL);
    }

    const gridEntityType = gridEntity.GetType();
    return !exceptions.includes(gridEntityType);
  });

  return filteredGridIndices;
}

/**
 * Returns the grid index located at Position. Clamps to the nearest grid index if Position is out
 * of bounds.
 */
export function positionToClampedGridIndex(position: Vector): int {
  return game.GetRoom().GetClampedGridIndex(position);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\gridEntityHelper\gridIDHelper.ts`:

```````ts
import type { GridEntityID } from "isaacscript-common";
import {
  getConstituentsFromGridEntityID,
  getGridEntities,
  getMatchingGridEntities,
  getRandomEnumValue,
  spawnGridEntityWithVariant,
} from "isaacscript-common";
import { GridID } from "../../enums/data/ID/GridID";
import { PoopGridEntityVariant } from "isaac-typescript-definitions";

/**
 * Spawns a Grid Entity using its GridID.
 *
 * @param gridID The GridID of the Grid Entity to spawn.
 * @param gridIndexOrPosition The Grid Index or Position to spawn the Grid Entity at.
 * @param removeExistingGridEntity Optional. Whether to remove the existing grid entity on the same
 *                                 tile, if it exists. Defaults to true. If false, this function
 *                                 will do nothing, since spawning a grid entity on top of another
 *                                 grid entity will not replace it.
 * @returns The spawned Grid Entity.
 */
export function spawnGridID(
  gridID: GridID,
  gridIndexOrPosition: int | Vector,
  removeExistingGridEntity?: boolean | undefined,
): GridEntity | undefined {
  const [type, variant] = gridID.split(".");
  return spawnGridEntityWithVariant(
    Number(type),
    Number(variant),
    gridIndexOrPosition,
    removeExistingGridEntity,
  );
}

/** Returns a random GridID from the GridID Enum. */
export function getRandomGridID(
  seedOrRNG: Seed | RNG | undefined = undefined,
): GridID {
  return getRandomEnumValue(GridID, seedOrRNG);
}

/**
 * Helper function to get all of the grid entities in the room that specifically match the GridID
 * (or GridEntityID) provided. If the variant is '-1', will return all grid entities of that
 * GridEntityType. If the GridEntityType is '-1', will return all grid entities.
 *
 * @example getGridEntitiesFromGridID(GridID.ROCK) --> All rocks in the room.
 * @example getGridEntitiesFromGridID("-1.-1") --> All grid entities in the room.
 */
export function getGridEntitiesFromGridID(
  gridID: GridID,
): readonly GridEntity[] {
  const [gridEntityType, variant] = getConstituentsFromGridEntityID(
    gridID as GridEntityID,
  );
  if ((gridEntityType as number) === -1) {
    return getGridEntities();
  }

  if (variant === -1) {
    return getGridEntities(gridEntityType);
  }

  return getMatchingGridEntities(gridEntityType, variant);
}

/** Determine if a variable is an GridEntityID (e.g '11.0'). */
export function isGridEntityID(variable: unknown): variable is GridEntityID {
  if (typeof variable !== "string") {
    return false;
  }
  const constituents = variable.split(".");
  if (constituents.length !== 2) {
    return false;
  }
  const [type, variant] = constituents;
  return (
    type !== undefined &&
    variant !== undefined &&
    !Number.isNaN(Number(type)) &&
    !Number.isNaN(Number(variant))
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\HUDHelper.ts`:

```````ts
import { ActiveSlot, PocketItemSlot } from "isaac-typescript-definitions";
import {
  VectorOne,
  getHUDOffsetVector,
  getPlayerIndexVanilla,
  getScreenBottomLeftPos,
  getScreenBottomRightPos,
  getScreenTopRightPos,
} from "isaacscript-common";
import {
  POCKET_SLOT_1_HUD_RENDER_POSITION_PLAYER_1,
  POCKET_SLOT_2_HUD_RENDER_POSITION_PLAYER_1,
  POCKET_SLOT_3_HUD_RENDER_POSITION_PLAYER_1,
  POCKET_SLOT_4_HUD_RENDER_POSITION_PLAYER_1,
  PRIMARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1,
  PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1,
  PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2,
  SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_1,
  SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1,
  SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1,
  SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2,
} from "../constants/renderConstants";
import { HUDQuadrant } from "../enums/general/HUDQuandrant";

/**
 * When going from windowed to full-screen, the right quadrants of the HUD are shifted by an Offset
 * This offset needs to be subtracted from the final Vector.
 */
export function getFullScreenOffset(): Vector {
  return Options.Fullscreen ? Vector(-20, -2) : Vector(20, -2);
}

/** The HUD Offset Vector that needs to be added for rendering in the bottom left HUD quadrant. */
export function getBottomRightHUDOffsetVector(): Vector {
  return Vector(Options.HUDOffset * -16, Options.HUDOffset * -6);
}

/** The HUD Offset Vector that needs to be added for rendering in the top right HUD quadrant. */
export function getTopRightHUDOffsetVector(): Vector {
  return Vector(Options.HUDOffset * -22, Options.HUDOffset * 16);
}

/** The HUD Offset Vector that needs to be added for rendering in the bottom left HUD quadrant. */
export function getBottomLeftOffsetVector(): Vector {
  return Vector(Options.HUDOffset * 22, Options.HUDOffset * -16);
}

/**
 * Rendering on the HUD requires multiple transformations to account for:
 * - The HUD offset, a setting that can be changed by the user. This is different for each quadrant.
 * - The HUD quadrant, each quadrant shifts in a different direction when the HUD offset changes.
 * - The full-screen setting, which shifts the right quadrants of the HUD by an offset.
 *
 * @param position The position to render at.
 * @param hudQuadrant The HUD quadrant to render in. Defaults to top left. Note that you can still
 *                    render anywhere on the screen regardless of the quadrant, but it's recommended
 *                    to render in the quadrant this parameter specifies.
 */
export function HUDPositionToRenderPosition(
  position: Vector,
  hudQuadrant: HUDQuadrant = HUDQuadrant.TOP_LEFT,
): Vector {
  let newPosition = VectorOne;
  if (hudQuadrant === HUDQuadrant.TOP_LEFT) {
    newPosition = getHUDOffsetVector().add(position);
  } else if (hudQuadrant === HUDQuadrant.TOP_RIGHT) {
    newPosition = getScreenTopRightPos()
      .add(getTopRightHUDOffsetVector())
      .add(Vector(-position.X, position.Y));
  } else if (hudQuadrant === HUDQuadrant.BOTTOM_LEFT) {
    newPosition = getScreenBottomLeftPos()
      .add(getBottomLeftOffsetVector())
      .add(Vector(position.X, -position.Y));
  } else {
    newPosition = getScreenBottomRightPos()
      .add(getBottomRightHUDOffsetVector())
      .add(position.mul(-1));
  }
  return newPosition;
}

/**
 * Get the size of the collectible render when rendering on the HUD. This is different per player
 * and ActiveSlot.
 */
export function getActiveRenderSize(
  activeSlot: ActiveSlot.PRIMARY | ActiveSlot.SECONDARY,
  player: EntityPlayer,
): Vector {
  const index = getPlayerIndexVanilla(player);
  if (index === 0) {
    switch (activeSlot) {
      case ActiveSlot.PRIMARY:
        return VectorOne;
      case ActiveSlot.SECONDARY:
        return SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_1;
      default:
        error(`Invalid active slot: ${activeSlot}, if you want to render in the pocket slot use
      getPocketActiveRenderSize() instead.`);
    }
  } else {
    switch (activeSlot) {
      case ActiveSlot.PRIMARY:
        return PRIMARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1;
      case ActiveSlot.SECONDARY:
        return SECONDARY_ACTIVE_SLOT_COLLECTIBLE_SPRITE_SCALE_PLAYER_NOT_1;
      default:
        error(`Invalid active slot: ${activeSlot}, if you want to render in the pocket slot use
      getPocketActiveRenderSize() instead.`);
    }
  }
}

/**
 * Get the render position to render a collectible sprite in ActiveSlot 1 or ActiveSlot 2, unique to
 * each player. TODO: Update for players.
 */
export function getActiveRenderPosition(
  activeSlot: ActiveSlot.PRIMARY | ActiveSlot.SECONDARY,
  player: EntityPlayer,
): Vector {
  const index = getPlayerIndexVanilla(player);
  if (index === 0) {
    switch (activeSlot) {
      case ActiveSlot.PRIMARY:
        return HUDPositionToRenderPosition(
          PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1,
        );
      case ActiveSlot.SECONDARY:
        return HUDPositionToRenderPosition(
          SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1,
        );
      default:
        error(`Invalid active slot: ${activeSlot}, if you want to render in the pocket slot use
      getPocketActiveRenderPosition() instead.`);
    }
  } else if (index === 1) {
    switch (activeSlot) {
      case ActiveSlot.PRIMARY:
        return HUDPositionToRenderPosition(
          PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2,
          HUDQuadrant.TOP_RIGHT,
        );
      case ActiveSlot.SECONDARY:
        return HUDPositionToRenderPosition(
          SECONDARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_2,
          HUDQuadrant.TOP_RIGHT,
        );
      default:
        error(`Invalid active slot: ${activeSlot}, if you want to render in the pocket slot use
      getPocketActiveRenderPosition() instead.`);
    }
  } else {
    error(`Invalid player index: ${index}`);
  }
}

/**
 * Get the render position for collectible sprites in the various pocket slots. Note: Some may
 * require changing the scale of the sprite. TODO: Update for players.
 */
export function getPocketActiveRenderPosition(
  pocketSlot: PocketItemSlot,
  player: EntityPlayer,
): Vector {
  switch (pocketSlot) {
    case PocketItemSlot.SLOT_1:
      return HUDPositionToRenderPosition(
        POCKET_SLOT_1_HUD_RENDER_POSITION_PLAYER_1,
        HUDQuadrant.BOTTOM_RIGHT,
      );
    case PocketItemSlot.SLOT_2:
      return HUDPositionToRenderPosition(
        POCKET_SLOT_2_HUD_RENDER_POSITION_PLAYER_1,
        HUDQuadrant.BOTTOM_RIGHT,
      );
    case PocketItemSlot.SLOT_3:
      return HUDPositionToRenderPosition(
        POCKET_SLOT_3_HUD_RENDER_POSITION_PLAYER_1,
        HUDQuadrant.BOTTOM_RIGHT,
      );
    case PocketItemSlot.SLOT_4:
      return HUDPositionToRenderPosition(
        POCKET_SLOT_4_HUD_RENDER_POSITION_PLAYER_1,
        HUDQuadrant.BOTTOM_RIGHT,
      );
    default:
      error(`Invalid pocket slot: ${pocketSlot}`);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\inputHelper.ts`:

```````ts
/** Functions to help assist player input. */

import { ActiveSlot, ButtonAction } from "isaac-typescript-definitions";

/** This will get the ButtonAction that would have been pressed for the item in the specified activeSlot to fire. */
export function activeSlotToButtonAction(activeSlot: ActiveSlot): ButtonAction {
  if (activeSlot === ActiveSlot.PRIMARY) {
    return ButtonAction.ITEM;
  } else if (activeSlot === ActiveSlot.POCKET) {
    return ButtonAction.PILL_CARD;
  }
  error("Invalid active slot: " + activeSlot);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\inventoryHelper.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { mod } from "../mod";
import {
  removePlayerInvertedActive,
  removePlayerMostRecentInvertedPassive,
} from "./deletedSpecific/inventory/invertedInventoryHelper";

/** Check if the players' inventory is empty (i.e they have no items). */
export function isPlayerInventoryEmpty(player: EntityPlayer): boolean {
  return mod.getPlayerCollectibleTypes(player).length === 0;
}

/** Get the most recent addition to the player inventory (i.e the last item they obtained). */
export function getLatestItemInPlayerInventory(
  player: EntityPlayer,
): CollectibleType | undefined {
  const inventory = mod.getPlayerCollectibleTypes(player);

  const latestItemInInventory = inventory.at(-1);
  if (latestItemInInventory === undefined) {
    return;
  }

  return latestItemInInventory;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\mapHelper.ts`:

```````ts
/**
 * Returns true if at least one element in this map satisfies the provided testing function.
 *
 * @param map The map to test.
 * @param predicate find calls predicate once for each element of the map, in insertion order, until
 *                  it finds one where predicate returns true. If such an element is found, find
 *                  immediately returns true. Otherwise, find returns false.
 * @returns true if the callback function returns a truthy value for at least one element in the
 *          map. Otherwise, false.
 */
export function someMap(
  map: Map<unknown, unknown>,
  predicate: (
    value: unknown,
    key: unknown,
    map: Map<unknown, unknown>,
  ) => boolean,
): boolean {
  for (const [key, value] of map) {
    if (predicate(value, key, map)) {
      return true;
    }
  }
  return false;
}

/**
 * Returns the value of the first element in the map where predicate is true, and undefined
 * otherwise.
 *
 * @param map The map to test.
 * @param predicate find calls predicate once for each element of the map, in insertion order, until
 *                  it finds one where predicate returns true. If such an element is found, find
 *                  immediately returns that element value. Otherwise, find returns undefined.
 * @returns The value of the first element in the map that satisfies the provided testing function.
 *          Otherwise, undefined is returned.
 */
export function findMap<T>(
  map: Map<unknown, unknown>,
  predicate: (
    value: unknown,
    key: unknown,
    map: Map<unknown, unknown>,
  ) => boolean,
): T | undefined {
  for (const [key, value] of map) {
    if (predicate(value, key, map)) {
      return value as T;
    }
  }
  return undefined;
}

/** Returns a random map value. */
export function getRandomMapElement<T>(map: Map<unknown, unknown>): T {
  const index = Math.floor(Math.random() * map.size);
  return [...map.values()][index] as T;
}

/**
 * Returns a random element from the map that satisfies the provided testing function.
 *
 * @param map The map to get a random element from.
 * @param predicate The predicate to test the elements against.
 * @returns A random element from the map that satisfies the provided testing function.
 */
export function getRandomMapElementWithPredicate<T>(
  map: Map<unknown, unknown>,
  predicate: (
    value: unknown,
    key: unknown,
    map: Map<unknown, unknown>,
  ) => boolean,
): T {
  const filteredMap = new Map<unknown, unknown>();
  for (const [key, value] of map) {
    if (predicate(value, key, map)) {
      filteredMap.set(key, value);
    }
  }
  return getRandomMapElement(filteredMap);
}

/** Convert a map to string. */
export function mapToString(map: Map<unknown, unknown>): string {
  return [...map.entries()]
    .map(([key, value]) => `${key} => ${value}`)
    .join(", ");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\numbers\numberHelper.ts`:

```````ts
import { getRandomInt } from "isaacscript-common";
import { getRandomInteger } from "../randomHelper";

/** Returns a random rotation as an integer from 0 to 360. */
export function getRandomRotation(seedOrRNG?: Seed | RNG | undefined): number {
  return getRandomInteger(0, 360, seedOrRNG);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\numbers\numberToWords.ts`:

```````ts
const TEN = 10;
const ONE_HUNDRED = 100;
const ONE_THOUSAND = 1000;
const ONE_MILLION = 1000000;
const ONE_BILLION = 1000000000; //         1.000.000.000 (9)
const ONE_TRILLION = 1000000000000; //     1.000.000.000.000 (12)
const ONE_QUADRILLION = 1000000000000000; // 1.000.000.000.000.000 (15)
const MAX = 9007199254740992; // 9.007.199.254.740.992 (15)

const LESS_THAN_TWENTY = [
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen",
];

const TENTHS_LESS_THAN_HUNDRED = [
  "zero",
  "ten",
  "twenty",
  "thirty",
  "forty",
  "fifty",
  "sixty",
  "seventy",
  "eighty",
  "ninety",
];

const MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Converts an integer into words. If number is decimal, the decimals will be removed.
 *
 * @example toWords(12) => "twelve"
 * @param number
 * @returns
 */
export function numberToWords(num: number): string {
  if (!(Math.abs(num) <= MAX_SAFE_INTEGER)) {
    throw new RangeError(
      "Input is not a safe number, it’s either too large or too small.",
    );
  }

  return generateWords(num);
}

function generateWords(number: number, words: string[] = []): string {
  let remainder = 0;
  let word = "";

  // We’re done
  if (number === 0) {
    return words.length === 0 ? "zero" : words.join(" ");
  }

  // If negative, prepend “minus”.
  if (number < 0) {
    words.push("minus");
    number = Math.abs(number);
  }

  if (number < 20) {
    remainder = 0;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    word = LESS_THAN_TWENTY[number]!;
  } else if (number < ONE_HUNDRED) {
    remainder = number % TEN;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    word = TENTHS_LESS_THAN_HUNDRED[Math.floor(number / TEN)]!;
    // In case of remainder, we need to handle it here to be able to add the “-”.
    if (remainder !== 0) {
      word += `-${LESS_THAN_TWENTY[remainder]}`;
      remainder = 0;
    }
  } else if (number < ONE_THOUSAND) {
    remainder = number % ONE_HUNDRED;
    word = `${generateWords(Math.floor(number / ONE_HUNDRED))} hundred and`;
  } else if (number < ONE_MILLION) {
    remainder = number % ONE_THOUSAND;
    word = `${generateWords(Math.floor(number / ONE_THOUSAND))} thousand,`;
  } else if (number < ONE_BILLION) {
    remainder = number % ONE_MILLION;
    word = `${generateWords(Math.floor(number / ONE_MILLION))} million,`;
  } else if (number < ONE_TRILLION) {
    remainder = number % ONE_BILLION;
    word = `${generateWords(Math.floor(number / ONE_BILLION))} billion,`;
  } else if (number < ONE_QUADRILLION) {
    remainder = number % ONE_TRILLION;
    word = `${generateWords(Math.floor(number / ONE_TRILLION))} trillion,`;
  } else if (number <= MAX) {
    remainder = number % ONE_QUADRILLION;
    word = `${generateWords(
      Math.floor(number / ONE_QUADRILLION),
    )} quadrillion,`;
  }

  words.push(word);
  return generateWords(remainder, words);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\objectHelper.ts`:

```````ts
import { getRandomArrayIndex } from "isaacscript-common";

/** Does the Object contain a certain value. */
export function objectContainsValue<T>(
  object: Record<string, T>,
  value: T,
): boolean {
  return Object.values(object).includes(value);
}

/** Returns an array of keys in an object, as type 'keyof <Object>'. */
export function getObjectKeys<T extends Record<string, unknown>>(
  obj: T,
): Array<keyof T> {
  return Object.keys(obj) as Array<keyof typeof obj>;
}

/** Returns an array of values in an Object. */
export function getObjectValues<T>(obj: Record<string, T>): T[] {
  const keys = getObjectKeys(obj);
  return keys.map((key) => obj[key]) as T[];
}

/**
 * Gets the object key as a string from its value. Only works if the values are unique, otherwise
 * returns the first match.
 */
export function getObjectKeyByValue<T>(
  obj: Record<string, T>,
  value: T,
): string | undefined {
  return Object.keys(obj).find((key) => obj[key] === value);
}

/**
 * Get a random string key from an Object.
 *
 * @param obj The object to get a random key from.
 * @param seedOrRNG The seed or RNG to use for the random number generator.
 * @returns A random string key from the object.
 *
 * If the object is empty, an error is thrown.
 */
export function getRandomObjectKey<T>(
  obj: Record<string, T>,
  seedOrRNG: Seed | RNG | undefined = undefined,
): string {
  const keys = Object.keys(obj);
  if (keys.length === 0) {
    error(
      "Failed to get a random object key since the provided object is empty.",
    );
  }
  const randomIndex = getRandomArrayIndex(keys, seedOrRNG);
  const randomKey = keys[randomIndex];
  if (randomKey === undefined) {
    error(
      `Failed to get a random object key since the random index of ${randomIndex} was not valid.`,
    );
  }
  return randomKey;
}

/** Converts an object to a key:value printable string, taking into account objects in objects. */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
export function objectToString<T>(obj: any): string {
  if (typeof obj !== "object") {
    error(
      `ObjectHelper.objectToString() was passed a non-object, it was passed a ${typeof obj}`,
    );
  }
  const keys = Object.keys(obj as Record<string, T>);
  const values = Object.values(obj as Record<string, T>);
  let output = "";
  for (const [i, key] of keys.entries()) {
    const value = values[i];
    output +=
      typeof value === "object"
        ? `${key}: { ${objectToString(value)} }, `
        : `${key}: ${values[i]}, `;
  }
  return output;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\patternHelper.ts`:

```````ts
export function patternToPlainString(pattern: string): string {
  return string.gsub(pattern, "[%^%$%(%)%%%.%[%]%*%+%-%?]", "%%%1")[0];
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\pickupHelper.ts`:

```````ts
import { ChestSubType, CollectibleType } from "isaac-typescript-definitions";
import type { EntityID } from "isaacscript-common";
import {
  isChest,
  isCollectible,
  spawnEntityID,
  spawnPickup,
} from "isaacscript-common";
import type { PickupID } from "../enums/data/ID/PickupID";

/**
 * If the Pickup is in the process of being collected by playing its 'Collect' animation. Note, not
 * all pickups may play this when collected.
 */
export function isPickupBeingCollected(pickup: EntityPickup): boolean {
  return pickup.GetSprite().IsPlaying("Collect");
}

/** Checks if a Pickup is in a 'opened', 'collected' form, e.g empty pedestals and opened chests. */
export function isUselessPickup(pickup: EntityPickup): boolean {
  if (isChest(pickup) && pickup.SubType === (ChestSubType.OPENED as number)) {
    return true;
  }

  if (isCollectible(pickup) && pickup.SubType === CollectibleType.NULL) {
    return true;
  }

  return false;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\playerHelper.ts`:

```````ts
import type { UseFlag } from "isaac-typescript-definitions";
import {
  ActiveSlot,
  CardType,
  PillColor,
  PocketItemSlot,
  CollectibleType,
} from "isaac-typescript-definitions";
import {
  arrayToBitFlags,
  getEnumValues,
  getPlayerBlackHearts,
  getPlayerSoulHearts,
} from "isaacscript-common";
import { USE_ACTIVE_ITEM_RESPONSE_BITFLAG_ARRAY } from "../constants/corruptionConstants";

/** Sets the players' bomb count to a specific amount. */
export function setPlayerBombs(player: EntityPlayer, amount: number): void {
  player.AddBombs(amount - player.GetNumBombs());
}

/** Sets the players' key count to a specific amount. */
export function setPlayerKeys(player: EntityPlayer, amount: number): void {
  player.AddKeys(amount - player.GetNumKeys());
}

/** Sets the players' coin count to a specific amount. */
export function setPlayerCoins(player: EntityPlayer, amount: number): void {
  player.AddCoins(amount - player.GetNumBombs());
}

/**
 * Sets heart containers the player has to a specific amount. These heart containers will be empty.
 * One unit is half a heart container.
 */
export function setPlayerHeartContainers(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddMaxHearts(amount - player.GetMaxHearts(), true);
}

/** Sets the amount of red hearts the player has. One unit equals half a red heart. */
export function setPlayerRedHearts(player: EntityPlayer, amount: number): void {
  player.AddHearts(amount - player.GetHearts());
}

/** Sets the amount of rotten hearts the player has. One unit equals half a red heart. */
export function setPlayerRottenHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddRottenHearts(amount - player.GetRottenHearts());
}

/** Sets the amount of soul hearts the player has. One unit equals half a soul heart. */
export function setPlayerSoulHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddSoulHearts(amount - getPlayerSoulHearts(player));
}

/** Sets the amount of black hearts the player has. One unit equals half a black heart. */
export function setPlayerBlackHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddBlackHearts(amount - getPlayerBlackHearts(player));
}

/**
 * Sets the amount of bone hearts the player has. One unit equals one bone heart. They will be
 * empty.
 */
export function setPlayerBoneHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddBoneHearts(amount - player.GetBoneHearts());
}

/** Sets the amount of broken hearts the player has. One unit equals one broken heart. */
export function setPlayerBrokenHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddBrokenHearts(amount - player.GetBrokenHearts());
}

/** Sets the amount of golden hearts the player has. One unit equals one golden heart. */
export function setPlayerGoldenHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddGoldenHearts(amount - player.GetGoldenHearts());
}

/** Sets the amount of eternal hearts the player has. One unit equals one eternal heart. */
export function setPlayerEternalHearts(
  player: EntityPlayer,
  amount: number,
): void {
  player.AddEternalHearts(amount - player.GetEternalHearts());
}

/** Replace player "001.000_player.anm2" file. */
export function replacePlayerAnm2(
  player: EntityPlayer,
  anm2Path: string,
): void {
  const sprite = player.GetSprite();
  sprite.Load(anm2Path, true);
}

/** Quickly teleports a player to a location and uses the active item, then teleports them back. */
export function useActiveItemAtPosition(
  activeItem: CollectibleType,
  roomPos: Vector,
  player?: EntityPlayer,
): void {
  player ??= Isaac.GetPlayer();
  const currentPos = player.Position;
  player.Position = roomPos;
  player.UseActiveItem(
    activeItem,
    arrayToBitFlags<UseFlag>(USE_ACTIVE_ITEM_RESPONSE_BITFLAG_ARRAY),
  );
  player.Position = currentPos;
}

/** Checks if the player is currently playing an animation. Can provide more than one. */
export function isPlayerPlayingAnimation(
  player: EntityPlayer,
  ...animation: string[]
): boolean {
  const sprite = player.GetSprite();
  const playerAnimation = sprite.GetAnimation();
  if (animation.includes(playerAnimation)) {
    return true;
  }

  return false;
}

/**
 * Get the players' total health in half hearts. This counts all types of hearts the player has,
 * including broken hearts.
 *
 * @example If the player has 2 red hearts, 1 soul heart, and 1 black heart, this will return 8.
 */
export function getPlayerTotalHealth(player: EntityPlayer): number {
  return (
    player.GetEffectiveMaxHearts() +
    player.GetSoulHearts() +
    player.GetBrokenHearts() * 2
  );
}

/**
 * Returns true if the player is holding a pill in any slot.
 *
 * @param player The player to check.
 * @param pillColor If set, will only return true if the player is holding a pill of this color.
 */
export function isPlayerHoldingPill(
  player: EntityPlayer,
  pillColor: PillColor = PillColor.NULL,
): boolean {
  return getEnumValues(PocketItemSlot).some((slot) => {
    const pill = player.GetPill(slot);
    return (
      pill !== PillColor.NULL &&
      (pillColor === PillColor.NULL || pill === pillColor)
    );
  });
}

/**
 * Returns true if the player is holding a card in any slot.
 *
 * @param player The player to check.
 * @param cardType If set, will only return true if the player is holding a card of this type.
 */
export function isPlayerHoldingCard(
  player: EntityPlayer,
  cardType: CardType = CardType.NULL,
): boolean {
  return getEnumValues(PocketItemSlot).some((slot) => {
    const card = player.GetCard(slot);
    return (
      card !== CardType.NULL &&
      (cardType === CardType.NULL || card === cardType)
    );
  });
}

/** Returns true if the player has any active item in any slot (including the pocket slot). */
export function doesPlayerHaveAnyActiveItem(player: EntityPlayer): boolean {
  return getEnumValues(ActiveSlot).some(
    (slot) => player.GetActiveItem(slot) !== CollectibleType.NULL,
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\positionHelper.ts`:

```````ts
import { EntityType } from "isaac-typescript-definitions";
import {
  game,
  DISTANCE_OF_GRID_TILE,
  getPlayers,
  spawnNPC,
} from "isaacscript-common";

const RANDOM_POSITION_AVOID_PLAYER_DISTANCE = DISTANCE_OF_GRID_TILE * 2;

/** Gets a random position in the room. */
export function getRandomPosition(): Vector {
  return game.GetRoom().GetRandomPosition(DISTANCE_OF_GRID_TILE);
}

/**
 * Find a random position in the room that has direct access to 'accessorPos'. Poop is ignored and
 * acts as if nothing is there. Does not overlap with any players.
 *
 * @accessorPos The position you want to check it connects to.
 * @maxIterations The amount of iterations until it gives up (default 100).
 * @checkOverlapWithPlayers Whether to check if the position overlaps with any players (default
 *                          true).
 */
export function getRandomAccessiblePosition(
  accessorPos: Vector,
  maxIterations = 100,
  checkOverlapWithPlayers = true,
): Vector | undefined {
  let freePosition = Vector(0, 0);
  let i = 0;
  const playerPositions = getPlayers().map((player) => player.Position);
  while (i < maxIterations) {
    freePosition = game.GetRoom().GetRandomPosition(DISTANCE_OF_GRID_TILE);
    const doesOverlapPlayer = checkOverlapWithPlayers
      ? playerPositions.some(
          (playerPosition) =>
            playerPosition.Distance(freePosition) <
            RANDOM_POSITION_AVOID_PLAYER_DISTANCE,
        )
      : false;
    if (!doesOverlapPlayer && isPositionAccessible(freePosition, accessorPos)) {
      break;
    }
    i++;
  }
  return freePosition;
}

/**
 * Checks if a position is accessible to another position.
 *
 * @testPos The position you're checking for.
 * @accessorPos The position you want to check it connects to.
 * @ignorePoop Whether to ignore poops (default true).
 */
export function isPositionAccessible(
  testPos: Vector,
  accessorPos: Vector,
  ignorePoop = true,
): boolean {
  const npc = spawnNPC(EntityType.FLY, 0, 0, testPos);
  npc.Visible = false;
  const pathfinder = npc.Pathfinder;
  const hasPath = pathfinder.HasPathToPos(accessorPos, ignorePoop);
  npc.Remove();
  return hasPath;
}

/**
 * Get a random position in the room that has direct access to the first player. Poop is ignored and
 * acts as if nothing is there. Does not overlap with any players. If there are no possible
 * positions, returns Vector(0, 0).
 */
export function getQuickAccessiblePosition(): Vector {
  return (
    getRandomAccessiblePosition(Isaac.GetPlayer().Position) ?? Vector(0, 0)
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\priceHelper.ts`:

```````ts
import { PickupPrice } from "isaac-typescript-definitions";

/** Returns true if a collectible has no price, otherwise false (i.e Devil Deals and Shop Items). */
export function isCollectibleFree(
  collectible: EntityPickupCollectible,
): boolean {
  return (
    collectible.Price === (PickupPrice.FREE as number) ||
    collectible.Price === (PickupPrice.NULL as number)
  );
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\printHelper.ts`:

```````ts
import { log, logTable } from "isaacscript-common";
import { objectToString } from "./objectHelper";

export function fprint(arg: unknown): void {
  print(arg);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\randomHelper.ts`:

```````ts
import { getRandomInt } from "isaacscript-common";

export function randomDistribution(
  mean: number,
  standardDeviation: number,
  minValue: number,
  maxValue: number,
  ignorePercent: number,
): number {
  const ignoreProb = ignorePercent / 100;
  if (Math.random() < ignoreProb) {
    return Math.random() * (maxValue - minValue) + minValue;
  }
  let num: number;
  do {
    num =
      Math.random() * 2 - 1 + (Math.random() * 2 - 1) + (Math.random() * 2 - 1);
    num = num * standardDeviation + mean;
  } while (num < minValue || num > maxValue);
  return num;
}

export function randomLogDistribution(
  minValue: number,
  maxValue: number,
  skewness: number,
): number {
  const range = maxValue - minValue;
  const rand = Math.random();
  const logValue = skewness ** rand - 1;
  const value = (logValue / (skewness - 1)) * range + minValue;
  return Math.max(minValue, Math.min(maxValue, value));
}

/** Wrapper for getRandomInteger() to default seedOrRNG to undefined. */
export function getRandomInteger(
  min: int,
  max: int,
  seedOrRNG: Seed | RNG | undefined = undefined,
  exceptions?: int[] | readonly int[],
): int {
  return getRandomInt(min, max, seedOrRNG, exceptions);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\renderHelper.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ActiveSlot, PocketItemSlot } from "isaac-typescript-definitions";
import { game, getActivePocketItemSlot } from "isaacscript-common";
import { POCKET_SLOT_UNFOCUSSED_COLLECTIBLE_SPRITE_SCALE_PLAYER_1 } from "../constants/renderConstants";
import { getCollectibleSpriteFromCache } from "../features/general/spriteCache";
import { mod } from "../mod";
import {
  getActiveRenderPosition,
  getActiveRenderSize,
  getPocketActiveRenderPosition,
} from "./HUDHelper";

/** Continuously fires a function every render frame. */
export function renderConstantly(func: () => void): void {
  mod.runInNRenderFrames(() => {
    func();
    renderConstantly(func);
  }, 1);
}

/** Translates world to render coordinates, taking into account scroll offset. */
export function worldToRenderPosition(position: Vector): Vector {
  return Isaac.WorldToRenderPosition(position).add(
    game.GetRoom().GetRenderScrollOffset(),
  );
}

export function renderToWorldPosition(position: Vector): Vector {
  return Isaac.ScreenToWorld(position);
}

/**
 * Renders a collectible in a slot. If the slot is a Pocket slot, the collectible will be rendered
 * in the correct position depending on where the Pocket slot is.
 *
 * @param player The player to render the collectible for.
 * @param collectibleType The collectible to render.
 * @param slot The slot to render the collectible in.
 * @param topLeftClamp The top left clamp for the sprite.
 * @param bottomRightClamp The bottom right clamp for the sprite.
 * @param flipX Whether to flip the sprite on the X axis.
 */
export function renderCollectibleInSlot(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  slot: ActiveSlot,
  topLeftClamp?: Vector,
  bottomRightClamp?: Vector,
  flipX?: boolean,
): void {
  // Get the sprite from the cache.
  const collectibleSprite = getCollectibleSpriteFromCache(collectibleType);

  // Flip the sprite if necessary.
  if (flipX !== undefined) {
    collectibleSprite.FlipX = flipX;
  }

  // Get the position to render the sprite at. This is different for Pocket slots, as they can be in
  // different positions.
  let position: Vector | undefined;
  if (slot === ActiveSlot.POCKET) {
    const pocketSlot = getActivePocketItemSlot(player);
    if (pocketSlot === undefined) {
      return;
    }
    position = getPocketActiveRenderPosition(pocketSlot, player);

    // Scale the sprite if it is not in the first PocketItemSlot.
    if (pocketSlot !== PocketItemSlot.SLOT_1) {
      collectibleSprite.Scale =
        POCKET_SLOT_UNFOCUSSED_COLLECTIBLE_SPRITE_SCALE_PLAYER_1;
    }
  } else if (slot === ActiveSlot.POCKET_SINGLE_USE) {
    // Unimplemented.
  } else {
    position = getActiveRenderPosition(slot, player);

    // Scale.
    collectibleSprite.Scale = getActiveRenderSize(slot, player);
  }

  if (position === undefined) {
    return;
  }

  // Render the sprite.
  collectibleSprite.Render(position, topLeftClamp, bottomRightClamp);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\rngHelper.ts`:

```````ts
import { nextSeed } from "isaacscript-common";

/** Helper function to iterate the seed by X amount. */
export function nextSeeds(seed: Seed, amount: number): Seed {
  for (let i = 0; i < amount; i++) {
    seed = nextSeed(seed);
  }
  return seed;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\roomHelper.ts`:

```````ts
import {
  CollectibleType,
  EntityFlag,
  UseFlag,
} from "isaac-typescript-definitions";
import {
  game,
  getNPCs,
  getRoomAdjacentGridIndexes,
  getRoomListIndex,
  openAllDoors,
} from "isaacscript-common";

/** Check if a specific room is adjacent to the room the player is currently in. */
export function isRoomAdjacent(roomListIndex: number): boolean {
  const adjacentRoomGridIndexes = [...getRoomAdjacentGridIndexes().values()];
  const adjacentRoomListIndexes = adjacentRoomGridIndexes.map((gridIndex) =>
    getRoomListIndex(gridIndex),
  );

  return adjacentRoomListIndexes.includes(roomListIndex);
}

/** Floods a room with water similar to the 'flush' effect, without removing enemies. */
export function floodRoom(): void {
  const npcs = getNPCs().filter(
    (npc) => !npc.HasEntityFlags(EntityFlag.FRIENDLY),
  );
  for (const npc of npcs) {
    npc.AddEntityFlags(EntityFlag.FRIENDLY);
  }
  Isaac.GetPlayer().UseActiveItem(CollectibleType.FLUSH, UseFlag.NO_ANIMATION);
  for (const npc of npcs) {
    npc.ClearEntityFlags(EntityFlag.FRIENDLY);
  }
}

/**
 * If a room is not cleared, this will set the room to clear, spawn the clear reward and activate
 * any on-clear items, as well as opening all doors. This will not kill any NPCs still alive.
 */
export function clearRoom(): void {
  const room = game.GetRoom();
  if (room.IsClear()) {
    return;
  }

  room.SetClear(true);
  room.TriggerClear();
  openAllDoors();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\setHelper.ts`:

```````ts
/**
 * Returns the value of the first element in the set where predicate is true, and undefined
 * otherwise.
 *
 * @param set The set to test.
 * @param predicate find calls predicate once for each element of the set, in insertion order, until
 *                  it finds one where predicate returns true. If such an element is found, find
 *                  immediately returns that element value. Otherwise, find returns undefined.
 * @returns The value of the first element in the set that satisfies the provided testing function.
 *          Otherwise, undefined is returned.
 */
export function findSet<T>(
  set: Set<T>,
  predicate: (value: T) => boolean,
): T | undefined {
  for (const value of set) {
    if (predicate(value)) {
      return value;
    }
  }
  return undefined;
}

/**
 * Returns a random element from the set that satisfies the provided testing function.
 *
 * @param set The set to get a random element from.
 * @param predicate The predicate to test the elements against.
 * @returns A random element from the set that satisfies the provided testing function.
 */
export function getRandomSetElementWithPredicate<T>(
  set: Set<T>,
  predicate: (value: T) => boolean,
): T {
  const filteredSet = new Set<T>();
  for (const value of set) {
    if (predicate(value)) {
      filteredSet.add(value);
    }
  }
  return getRandomSetElement(filteredSet);
}

/**
 * Returns a random element from the set.
 *
 * @param set The set to get a random element from.
 * @returns A random element from the set.
 */
export function getRandomSetElement<T>(set: Set<T>): T {
  const index = Math.floor(Math.random() * set.size);
  let i = 0;
  for (const value of set) {
    if (i === index) {
      return value;
    }
    i++;
  }
  error("Set is empty.");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\soundHelper.ts`:

```````ts
import { SoundEffect } from "isaac-typescript-definitions";
import { getRandomEnumValue, sfxManager } from "isaacscript-common";
import { PICKUP_SOUNDS } from "../constants/soundConstants";
import type { SoundEffectOptions } from "../interfaces/general/SoundEffectOptions";

/**
 * Stops the sounds that run after picking up any sort of item. You may need to run this in the next
 * game frame instead of the callback you are in.
 */
export function stopPickupSounds(): void {
  for (const sound of PICKUP_SOUNDS) {
    sfxManager.Stop(sound as SoundEffect);
  }
}

export function getRandomSoundEffect(): SoundEffect {
  return getRandomEnumValue(SoundEffect, undefined);
}

/** Play a sound effect using a SoundEffectOptions object. */
export function playSoundEffectWithOptions(
  soundEffectOptions: SoundEffectOptions,
): void {
  const { soundEffect, volume, pitch, frameDelay, loop, pan } =
    soundEffectOptions;
  sfxManager.Play(soundEffect, volume, frameDelay, loop, pitch, pan);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\spriteHelper.ts`:

```````ts
import type { EntityType, NPCID } from "isaac-typescript-definitions";
import type { EntityID } from "isaacscript-common";
import { VectorZero, copyColor, spawnEntityID } from "isaacscript-common";
import { renderToWorldPosition, worldToRenderPosition } from "./renderHelper";

/**
 * Copies a sprite into a new fresh sprite.
 *
 * @param oldSprite The sprite to copy.
 * @param play If false, will not play the animation the oldSprite is playing (default false).
 * @param copyData If true, will copy attributes from the old sprite such as Color, Scale, Frame,
 *                 etc (default true).
 */
export function copySprite(
  oldSprite: Sprite,
  play = false,
  copyData = true,
): Sprite {
  const nSprite = Sprite();
  nSprite.Load(oldSprite.GetFilename(), true);
  if (play) {
    nSprite.Play(oldSprite.GetAnimation(), true);
  }
  if (!copyData) {
    nSprite.Color = oldSprite.Color;
    nSprite.FlipX = oldSprite.FlipX;
    nSprite.FlipY = oldSprite.FlipY;
    nSprite.Scale = oldSprite.Scale;
    nSprite.Rotation = oldSprite.Rotation;
    nSprite.SetFrame(oldSprite.GetFrame());
  }
  return nSprite;
}

/** Generates a Sprite from the provided NPC. Does not play an animation. */
export function newNPCSprite(npc: NPCID): Sprite {
  const spawnedNPC = spawnEntityID(npc as EntityID, Vector(0, 0));
  spawnedNPC.Visible = false;
  const copiedSprite = copySprite(spawnedNPC.GetSprite());
  spawnedNPC.Remove();
  return copiedSprite;
}

/** Generates a Sprite from the provided EntityType. Does not play an animation. */
export function newEntitySprite(
  entityType: EntityType,
  entityVariant?: number,
  entitySubType?: number,
): Sprite {
  const spawnedEntity = Isaac.Spawn(
    entityType,
    entityVariant ?? 0,
    entitySubType ?? 0,
    Vector(0, 0),
    Vector(0, 0),
    undefined,
  );
  spawnedEntity.Visible = false;
  const copiedSprite = copySprite(spawnedEntity.GetSprite());
  spawnedEntity.Remove();
  return copiedSprite;
}

/** Generates a Sprite from the provided sprite filename. Does not play an animation. */
export function newSprite(filename: string): Sprite {
  const sprite = Sprite();
  sprite.Load(filename, true);
  return sprite;
}

/** Invert a sprites color. */
export function invertSpriteColors(sprite: Sprite): Sprite {
  const oldColor = sprite.Color;
  const newColor = copyColor(oldColor);
  newColor.SetColorize(1, 1, 1, 2);
  sprite.Color = newColor;
  return sprite;
}

/**
 * Create a Collectible Sprite set to 'PlayerPickupSparkle' with the correct playback speed. Needs
 * to be updated every render frame.
 */
export function newSparkleSprite(): Sprite {
  const sparkleSprite = newSprite("gfx/005.100_collectible.anm2");
  sparkleSprite.PlaybackSpeed = 0.5;
  sparkleSprite.Play("PlayerPickupSparkle", true);
  return sparkleSprite;
}

/**
 * Use this instead of the sprite.Render function if you want to clamp the sprite, while it is
 * flipped in the X and Y axis. Doing this with sprite.Render() will move the sprite in the opposite
 * direction.
 */
export function renderSprite(
  sprite: Sprite,
  position: Vector,
  topLeftClamp: Vector,
  bottomRightClamp: Vector,
): void {
  if (!sprite.FlipX && !sprite.FlipY) {
    sprite.Render(position, topLeftClamp, bottomRightClamp);
  } else if (sprite.FlipX && !sprite.FlipY) {
    sprite.Render(
      position.add(Vector(topLeftClamp.X - bottomRightClamp.X, 0)),
      bottomRightClamp,
      topLeftClamp,
    );
  } else if (!sprite.FlipX && sprite.FlipY) {
    sprite.Render(
      position.add(Vector(0, topLeftClamp.Y - bottomRightClamp.Y)),
      bottomRightClamp,
      topLeftClamp,
    );
  } else {
    sprite.Render(
      position.add(
        Vector(
          topLeftClamp.X - bottomRightClamp.X,
          topLeftClamp.Y - bottomRightClamp.Y,
        ),
      ),
      bottomRightClamp,
      topLeftClamp,
    );
  }
}

export function getPixelColorMap(sprite: Sprite): Map<Vector, KColor> {
  const xMaxIterations = 600;
  const yMaxIterations = 600;
  const pixelColorMap = new Map<Vector, KColor>();
  for (let x = 0; x < xMaxIterations; x++) {
    for (let y = 0; y < yMaxIterations; y++) {
      const pixelKColor = sprite.GetTexel(
        Vector(x, y),
        renderToWorldPosition(Vector(300, 100)),
        1,
        1,
      );
      const position = worldToRenderPosition(Vector(x, y));
      if (pixelKColor.Alpha === 0) {
        continue;
      }
      pixelColorMap.set(position, pixelKColor);
    }
  }
  return pixelColorMap;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\statHelper.ts`:

```````ts
import { CacheFlag } from "isaac-typescript-definitions";

/** Triggers a cache update for the specified cache flag and player. */
export function triggerCacheUpdate(
  player: EntityPlayer,
  cacheFlag: CacheFlag,
): void {
  player.AddCacheFlags(cacheFlag);
  player.EvaluateItems();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\stringHelper.ts`:

```````ts
import { capitalizeFirstLetter, getRandomInt } from "isaacscript-common";
import { patternToPlainString } from "./patternHelper";
import { getRandomInteger } from "./randomHelper";

const articles = new Set(["a", "an", "the"]);
const vowels = new Set(["a", "e", "i", "o", "u"]);

/**
 * Removes unnecessary spaces, capitalizes first letter.
 * TODO: fix: "thing ," <-- space before comma.
 */
export function legibleString(s: string): string {
  return capitalizeFirstLetter(removeUnnecessaryWhiteSpace(s));
}

/** Remove unnecessary spaces from the whole string. */
export function removeUnnecessaryWhiteSpace(s: string): string {
  return string.gsub(s.trim(), "%s+", " ")[0];
}

/** Returns number of occurrences of String or Character in string. */
export function getNumberOfStringInString(s: string, pattern: string): number {
  return string.gsub(s, patternToPlainString(pattern), "")[1];
}

/** Does the string start with a digit (0-9). */
export function stringStartsWithDigit(s: string): boolean {
  return string.find(s, "^%d")[0] !== undefined;
}

/**
 * If n is not 1, will add an 's' to the string.
 *
 * @param s The string to add an 's' to.
 * @param n The number to check. If it's a boolean, will add an 's' if true.
 * @param careAboutEnding If true, will only add an 's' if the string doesn't end with an 's'. If
 *                        the string ends with an 's', it will add 'es' instead. If the string ends
 *                        with a 'y', will add 'ies' instead. Default true.
 * @returns The string with an 's' added if necessary.
 */
export function addTheS(
  s: string,
  n: number | boolean,
  careAboutEnding = true,
): string {
  if (type(n) === "boolean") {
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    n = n ? 2 : 1;
  }
  if (n !== 1) {
    if (careAboutEnding) {
      const lastLetter = string.sub(s, -1);
      if (lastLetter === "s") {
        return `${s}es`;
      }
      if (lastLetter === "y") {
        return `${string.sub(s, 1, -2)}ies`;
      }
    }
    return `${s}s`;
  }
  return s;
}

export function getRandomPrefix(s: string): string {
  const len = s.length;
  let num = 1;
  num =
    len < 3
      ? string.find(s, "[.]", getRandomInteger(1, len, undefined))[1]
      : string.find(s, "[AEIOUaeiou]", getRandomInteger(2, len, undefined))[1];
  const prefix = string.sub(s, 1, num);
  return prefix;
}

export function getRandomSuffix(s: string): string {
  const len = s.length;
  let num = 1;
  num =
    len < 3
      ? string.find(s, "[.]", getRandomInteger(1, len - 1, undefined))[1]
      : string.find(
          s,
          "[^AEIOUaeiou]",
          getRandomInteger(1, len - 1, undefined),
        )[1];
  const suffix = string.sub(s, num, len);
  return suffix;
}

/**
 * Returns a string joining all elements in the array, where the last element is joined with the
 * specified string, and the rest are joined with commas.
 *
 * @param s The string to join the last element with.
 * @param arr The array to join.
 * @returns The joined string.
 *
 * @example joinWith("and", ["a", "b", "c"]) // "a, b and c".
 */
export function joinWith(s: string, arr: string[]): string {
  const len = arr.length;
  if (len === 0) {
    return "";
  }
  if (len === 1) {
    return arr[0] ?? "";
  }
  const last = arr[len - 1];
  const rest = arr.slice(0, len - 1).join(s);
  return `${rest} ${s} ${last}`;
}

/**
 * Returns a string joining all elements in the array, where the last two elements are joined with
 * "or", and the rest are joined with commas.
 */
export function joinWithOr(arr: string[]): string {
  const len = arr.length;
  if (len === 0) {
    return "";
  }
  if (len === 1) {
    return arr[0] ?? "";
  }
  if (len === 2) {
    return `${arr[0]} or ${arr[1]}`;
  }
  const lastTwo = `${arr[len - 2]} or ${arr[len - 1]}`;
  const rest = arr.slice(0, len - 2).join(", ");
  return `${rest}, ${lastTwo}`;
}

/** Split a string into multiple sub-strings of equal (or near equal) length. */
export function splitString(s: string, segments: number): readonly string[] {
  const len = s.length;
  const segmentLength = math.floor(len / segments);
  const arr: string[] = [];
  for (let i = 0; i < segments; i++) {
    const start = i * segmentLength + 1;
    const end = (i + 1) * segmentLength;
    const segment = string.sub(s, start, end);
    arr.push(segment);
  }
  return arr;
}

/**
 * Adds 'a' or 'an' to the start of a string, depending on whether the first letter is a vowel. If
 * the string already starts with an article, it will not add one.
 *
 * @returns The string with an article added.
 */
export function addArticle(s: string): string {
  // Find the first word in the string.
  const firstWord = s.split(" ")[0];
  if (firstWord === undefined) {
    return s;
  }

  // If the first word is an article, we don't need to add one.
  if (articles.has(firstWord.toLowerCase())) {
    return s;
  }

  // Otherwise, check if the first letter is a vowel.
  const firstLetter = string.sub(firstWord, 1, 1);
  if (vowels.has(firstLetter.toLowerCase())) {
    return `an ${s}`;
  }

  return `a ${s}`;
}

/** Returns a string with the first letter un-capitalized. */
export function uncapitalizeFirstLetter(s: string): string {
  return string.lower(string.sub(s, 1, 1)) + string.sub(s, 2);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\textHelper.ts`:

```````ts
/** Functions related to rendering text on the screen. */

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\helper\tmtrainerHelper.ts`:

```````ts
import { CollectibleType, ItemType } from "isaac-typescript-definitions";
import { getCollectibleItemType, spawnCollectible } from "isaacscript-common";
import { mod } from "../mod";
import { TMTRAINER_THRESHOLD } from "../constants/tmtrainerConstants";
import { doesInvertedItemHaveActionSet } from "../features/corruption/effects/itemEffects";

/** No of TMTRAINER items to spawn when searching for an Active TMTRAINER item. */
const TMTRAINER_FIND_ACTIVE_ITEM_LIMIT = 200;

/**
 * Returns a random TMTRAINER CollectibleType. This is done by temporarily giving the player
 * TMTRAINER, and spawning a collectible, grabbing the SubType then removing the pedestal.
 */
export function getRandomTMTRAINERItem(): CollectibleType {
  const player = Isaac.GetPlayer();
  const hasTMTRAINER = player.HasCollectible(CollectibleType.TMTRAINER);
  if (!hasTMTRAINER) {
    player.AddCollectible(CollectibleType.TMTRAINER, 0, false);
  }

  const tmtCollectible = spawnCollectible(
    CollectibleType.SAD_ONION,
    Vector(0, 0),
    undefined,
  );
  tmtCollectible.Remove();

  if (!hasTMTRAINER) {
    player.RemoveCollectible(CollectibleType.TMTRAINER);
  }

  return tmtCollectible.SubType;
}

/**
 * Returns a random TMTRAINER CollectibleType, that does not already have an ActionSet attached to
 * it.
 */
export function getRandomUnusedTMTRAINERItem(): CollectibleType {
  let tmtCollectibleType = getRandomTMTRAINERItem();
  for (let i = 0; i < TMTRAINER_FIND_ACTIVE_ITEM_LIMIT; i++) {
    if (!doesInvertedItemHaveActionSet(tmtCollectibleType)) {
      break;
    }
    tmtCollectibleType = getRandomTMTRAINERItem();
  }
  return tmtCollectibleType;
}

/** Returns true if the subType of a Collectible dictates it as a TMTRAINER item. */
export function isGlitchedCollectibleSubType(
  subType: CollectibleType,
): boolean {
  return (subType as number) > TMTRAINER_THRESHOLD;
}

/**
 * Returns a random TMTRAINER active CollectibleType. This is done by temporarily giving the player
 * TMTRAINER, and spawning collectibles until an active item is found, giving them to the player
 * then removing them.
 */
export function getRandomTMTRAINERActiveItem(): CollectibleType {
  const player = Isaac.GetPlayer();

  const hasTMTRAINER = player.HasCollectible(CollectibleType.TMTRAINER);
  if (!hasTMTRAINER) {
    player.AddCollectible(CollectibleType.TMTRAINER, 0, false);
  }

  let activeItemType = CollectibleType.POOP;

  for (let i = 0; i < TMTRAINER_FIND_ACTIVE_ITEM_LIMIT; i++) {
    const tmtCollectible = spawnCollectible(
      CollectibleType.SAD_ONION,
      Vector(0, 0),
      undefined,
    );
    const tmtCollectibleType = tmtCollectible.SubType;
    tmtCollectible.Remove();
    if (getCollectibleItemType(tmtCollectibleType) === ItemType.ACTIVE) {
      activeItemType = tmtCollectibleType;
      break;
    }
  }

  if (!hasTMTRAINER) {
    player.RemoveCollectible(CollectibleType.TMTRAINER);
  }

  return activeItemType;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\compatibility\EIDDescObject.ts`:

```````ts
import type {
  EntityType,
  ItemConfigChargeType,
  ItemType,
} from "isaac-typescript-definitions";

/** Alternative to 'EIDDescriptionObject' that is more accurate. */
export interface EIDDescObject {
  /** Type of the Entity. */
  ObjType?: EntityType;

  /** Variant of the Entity. */
  ObjVariant?: number;

  /** Subtype of the Entity. */
  ObjSubType?: number;

  /** Combined string that describes the entity. */
  fullItemString?: string;

  /** Translated name of the entity. */
  Name?: string;

  /** Unformatted translated EID description. */
  Description?: string;

  /** Transformation Object. */
  Transformation?: string;

  /** Mod name. */
  ModName?: string;

  /** Quality of the item, 0-4. */
  Quality?: number;

  /** Object icon on the top left. */
  Icon?: EIDInlineIcon | null;

  /** Entity Object which is currently described. */
  Entity?: Entity;

  /** The item type. */
  ItemType?: ItemType;

  /** The total charges the active item holds. */
  Charges?: number;

  /** The ChargeType. */
  ChargeType?: ItemConfigChargeType;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\actions\TriggerData.ts`:

```````ts
import type {
  CardType,
  CollectibleType,
  DamageFlag,
  PillColor,
  PillEffect,
  UseFlag,
} from "isaac-typescript-definitions";
import type { Action } from "../../../classes/corruption/actions/Action";
import type { Response } from "../../../classes/corruption/responses/Response";
import type { PlayerStat } from "isaacscript-common";

/**
 * Data that you can provide when triggering an Action or Response. If you pass through triggerData
 * when triggering an Action, it will be passed through to the Response.
 */
export interface TriggerData {
  // If an Action has started the 'trigger' chain, this will contain that Action.
  action?: Action;
  // If the Response was triggered by a non-inverted pickup.
  nonInvertedPickup?: EntityPickup;
  // Responses that are triggered will be added to the end of this array.
  responses?: Response[];
  // If the Action / Response takes a player input.
  player?: EntityPlayer;
  // If the Action / Response takes an NPC input. Sometimes overrides player.
  onKillAction?: EntityNPC;
  // If the Action is onDamage.
  onDamageAction?: {
    damageFlags: BitFlags<DamageFlag>;
    source: EntityRef;
    amount: float;
    countdownFrames: int;
  };
  // If the player has corrupted bombs or onBombExplode Actions.
  onBombExplodedAction?: {
    bomb: EntityBomb;
  };

  // If the Action / Response would spawn an Entity, this is the position it should spawn at.
  spawnPosition?: Vector;

  // If the Action / Response would spawn an Entity, this is the velocity it should spawn with.
  spawnVelocity?: Vector;

  // If true, the SpawnGridEntity response should be triggered on the next frame. This will also
  // prevent it from returning any spawned grid entities.
  shouldSpawnGridEntityResponseDelay?: boolean;

  // If the Action is onDeath.
  onDeathAction?: {
    player: EntityPlayer;
  };

  // If the Action is onRevive.
  onReviveAction?: {
    player: EntityPlayer;
  };

  // If the Action is onPillUse.
  onPillUseAction?: {
    pillEffect: PillEffect;
    useFlags: BitFlags<UseFlag>;
  };

  // If the Action is onActiveUse.
  onActiveUseAction?: {
    player: EntityPlayer;
    active: CollectibleType;
  };

  // If the Action is onCardUse.
  onCardUseAction?: {
    player: EntityPlayer;
    card: CardType;
  };

  // If the Action is onBombExplode.
  onBombExplodeAction?: {
    bomb: EntityBomb;
  };

  // If the Action is onPickupCollect.
  onPickupCollectAction?: {
    player: EntityPlayer;
    pickup: EntityPickup;
  };

  // If the Action is onStat.
  onStatAction?: {
    player: EntityPlayer;
    stat: PlayerStat;
    difference: int;
  };

  onPurchaseAction?: {
    player: EntityPlayer;
    pickup: EntityPickup;
  };

  onSacrificeAction?: {
    player: EntityPlayer;
    numSacrifices: int;
  };

  onSlotUseAction?: {
    slot: Entity;
  };

  onSlotDestroyAction?: {
    slot: Entity;
  };
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\actionSets\ActionSetBuilderInput.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";

/** Data sent to ActionSetBuilders. */
export interface ActionSetBuilderInput {
  /** Player who the ActionSet belongs to, may be no-one. */
  player?: EntityPlayer;

  /** Collectible the ActionSet is based on. */
  collectible?: CollectibleType;

  /** Set to true to force an active, and false to force a passive. */
  forceActiveOrPassive?: boolean;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\actionSets\CustomActiveData.ts`:

```````ts
/** Tracks data relevant to the Custom Active that the InvertedActiveActionSet relates to. */
export interface CustomActiveData {
  /** The current charge count of the custom active item. */
  i?: number;

  /**
   * The current charge count of the non-Inverted Active item that is on the flip side of this one.
   */
  n?: number;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\funny\CorruptedCollectibleSprite.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { AdvancedColor } from "../../general/AdvancedColor";

/**
 * CorruptedCollectibleSprite is an interface used to represent Corrupted Collectible Sprites in a
 * format that can be easily serialized and deserialized. These sprites are limited to being either
 * a single Collectible, or an amalgamation similar to TMTRAINER items.
 */
export interface CorruptedCollectibleSprite {
  /** An array of collectibles that will be in the sprite amalgamation. */
  collectibles: CollectibleType[];

  /**
   * Whether the collectibles will be sliced vertically or horizontally. Leave it undefined to
   * randomly choose.
   */
  horizontal?: boolean;

  /**
   * The color of the Corrupted sprite.
   *
   * - If false, the sprite segments will remain their default color.
   * - If a Color, the sprite segments will be colored in that color.
   * - If an array of Colors, the sprite segments will be colored in those colors in order, random
   *   if there are more segments than colors.
   * - If "random", the sprite segments will be colored in random colors.
   * - If an AdvancedColor, the sprite segments will be colored in that AdvancedColor.
   * - If an array of AdvancedColors, the sprite segments will be colored in those AdvancedColors in
   *   order, random if there are more segments than colors.
   */
  color?: Color | Color[] | "random" | AdvancedColor | AdvancedColor[];

  /** Seed for the sprite. */
  seed: Seed;

  /** Whether the individual segments are flipped along the X axis. */
  flipX?: boolean;

  /** To be fixed. */
  flipY?: boolean;

  /** To be fixed. */
  rotation?: number;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\funny\CorruptedSoundEffect.ts`:

```````ts
import type { SoundEffect } from "isaac-typescript-definitions";

/**
 * A serializable object containing information for a corrupted sound effect - these sound effects
 * may contain multiple sound effects that are played in order.
 */
export interface CorruptedSoundEffect {
  /**
   * The sound effects to play, this will be in order. Can either be a SoundEffect for default
   * volume, pitch and delay or a SoundEffectOptions object. The secondary number in the tuple is
   * the length of the sound effect in seconds. Leave it as 0 if you don't know. Can be a decimal.
   * Can be a range of numbers, in which case a random time will be chosen in milliseconds.
   */
  soundEffects: Array<[SoundEffect, number]>;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\inversion\LastPickedUpCollectibleData.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import type { PickupIndex } from "isaacscript-common";
import type { PickupStage } from "../../../enums/general/PickupStage";
import type { InvertedItemActionSet } from "../../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";

/**
 * Data related to the last picked up / currently being picked up collectible, used by the inverted
 * collectible system.
 */
export interface LastPickedUpCollectibleData {
  collectibleType: CollectibleType;
  pickupStage: PickupStage;
  pickupIndex: PickupIndex;
  inverted: boolean;
  pedestal: EntityPickupCollectible;
  actionSet?: InvertedItemActionSet;
  nonInvertedCharge?: number;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\responses\LogicResponseInterface.ts`:

```````ts
import type { Response } from "../../../classes/corruption/responses/Response";

/** Responses which conditionally trigger one of the Responses stored inside them. */
export interface LogicResponseInterface<T extends Response> {}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\responses\ResponseReturnData.ts`:

```````ts
import { ResponseType } from "../../../enums/corruption/responses/ResponseType";

export interface ResponseReturnData {
  [ResponseType.USE_ACTIVE_ITEM]: string;
}

const thing: ResponseReturnData = {
  [ResponseType.USE_ACTIVE_ITEM]: "string",
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\corruption\responses\SpawnEntityResponseInterface.ts`:

```````ts
import type { Response } from "../../../classes/corruption/responses/Response";
import type { TriggerData } from "../actions/TriggerData";

/** Defines common methods and attributes for the Responses which are used to spawn entities. */
export interface SpawnEntityResponseInterface<T extends Response> {
  /** Overridden spawn position. */
  sp?: Vector;

  /** Overridden spawn velocity. */
  v?: Vector;

  /** Get the overridden position (if any). */
  getPosition: () => Vector | undefined;

  /** Set the overridden position. */
  setPosition: (position?: Vector) => T;

  /** Get the overridden velocity (if any). */
  getVelocity: () => Vector | undefined;

  /** Set the overridden velocity. */
  setVelocity: (velocity?: Vector) => T;

  /** Determine spawn position of entity. */
  calculatePosition: (triggerData: TriggerData) => Vector;

  /** Determine spawn velocity of entity. */
  calculateVelocity: (triggerData: TriggerData) => Vector;

  /** Trigger the response, returning entities spawned. */
  trigger: (triggerData: TriggerData) => Entity[];

  /** Fire the response, returning an entity. */
  fire: (triggerData: TriggerData) => Entity;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\general\AdvancedColor.ts`:

```````ts
/**
 * Color objects do not provide methods to retrieve Colorize, Offset and Tint values. Furthermore
 * cloning colors removes these properties. This interface is used to store these values.
 */
export interface AdvancedColor {
  color: Color;
  colorize?: [number, number, number, number];
  tint?: [number, number, number, number];
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\general\CollectibleAttribute.ts`:

```````ts
import type {
  CollectibleType,
  ItemConfigChargeType,
  ItemConfigTag,
  ItemPoolType,
  ItemType,
} from "isaac-typescript-definitions";
import type { PlayerIndex } from "isaacscript-common";

/**
 * Modifiers to describe a subset of all CollectibleTypes.
 *
 * @example Used to get a random CollectibleType through getRandomCollectibleType().
 */
export interface CollectibleAttribute {
  /** Type of item, e.g Active. Remember familiars are separate from passives. */
  itemType?: ItemType | ItemType[];

  /** The pool the item is in. */
  poolType?: ItemPoolType | ItemPoolType[] | "room";

  /** The item quality. */
  quality?: number | number[];

  /** The item charge type (passive collectibles return 'normal'). */
  chargeType?: ItemConfigChargeType | ItemConfigChargeType[];

  /** The charges the item has (passive collectibles return 0). */
  maxCharges?: number | number[];

  /**
   * If set to true, the item must already be owned by a player. If set to false, the item must not
   * be owned by a player.
   */
  playerHas?: boolean;

  /** Item name starts with (capitalization doesn't matter). */
  startsWith?: string;

  /** Item name ends with (capitalization doesn't matter). */
  endsWith?: string;

  /** The tag/s the item should have all of (can have more than these). */
  itemTagAll?: ItemConfigTag[];

  /** The tag/s the item should have at least one of. */
  itemTagOne?: ItemConfigTag[];

  /** Banned Collectibles. */
  banned?: CollectibleType[];

  /** Collectibles that ignore other tags. */
  forced?: CollectibleType[];

  /** If you can/can't find it in Death Certificate. */
  hidden?: boolean;
}

/** Modifiers to describe a subset of all Active Items. */
export interface ActiveCollectibleAttribute extends CollectibleAttribute {
  itemType: ItemType.ACTIVE;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\general\NPCAttribute.ts`:

```````ts
import type {
  CollectibleType,
  LevelStage,
  NPCID,
} from "isaac-typescript-definitions";
import type { Range } from "../../types/general/Range";
import type { COLORS } from "isaacscript-common";
import type { Mods } from "../../enums/compatibility/Mods";

/**
 * Modifiers to describe a subset of all NPCs.
 *
 * @example Used to get a random NPC through getRandomNPC().
 */
export interface NPCAttribute {
  /**
   * If the NPC should be modded (true), not modded (false), or either (undefined). Alternatively,
   * specify a Mod it should be from.
   */
  modded?: boolean | Mods;

  /** General Color of the NPC. */
  color?: keyof typeof COLORS;

  /** Where the NPC is found. */
  stage?: LevelStage;

  /** Size of hitbox, will be between Range max and min (inclusive). */
  size?: Range;

  /** Mass of NPC will be between min and max of Range (inclusive). */
  mass?: Range;

  /** Whether the NPC flies. */
  flying?: boolean;

  /** Whether the NPC is a boss. */
  boss?: boolean;

  /**
   * NPC will have a max health between range minimum and maximum (inclusive).
   *
   * Provide min or max as 0 for "NPC has less health than X" or "NPC has more health than X"
   */
  health?: Range;

  /** NPC name starts with (capitalization doesn't matter). */
  startsWith?: string;

  /** NPC name ends with (capitalization doesn't matter). */
  endsWith?: string;

  /** Banned NPCIDs. */
  banned?: NPCID[];

  /** NPCIDs that ignore other tags. */
  forced?: NPCID[];
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\general\SoundEffectOptions.ts`:

```````ts
import type { SoundEffect } from "isaac-typescript-definitions";

/** Describes a sound effect and its settings. */
export interface SoundEffectOptions {
  /** The sound effect to play. */
  soundEffect: SoundEffect;

  /** The volume of the sound effect. */
  volume?: number;

  /** The pitch of the sound effect. */
  pitch?: number;

  /** The delay before the sound effect is played. */
  frameDelay?: number;

  /** Whether to loop the sound effect. */
  loop?: boolean;

  /** How much to pan the sound effect from L to R. */
  pan?: number;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\modes\ModeData.ts`:

```````ts
import type { CacheFlag, CollectibleType } from "isaac-typescript-definitions";
import type { PlayerHealth } from "isaacscript-common";
import type { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import type { CharacterType } from "../../enums/general/CharacterType";

/** Information about the mode, including player settings. */
export interface ModeData {
  /** A short description of the mode. */
  description: string;

  /** The description of the mode's Birthright. */
  birthright: string;

  /** If the mode is for Deleted or Tainted Deleted. */
  characterType: CharacterType;

  /** The pocket item the player starts with. */
  startingPocket?: CollectibleType;

  /**
   * Items the player starts with. Note that these are visible on the item tracker, to add invisible
   * items reapply temporary effects every room in the specific mode file.
   */
  startingItems?: CollectibleType[];

  /** Starting coins to set coin count to (0 - 99). */
  startingCoins: number;

  /** Starting keys to set key count to (0 - 99). */
  startingKeys: number;

  /** Starting bombs to set bomb count to (0 - 99). */
  startingBombs: number;

  /** Starting health. */
  startingHealth: PlayerHealth;

  /**
   * The main color associated with the mode. Note: Some modes have multiple 'main' colors, so just
   * do not set the main Color and set it instead in the mode file.
   */
  mainColor?: Color;

  /** The location of the characters' custom anm2 file. */
  anm2File?: string;

  /**
   * Any stat included in this map will make the character start with alternate stats to base isaac.
   */
  characterStats?: Map<CacheFlag, number>;

  /** The mode's ItemActionSetBuilder generation method. */
  itemActionSetBuilderReference?: InvertedItemActionSetBuilderReference;

  /**
   * If the character starts inverted. If at least one player has this set to true during a run, the
   * corrupted backdrop will not be displayed to prevent annoyance as the majority of the run would
   * be in the inverted state.
   */
  startInverted?: boolean;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\xml\entities2XML.ts`:

```````ts
import type { EntityCategory } from "../../enums/general/EntityCategory";
import type { NameSubType } from "../../types/data/nameSubType";

export interface EntityXML {
  _attr: {
    name: string;
    id: string;
    variant?: string;
    subtype?: string;
    anm2path?: string;
    baseHP?: string;
    boss?: "0" | "1";
    bossID?: string;
    champion?: string;
    collisionDamage?: string;
    collisionMass?: string;
    collisionRadius?: string;
    collisionRadiusXMulti?: string;
    collisionRadiusYMulti?: string;
    collisionInterval?: string;
    numGridCollisionPoints?: string;
    friction?: string;
    shadowSize?: string;
    stageHP?: string;
    tags?: string;
    gridCollision?: string;
    portrait?: string;
    hasFloorAlts?: string;
    reroll?: string;
    shutdoors?: string;
    shieldStrength?: string;
    gibAmount?: string;
    gibFlags?: string;
    bestiaryAnim?: string;
    bestiaryOverlay?: string;
  };
  gibs: GibsXML;
}

export interface GibsXML {
  _attr: {
    amount: string;
    blood?: "0" | "1";
    bone?: "0" | "1";
    chain?: "0" | "1";
    colorblood?: "0" | "1";
    dust?: "0" | "1";
    eye?: "0" | "1";
    gut?: "0" | "1";
    huge?: "0" | "1";
    large?: "0" | "1";
    poop?: "0" | "1";
    rock?: "0" | "1";
    rock_small?: "0" | "1";
    small?: "0" | "1";
    sound_baby?: "0" | "1";
    sound_bone?: "0" | "1";
    worm?: "0" | "1";
  };
}

/**
 * This type is used to describe a group of entities derived from entities2.xml that are separated
 * into their entity categories. The entities are stored in an object with the keys being the
 * entityNameSubType, and the values being the entity data.
 */
export type Entities2XML = Record<NameSubType, EntityXML>;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\xml\itemPoolXML.ts`:

```````ts
/**
 * Interface for lua transcription of itemPools from itempools.xml. Use the type 'ItemPoolsXML'
 * instead.
 */
export interface ItemPoolXML {
  _attr: {
    Name: string;
  };
  Item: Array<{
    _attr: {
      Id?: string;
      Name?: string;
      DecreaseBy: string;
      Weight: string;
      RemoveOn: string;
    };
  }>;
}

/** Interface for lua transcription of itempools.xml. */
export type ItemPoolsXML = ItemPoolXML[];

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\xml\itemsXML.ts`:

```````ts
/** Can be referencing a Trinket, Active, Passive or Familiar. */
export interface ItemXML {
  _attr: {
    id?: string;
    cache?: string;
    name: string;
    description: string;
    gfx: string;
    tags?: string;
    bombs?: string;
    keys?: string;
    coins?: string;
    hearts?: string;
    soulhearts?: string;
    blackhearts?: string;
    maxhearts?: string;
    chargetype?: "normal" | "timed" | "special";
    cooldown?: string;
    passivecache?: "true" | "false";
    special?: "true" | "false";
    initcharge?: string;
    devilprice?: "1" | "2";
    shopprice?: string;
    addcostumeonpickup?: "true" | "false";
    persistent?: "true" | "false";
    achievement?: string;
    quality?: "0" | "1" | "2" | "3" | "4";
    craftquality?: "-1" | "0" | "1" | "2" | "3" | "4";
    hidden?: "true" | "false";
    cleareffectsonremove?: "true" | "false";
  };
}

/** Interface for lua transcription of items.xml file. */
export interface ItemsXML {
  _attr: {
    deathanm2: string;
    gfxroot: string;
    version: string;
  };
  passive?: ItemXML[];
  active?: ItemXML[];
  familiar?: ItemXML[];
  trinket?: ItemXML[];
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\interfaces\xml\playersXML.ts`:

```````ts
/** References a player entry from players.xml. */
export interface PlayerXML {
  _attr: {
    name: string;
    skin: string;
    skinColor: string;
    nameimage: string;
    portrait: string;
    extraportrait?: string;
    hp?: string;
    armor?: string;
    black?: string;
    items?: string;
    trinket?: string;
    costume?: string;
    costumeSuffix?: string;
    bombs?: string;
    keys?: string;
    coins?: string;
    card?: string;
    pill?: string;
    canShoot?: string;
    achievement?: string;
    broken?: string;
    pocketActive?: string;
    birthright?: string;
    bSkinParent?: string;
    hidden?: string;
  };
}

/** References players.xml. */
export type PlayersXML = PlayerXML[];

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\main.ts`:

```````ts
import { getEnumValues } from "isaacscript-common";
import { evaluateCacheInit } from "./callbacks/evaluateCache";
import { postPlayerCollectibleAddedInit } from "./callbacks/playerCollectibleAdded";
import { postPlayerCollectibleRemovedInit } from "./callbacks/playerCollectibleRemoved";
import { playerTakeDMGInit } from "./callbacks/playerTakeDMG";
import { postBombExplodedInit } from "./callbacks/postBombExploded";
import { postBombInitLateInit } from "./callbacks/postBombInitLate";
import { postEntityKillInit } from "./callbacks/postEntityKill";
import { postFireTearInit } from "./callbacks/postFireTear";
import { postGameStartedReorderedInit } from "./callbacks/postGameStartedReordered";
import { postItemPickupInit } from "./callbacks/postItemPickup";
import { postNPCInitLateInit } from "./callbacks/postNPCInitLate";
import { postNewLevelReorderedInit } from "./callbacks/postNewLevelReordered";
import { postNewRoomInit } from "./callbacks/postNewRoom";
import { postNewRoomReorderedInit } from "./callbacks/postNewRoomReordered";
import { postPeffectUpdateReorderedInit } from "./callbacks/postPeffectUpdateReordered";
import { postPickupChangedInit } from "./callbacks/postPickupChanged";
import { postPickupCollectInit } from "./callbacks/postPickupCollect";
import { postPickupInitFirst } from "./callbacks/postPickupInitFirst";
import { postPickupInitLate } from "./callbacks/postPickupInitLate";
import { postPlayerChangeTypeInit } from "./callbacks/postPlayerChangeType";
import { postPlayerFatalDamageInit } from "./callbacks/postPlayerFatalDamage";
import { postPlayerInitInit } from "./callbacks/postPlayerInit";
import { postPlayerInitFirstInit } from "./callbacks/postPlayerInitFirst";
import { postRenderInit } from "./callbacks/postRender";
import { postUpdateInit } from "./callbacks/postUpdate";
import { postUseItemInit } from "./callbacks/postUseItem";
import { preGameExitInit } from "./callbacks/preGameExit";
import { preGetPedestalInit } from "./callbacks/preGetPedestal";
import { preItemPickupInit } from "./callbacks/preItemPickup";
import { preNewLevelReorderedInit } from "./callbacks/preNewLevel";
import { prePickupCollisionInit } from "./callbacks/prePickupCollision";
import { prePlayerCollisionInit } from "./callbacks/prePlayerCollision";
import { preSpawnClearAwardInit } from "./callbacks/preSpawnClearAward";
import { initCorruptedCollectibleSpriteFacet } from "./classes/facets/CorruptedCollectibleSpriteFacet";
import { initCustomActiveFacet } from "./classes/facets/CustomActiveFacet";
import { initExampleFacet } from "./classes/facets/ExampleFacet";
import { initRenderOverHeadFacet } from "./classes/facets/RenderOverHeadFacet";
import { initBolsterNPCFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/BolsterNPCFacet";
import { initFreezeNPCFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/FreezeNPCFacet";
import { initHybridNPCFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/HybridNPCFacet";
import { initNonMandatoryNPCFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/NonMandatoryNPCFacet";
import { initUnstableEntityFacet } from "./classes/facets/entityModifiers.ts/UnstableEntityFacet";
import { initEveryItemIsFacet } from "./classes/facets/entityModifiers.ts/pickupModifiers/EveryItemIsFacet";
import { initPCFacet } from "./classes/facets/pc/PCFacet";
import { Mode } from "./enums/modes/Mode";
import { FEATURE_INIT_FUNCTIONS } from "./features";
import { initEID } from "./features/compatibility/EID/EIDInit";
import { addTestingCommands } from "./features/console/testing";
import { fprint } from "./helper/printHelper";
import { MODE_DATA_MAP, getModePlayerType } from "./maps/modes/modeMap";
import { mod } from "./mod";
import { initHideNPCFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/HideNPCFacet";
import { initSpawnEntityByNameFacet } from "./classes/facets/SpawnEntityByNameFacet";
import { postEntityRemoveInit } from "./callbacks/postEntityRemove";
import { postNPCUpdateInit } from "./callbacks/postNPCUpdate";
import { initPermanentNPCStatusEffectFacet } from "./classes/facets/entityModifiers.ts/NPCModifiers/PermanentNPCStatusEffectFacet";
import { preCustomReviveInit } from "./callbacks/preCustomRevive";
import { postUsePillInit } from "./callbacks/postUsePill";
import { postPlayerStatChangedInit } from "./callbacks/postPlayerChangeStat";
import { postUseCardInit } from "./callbacks/postUseCard";
import { postGreedWaveClearInit } from "./callbacks/postGreedWaveClear";
import { postPurchaseInit } from "./callbacks/postPurchase";
import { initClasses } from "./classes";
import { postRoomClearInit } from "./callbacks/postRoomClear";
import { postSacrificeInit } from "./callbacks/postSacrifice";
import { postSlotAnimationChanged } from "./callbacks/postSlotUse";

const IS_DEV = true;

fprint("Loading 'main.ts'...");
main();

function main() {
  initCallbacks();
  initStats();
  initClasses();
  initFeatures();
  initExternalMods();
  initExports();
  initFacets();
}

/** Initialize mod features. */
function initFeatures() {
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (IS_DEV) {
    devInit();
  }

  for (const initFunction of FEATURE_INIT_FUNCTIONS) {
    initFunction();
  }
}

/** Initialize mod features for dev. */
function devInit() {
  fprint("Initializing dev features...");
  addTestingCommands();
  mod.enableFastReset();
}

/** Register all the callbacks. */
function initCallbacks() {
  postUpdateInit(mod);
  postRenderInit(mod);
  postPeffectUpdateReorderedInit(mod);
  postNewRoomInit(mod);
  postUseItemInit(mod);
  postPlayerInitFirstInit(mod);
  postPickupInitLate(mod);
  postItemPickupInit(mod);
  postNewRoomReorderedInit(mod);
  preGetPedestalInit(mod);
  postPlayerInitInit(mod);
  postPlayerChangeTypeInit(mod);
  postNPCInitLateInit(mod);
  postGameStartedReorderedInit(mod);
  postNewLevelReorderedInit(mod);
  preNewLevelReorderedInit(mod);
  playerTakeDMGInit(mod);
  postPlayerFatalDamageInit(mod);
  evaluateCacheInit(mod);
  postPickupInitFirst(mod);
  postPickupCollectInit(mod);
  postPlayerCollectibleAddedInit(mod);
  postPlayerCollectibleRemovedInit(mod);
  postEntityKillInit(mod);
  prePickupCollisionInit(mod);
  postBombExplodedInit(mod);
  postBombInitLateInit(mod);
  preItemPickupInit(mod);
  preGameExitInit(mod);
  postPickupChangedInit(mod);
  prePlayerCollisionInit(mod);
  preSpawnClearAwardInit(mod);
  postFireTearInit(mod);
  preNewLevelReorderedInit(mod);
  postEntityRemoveInit(mod);
  postNPCUpdateInit(mod);
  preCustomReviveInit(mod);
  postUsePillInit(mod);
  postPlayerStatChangedInit(mod);
  postUseCardInit(mod);
  postGreedWaveClearInit(mod);
  postPurchaseInit(mod);
  postRoomClearInit(mod);
  postSacrificeInit(mod);
  postSlotAnimationChanged(mod);
}

/** Initialize External mods if they exist. */
function initExternalMods() {
  initEID();
}

function initExports() {
  // eslint-disable-next-line no-implicit-globals
  TheDeleted = {};
}

function initStats() {
  const modes = getEnumValues(Mode);
  for (const mode of modes) {
    const characterStats = MODE_DATA_MAP.get(mode);
    if (characterStats?.characterStats !== undefined) {
      mod.registerCharacterStats(
        getModePlayerType(mode),
        characterStats.characterStats,
      );
    }
  }
}

function initFacets() {
  initExampleFacet();
  initCorruptedCollectibleSpriteFacet();
  initRenderOverHeadFacet();
  initPCFacet();
  initUnstableEntityFacet();
  initHybridNPCFacet();
  initFreezeNPCFacet();
  initBolsterNPCFacet();
  initEveryItemIsFacet();
  initCustomActiveFacet();
  initNonMandatoryNPCFacet();
  initHideNPCFacet();
  initSpawnEntityByNameFacet();
  initPermanentNPCStatusEffectFacet();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\activeChargeToZazzActive.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ItemConfigChargeType } from "isaac-typescript-definitions";
import { CollectibleTypeCustom } from "../enums/general/CollectibleTypeCustom";

const ACTIVE_CHARGE_TO_ZAZZ_ACTIVE_MAP: ReadonlyMap<string, CollectibleType> =
  new Map([
    [
      `${ItemConfigChargeType.NORMAL}.0`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.1`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.2`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.3`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.4`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.5`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.6`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.7`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.8`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.9`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.10`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.11`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11,
    ],
    [
      `${ItemConfigChargeType.NORMAL}.12`,
      CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12,
    ],
  ]);

/**
 * Get the Zazzinator active item that corresponds to the given charge type and charge.
 *
 * @param chargeType The charge type of the active item.
 * @param charge The charge of the active item.
 * @returns The Zazzinator active item that corresponds to the given charge type and charge.
 */
export function getZazzActiveFromCharge(
  chargeType: ItemConfigChargeType,
  charge: number,
): CollectibleType {
  const chargeID = `${chargeType.toString()}.${charge.toString()}`;
  const result = ACTIVE_CHARGE_TO_ZAZZ_ACTIVE_MAP.get(chargeID);
  if (result === undefined) {
    error(
      "Failed to get the Zazzinator active item from the given charge type and charge.",
    );
  }
  return result;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\activeSlotRenderMap.ts`:

```````ts
import { ActiveSlot } from "isaac-typescript-definitions";
import { PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1 } from "../constants/renderConstants";

const ACTIVE_SLOT_RENDER_MAP: ReadonlyMap<ActiveSlot, Vector> = new Map([
  [ActiveSlot.PRIMARY, PRIMARY_ACTIVE_SLOT_HUD_RENDER_POSITION_PLAYER_1],
]);

/**
 * Get the coordinates on the HUD to render an active item, taking into account its size and also
 * HUD offset.
 * TODO: Update for different players.
 */
export function getActiveSlotRenderPosition(activeSlot: ActiveSlot): Vector {
  const position = ACTIVE_SLOT_RENDER_MAP.get(activeSlot);
  if (position === undefined) {
    error("Failed to get the render position for the active slot.");
  }
  return position;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\builders\actionSetBuilderMap.ts`:

```````ts
import { InvertedItemActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedItemActionSet";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { defaultInvertedItemActionSetBuilder } from "../../helper/builders/genericBuilders";
import { happy99DefaultBuilder } from "../../helper/builders/modes/HAPPY99Builders";
import { hicurdismosDefaultBuilder } from "../../helper/builders/modes/HICURDISMOSBuilders";
import { iLoveYouDefaultBuilder } from "../../helper/builders/modes/ILOVEYOUBuilders";
import { morrisDefaultBuilder } from "../../helper/builders/modes/MORRISBuilders";
import { mydoomDefaultBuilder } from "../../helper/builders/modes/MYDOOMBuilders";
import { revetonDefaultBuilder } from "../../helper/builders/modes/REVETONBuilders";
import type { ActionSetBuilderInput } from "../../interfaces/corruption/actionSets/ActionSetBuilderInput";
import type {
  Builder,
  InvertedItemActionSetBuilder,
} from "../../types/general/Builder";

const INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE_MAP: ReadonlyMap<
  InvertedItemActionSetBuilderReference,
  Builder<InvertedItemActionSet>
> = new Map([
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_DEFAULT,
    (inputs: ActionSetBuilderInput) =>
      defaultInvertedItemActionSetBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_HAPPY_DEFAULT,
    (inputs: ActionSetBuilderInput) => happy99DefaultBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_ILOVEYOU_DEFAULT,
    (inputs: ActionSetBuilderInput) => iLoveYouDefaultBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MORRIS_DEFAULT,
    (inputs: ActionSetBuilderInput) => morrisDefaultBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_HICURDISMOS_DEFAULT,
    (inputs: ActionSetBuilderInput) => hicurdismosDefaultBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
    (inputs: ActionSetBuilderInput) => mydoomDefaultBuilder(inputs),
  ],
  [
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_REVETON_DEFAULT,
    (inputs: ActionSetBuilderInput) => revetonDefaultBuilder(inputs),
  ],
]);

/** Returns the ActionSetBuilder correlated to the ActionSetBuilderReference. */
export function getInvertedItemActionSetBuilderFromReference(
  reference: InvertedItemActionSetBuilderReference,
): InvertedItemActionSetBuilder {
  const builder = INVERTED_ITEM_ACTION_SET_BUILDER_REFERENCE_MAP.get(reference);
  if (builder === undefined) {
    error("actionSetBuilderReferenceMap: Builder not found!");
  } else {
    return builder as InvertedItemActionSetBuilder;
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\collectiblePrefixes.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";

const COLLECTIBLE_PREFIX_MAP: ReadonlyMap<CollectibleType, string[]> = new Map([
  [CollectibleType.ABADDON, ["Aba", "Abaddo"]],
  [CollectibleType.ABEL, ["Abe", "Ab"]],
  [CollectibleType.ABYSS, ["Aby", "Ab"]],
  [CollectibleType.ACID_BABY, ["Acid ", "Aci", "Acid Ba"]],
  [
    CollectibleType.ACT_OF_CONTRITION,
    ["Act of ", "Act of co", "Act of contri"],
  ],
]);

const COLLECTIBLE_SUFFIX_MAP: ReadonlyMap<CollectibleType, string[]> = new Map([
  [CollectibleType.ABADDON, ["ddon", "don"]],
  [CollectibleType.ABEL, ["bel", "abel"]],
  [CollectibleType.ABYSS, ["yss", "ss", "byss"]],
  [CollectibleType.ACID_BABY, [" Baby", "by", "baby"]],
  [CollectibleType.ACT_OF_CONTRITION, ["ntrition", "trition", "rition"]],
]);

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\compatibility\EIDColorMap.ts`:

```````ts
import { K_COLORS } from "isaacscript-common";
import { EIDColorShortcut } from "../../enums/compatibility/EID/EIDColor";
import { EIDColorTriplet } from "../../enums/compatibility/EID/EIDColorTriplet";
import { Morality } from "../../enums/corruption/Morality";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { colorToKColor } from "../../helper/colorHelper";

const EID_COLOR_MAP: ReadonlyMap<EIDColorShortcut, KColor | (() => KColor)> =
  new Map([
    [EIDColorShortcut.RED, K_COLORS.Red],
    [EIDColorShortcut.HAPPY_YELLOW, colorToKColor(DeletedColor.HAPPY_YELLOW)],
    [
      EIDColorShortcut.HAPPY_YELLOW_DARKER,
      colorToKColor(DeletedColor.HAPPY_YELLOW_DARKER),
    ],
    [
      EIDColorShortcut.HAPPY_YELLOW_DARKEST,
      colorToKColor(DeletedColor.HAPPY_YELLOW_DARKEST),
    ],
    [EIDColorShortcut.LOVE_PINK, colorToKColor(DeletedColor.LOVE_PINK)],
    [
      EIDColorShortcut.LOVE_PINK_DARKER,
      colorToKColor(DeletedColor.LOVE_PINK_DARKER),
    ],
    [
      EIDColorShortcut.LOVE_PINK_DARKEST,
      colorToKColor(DeletedColor.LOVE_PINK_DARKEST),
    ],
    [
      EIDColorShortcut.WORM_TURQUOISE,
      colorToKColor(DeletedColor.WORM_TURQUOISE),
    ],
    [
      EIDColorShortcut.WORM_TURQUOISE_DARKER,
      colorToKColor(DeletedColor.WORM_TURQUOISE_DARKER),
    ],
    [
      EIDColorShortcut.WORM_TURQUOISE_DARKEST,
      colorToKColor(DeletedColor.WORM_TURQUOISE_DARKEST),
    ],
    [EIDColorShortcut.ANGRY_RED, colorToKColor(DeletedColor.ANGRY_RED)],
    [EIDColorShortcut.WINDOWS_BLUE, colorToKColor(DeletedColor.WINDOWS_BLUE)],
    [
      EIDColorShortcut.WINDOWS_BLUE_DARKER,
      colorToKColor(DeletedColor.WINDOWS_BLUE_DARKER),
    ],
    [
      EIDColorShortcut.WINDOWS_BLUE_DARKEST,
      colorToKColor(DeletedColor.WINDOWS_BLUE_DARKEST),
    ],
    [EIDColorShortcut.WINDOWS_WHITE, colorToKColor(DeletedColor.WINDOWS_WHITE)],
    [EIDColorShortcut.DEATH_BLACK, colorToKColor(DeletedColor.DEATH_BLACK)],
    [
      EIDColorShortcut.DEATH_BLACK_DARKER,
      colorToKColor(DeletedColor.DEATH_BLACK_DARKER),
    ],
    [
      EIDColorShortcut.DEATH_BLACK_DARKEST,
      colorToKColor(DeletedColor.DEATH_BLACK_DARKEST),
    ],
    [EIDColorShortcut.REVETON_RED, colorToKColor(DeletedColor.REVETON_RED)],
    [EIDColorShortcut.REVETON_BLUE, colorToKColor(DeletedColor.REVETON_BLUE)],
  ]);

const EID_MORALITY_TO_COLOR_MAP: ReadonlyMap<Morality, string> = new Map([
  [Morality.POSITIVE, "ColorWhite"],
  [Morality.NEUTRAL, "ColorYellow"],
  [Morality.NEGATIVE, "ColorRed"],
]);

const EID_COLOR_TRIPLET_TO_TUPLE_MAP: ReadonlyMap<
  EIDColorTriplet,
  [EIDColorShortcut, EIDColorShortcut, EIDColorShortcut]
> = new Map([
  [
    EIDColorTriplet.HAPPY99_TRIPLET,
    [
      EIDColorShortcut.HAPPY_YELLOW,
      EIDColorShortcut.HAPPY_YELLOW_DARKER,
      EIDColorShortcut.HAPPY_YELLOW_DARKEST,
    ],
  ],
  [
    EIDColorTriplet.ILOVEYOU_TRIPLET,
    [
      EIDColorShortcut.LOVE_PINK,
      EIDColorShortcut.LOVE_PINK_DARKER,
      EIDColorShortcut.LOVE_PINK_DARKEST,
    ],
  ],
  [
    EIDColorTriplet.MORRIS_TRIPLET,
    [
      EIDColorShortcut.WORM_TURQUOISE,
      EIDColorShortcut.WORM_TURQUOISE_DARKER,
      EIDColorShortcut.WORM_TURQUOISE_DARKEST,
    ],
  ],
  [
    EIDColorTriplet.HICURDISMOS_TRIPLET,
    [
      EIDColorShortcut.WINDOWS_BLUE,
      EIDColorShortcut.WINDOWS_BLUE_DARKER,
      EIDColorShortcut.WINDOWS_WHITE,
    ],
  ],
  [
    EIDColorTriplet.MYDOOM_TRIPLET,
    [
      EIDColorShortcut.DEATH_BLACK,
      EIDColorShortcut.DEATH_BLACK_DARKER,
      EIDColorShortcut.DEATH_BLACK_DARKEST,
    ],
  ],
]);

/** Returns the KColor for the given EIDColorShortcut. */
export function getKColorFromEIDColorShortcut(
  shortcut: EIDColorShortcut,
): KColor | (() => KColor) {
  const color = EID_COLOR_MAP.get(shortcut);
  if (color === undefined) {
    return error(`No KColor found for EIDColorShortcut: ${shortcut}`);
  }
  return color;
}

/** Returns the EIDColorShortcut for the given Morality. */
export function getEIDColorShortcutFromMorality(
  morality: Morality,
): EIDColorShortcut {
  const color = EID_MORALITY_TO_COLOR_MAP.get(morality);
  if (color === undefined) {
    return error(`No EIDColorShortcut found for Morality: ${morality}`);
  }
  return color as EIDColorShortcut;
}

/**
 * Retrieves a set of EIDColorShortcuts from the EIDColorTriplet enum value. This can be used with
 * the 'setTheme' ActionSet function.
 */
export function getEIDColorTupleFromTriplet(
  triplet: EIDColorTriplet,
): [EIDColorShortcut, EIDColorShortcut, EIDColorShortcut] {
  const tuple = EID_COLOR_TRIPLET_TO_TUPLE_MAP.get(triplet);
  if (tuple === undefined) {
    return error(`No EIDColorTuple found for EIDColorTriplet: ${triplet}`);
  }
  return tuple;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\conditionalToFunctionMap.ts`:

```````ts
import {
  game,
  getCurseIDByName,
  getGridEntities,
  getPickups,
  getPlayerTransformations,
  getRandomInt,
  getRoomType,
  hasCurse,
} from "isaacscript-common";
import { Conditional } from "../enums/general/Conditional";
import { isPlayerHoldingTrinkets } from "../helper/entityHelper/trinketHelper";
import {
  doesPlayerHaveAnyActiveItem,
  getPlayerTotalHealth,
  isPlayerHoldingCard,
  isPlayerHoldingPill,
} from "../helper/playerHelper";
import type {
  Difficulty,
  CardType,
  CollectibleType,
  LevelStage,
  PillColor,
  PlayerForm,
  PlayerType,
  RoomType,
  Direction,
} from "isaac-typescript-definitions";
import { isWorldInverted } from "../helper/deletedSpecific/inversion/worldInversionHelper";
import { isWorld } from "../helper/deletedSpecific/worlds/worldHelper";
import type { World } from "../enums/worlds/Worlds";
import { getCurses, hasAnyCurse } from "../helper/curseHelper";

const CONDITIONAL_TO_FUNCTION_MAP: ReadonlyMap<
  Conditional,
  (player: EntityPlayer, num: number) => boolean
> = new Map([
  [
    Conditional.PLAYER_HAS_X_OR_MORE_HEALTH,
    (player, num) => getPlayerTotalHealth(player) >= num,
  ],
  [
    Conditional.PLAYER_HAS_X_OR_MORE_COINS,
    (player, num) => player.GetNumCoins() >= num,
  ],
  [
    Conditional.PLAYER_HAS_X_OR_MORE_BOMBS,
    (player, num) => player.GetNumBombs() >= num,
  ],
  [
    Conditional.PLAYER_HAS_X_OR_MORE_KEYS,
    (player, num) => player.GetNumKeys() >= num,
  ],
  [
    Conditional.PLAYER_HAS_X_OR_MORE_COLLECTIBLES,
    (player, num) => player.GetCollectibleCount() >= num,
  ],
  [
    Conditional.PLAYER_HAS_TRANSFORMATION_X,
    (player, num) => getPlayerTransformations(player).has(num as PlayerForm),
  ],
  [
    Conditional.PLAYER_HOLDING_TRINKET,
    (player) => isPlayerHoldingTrinkets(player),
  ],
  [
    Conditional.PLAYER_HAS_TRINKET_X,
    (player, num) => player.HasTrinket(num, true),
  ],
  [Conditional.PLAYER_HOLDING_PILL, (player) => isPlayerHoldingPill(player)],
  [Conditional.PLAYER_HOLDING_CARD, (player) => isPlayerHoldingCard(player)],
  [
    Conditional.PLAYER_HOLDING_PILL_X,
    (player, num) => isPlayerHoldingPill(player, num as PillColor),
  ],
  [
    Conditional.PLAYER_HOLDING_CARD_X,
    (player, num) => isPlayerHoldingCard(player, num as CardType),
  ],
  [
    Conditional.PLAYER_HAS_ACTIVE_ITEM,
    (player) => doesPlayerHaveAnyActiveItem(player),
  ],
  [
    Conditional.PLAYER_HAS_COLLECTIBLE_X,
    (player, num) => player.HasCollectible(num as CollectibleType, true),
  ],
  [
    Conditional.PLAYER_IS_IN_ROOM_X,
    (_player, num) => getRoomType() === (num as RoomType),
  ],
  [
    Conditional.PLAYER_IS_ON_FLOOR_X,
    (_player, num) => game.GetLevel().GetStage() === (num as LevelStage),
  ],
  [
    Conditional.PLAYER_IS_CHARACTER_X,
    (player, num) => player.GetPlayerType() === (num as PlayerType),
  ],

  // TODO.
  [
    Conditional.PLAYER_IS_ON_LEFT_SIDE_OF_ROOM,
    (player) => player.Position.X < 320,
  ],

  [
    Conditional.PLAYER_IS_ON_X_HEALTH,
    (player, num) => getPlayerTotalHealth(player) === num,
  ],

  // TODO.
  [
    Conditional.PLAYER_HAS_X_HEART_TYPE,
    (_player, num) => getRandomInt(1, 2, undefined) === num,
  ],

  // TODO.
  [
    Conditional.PLAYER_HAS_ONLY_X_HEARTS,
    (_player, num) => getRandomInt(1, 2, undefined) === num,
  ],

  [Conditional.WORLD_IS_INVERTED, (_player, _num) => isWorldInverted()],
  [Conditional.WORLD_IS_X, (_player, num) => isWorld(num as World)],
  [
    Conditional.IS_DIFFICULTY_X,
    (_player, num) => game.Difficulty === (num as Difficulty),
  ],
  [
    Conditional.ROOM_HAS_ENEMIES,
    (_player, _num) => game.GetRoom().GetAliveEnemiesCount() > 0,
  ],
  [Conditional.ROOM_HAS_PICKUPS, (_player, _num) => getPickups().length > 0],
  [
    Conditional.ROOM_HAS_OBSTACLES,
    (_player, _num) => getGridEntities().length > 0,
  ],
  [
    Conditional.PLAYER_IS_MOVING,
    (player, _num) => player.Velocity.X !== 0 || player.Velocity.Y !== 0,
  ],
  [Conditional.PLAYER_IS_FLYING, (player, _num) => player.IsFlying()],

  // TODO: DayType enum.

  // TODO: HolidayType enum.

  [Conditional.FLOOR_IS_CURSED, (_player, _num) => hasAnyCurse()],

  // TODO: Player has only X type of heart.
]);

/**
 * Determine if a conditional is true.
 *
 * @param conditional The conditional to check.
 * @param player The player to check the conditional against. Defaults to the first player.
 * @param amount The amount to check the conditional against. If the conditional doesn't use an
 *               amount, this will be ignored. Defaults to 1.
 */
export function isConditionalSatisfied(
  conditional: Conditional,
  player: EntityPlayer = Isaac.GetPlayer(),
  amount = 1,
): boolean {
  const func = CONDITIONAL_TO_FUNCTION_MAP.get(conditional);
  if (func === undefined) {
    error(`No function for conditional ${conditional}.`);
  }
  return func(player, amount);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\corruption\responses\entityCategoryToResponseMap.ts`:

```````ts
import type { Response } from "../../../classes/corruption/responses/Response";
import { SpawnEffectResponse } from "../../../classes/corruption/responses/SpawnEffectResponse";
import { SpawnLiveBombResponse } from "../../../classes/corruption/responses/SpawnLiveBombResponse";
import { SpawnNPCResponse } from "../../../classes/corruption/responses/SpawnNPCResponse";
import { SpawnPickupResponse } from "../../../classes/corruption/responses/SpawnPickupResponse";
import { SpawnSlotResponse } from "../../../classes/corruption/responses/SpawnSlotResponse";
import { SpawnTearResponse } from "../../../classes/corruption/responses/SpawnTearResponse";
import { EntityCategory } from "../../../enums/general/EntityCategory";

const ENTITY_CATEGORY_TO_RESPONSE_MAP: ReadonlyMap<
  EntityCategory,
  () => Response
> = new Map([
  [EntityCategory.BOMB, () => new SpawnLiveBombResponse() as Response],
  [EntityCategory.EFFECT, () => new SpawnEffectResponse() as Response],

  // [EntityCategory.FAMILIAR, () => new SpawnEffectResponse() as Response].

  // [EntityCategory.KNIFE, () => new SpawnEffectResponse() as Response].

  // [EntityCategory.LASER, () => new SpawnEffectResponse() as Response].

  [EntityCategory.NPC, () => new SpawnNPCResponse() as Response],
  [EntityCategory.PICKUP, () => new SpawnPickupResponse() as Response],

  // [EntityCategory.PLAYER, () => new SpawnEffectResponse() as Response].

  // [EntityCategory.PROJECTILE, () => new SpawnEffectResponse() as Response].

  [EntityCategory.TEAR, () => new SpawnTearResponse() as Response],
  [EntityCategory.SLOT, () => new SpawnSlotResponse() as Response],
]);

export function getResponseFromEntityCategory(
  entityCategory: EntityCategory,
): Response {
  const responseConstructor =
    ENTITY_CATEGORY_TO_RESPONSE_MAP.get(entityCategory);
  if (responseConstructor === undefined) {
    error(
      `No response constructor found for entity category ${entityCategory}`,
    );
  }

  return responseConstructor();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\moddedEntityIDToModMap.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import type { Mods } from "../../enums/compatibility/Mods";

const moddedEntityIDToModMap = new Map<EntityID, Mods>([]);

/** Map the modded EntityID to its mod. */
export function _addModdedEntityIDToModMap(
  entityID: EntityID,
  mod: Mods,
): void {
  moddedEntityIDToModMap.set(entityID, mod);
}

/** Get the mod that the modded EntityID is from. */
export function getModFromModdedEntityID(entityID: EntityID): Mods | undefined {
  return moddedEntityIDToModMap.get(entityID);
}

export function _clearModdedEntityIDToModMap(): void {
  moddedEntityIDToModMap.clear();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\moddedEntityIDToNameSubType.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import type { NameSubType } from "../../types/data/nameSubType";

/**
 * Gets a modded Entity NameSubType string (e.g "0.HoneyFox") from its Entity ID (e.g "27.1.0").
 * This map will be populated upon game start, as modded Entity ID's are not known until then.
 *
 * This map is necessary as other maps for modded entities will use the Entity Name + SubType string
 * as a key. The EntityID will first be converted to the Entity Name + SubType string, and then used
 * to get the value from the other maps.
 */
const moddedEntityIDToNameSubTypeMap = new Map<EntityID, NameSubType>([]);

/** Map the modded EntityID to its name + subType ID (e.g "0.HoneyFox"). */
export function _addModdedEntityIDToNameSubTypeMap(
  entityID: EntityID,
  nameSubType: NameSubType,
): void {
  moddedEntityIDToNameSubTypeMap.set(entityID, nameSubType);
}

/**
 * Get the modded Entity Name + SubType string from its Entity ID. If the EntityID does not exist in
 * the map, return undefined. This may happen when a modded entity is not tracked.
 */
export function getNameSubTypeFromModdedEntityID(
  entityID: EntityID,
): NameSubType | undefined {
  return moddedEntityIDToNameSubTypeMap.get(entityID);
}

export function _clearModdedEntityIDToNameSubTypeMap(): void {
  moddedEntityIDToNameSubTypeMap.clear();
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\bombEntityNameMap.ts`:

```````ts
import { BombVariant } from "isaac-typescript-definitions";

const BOMB_ENTITY_NAME_MAP: ReadonlyMap<BombVariant, string> = new Map([
  [BombVariant.BIG, "big bomb"],
  [BombVariant.BOBBY, "bobby bomb"],
  [BombVariant.BRIMSTONE, "brimstone bomb"],
  [BombVariant.BUTT, "butt bomb"],
  [BombVariant.DECOY, "best friend"],
  [BombVariant.GIGA, "giga bomb"],
  [BombVariant.GLITTER, "glitter bomb"],
  [BombVariant.GOLDEN_TROLL, "golden troll bomb"],
  [BombVariant.HOT, "hot bomb"],
  [BombVariant.MEGA_TROLL, "mega troll bomb"],
  [BombVariant.MR_MEGA, "mr. mega bomb"],
  [BombVariant.NORMAL, "bomb"],
  [BombVariant.POISON, "poison bomb"],
  [BombVariant.POISON_BIG, "big poison bomb"],
  [BombVariant.ROCKET, "rocket"],
  [BombVariant.ROCKET_GIGA, "giga rocket"],
  [BombVariant.SAD, "sad bomb"],
  [BombVariant.SAD_BLOOD, "bloody sad bomb"],
  [BombVariant.SMALL, "small bomb"],
  [BombVariant.THROWABLE, "throwable bomb"],
  [BombVariant.TROLL, "troll bomb"],
]);

/** Get the name of a bomb entity from its variant. */
export function getNonModdedBombEntityName(bombVariant: BombVariant): string {
  const name = BOMB_ENTITY_NAME_MAP.get(bombVariant);
  if (name === undefined) {
    error(`Unknown bomb variant: ${bombVariant}`);
  }
  return name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\championColorNameMap.ts`:

```````ts
import { ChampionColor } from "isaac-typescript-definitions";

const ChampionColorNameMap: ReadonlyMap<ChampionColor, string> = new Map([
  [ChampionColor.BLACK, "Black"],
  [ChampionColor.BLUE, "Blue"],
  [ChampionColor.CAMO, "Camouflaged"],
  [ChampionColor.DARK_RED, "Dark Red"],
  [ChampionColor.FLICKER, "Flickering"],
  [ChampionColor.GREEN, "Green"],
  [ChampionColor.GREY, "Grey"],
  [ChampionColor.LIGHT_BLUE, "Light Blue"],
  [ChampionColor.ORANGE, "Orange"],
  [ChampionColor.PINK, "Pink"],
  [ChampionColor.PULSE_GREEN, "Pulsating Green"],
  [ChampionColor.PULSE_GREY, "Pulsating Grey"],
  [ChampionColor.PURPLE, "Purple"],
  [ChampionColor.RED, "Red"],
  [ChampionColor.TRANSPARENT, "Transparent"],
  [ChampionColor.WHITE, "White"],
  [ChampionColor.YELLOW, "Yellow"],
  [ChampionColor.BROWN, "Brown"],
  [ChampionColor.RAINBOW, "Rainbow"],
  [ChampionColor.DEATH, "Death"],
  [ChampionColor.KING, "King"],
  [ChampionColor.SIZE_PULSE, "Size-Pulsating"],
  [ChampionColor.PULSE_RED, "Pulsating Red"],
  [ChampionColor.GIANT, "Giant"],
  [ChampionColor.TINY, "Tiny"],
  [ChampionColor.FLY_PROTECTED, "Fly Protected"],
  [ChampionColor.DARK_RED, "Dark Red"],
]);

/**
 * Converts a ChampionColor to a printable text value.
 *
 * @example getChampionColorTextFromMap(ChampionColor.BLACK); // "Black"
 */
export function championColorToString(championColor: ChampionColor): string {
  const text = ChampionColorNameMap.get(championColor);
  if (text !== undefined) {
    return text;
  }
  error("ChampionColorText: ChampionColor text cannot be found.");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\conditionToNameMap.ts`:

```````ts
import { getCollectibleName } from "isaacscript-common";
import { Conditional } from "../../../enums/general/Conditional";

const CONDITION_TO_NAME_MAP: ReadonlyMap<
  Conditional,
  (xValue: number) => string
> = new Map([
  [Conditional.FLOOR_IS_CURSED, (_xValue) => "the floor is cursed"],
  [Conditional.PLAYER_HAS_ACTIVE_ITEM, (_xValue) => "you have an active item"],
  [
    Conditional.PLAYER_HAS_COLLECTIBLE_X,
    (xValue) => `you have ${getCollectibleName(xValue)}`,
  ],

  // TODO: Fix.
  [
    Conditional.PLAYER_HAS_ONLY_X_HEARTS,
    (xValue) => `you only have ${xValue} hearts`,
  ],
]);

/**
 * Get the conditional in string format.
 *
 * @param conditional The conditional to convert to string.
 * @param xValue The value of the conditional (e.g 3 for PLAYER_HAS_X_OR_MORE_HEALTH).
 * @param addIf Whether to add 'if' to the start of the string (e.g 'if the floor is cursed').
 *
 * @example 'conditionalToString(Conditional.FLOOR_IS_CURSED, 1)' returns 'the floor is cursed'
 * @example
 */
export function conditionalToString(
  conditional: Conditional,
  xValue: number,
  addIf = true,
): string {
  const name = CONDITION_TO_NAME_MAP.get(conditional);
  if (name === undefined) {
    error(`Unknown conditional ${conditional}`);
  }

  return `${addIf ? "if " : ""}${name(xValue)}`;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\damageFlagNameMap.ts`:

```````ts
import { DamageFlag } from "isaac-typescript-definitions";

const DAMAGE_FLAG_TEXT_MAP: ReadonlyMap<DamageFlag, string> = new Map([
  [DamageFlag.ACID, "Acid"],
  [DamageFlag.BOOGER, "Booger tears"],
  [DamageFlag.CHEST, "Spiked chests"],
  [DamageFlag.CLONES, "Clones"],
  [DamageFlag.COUNTDOWN, "Countdown"],
  [DamageFlag.CRUSH, "Being crushed"],
  [DamageFlag.CURSED_DOOR, "Cursed room doors"],
  [DamageFlag.DEVIL, "Devil deals"],
  [DamageFlag.EXPLOSION, "Explosions"],
  [DamageFlag.FAKE, "Fake damage sources"],
  [DamageFlag.FIRE, "Fire"],
  [DamageFlag.IGNORE_ARMOR, "Armor ignoring damage sources"],
  [DamageFlag.INVINCIBLE, "Invincible piercing damage sources"],
  [DamageFlag.ISSAC_HEART, "Isaac's Heart being hit"],
  [DamageFlag.IV_BAG, "IV Bag"],
  [DamageFlag.LASER, "Lasers"],
  [DamageFlag.NO_KILL, "Damage that does not kill"],
  [DamageFlag.NO_MODIFIERS, "Damage that is does not follow modifiers"],
  [DamageFlag.NO_PENALTIES, "Damage that has no penalties"],
  [DamageFlag.PITFALL, "Pitfalls"],
  [DamageFlag.POISON_BURN, "Poison or burns"],
  [DamageFlag.POOP, "Poop"],
  [DamageFlag.RED_HEARTS, "Red hearts"],
  [DamageFlag.SPAWN_BLACK_HEART, "Sources that spawn black hearts"],
  [DamageFlag.SPAWN_CARD, "Sources that spawn cards"],
  [DamageFlag.SPAWN_COIN, "Sources that spawn coins"],
  [DamageFlag.SPAWN_FLY, "Sources that spawn flies"],
  [DamageFlag.SPAWN_RED_HEART, "Sources that spawn red hearts"],
  [DamageFlag.SPAWN_RUNE, "Sources that spawn runes"],
  [
    DamageFlag.SPAWN_TEMP_HEART,
    "Sources that spawn disappearing half red hearts",
  ],
  [DamageFlag.SPIKES, "Spikes"],
  [DamageFlag.TIMER, "Timed sources"],
  [DamageFlag.TNT, "TNT"],
]);

export function damageFlagToString(damageFlag: DamageFlag): string {
  const text = DAMAGE_FLAG_TEXT_MAP.get(damageFlag);
  if (text !== undefined) {
    return text;
  }
  error("DamageFlagText: DamageFlag text cannot be found.");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\effectNameMap.ts`:

```````ts
import { EffectID } from "../../../enums/data/ID/EffectID";

const EFFECT_NAME_MAP: ReadonlyMap<EffectID, string> = new Map([
  [EffectID.WISP, "Wisp"],
  [EffectID.LEMON_MISHAP, "Lemon Mishap"],
  [EffectID.GRID_PROJECTILE_HELPER, "Grid Projectile Helper"],
  [EffectID.SIREN_CHARM_EFFECT, "Siren Charm Effect"],
  [EffectID.SPIKE_EFFECT, "Spike Effect"],
  [EffectID.TELEKINESIS_HALO, "Telekinesis Halo"],
  [EffectID.TRAP_DOOR_COVER, "Trap Door Cover"],
  [EffectID.COIN_PARTICLE, "Coin Particle"],
  [EffectID.BRIMSTONE_IMPACT_CAGE_VIS, "Brimstone Impact Cage Vis"],
  [EffectID.PLAYER_CREEP_BLACK_POWDER, "Black Powder Player Creep"],
  [EffectID.SCYTHE_BREAK, "Breaking Scythe"],
  [EffectID.STATIC_SPLASH_2, "Static Splash 2"],
  [EffectID.THORNS_HALO, "Halo of Thorns"],
  [EffectID.PICKUP_GHOST, "Pickup Ghost"],
  [EffectID.PORTAL_TELEPORT_PURPLE, "Purple Portal Teleport"],
  [EffectID.BRIMSTONE_SWIRL, "Brimstone Swirl"],
  [EffectID.BOMB_EXPLOSION, "Bomb Explosion"],
  [EffectID.SHOOP_IMPACT, "Shoop Impact"],
  [EffectID.HUSH_LASER, "Hush Laser"],
  [EffectID.FART, "Fart"],
  [
    EffectID.BLOOD_EXPLOSION_MEDIUM_WITH_LEFTOVER_BLOOD,
    "Medium Blood Explosion With Leftover Blood",
  ],
  [EffectID.BLOOD_EXPLOSION_MEDIUM, "Medium Blood Explosion"],
  [EffectID.MOTHER_TRACER, "Mother Tracer"],
  [EffectID.HUNGRY_SOUL, "Hungry Soul"],
  [EffectID.PLAYER_CREEP_BLACK, "Black Player Creep"],
  [EffectID.DICE_FLOOR_SIX_PIP, "Six Pip Dice Floor"],
  [EffectID.ENEMY_BRIMSTONE_SWIRL, "Enemy Brimstone Swirl"],
  [EffectID.MAGGOT, "Maggot"],
  [EffectID.FIREWORKS, "Fireworks"],
  [EffectID.LASER_IMPACT, "Laser Impact"],
  [EffectID.WOMB_HOLE_TELEPORT, "Womb Hole Teleport"],
  [EffectID.URN_OF_SOULS, "Urn Of Souls"],
  [EffectID.DEATH_SKULL, "Death Skull"],
  [EffectID.EYE_PARTICLE, "Eye Particle"],
  [EffectID.PORTAL_TELEPORT_RED, "Red Portal Teleport"],
  [EffectID.LADDER, "Ladder"],
  [EffectID.PLAYER_CREEP_HOLY_WATER_TRAIL, "Holy Water Trail Player Creep"],
  [EffectID.WALL_BUG, "Wall Bug"],
  [EffectID.LAVA_SPLASH, "Lava Splash"],
  [EffectID.BLOOD_EXPLOSION_LARGE, "Large Blood Explosion"],
  [EffectID.SHOCKWAVE_RANDOM, "Random Shockwave"],
  [EffectID.TOOTH_PARTICLE, "Tooth Particle"],
  [EffectID.BIG_KNIFE_PROJECTILE, "Big Knife Projectile"],
  [EffectID.BLOOD_SPLAT, "Blood Splat"],
  [EffectID.TAR_BUBBLE, "Tar Bubble"],
  [EffectID.LARGE_GROUND_POOF, "Large Ground Poof"],
  [EffectID.DIVINE_INTERVENTION, "Divine Intervention"],
  [EffectID.DOOR_OUTLINE, "Door Outline"],
  [EffectID.MOMS_HAND_EMERGENCY_CONTACT, "Emergency Contact Moms Hand"],
  [EffectID.LIGHT, "Light"],
  [EffectID.SHOCKWAVE_TRAIL, "Shockwave Trail"],
  [EffectID.BIG_ROCK_WAVE, "Big Rock Wave"],
  [EffectID.WHIRLPOOL, "Whirlpool"],
  [EffectID.HALO, "Halo"],
  [EffectID.BIG_HORN_HOLE_HELPER, "Big Horn Hole Helper"],
  [EffectID.MAGGOT_EXPLOSION, "Maggot Explosion"],
  [EffectID.ANGEL, "Angel"],
  [EffectID.POOF_01_SMALL, "Poof 01 Small"],
  [EffectID.MIST, "Mist"],
  [EffectID.MONSTROS_TOOTH, "Monstros Tooth"],
  [EffectID.CREEP_RED, "Red Creep"],
  [EffectID.LARGE_BLOOD_POOF, "Large Blood Poof"],
  [EffectID.HOLY_MANTLE_POOF, "Holy Mantle Poof"],
  [EffectID.ROCK_PARTICLE, "Rock Particle"],
  [EffectID.FORGOTTEN_SOUL_POOF, "Forgotten Soul Poof"],
  [EffectID.PENTAGRAM_BLACK_POWDER, "Pentagram Black Powder"],
  [EffectID.BONE_PARTICLE, "Bone Particle"],
  [EffectID.BRIMSTONE_IMPACT, "Brimstone Impact"],
  [EffectID.DIRT_PATCH, "Dirt Patch"],
  [EffectID.BLACK_HOLE_RAY, "Black Hole Ray"],
  [EffectID.LAVA_SPLASH_LARGE, "Lava Splash Large"],
  [EffectID.DOGMA_BLACK_HOLE, "Dogma Black Hole"],
  [EffectID.TIMER, "Timer"],
  [EffectID.SLIPPERY_BROWN_CREEP, "Slippery Brown Creep"],
  [EffectID.TEAR_POOF_B, "Tear Poof B"],
  [EffectID.TECH_SWORD_TEAR_POOF, "Tech Sword Tear Poof"],
  [EffectID.EVIL_EYE, "Evil Eye"],
  [EffectID.NAIL_PARTICLE, "Nail Particle"],
  [EffectID.BULLET_POOF_STATIC, "Static Bullet Poof"],
  [EffectID.DOGMA_ORB, "Dogma Orb"],
  [EffectID.FART_RING, "Fart Ring"],
  [EffectID.BIG_WATER_SPLASH, "Big Water Splash"],
  [EffectID.WORMWOOD_HOLE, "Wormwood Hole"],
  [EffectID.RING_IMPACT, "Ring Impact"],
  [EffectID.DR_FETUS_TARGET, "Dr Fetus Target"],
  [EffectID.BLOOD_EXPLOSION_SMALL, "Small Blood Explosion"],
  [EffectID.MOTHER_SHOCKWAVE, "Mother Shockwave"],
  [EffectID.TEAR_POOF_A_NO_TEAR, "Tear Poof A No Tear"],
  [EffectID.WORM, "Worm"],
  [EffectID.EFFECT_NOTIFICATION, "Effect Notification"],
  [EffectID.BOOMERANG, "Boomerang"],
  [EffectID.LARGE_GROUND_POOF_FOREGROUND, "Large Ground Poof Foreground"],
  [EffectID.GUT_PARTICLE, "Gut Particle"],
  [EffectID.COLOSTOMIA_PUDDLE, "Colostomia Puddle"],
  [EffectID.SMALL_WATER_RIPPLE, "Small Water Ripple"],
  [EffectID.UMBILICAL_CORD_HELPER, "Umbilical Cord Helper"],
  [EffectID.SLIPPERY_BROWN_CREEP_GROWING, "Growing Slippery Brown Creep"],
  [EffectID.REVERSE_EXPLOSION_DEBRIS, "Reverse Explosion Debris"],
  [EffectID.BROKEN_SHOVEL_SHADOW, "Broken Shovel Shadow"],
  [EffectID.HERETIC_PENTAGRAM, "Heretic Pentagram"],
  [EffectID.SWORD_TEAR_POOF, "Sword Tear Poof"],
  [EffectID.BEETLE, "Beetle"],
  [EffectID.FORGOTTEN_CHAIN, "Forgotten Chain"],
  [EffectID.EMBER_PARTICLE, "Ember Particle"],
  [EffectID.SHOCKWAVE_DIRECTIONAL, "Directional Shockwave"],
  [EffectID.SPRITE_TRAIL, "Sprite Trail"],
  [EffectID.BROWN_CREEP, "Brown Creep"],
  [EffectID.RIFT, "Rift"],
  [EffectID.MILK_PUDDLE, "Milk Puddle"],
  [EffectID.FIRE_JET, "Fire Jet"],
  [EffectID.WALL_HOLE_XRAY, "Wall Hole Xray"],
  [EffectID.FART_WAVE, "Fart Wave"],
  [EffectID.PLAYER_CREEP_HOLY_WATER, "Holy Water Player Creep"],
  [EffectID.CREEP_STATIC, "Static Creep"],
  [EffectID.SHOCKWAVE_RING, "Shockwave Ring"],
  [EffectID.BIG_BRIMSTONE_IMPACT, "Big Brimstone Impact"],
  [EffectID.BACKDROP_DECORATION, "Backdrop Decoration"],
  [EffectID.BLACK_HOLE, "Black Hole"],
  [EffectID.WATER_DROPLET, "Water Droplet"],
  [EffectID.PORTAL_TELEPORT_BLUE, "Blue Portal Teleport"],
  [EffectID.BLOOD_CLOUD, "Blood Cloud"],
  [EffectID.TALL_LADDER, "Tall Ladder"],
  [EffectID.BIG_ROCK_EXPLOSION, "Big Rock Explosion"],
  [EffectID.DOGMA_DEBRIS, "Dogma Debris"],
  [EffectID.BIG_HORN_HAND, "Big Horn Hand"],
  [EffectID.PLAYER_CREEP_RED, "Red Player Creep"],
  [EffectID.TEAR_POOF_VERY_SMALL, "Very Small Tear Poof"],
  [EffectID.REVERSE_EXPLOSION, "Reverse Explosion"],
  [EffectID.SPAWNER, "Spawner"],
  [EffectID.GIDEON_ATTRACT_TRAIL, "Gideon Attract Trail"],
  [EffectID.LEECH_EXPLOSION, "Leech Explosion"],
  [EffectID.CURSE_HALO, "Cursed Halo"],
  [EffectID.MOM_FOOT_STOMP, "Moms Foot Stomp"],
  [EffectID.BOUNCING_IMPACT, "Bouncing Impact"],
  [EffectID.DARK_ARTS_HALO, "Dark Arts Halo"],
  [EffectID.FORGOTTEN_SOUL, "Forgotten Soul"],
  [EffectID.HAEMOLACRIA_TRAIL, "Haemolacria Trail"],
  [EffectID.KINETI_BEAM, "Kineti Beam"],
  [EffectID.SPEAR_OF_DESTINY, "Spear Of Destiny"],
  [EffectID.LIL_GHOST, "Lil Ghost"],
  [EffectID.BRIMSTONE_IMPACT_POOP, "Brimstone Impact Poop"],
  [EffectID.STATIC_HALO_PRERENDERED, "Prerendered Static Halo"],
  [EffectID.SHOP_SPIKES, "Shop Spikes"],
  [EffectID.SIREN_RING, "Siren Ring"],
  [EffectID.LARGE_BLOOD_EXPLOSION, "Large Blood Explosion"],
  [EffectID.HORNFEL_ROOM_CONTROLLER, "Hornfel Room Controller"],
  [EffectID.BRIMSTONE_BALL, "Brimstone Ball"],
  [EffectID.WATER_SPLASH, "Water Splash"],
  [EffectID.BAR_PARTICLE, "Bar Particle"],
  [EffectID.ENEMY_GHOST, "Enemy Ghost"],
  [EffectID.WILLO_SPAWNER, "Willo Spawner"],
  [EffectID.DEVIL, "Devil"],
  [EffectID.BUTTERFLY, "Butterfly"],
  [EffectID.FIRE_JET_PURPLE, "Purple Fire Jet"],
  [EffectID.CRACK_WAVE, "Crack Wave"],
  [EffectID.WORMWOOD_HOLE_SPRAY, "Wormwood Hole Spray"],
  [EffectID.FIRE_WAVE, "Fire Wave"],
  [EffectID.ISAACS_CARPET, "Isaacs Carpet"],
  [EffectID.TECH_DOT, "Tech Dot"],
  [EffectID.DR_FETUS_ROCKET, "Dr Fetus Rocket"],
  [EffectID.MOMS_CARPET_2, "Moms Carpet 2"],
  [EffectID.BISHOP_SHIELD, "Bishop Shield"],
  [EffectID.IMPACT, "Impact"],
  [EffectID.HUSH_LASER_UP, "Hush Laser Up"],
  [EffectID.BULLET_POOF, "Bullet Poof"],
  [EffectID.RED_FLAME, "Red Flame"],
  [EffectID.GROUND_GLOW, "Ground Glow"],
  [EffectID.URN_OF_SOULS_BELIAL, "Urn Of Souls Belial"],
  [EffectID.MAMA_MEGA_EXPLOSION, "Mama Mega Explosion"],
  [EffectID.POOF_01_LARGE, "Large Poof 01"],
  [EffectID.PURGATORY_RIFT, "Purgatory Rift"],
  [EffectID.BROWN_CLOUD, "Brown Cloud"],
  [EffectID.CREEP_YELLOW, "Yellow Creep"],
  [EffectID.TINY_FLY, "Tiny Fly"],
  [EffectID.BATTERY_UP, "Battery Up"],
  [EffectID.WHIRLPOOL_PARTICLE, "Whirlpool Particle"],
  [EffectID.PLAYER_CREEP_WHITE, "White Player Creep"],
  [EffectID.ANIMA_CHAIN, "Anima Chain"],
  [EffectID.FISSURE_SPAWNER, "Fissure Spawner"],
  [EffectID.POOP_EXPLOSION, "Poop Explosion"],
  [EffectID.STATIC_SPLASH, "Static Splash"],
  [EffectID.LEECH, "Leech"],
  [EffectID.BLOOD_GUSH, "Blood Gush"],
  [EffectID.PURGATORY_SOUL, "Purgatory Soul"],
  [EffectID.DICE_FLOOR_FIVE_PIP, "Five Pip Dice Floor"],
  [EffectID.MOMS_CARPET_1, "Moms Carpet 1"],
  [EffectID.ROCK_TEAR_POOF, "Rock Tear Poof"],
  [EffectID.BOMB_CRATER, "Bomb Crater"],
  [EffectID.CREEP_GREEN, "Green Creep"],
  [EffectID.CREEP_BLACK, "Black Creep"],
  [EffectID.TEAR_POOF_SMALL, "Small Tear Poof"],
  [EffectID.ULTRA_GREED_FOOTPRINT, "Ultra Greed Footprint"],
  [EffectID.STATIC_HALO, "Static Halo"],
  [EffectID.EXPLOSION_WAVE, "Explosion Wave"],
  [EffectID.BLOODY_KEY_TEAR_POOF, "Bloody Key Tear Poof"],
  [EffectID.BLOOD_PARTICLE, "Blood Particle"],
  [EffectID.BLOOD_DROP, "Blood Drop"],
  [EffectID.WATER_RIPPLE, "Water Ripple"],
  [EffectID.HALLOWED_GROUND, "Hallowed Ground"],
  [EffectID.REDEMPTION, "Redemption"],
  [EffectID.POOF_01_NORMAL, "Normal Poof 01"],
  [EffectID.WORM_FRIEND_SNARE, "Worm Friend Snare"],
  [EffectID.DEAD_BIRD, "Dead Bird"],
  [EffectID.MOONLIGHT, "Moonlight"],
  [EffectID.RAIN_DROP, "Rain Drop"],
  [EffectID.LAVA_SPAWNER, "Lava Spawner"],
  [EffectID.TINY_BUG, "Tiny Bug"],
  [EffectID.ENEMY_SOUL_BELIAL, "Enemy Soul Belial"],
  [EffectID.ENEMY_SOUL, "Enemy Soul"],
  [EffectID.SPIDER_EXPLOSION, "Spider Explosion"],
  [EffectID.DARK_BALL_SMOKE_PARTICLE, "Dark Ball Smoke Particle"],
  [EffectID.FRIENDLY_BALL, "Friendly Ball"],
  [EffectID.TEAR_POOF_A, "Tear Poof A"],
  [EffectID.SIREN_CHARM_GLOW, "Glowing Siren Charm"],
  [EffectID.ULTRA_GREED_BLING, "Ultra Greed Bling"],
  [EffectID.GIDEON_ATTRACT_RING, "Gideon Attract Ring"],
  [EffectID.HEAVEN_DOOR, "Heaven Door"],
  [EffectID.DICE_FLOOR_ONE_PIP, "One Pip Dice Floor"],
  [EffectID.FLY_EXPLOSION, "Fly Explosion"],
  [EffectID.CLEAVER_SLASH, "Cleaver Slash"],
  [EffectID.KEY_TEAR_POOF, "Key Tear Poof"],
  [EffectID.SMALL_ROCKET, "Small Rocket"],
  [EffectID.LARGE_BLOOD_POOF_FOREGROUND, "Large Blood Poof Foreground"],
  [EffectID.DICE_FLOOR_TWO_PIP, "Two Pip Dice Floor"],
  [EffectID.CRACKED_ORB_POOF, "Cracked Orb Poof"],
  [EffectID.FIRE, "Fire"],
  [EffectID.DICE_FLOOR_FOUR_PIP, "Four Pip Dice Floor"],
  [EffectID.WOOD_PARTICLE, "Wood Particle"],
  [EffectID.CHAIN_LIGHTNING, "Chain Lightning"],
  [EffectID.FALLING_EMBER, "Falling Ember"],
  [EffectID.POOF_02, "Poof 02"],
  [EffectID.BLOOD_EXPLOSION_SWIRL, "Swirly Blood Explosion"],
  [EffectID.TADPOLE, "Tadpole"],
  [EffectID.CHAIN_GIB, "Chain Gib"],
  [EffectID.SATURNUS_HALO, "Saturnus Halo"],
  [EffectID.TEAR_CREEP_GREEN, "Green Tear Creep"],
  [EffectID.PORTAL_TELEPORT_YELLOW, "Yellow Portal Teleport"],
  [EffectID.STAIRWAY, "Stairway"],
  [EffectID.DIAMOND_PARTICLE, "Diamond Particle"],
  [EffectID.POOP_PARTICLE, "Poop Particle"],
  [EffectID.OCCULT_TARGET, "Occult Target"],
  [EffectID.DIRT_PILE, "Dirt Pile"],
  [EffectID.CREEP_WHITE, "White Creep"],
  [EffectID.DICE_FLOOR_THREE_PIP, "Three Pip Dice Floor"],
  [EffectID.RIPPLE_POOF, "Ripple Poof"],
  [EffectID.DARK_SNARE, "Dark Snare"],
  [EffectID.SMOKE_CLOUD, "Smoke Cloud"],
  [EffectID.PULLING_EFFECT, "Pulling Effect"],
  [EffectID.DUST_CLOUD, "Dust Cloud"],
  [EffectID.BLOOD_EXPLOSION_GIANT, "Giant Blood Explosion"],
  [EffectID.PEDESTAL_RIPPLE, "Pedestal Ripple"],
  [EffectID.ROCK_EXPLOSION, "Rock Explosion"],
  [EffectID.CRACK_THE_SKY, "Crack The Sky"],
  [EffectID.GENERIC_TRACER, "Generic Tracer"],
  [EffectID.SHOCKWAVE_RADIAL, "Radial Shockwave"],
  [EffectID.LEMON_PARTY, "Lemon Party"],
  [EffectID.ULTRA_DEATH_SCYTHE, "Ultra Death Scythe"],
  [EffectID.LIQUID_POOP_CREEP, "Liquid Poop Creep"],
  [EffectID.MR_ME, "Mr Me"],
  [EffectID.POOF_04, "Poof 04"],
  [EffectID.HUSH_ASHES, "Hush Ashes"],
  [EffectID.TRINITY_SHIELD, "Trinity Shield"],
  [EffectID.BLUE_FLAME, "Blue Flame"],
  [EffectID.MONSTRANCE_HALO, "Monstrance Halo"],
]);

export function getNonModdedEffectName(effectID: EffectID): string | undefined {
  return EFFECT_NAME_MAP.get(effectID);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\entityCategoryNameMap.ts`:

```````ts
import { EntityCategory } from "../../../enums/general/EntityCategory";

const ENTITY_CATEGORY_NAME_MAP: ReadonlyMap<EntityCategory, string> = new Map([
  [EntityCategory.FAMILIAR, "Familiar"],
  [EntityCategory.TEAR, "Tear"],
  [EntityCategory.BOMB, "Bomb"],
  [EntityCategory.KNIFE, "Knife"],
  [EntityCategory.LASER, "Laser"],
  [EntityCategory.NPC, "Enemy"],
  [EntityCategory.PROJECTILE, "Projectile"],
  [EntityCategory.PICKUP, "Pickup"],
  [EntityCategory.PLAYER, "Player"],
  [EntityCategory.EFFECT, "Effect"],
  [EntityCategory.SLOT, "Slot"],
]);

/**
 * Convert an EntityCategory to a string value.
 *
 * @example `entityCategoryToString(EntityCategory.FAMILIAR)` returns `"Familiar"`.
 */
export function entityCategoryToString(entityCategory: EntityCategory): string {
  const entityCategoryName = ENTITY_CATEGORY_NAME_MAP.get(entityCategory);
  if (entityCategoryName === undefined) {
    error(`Unknown EntityCategory '${entityCategory}'`);
  }

  return entityCategoryName;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\familiarNameMap.ts`:

```````ts
import { FamiliarID } from "../../../enums/data/ID/FamiliarID";

const FAMILIAR_NAME_MAP: ReadonlyMap<FamiliarID, string> = new Map([
  [FamiliarID.BOT_FLY, "Bot Fly"],
  [FamiliarID.RAINBOW_BABY, "Rainbow Baby"],
  [FamiliarID.WISP_FAMILIAR, "Wisp Familiar"],
  [FamiliarID.LIL_LOKI, "Lil Loki"],
  [FamiliarID.GUILLOTINE, "Guillotine"],
  [FamiliarID.DIP_FAMILIAR_BROWNIE, "Dip Familiar Brownie"],
  [FamiliarID.BBF, "Bbf"],
  [FamiliarID.FARTING_BABY, "Farting Baby"],
  [FamiliarID.DRY_BABY, "Dry Baby"],
  [FamiliarID.SUCCUBUS, "Succubus"],
  [FamiliarID.JAW_BONE, "Jaw Bone"],
  [FamiliarID.ABYSS_LOCUST, "Abyss Locust"],
  [FamiliarID.ISAACS_BODY, "Isaacs Body"],
  [FamiliarID.VANISHING_TWIN, "Vanishing Twin"],
  [FamiliarID.DIP_FAMILIAR_WHITE, "Dip Familiar White"],
  [FamiliarID.ISAACS_HEART, "Isaacs Heart"],
  [FamiliarID.ANGRY_FLY, "Angry Fly"],
  [FamiliarID.FRIEND_ZONE, "Friend Zone"],
  [FamiliarID.JUICY_SACK, "Juicy Sack"],
  [FamiliarID.HOLY_WATER, "Holy Water"],
  [FamiliarID.KING_BABY, "King Baby"],
  [FamiliarID.MOMS_RAZOR, "Moms Razor"],
  [FamiliarID.SACK_OF_PENNIES, "Sack Of Pennies"],
  [FamiliarID.DEAD_CAT, "Dead Cat"],
  [FamiliarID.BALL_OF_BANDAGES_L2, "Ball Of Bandages L2"],
  [FamiliarID.KEY_BUM, "Key Bum"],
  [FamiliarID.LIL_SPEWER, "Lil Spewer"],
  [FamiliarID.PUNCHING_BAG, "Punching Bag"],
  [FamiliarID.RUNE_BAG, "Rune Bag"],
  [FamiliarID.MINISAAC, "Minisaac"],
  [FamiliarID.BOMB_BAG, "Bomb Bag"],
  [FamiliarID.FULL_KNIFE, "Full Knife"],
  [FamiliarID.FORGOTTEN_BODY, "Forgotten Body"],
  [FamiliarID.ROBO_BABY, "Robo Baby"],
  [FamiliarID.SUPER_BUM, "Super Bum"],
  [FamiliarID.HARLEQUIN_BABY, "Harlequin Baby"],
  [FamiliarID.MILK, "Milk"],
  [FamiliarID.BIG_CHUBBY, "Big Chubby"],
  [FamiliarID.GB_BUG, "Gb Bug"],
  [FamiliarID.DIP_FAMILIAR_STINKY, "Dip Familiar Stinky"],
  [FamiliarID.ABEL, "Abel"],
  [FamiliarID.LIL_MONSTRO, "Lil Monstro"],
  [FamiliarID.DIP_FAMILIAR_BLACK, "Dip Familiar Black"],
  [FamiliarID.BLUE_BABY_SOUL, "Blue Baby Soul"],
  [FamiliarID.DIP_FAMILIAR_GOLD, "Dip Familiar Gold"],
  [FamiliarID.CUBE_OF_MEAT_L1, "Cube Of Meat L1"],
  [FamiliarID.LIL_HARBINGERS, "Lil Harbingers"],
  [FamiliarID.CUBE_BABY, "Cube Baby"],
  [FamiliarID.GEMINI_FAMILIAR, "Gemini Familiar"],
  [FamiliarID.THE_RELIC, "The Relic"],
  [FamiliarID.FOREVER_ALONE, "Forever Alone"],
  [FamiliarID.CUBE_OF_MEAT_L2, "Cube Of Meat L2"],
  [FamiliarID.INCUBUS, "Incubus"],
  [FamiliarID.BUMBO, "Bumbo"],
  [FamiliarID.BONE_ORBITAL, "Bone Orbital"],
  [FamiliarID.BIG_FAN, "Big Fan"],
  [FamiliarID.FREEZER_BABY, "Freezer Baby"],
  [FamiliarID.ROTTEN_BABY, "Rotten Baby"],
  [FamiliarID.LITTLE_STEVE, "Little Steve"],
  [FamiliarID.LITTLE_GISH, "Little Gish"],
  [FamiliarID.ESAU_JR, "Esau Jr"],
  [FamiliarID.DEPRESSION, "Depression"],
  [FamiliarID.SCISSORS, "Scissors"],
  [FamiliarID.SIREN_MINION, "Siren Minion"],
  [FamiliarID.SPIN_TO_WIN, "Spin To Win"],
  [FamiliarID.INTRUDER, "Intruder"],
  [FamiliarID.SWARM_FLY_ORBITAL, "Swarm Fly Orbital"],
  [FamiliarID.MYSTERY_EGG, "Mystery Egg"],
  [FamiliarID.SPRINKLER, "Sprinkler"],
  [FamiliarID.POINTY_RIB, "Pointy Rib"],
  [FamiliarID.DIP_FAMILIAR, "Dip Familiar"],
  [FamiliarID.BALL_OF_BANDAGES_L3, "Ball Of Bandages L3"],
  [FamiliarID.DEMON_BABY, "Demon Baby"],
  [FamiliarID.BALL_OF_BANDAGES_L4, "Ball Of Bandages L4"],
  [FamiliarID.SPIDER_MOD, "Spider Mod"],
  [FamiliarID.DEAD_BIRD_PERMANENT, "Dead Bird Permanent"],
  [FamiliarID.DIP_FAMILIAR_RED, "Dip Familiar Red"],
  [FamiliarID.BABY_PLUM_FAMILIAR, "Baby Plum Familiar"],
  [FamiliarID.BROTHER_BOBBY, "Brother Bobby"],
  [FamiliarID.STAR_OF_BETHLEHEM, "Star Of Bethlehem"],
  [FamiliarID.BLOOD_BABY, "Blood Baby"],
  [FamiliarID.BUM_FIEND, "Bum Fiend"],
  [FamiliarID.ITEM_WISP_FAMILIAR, "Item Wisp Familiar"],
  [FamiliarID.UMBILICAL_BABY, "Umbilical Baby"],
  [FamiliarID.LIL_BRIMSTONE, "Lil Brimstone"],
  [FamiliarID.TWISTED_BABY_2, "Twisted Baby 2"],
  [FamiliarID.TWISTED_BABY_1, "Twisted Baby 1"],
  [FamiliarID.LOST_FLY, "Lost Fly"],
  [FamiliarID.SACK_OF_SACKS, "Sack Of Sacks"],
  [FamiliarID.PAPA_FLY, "Papa Fly"],
  [FamiliarID.WORM_FRIEND, "Worm Friend"],
  [FamiliarID.LIL_ABADDON, "Lil Abaddon"],
  [FamiliarID.BETHS_HEART, "Beths Heart"],
  [FamiliarID.DISTANT_ADMIRATION, "Distant Admiration"],
  [FamiliarID.FRUITY_PLUM, "Fruity Plum"],
  [FamiliarID.FINGER, "Finger"],
  [FamiliarID.BOILED_BABY, "Boiled Baby"],
  [FamiliarID.LITTLE_CHUBBY, "Little Chubby"],
  [FamiliarID.DECAP_ATTACK, "Decap Attack"],
  [FamiliarID.HUSHY, "Hushy"],
  [FamiliarID.STITCHES, "Stitches"],
  [FamiliarID.PASCHAL_CANDLE, "Paschal Candle"],
  [FamiliarID.TINYTOMA_SMALL, "Tinytoma Small"],
  [FamiliarID.PEEPERS_OTHER_EYE, "Peepers Other Eye"],
  [FamiliarID.ROBO_BABY_20, "Robo Baby 20"],
  [FamiliarID.CUBE_OF_MEAT_L3, "Cube Of Meat L3"],
  [FamiliarID.TINYTOMA, "Tinytoma"],
  [FamiliarID.PSY_FLY, "Psy Fly"],
  [FamiliarID.BOX_BUDDY, "Box Buddy"],
  [FamiliarID.KNIFE_PIECE_2, "Knife Piece 2"],
  [FamiliarID.KNIFE_PIECE_1, "Knife Piece 1"],
  [FamiliarID.LIL_DUMPY, "Lil Dumpy"],
  [FamiliarID.LOST_SOUL, "Lost Soul"],
  [FamiliarID.BIRD_CAGE, "Bird Cage"],
  [FamiliarID.MENORAH, "Menorah"],
  [FamiliarID.CENSER, "Censer"],
  [FamiliarID.BROWN_NUGGET, "Brown Nugget"],
  [FamiliarID.CHARGED_BABY, "Charged Baby"],
  [FamiliarID.BLOOD_OATH, "Blood Oath"],
  [FamiliarID.DAMOCLES, "Damocles"],
  [FamiliarID.S_ONLY_FRIEND, "S Only Friend"],
  [FamiliarID.MONGO_BABY, "Mongo Baby"],
  [FamiliarID.LIL_GURDY, "Lil Gurdy"],
  [FamiliarID.DIP_FAMILIAR_FLAMING, "Dip Familiar Flaming"],
  [FamiliarID.HEADLESS_BABY, "Headless Baby"],
  [FamiliarID.DIP_FAMILIAR_STONE, "Dip Familiar Stone"],
  [FamiliarID.EVES_BIRD_FOOT, "Eves Bird Foot"],
  [FamiliarID.FULL_KEY, "Full Key"],
  [FamiliarID.MULTIDIMENSIONAL_BABY, "Multidimensional Baby"],
  [FamiliarID.PEEPERS_EYE, "Peepers Eye"],
  [FamiliarID.SAMSONS_CHAINS, "Samsons Chains"],
  [FamiliarID.GHOST_BABY, "Ghost Baby"],
  [FamiliarID.SWORN_PROTECTOR, "Sworn Protector"],
  [FamiliarID.FATES_REWARD, "Fates Reward"],
  [FamiliarID.BOBS_BRAIN, "Bobs Brain"],
  [FamiliarID.DIP_FAMILIAR_CORNY, "Dip Familiar Corny"],
  [FamiliarID.ANGELIC_PRISM, "Angelic Prism"],
  [FamiliarID.DIP_FAMILIAR_RAINBOW, "Dip Familiar Rainbow"],
  [FamiliarID.CUBE_OF_MEAT_L4, "Cube Of Meat L4"],
  [FamiliarID.LITTLE_CHAD, "Little Chad"],
  [FamiliarID.GUPPYS_HAIR_BALL, "Guppys Hair Ball"],
  [FamiliarID.CAINS_EYE, "Cains Eye"],
  [FamiliarID.SHADE, "Shade"],
  [FamiliarID.LEPROCY, "Leprocy"],
  [FamiliarID.KNIFE_PIECE_3, "Knife Piece 3"],
  [FamiliarID.ISAACS_HEAD, "Isaacs Head"],
  [FamiliarID.GUARDIAN_ANGEL, "Guardian Angel"],
  [FamiliarID.BONE_SPUR, "Bone Spur"],
  [FamiliarID.ACID_BABY, "Acid Baby"],
  [FamiliarID.SISSY_LONGLEGS, "Sissy Longlegs"],
  [FamiliarID.LIL_CHEST, "Lil Chest"],
  [FamiliarID.SPIDER_BABY, "Spider Baby"],
  [FamiliarID.ONE_UP, "One Up"],
  [FamiliarID.SISTER_MAGGY, "Sister Maggy"],
  [FamiliarID.SMART_FLY, "Smart Fly"],
  [FamiliarID.BEST_BUD, "Best Bud"],
  [FamiliarID.OBSESSED_FAN, "Obsessed Fan"],
  [FamiliarID.SERAPHIM, "Seraphim"],
  [FamiliarID.YO_LISTEN, "Yo Listen"],
  [FamiliarID.SLIPPED_RIB, "Slipped Rib"],
  [FamiliarID.TONSIL, "Tonsil"],
  [FamiliarID.KEY_PIECE_1, "Key Piece 1"],
  [FamiliarID.DADDY_FOOT, "Daddy Foot"],
  [FamiliarID.MYSTERY_SACK, "Mystery Sack"],
  [FamiliarID.KEY_PIECE_2, "Key Piece 2"],
  [FamiliarID.FLY_ORBITAL, "Fly Orbital"],
  [FamiliarID.SACRIFICIAL_DAGGER, "Sacrificial Dagger"],
  [FamiliarID.DARK_BUM, "Dark Bum"],
  [FamiliarID.BLUE_SPIDER, "Blue Spider"],
  [FamiliarID.BALL_OF_BANDAGES_L1, "Ball Of Bandages L1"],
]);

export function getNonModdedFamiliarIDName(
  familiarID: FamiliarID,
): string | undefined {
  return FAMILIAR_NAME_MAP.get(familiarID);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\gridEntityTypeNameMap.ts`:

```````ts
import { GridEntityType } from "isaac-typescript-definitions";

const GRID_ENTITY_TYPE_NAME_MAP: ReadonlyMap<GridEntityType, string> = new Map([
  [GridEntityType.BLOCK, "Block"],
  [GridEntityType.ROCK, "Rock"],
  [GridEntityType.PIT, "Pit"],
  [GridEntityType.SPIKES, "Spikes"],
  [GridEntityType.SPIKES_ON_OFF, "On-Off Spikes"],
  [GridEntityType.SPIDER_WEB, "Spider Web"],
  [GridEntityType.LOCK, "Lock"],
  [GridEntityType.TNT, "TNT"],
  [GridEntityType.FIREPLACE, "Fireplace"],
  [GridEntityType.POOP, "Poop"],
  [GridEntityType.WALL, "Wall"],
  [GridEntityType.DOOR, "Door"],
  [GridEntityType.CRAWL_SPACE, "Crawl Space"],
  [GridEntityType.GRAVITY, "Gravity"],
  [GridEntityType.PRESSURE_PLATE, "Pressure Plate"],
  [GridEntityType.ROCK_ALT, "Alt Rock"],
  [GridEntityType.ROCK_BOMB, "Bomb Rock"],
  [GridEntityType.ROCK_TINTED, "Tinted Rock"],
  [GridEntityType.ROCK_ALT_2, "Alt Rock 2"],
  [GridEntityType.PILLAR, "Pillar"],
  [GridEntityType.DECORATION, "Decoration"],
  [GridEntityType.STATUE, "Statue"],
  [GridEntityType.ROCK_GOLD, "Gold Rock"],
  [GridEntityType.ROCK_SPIKED, "Spiked Rock"],
  [GridEntityType.ROCK_SUPER_SPECIAL, "Super Special Rock"],
  [GridEntityType.TELEPORTER, "Teleporter"],
  [GridEntityType.TRAPDOOR, "Trapdoor"],
]);

/** Get the name of a grid entity type. This may refer to multiple types of grid entities. */
export function gridEntityTypeToString(gridEntityType: GridEntityType): string {
  const gridEntityTypeName = GRID_ENTITY_TYPE_NAME_MAP.get(gridEntityType);
  if (gridEntityTypeName === undefined) {
    error(`Unknown grid entity type: ${gridEntityType}`);
  }

  return gridEntityTypeName;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\gridIDNameMap.ts`:

```````ts
import { GridID } from "../../../enums/data/ID/GridID";

const gridIDNameMap = new Map<GridID, string>([
  [GridID.NULL, "Null"],
  [GridID.DECORATION, "Decoration"],
  [GridID.ROCK, "Rock"],
  [GridID.EVENT_ROCK, "Event Rock"],
  [GridID.BLOCK, "Block"],
  [GridID.ROCK_TINTED, "Tinted Rock"],
  [GridID.ROCK_BOMB, "Bomb Rock"],
  [GridID.ROCK_ALT, "Alt Rock"],
  [GridID.PIT, "Pit"],
  [GridID.PIT_FISSURE_SPAWNER, "Fissure Spawner Pit"],
  [GridID.SPIKES, "Spikes"],
  [GridID.SPIKES_ON_OFF, "On-Off Spikes"],
  [GridID.SPIDER_WEB, "Spider Web"],
  [GridID.LOCK, "Lock"],
  [GridID.TNT, "Tnt"],
  [GridID.FIREPLACE, "Normal Fireplace"],
  [GridID.FIREPLACE_RED, "Red Fireplace"],
  [GridID.POOP, "Normal Poop"],
  [GridID.POOP_RED, "Red Poop"],
  [GridID.POOP_CORNY, "Corny Poop"],
  [GridID.POOP_GOLDEN, "Golden Poop"],
  [GridID.POOP_RAINBOW, "Rainbow Poop"],
  [GridID.POOP_BLACK, "Black Poop"],
  [GridID.POOP_WHITE, "White Poop"],
  [GridID.POOP_GIANT_TOP_LEFT, "Giant Poop"],
  [GridID.POOP_GIANT_TOP_RIGHT, "Giant Poop"],
  [GridID.POOP_GIANT_BOTTOM_LEFT, "Giant Poop"],
  [GridID.POOP_GIANT_BOTTOM_RIGHT, "Giant Poop"],
  [GridID.POOP_CHARMING, "Charming Poop"],
  [GridID.WALL, "Wall"],
  [GridID.DOOR, "Door"],
  [GridID.DOOR_LOCKED, "Locked Door"],
  [GridID.DOOR_LOCKED_DOUBLE, "Double Locked Door"],
  [GridID.DOOR_LOCKED_CRACKED, "Cracked Locked Door"],
  [GridID.DOOR_LOCKED_BARRED, "Barred Locked Door"],
  [GridID.DOOR_LOCKED_KEY_FAMILIAR, "Mega Satan Locked Door"],
  [GridID.DOOR_LOCKED_GREED, "Greed Locked Door"],
  [GridID.DOOR_HIDDEN, "Hidden Door"],
  [GridID.DOOR_UNLOCKED, "Unlocked Door"],
  [GridID.TRAPDOOR, "Trapdoor"],
  [GridID.VOID_PORTAL, "Void Portal"],
  [GridID.CRAWL_SPACE, "Crawl Space"],
  [GridID.CRAWL_SPACE_GREAT_GIDEON, "Gideon Great Crawl Space"],
  [GridID.CRAWL_SPACE_SECRET_SHOP, "Secret Shop Crawl Space"],
  [
    GridID.CRAWL_SPACE_PASSAGE_TO_BEGINNING_OF_FLOOR,
    "Floor Of Beginning To Passage Space Crawl",
  ],
  [GridID.CRAWL_SPACE_NULL, "Null Crawl Space"],
  [GridID.GRAVITY, "Gravity"],
  [GridID.PRESSURE_PLATE, "Pressure Plate"],
  [GridID.REWARD_PLATE, "Reward Plate"],
  [GridID.GREED_PLATE, "Greed Plate"],
  [GridID.RAIL_PLATE, "Rail Plate"],
  [GridID.KILL_ALL_ENEMIES_PLATE, "Plate That Kills All Enemies"],
  [GridID.SPAWN_ROCKS_PLATE, "Plate That Spawns Rocks"],
  [GridID.STATUE_DEVIL, "Devil Statue"],
  [GridID.STATUE_ANGEL, "Angel Statue"],
  [GridID.ROCK_SUPER_SPECIAL, "Super Special Rock"],
  [GridID.TELEPORTER, "Teleporter"],
  [GridID.PILLAR, "Pillar"],
  [GridID.ROCK_SPIKED, "Spiked Rock"],
  [GridID.ROCK_FOOL_CARD, "Fool Card Rock"],
  [GridID.ROCK_GOLD, "Gold Rock"],
]);

/**
 * Converts a GridID into a name value (which will be its name).
 *
 * @param gridID The GridID to convert.
 *
 * @example gridIDToString(GridID.ROCK) // "rock"
 */
export function gridIDToString(gridID: GridID): string {
  const name = gridIDNameMap.get(gridID);
  if (name === undefined) {
    error(`No name for GridID ${gridID}`);
  }

  return name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\itemConfigChargeTypeNameMap.ts`:

```````ts
import { ItemConfigChargeType } from "isaac-typescript-definitions";

const itemConfigChargeTypeTextMap = new Map<ItemConfigChargeType, string>([
  [ItemConfigChargeType.NORMAL, "Normal"],
  [ItemConfigChargeType.TIMED, "Timed"],
  [ItemConfigChargeType.SPECIAL, "Special"],
]);

/** Convert a ItemConfigChargeType value to a text value. */
export function itemConfigChargeTypeToString(
  chargeType: ItemConfigChargeType,
): string {
  const chargeTypeText = itemConfigChargeTypeTextMap.get(chargeType);
  return chargeTypeText ?? "Unknown Charge Type";
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\itemPoolTypeNameMap.ts`:

```````ts
import { ItemPoolType } from "isaac-typescript-definitions";

const itemPoolTypeTextMap = new Map<ItemPoolType, string>([
  [ItemPoolType.TREASURE, "Treasure Room"],
  [ItemPoolType.SHOP, "Shop"],
  [ItemPoolType.BOSS, "Boss Room"],
  [ItemPoolType.DEVIL, "Devil Room"],
  [ItemPoolType.ANGEL, "Angel Room"],
  [ItemPoolType.SECRET, "Secret Room"],
  [ItemPoolType.LIBRARY, "Library"],
  [ItemPoolType.SHELL_GAME, "Shell Game"],
  [ItemPoolType.GOLDEN_CHEST, "Golden Chest"],
  [ItemPoolType.RED_CHEST, "Red Chest"],
  [ItemPoolType.BEGGAR, "Beggar"],
  [ItemPoolType.DEMON_BEGGAR, "Demon Beggar"],
  [ItemPoolType.CURSE, "Curse Room"],
  [ItemPoolType.KEY_MASTER, "Key Master"],
  [ItemPoolType.BATTERY_BUM, "Battery Bum"],
  [ItemPoolType.MOMS_CHEST, "Mom's Chest"],
  [ItemPoolType.GREED_TREASURE, "Greed Treasure Room"],
  [ItemPoolType.GREED_BOSS, "Greed Boss Room"],
  [ItemPoolType.GREED_SHOP, "Greed Shop"],
  [ItemPoolType.GREED_DEVIL, "Greed Devil Room"],
  [ItemPoolType.GREED_ANGEL, "Greed Angel Room"],
  [ItemPoolType.GREED_CURSE, "Greed Curse Room"],
  [ItemPoolType.GREED_SECRET, "Greed Secret Room"],
  [ItemPoolType.CRANE_GAME, "Crane Game"],
  [ItemPoolType.ULTRA_SECRET, "Ultra Secret Room"],
  [ItemPoolType.BOMB_BUM, "Bomb Bum"],
  [ItemPoolType.PLANETARIUM, "Planetarium"],
  [ItemPoolType.OLD_CHEST, "Old Chest"],
  [ItemPoolType.BABY_SHOP, "Baby Shop"],
  [ItemPoolType.WOODEN_CHEST, "Wooden Chest"],
  [ItemPoolType.ROTTEN_BEGGAR, "Rotten Beggar"],
]);

/**
 * Convert an ItemPoolType to a text string.
 *
 * @example itemPoolTypeToText(ItemPoolType.TREASURE) // "Treasure Room".
 */
export function itemPoolTypeToString(itemPoolType: ItemPoolType): string {
  const itemPoolTypeText = itemPoolTypeTextMap.get(itemPoolType);
  return itemPoolTypeText ?? "Unknown Item Pool Type";
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\itemTagNameMap.ts`:

```````ts
import { ItemConfigTag, ItemType } from "isaac-typescript-definitions";

const itemTagNameMap: Record<ItemConfigTag, string> = {
  [ItemConfigTag.ANGEL]: "Is an angel item",
  [ItemConfigTag.BABY]: "Is a baby Item",
  [ItemConfigTag.BATTERY]: "Is a battery item",
  [ItemConfigTag.BOB]: "Is apart of the Bob transformation",
  [ItemConfigTag.BOOK]: "Is a book",
  [ItemConfigTag.DEAD]: "Is a dead item",
  [ItemConfigTag.DEVIL]: "Is apart of the Leviathan transformation",
  [ItemConfigTag.FLY]: "Is apart of the Beelzebub transformation",
  [ItemConfigTag.FOOD]: "Is a food item",
  [ItemConfigTag.GUPPY]: "Is apart of the Guppy transformation",
  [ItemConfigTag.LAZ_SHARED]: "Is shared between Lazarus forms",
  [ItemConfigTag.LAZ_SHARED_GLOBAL]: "Is shared between Lazarus forms globally",
  [ItemConfigTag.MOM]: "Is apart of the Yes Mother transformation",
  [ItemConfigTag.MONSTER_MANUAL]: "Is a monster manual creation",
  [ItemConfigTag.MUSHROOM]: "Is apart of the Fun Guy transformation",
  [ItemConfigTag.NO_CANTRIP]: "Can't be obtained in the cantrip challenge",
  [ItemConfigTag.NO_CHALLENGE]: "Can't appear in any challenges",
  [ItemConfigTag.NO_DAILY]: "Can't appear in daily runs",
  [ItemConfigTag.NO_EDEN]: "Eden can't start with",
  [ItemConfigTag.NO_GREED]: "Can't appear in greed mode",
  [ItemConfigTag.NO_KEEPER]: "Is banned from Keeper",
  [ItemConfigTag.OFFENSIVE]: "Is banned from Tainted Lost",
  [ItemConfigTag.POOP]: "Is apart of the Oh Shit transformation",
  [ItemConfigTag.QUEST]: "Is a quest item",
  [ItemConfigTag.SPIDER]: "Is apart of the Spider Baby transformation",
  [ItemConfigTag.STARS]: "Is a star-themed item",
  [ItemConfigTag.SUMMONABLE]: "Is summonable",
  [ItemConfigTag.SYRINGE]: "Is apart of the Spun transformation",
  [ItemConfigTag.TEARS_UP]: "Gives you a tears up",
  [ItemConfigTag.TECH]: "Is a technology item",
  [ItemConfigTag.UNIQUE_FAMILIAR]: "Is a unique familiar",
  [ItemConfigTag.WISP]: "Has a unique wisp",
};

/**
 * Get a string text value describing the specified ItemConfigTag.
 *
 * @example getItemTypeText(ItemType.ACTIVE) // "active".
 */
export function itemConfigTagToString(itemConfigTag: ItemConfigTag): string {
  return itemTagNameMap[itemConfigTag]!;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\itemTypeNameMap.ts`:

```````ts
import { ItemType } from "isaac-typescript-definitions";

const itemTypeTextMap: Record<ItemType, string> = {
  [ItemType.NULL]: "null",
  [ItemType.PASSIVE]: "passive",
  [ItemType.TRINKET]: "trinket",
  [ItemType.ACTIVE]: "active",
  [ItemType.FAMILIAR]: "familiar",
};

/**
 * Get a string text value describing the specified ItemType.
 *
 * @example getItemTypeText(ItemType.ACTIVE) // "active".
 */
export function itemTypeToString(itemType: ItemType): string {
  return itemTypeTextMap[itemType];
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\levelStageNameMap.ts`:

```````ts
import { LevelStage } from "isaac-typescript-definitions";

const LEVEL_STAGE_TO_NAME_MAP: ReadonlyMap<LevelStage, string> = new Map([
  [LevelStage.BASEMENT_1, "Basement I and variants"],
  [LevelStage.BASEMENT_2, "Basement II and variants"],
  [LevelStage.CAVES_1, "Caves I and variants"],
  [LevelStage.CAVES_2, "Caves II and variants"],
  [LevelStage.DEPTHS_1, "Depths I and variants"],
  [LevelStage.DEPTHS_2, "Depths II and variants"],
  [LevelStage.WOMB_1, "Womb I and variants"],
  [LevelStage.WOMB_2, "Womb II and variants"],
  [LevelStage.BLUE_WOMB, "Blue Womb"],
  [LevelStage.SHEOL_CATHEDRAL, "Sheol or Cathedral"],
  [LevelStage.DARK_ROOM_CHEST, "the Dark Room or the Chest"],
  [LevelStage.VOID, "The Void"],
  [LevelStage.HOME, "Home"],
]);

/**
 * Retrieves a printable named version of the specified levelStage enum value.
 *
 * @example RoomType.THE_VOID = "The Void"].
 */
export function levelStageToString(levelStage: LevelStage): string {
  const name = LEVEL_STAGE_TO_NAME_MAP.get(levelStage);
  if (name === undefined) {
    error(`LevelStageNameMap: Cannot find Name of LevelStage: ${levelStage}`);
  }
  return name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\npcFlagNameMap.ts`:

```````ts
import { NPCFlag } from "../../../enums/general/NPCFlag";

const NPC_FLAG_NAME_MAP: ReadonlyMap<NPCFlag, string> = new Map([
  [NPCFlag.BOLSTERED, "Bolstered"],
  [NPCFlag.FROZEN, "Paralyzed"],
  [NPCFlag.NON_MANDATORY, "Non-Mandatory"],
  [NPCFlag.CENSORED, "Censored"],
  [NPCFlag.UNSTABLE, "Unstable"],
  [NPCFlag.FEAR, "Fearful"],
  [NPCFlag.BURN, "Burned"],
  [NPCFlag.CHARMED, "Charmed"],
  [NPCFlag.CONFUSED, "Confused"],
  [NPCFlag.ICE_FREEZE, "Frozen"],
  [NPCFlag.MIDAS_FREEZE, "Midas Frozen"],
  [NPCFlag.SHRUNKEN, "Shrunken"],
  [NPCFlag.POISONED, "Poisoned"],
  [NPCFlag.PERSISTENT, "Persistent"],
  [NPCFlag.FRIENDLY, "Friendly"],
  [NPCFlag.SLOWING, "Slow"],
]);

/**
 * Get a NPCFlag string description.
 *
 * @example npcFlagToString(NPCFlag.BOLSTERED); // "Bolstered"
 * @example npcFlagToString(NPCFlag.MIDAS_FREEZE); // "Midas Frozen"
 */
export function npcFlagToString(flag: NPCFlag): string {
  const npcFlag = NPC_FLAG_NAME_MAP.get(flag);
  if (npcFlag === undefined) {
    error(`Failed to get NPC flag name for flag ${flag}.`);
  }
  return npcFlag;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\npcNameMap.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";

const NPC_NAME_MAP: ReadonlyMap<NPCID, string> = new Map([
  [NPCID.FROWNING_GAPER, "Frowning Gaper"],
  [NPCID.GAPER, "Gaper"],
  [NPCID.FLAMING_GAPER, "Flaming Gaper"],
  [NPCID.ROTTEN_GAPER, "Rotten Gaper"],
  [NPCID.ROTTEN_GAPER_2, "Rotten Gaper V2"],
  [NPCID.ROTTEN_GAPER_3, "Rotten Gaper V3"],
  [NPCID.ROTTEN_GAPER_4, "Rotten Gaper V4"],
  [NPCID.ROTTEN_GAPER_5, "Rotten Gaper V5"],
  [NPCID.ROTTEN_GAPER_6, "Rotten Gaper V6"],
  [NPCID.WIDOW, "Widow"],
  [NPCID.WIDOW_BLACK, "Black Widow"],
  [NPCID.WIDOW_PINK, "Pink Widow"],
  [NPCID.THE_WRETCHED, "The Wretched"],
  [NPCID.DADDY_LONG_LEGS, "Daddy Long Legs"],
  [NPCID.TRIACHNID, "Triachnid"],
  [NPCID.ISAAC, "Isaac"],
  [NPCID.BLUE_BABY, "Blue Baby"],
  [NPCID.BLUE_BABY_HUSH, "Blue Baby Hush"],
  [NPCID.GUSHER, "Gusher"],
  [NPCID.PACER, "Pacer"],
  [NPCID.HORF, "Horf"],
  [NPCID.FLY, "Fly"],
  [NPCID.POOTER, "Pooter"],
  [NPCID.SUPER_POOTER, "Super Pooter"],
  [NPCID.TAINTED_POOTER, "Tainted Pooter"],
  [NPCID.CLOTTY, "Clotty"],
  [NPCID.CLOT, "Clot"],
  [NPCID.I_BLOB, "IBlob"],
  [NPCID.GRILLED_CLOTTY, "Grilled Clotty"],
  [NPCID.MULLIGAN, "Mulligan"],
  [NPCID.MULLIGOON, "Mulligoon"],
  [NPCID.MULLIBOOM, "Mulliboom"],
  [NPCID.SHOPKEEPER, "Shopkeeper"],
  [NPCID.SECRET_ROOM_KEEPER, "Secret Room Keeper"],
  [NPCID.ERROR_ROOM_KEEPER, "Error Room Keeper"],
  [NPCID.SPECIAL_SHOPKEEPER, "Special Shopkeeper"],
  [NPCID.SPECIAL_SECRET_ROOM_KEEPER, "Special Secret Room Keeper"],
  [NPCID.ATTACK_FLY, "Attack Fly"],
  [NPCID.LARRY_JR, "Larry Jr"],
  [NPCID.LARRY_JR_GREEN, "Green Larry Jr"],
  [NPCID.LARRY_JR_BLUE, "Blue Larry Jr"],
  [NPCID.THE_HOLLOW, "The Hollow"],
  [NPCID.THE_HOLLOW_GREEN, "Green Hollow"],
  [NPCID.THE_HOLLOW_BLACK, "Black Hollow"],
  [NPCID.THE_HOLLOW_YELLOW, "Yellow Hollow"],
  [NPCID.TUFF_TWIN, "Tuff Twin"],
  [NPCID.THE_SHELL, "The Shell"],
  [NPCID.MONSTRO, "Monstro"],
  [NPCID.MONSTRO_RED, "Red Monstro"],
  [NPCID.MONSTRO_GREY, "Grey Monstro"],
  [NPCID.STONE_EYE, "Stone Eye"],
  [NPCID.CONSTANT_STONE_SHOOTER_LEFT, "Left-facing Constant Stone Shooter"],
  [NPCID.CONSTANT_STONE_SHOOTER_UP, "Up-facing Constant Stone Shooter"],
  [NPCID.CONSTANT_STONE_SHOOTER_RIGHT, "Right-facing Constant Stone Shooter"],
  [NPCID.CONSTANT_STONE_SHOOTER_DOWN, "Down-facing Constant Stone Shooter"],
  [NPCID.CROSS_STONE_SHOOTER, "Cross Stone Shooter"],
  [NPCID.CROSS_STONE_SHOOTER_2, "Cross Stone Shooter V2"],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON, "Cross Stone Shooter Always On"],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON_2, "Cross Stone Shooter Always On V2"],
  [NPCID.BRIMSTONE_HEAD, "Brimstone Head"],
  [NPCID.MOBILE_HOST, "Mobile Host"],
  [NPCID.NEST, "Nest"],
  [NPCID.BABY_LONG_LEGS, "Baby Long Legs"],
  [NPCID.SMALL_BABY_LONG_LEGS, "Small Baby Long Legs"],
  [NPCID.CRAZY_LONG_LEGS, "Crazy Long Legs"],
  [NPCID.SMALL_CRAZY_LONG_LEGS, "Small Crazy Long Legs"],
  [NPCID.FATTY, "Fatty"],
  [NPCID.PALE_FATTY, "Pale Fatty"],
  [NPCID.FLAMING_FATTY, "Flaming Fatty"],
  [NPCID.FAT_SACK, "Fat Sack"],
  [NPCID.MAGGOT, "Maggot"],
  [NPCID.BLUBBER, "Blubber"],
  [NPCID.HALF_SACK, "Half Sack"],
  [NPCID.DEATHS_HEAD, "Death's Head"],
  [NPCID.DANK_DEATHS_HEAD, "Dank Deaths Head"],
  [NPCID.CURSED_DEATHS_HEAD, "Cursed Death''s Head"],
  [NPCID.BRIMSTONE_DEATHS_HEAD, "Brimstone Death's Head"],
  [NPCID.REDSKULL, "Redskull"],
  [NPCID.MOMS_HAND, "Mom's Hand"],
  [NPCID.LEVEL_2_FLY, "Level 2 Fly"],
  [NPCID.LEVEL_2_SPIDER, "Level 2 Spider"],
  [NPCID.SWINGER, "Swinger"],
  [NPCID.SWINGER_HEAD, "Swinger Head"],
  [NPCID.SWINGER_NECK, "Swinger Neck"],
  [NPCID.DIP, "Dip"],
  [NPCID.CORN, "Corn"],
  [NPCID.BROWNIE_CORN, "Brownie Corn"],
  [NPCID.BIG_CORN, "Big Corn"],
  [NPCID.WALL_HUGGER, "Wall Hugger"],
  [NPCID.WIZOOB, "Wizoob"],
  [NPCID.HIVE, "Hive"],
  [NPCID.DROWNED_HIVE, "Drowned Hive"],
  [NPCID.HOLY_MULLIGAN, "Holy Mulligan"],
  [NPCID.TAINTED_MULLIGAN, "Tainted Mulligan"],
  [NPCID.SQUIRT, "Squirt"],
  [NPCID.DANK_SQUIRT, "Dank Squirt"],
  [NPCID.COD_WORM, "Cod Worm"],
  [NPCID.RING_FLY, "Ring Fly"],
  [NPCID.DINGA, "Dinga"],
  [NPCID.OOB, "Oob"],
  [NPCID.BLACK_MAW, "Black Maw"],
  [NPCID.SKINNY, "Skinny"],
  [NPCID.ROTTY, "Rotty"],
  [NPCID.CRISPY, "Crispy"],
  [NPCID.BONY, "Bony"],
  [NPCID.HOLY_BONY, "Holy Bony"],
  [NPCID.HOMUNCULUS, "Homunculus"],
  [NPCID.HOMUNCULUS_CORD, "Homunculus Cord"],
  [NPCID.TUMOR, "Tumor"],
  [NPCID.PLANETOID, "Planetoid"],
  [NPCID.CHARGER, "Charger"],
  [NPCID.MY_SHADOW, "My Shadow"],
  [NPCID.DROWNED_CHARGER, "Drowned Charger"],
  [NPCID.DANK_CHARGER, "Dank Charger"],
  [NPCID.CARRION_PRINCESS, "Carrion Princess"],
  [NPCID.CAMILLO_JR, "Camillo Jr"],
  [NPCID.NERVE_ENDING, "Nerve Ending"],
  [NPCID.NERVE_ENDING_2, "Nerve Ending 2"],
  [NPCID.ONE_TOOTH, "One Tooth"],
  [NPCID.GAPING_MAW, "Gaping Maw"],
  [NPCID.BROKEN_GAPING_MAW, "Broken Gaping Maw"],
  [NPCID.GURGLING, "Gurgling"],
  [NPCID.GURGLING_BOSS, "Gurgling Boss"],
  [NPCID.GURGLING_BOSS_YELLOW, "Yellow Gurgling Boss"],
  [NPCID.GURGLING_BOSS_BLACK, "Black Gurgling Boss"],
  [NPCID.TURDLING, "Turdling"],
  [NPCID.SPLASHER, "Splasher"],
  [NPCID.GRUB, "Grub"],
  [NPCID.CORPSE_EATER, "Corpse Eater"],
  [NPCID.CARRION_RIDER, "Carrion Rider"],
  [NPCID.GLOBIN, "Globin"],
  [NPCID.GAZING_GLOBIN, "Gazing Globin"],
  [NPCID.DANK_GLOBIN, "Dank Globin"],
  [NPCID.CURSED_GLOBIN, "Cursed Globin"],
  [NPCID.WALL_CREEP, "Wall Creep"],
  [NPCID.SOY_CREEP, "Soy Creep"],
  [NPCID.RAG_CREEP, "Rag Creep"],
  [NPCID.TAINTED_SOY_CREEP, "Tainted Soy Creep"],
  [NPCID.RAGE_CREEP, "Rage Creep"],
  [NPCID.SPLIT_RAGE_CREEP, "Split Rage Creep"],
  [NPCID.BLIND_CREEP, "Blind Creep"],
  [NPCID.CONJOINED_SPITTY, "Conjoined Spitty"],
  [NPCID.ROUND_WORM, "Round Worm"],
  [NPCID.TUBE_WORM, "Tube Worm"],
  [NPCID.TAINTED_ROUND_WORM, "Tainted Round Worm"],
  [NPCID.TAINTED_ROUND_WORM_BUTT, "Tainted Round Worm Butt"],
  [NPCID.TAINTED_TUBE_WORM, "Tainted Tube Worm"],
  [NPCID.POOP, "Poop"],
  [NPCID.RAGLING, "Ragling"],
  [NPCID.RAG_MANS_RAGLING, "Rag Man's Ragling"],
  [NPCID.RAG_MANS_RAGLING_RED, "Red Rag Man's Ragling"],
  [NPCID.RAG_MANS_RAGLING_BLACK, "Black Rag Man's Ragling"],
  [NPCID.FLESH_MOBILE_HOST, "Flesh Mobile Host"],
  [NPCID.PSYCHIC_HORF, "Psychic Horf"],
  [NPCID.FULL_FLY, "Full Fly"],
  [NPCID.BOOM_FLY, "Boom Fly"],
  [NPCID.RED_BOOM_FLY, "Red Boom Fly"],
  [NPCID.DROWNED_BOOM_FLY, "Drowned Boom Fly"],
  [NPCID.DRAGON_FLY, "Dragon Fly"],
  [NPCID.DRAGON_FLY_X, "Dragon Fly X"],
  [NPCID.BONE_FLY, "Bone Fly"],
  [NPCID.SICK_BOOM_FLY, "Sick Boom Fly"],
  [NPCID.TAINTED_BOOM_FLY, "Tainted Boom Fly"],
  [NPCID.TICKING_SPIDER, "Ticking Spider"],
  [NPCID.BEGOTTEN, "Begotten"],
  [NPCID.BEGOTTEN_CHAIN, "Begotten Chain"],
  [NPCID.NULLS, "Nulls"],
  [NPCID.PSY_TUMOR, "Psy Tumor"],
  [NPCID.FLOATING_KNIGHT, "Floating Knight"],
  [NPCID.NIGHT_CRAWLER, "Night Crawler"],
  [NPCID.DART_FLY, "Dart Fly"],
  [NPCID.CONJOINED_FATTY, "Conjoined Fatty"],
  [NPCID.BLUE_CONJOINED_FATTY, "Blue Conjoined Fatty"],
  [NPCID.FAT_BAT, "Fat Bat"],
  [NPCID.IMP, "Imp"],
  [NPCID.MAW, "Maw"],
  [NPCID.RED_MAW, "Red Maw"],
  [NPCID.PSYCHIC_MAW, "Psychic Maw"],
  [NPCID.HAUNT, "Haunt"],
  [NPCID.HAUNT_BLACK, "Black Haunt"],
  [NPCID.HAUNT_PINK, "Pink Haunt"],
  [NPCID.LIL_HAUNT, "Lil Haunt"],
  [NPCID.DINGLE, "Dingle"],
  [NPCID.DINGLE_RED, "Red Dingle"],
  [NPCID.DINGLE_BLACK, "Black Dingle"],
  [NPCID.DANGLE, "Dangle"],
  [NPCID.MEGA_MAW, "Mega Maw"],
  [NPCID.MEGA_MAW_RED, "Red Mega Maw"],
  [NPCID.MEGA_MAW_BLACK, "Black Mega Maw"],
  [NPCID.THE_GATE, "The Gate"],
  [NPCID.THE_GATE_RED, "Red Gate"],
  [NPCID.THE_GATE_BLACK, "Black Gate"],
  [NPCID.MEGA_FATTY, "Mega Fatty"],
  [NPCID.MEGA_FATTY_RED, "Red Mega Fatty"],
  [NPCID.MEGA_FATTY_BROWN, "Brown Mega Fatty"],
  [NPCID.THE_CAGE, "The Cage"],
  [NPCID.THE_CAGE_GREEN, "Green Cage"],
  [NPCID.THE_CAGE_PINK, "Pink Cage"],
  [NPCID.MAMA_GURDY, "Mama Gurdy"],
  [NPCID.MAMA_GURDY_LEFT_HAND, "Mama Gurdy's Left Hand"],
  [NPCID.MAMA_GURDY_RIGHT_HAND, "Mama Gurdy's Right Hand"],
  [NPCID.DARK_ONE, "Dark One"],
  [NPCID.THE_ADVERSARY, "The Adversary"],
  [NPCID.POLYCEPHALUS, "Polycephalus"],
  [NPCID.POLYCEPHALUS_RED, "Red Polycephalus"],
  [NPCID.POLYCEPHALUS_PINK, "Pink Polycephalus"],
  [NPCID.THE_PILE, "The Pile"],
  [NPCID.HOST, "Host"],
  [NPCID.RED_HOST, "Red Host"],
  [NPCID.HARD_HOST, "Hard Host"],
  [NPCID.MR_FRED, "Mr Fred"],
  [NPCID.URIEL, "Uriel"],
  [NPCID.FALLEN_URIEL, "Fallen Uriel"],
  [NPCID.GABRIEL, "Gabriel"],
  [NPCID.FALLEN_GABRIEL, "Fallen Gabriel"],
  [NPCID.THE_LAMB, "The Lamb"],
  [NPCID.LAMB_BODY, "The Lamb's Body"],
  [NPCID.MEGA_SATAN, "Mega Satan"],
  [NPCID.MEGA_SATANS_RIGHT_HAND, "Mega Satan's Right Hand"],
  [NPCID.MEGA_SATANS_LEFT_HAND, "Mega Satan's Left Hand"],
  [NPCID.MEGA_SATAN_2, "Mega Satan 2"],
  [NPCID.MEGA_SATAN_2_RIGHT_HAND, "Mega Satan 2's Right Hand"],
  [NPCID.MEGA_SATAN_2_LEFT_HAND, "Mega Satan 2's Left Hand"],
  [NPCID.ROUNDY, "Roundy"],
  [NPCID.BLACK_BONY, "Black Bony"],
  [NPCID.BLACK_GLOBIN, "Black Globin"],
  [NPCID.BLACK_GLOBINS_HEAD, "Black Globin's Head"],
  [NPCID.CHUB, "Chub"],
  [NPCID.CHUB_BLUE, "Blue Chub"],
  [NPCID.CHUB_ORANGE, "Orange Chub"],
  [NPCID.CHAD, "Chad"],
  [NPCID.THE_CARRION_QUEEN, "The Carrion Queen"],
  [NPCID.THE_CARRION_QUEEN_PINK, "Pink Carrion Queen"],
  [NPCID.BLACK_GLOBINS_BODY, "Black Globin's Body"],
  [NPCID.SWARM, "Swarm"],
  [NPCID.MEGA_CLOTTY, "Mega Clotty"],
  [NPCID.BONE_KNIGHT, "Bone Knight"],
  [NPCID.CYCLOPIA, "Cyclopia"],
  [NPCID.RED_GHOST, "Red Ghost"],
  [NPCID.FLESH_DEATHS_HEAD, "Flesh Death's Head"],
  [NPCID.MOMS_DEAD_HAND, "Mom's Dead Hand"],
  [NPCID.DUKIE, "Dukie"],
  [NPCID.ULCER, "Ulcer"],
  [NPCID.HOPPER, "Hopper"],
  [NPCID.TRITE, "Trite"],
  [NPCID.EGGY, "Eggy"],
  [NPCID.TAINTED_HOPPER, "Tainted Hopper"],
  [NPCID.MEATBALL, "Meatball"],
  [NPCID.PITFALL, "Pitfall"],
  [NPCID.SUCTION_PITFALL, "Suction Pitfall"],
  [NPCID.TELEPORT_PITFALL, "Teleport Pitfall"],
  [NPCID.MOVABLE_TNT, "Movable Tnt"],
  [NPCID.MOVABLE_TNT_MINE_CRAFTER, "Movable Tnt Mine Crafter"],
  [NPCID.ULTRA_GREED_COIN_SPINNER, "Ultra Greed Coin"],
  [NPCID.ULTRA_GREED_COIN_KEY, "Ultra Greed Key Coin"],
  [NPCID.ULTRA_GREED_COIN_BOMB, "Ultra Greed Bomb Coin"],
  [NPCID.ULTRA_GREED_COIN_HEART, "Ultra Greed Heart Coin"],
  [NPCID.ULTRA_GREED_DOOR, "Ultra Greed Door"],
  [NPCID.CORN_MINE, "Corn Mine"],
  [NPCID.CORN_MINE_BLACK, "Black Corn Mine"],
  [NPCID.HUSH_FLY, "Hush Fly"],
  [NPCID.BLUE_GAPER, "Blue Gaper"],
  [NPCID.BLUE_BOIL, "Blue Boil"],
  [NPCID.GREED_GAPER, "Greed Gaper"],
  [NPCID.BOIL, "Boil"],
  [NPCID.BOIL_BLUE, "Blue Boil"],
  [NPCID.GUT, "Gut"],
  [NPCID.SACK, "Sack"],
  [NPCID.MUSHROOM, "Mushroom"],
  [NPCID.POISON_MIND, "Poison Mind"],
  [NPCID.STONEY, "Stoney"],
  [NPCID.CROSS_STONEY, "Cross Stoney"],
  [NPCID.BLISTER, "Blister"],
  [NPCID.THE_THING, "The Thing"],
  [NPCID.MINISTRO, "Ministro"],
  [NPCID.PORTAL, "Portal"],
  [NPCID.LIL_PORTAL, "Lil Portal"],
  [NPCID.TAR_BOY, "Tar Boy"],
  [NPCID.TAR_BOY_MOUTH, "Tar Boy's Mouth"],
  [NPCID.FISTULOID, "Fistuloid"],
  [NPCID.GUSH, "Gush"],
  [NPCID.SPITTY, "Spitty"],
  [NPCID.TAINTED_SPITTY, "Tainted Spitty"],
  [NPCID.LEPER, "Leper"],
  [NPCID.LEPER_STAGE_2, "Leper Stage 2"],
  [NPCID.LEPER_STAGE_3, "Leper Stage 3"],
  [NPCID.LEPER_STAGE_4, "Leper Stage 4"],
  [NPCID.LEPER_FLESH, "Leper Flesh"],
  [NPCID.MR_MINE, "Mr Mine"],
  [NPCID.MR_MINE_NECK, "Mr Mine Neck"],
  [NPCID.BRAIN, "Brain"],
  [NPCID.FIRE_PLACE, "Fire Place"],
  [NPCID.RED_FIRE_PLACE, "Red Fire Place"],
  [NPCID.MOVEABLE_FIREPLACE, "Moveable Fireplace"],
  [NPCID.COAL, "Coal"],
  [NPCID.COAL_2, "Coal V2"],
  [NPCID.COAL_3, "Coal V3"],
  [NPCID.COAL_4, "Coal V4"],
  [NPCID.MOVEABLE_BLUE_FIREPLACE, "Moveable Blue Fireplace"],
  [NPCID.MOVEABLE_PURPLE_FIREPLACE, "Moveable Purple Fireplace"],
  [NPCID.BLUE_FIRE_PLACE, "Blue Fire Place"],
  [NPCID.PURPLE_FIRE_PLACE, "Purple Fire Place"],
  [NPCID.WHITE_FIRE_PLACE, "White Fire Place"],
  [NPCID.LEAPER, "Leaper"],
  [NPCID.STICKY_LEAPER, "Sticky Leaper"],
  [NPCID.MR_MAW, "Mr Maw"],
  [NPCID.MR_MAW_HEAD, "Mr Maw Head"],
  [NPCID.MR_MAW_NECK, "Mr Maw Neck"],
  [NPCID.MR_RED_MAW, "Mr Red Maw"],
  [NPCID.MR_RED_MAW_HEAD, "Mr Red Maw Head"],
  [NPCID.GURDY, "Gurdy"],
  [NPCID.GURDY_GREEN, "Green Gurdy"],
  [NPCID.BABY, "Baby"],
  [NPCID.ANGELIC_BABY, "Angelic Baby"],
  [NPCID.ANGELIC_BABY_SMALL, "Small Angelic Baby"],
  [NPCID.ULTRA_PRIDE_BABY, "Ultra Pride Baby"],
  [NPCID.WRINKLY_BABY, "Wrinkly Baby"],
  [NPCID.VIS, "Vis"],
  [NPCID.DOUBLE_VIS, "Double Vis"],
  [NPCID.CHUBBER, "Chubber"],
  [NPCID.CHUBBER_PROJECTILE, "Chubber Projectile"],
  [NPCID.SCARRED_DOUBLE_VIS, "Scarred Double Vis"],
  [NPCID.GUTS, "Guts"],
  [NPCID.SCARRED_GUTS, "Scarred Guts"],
  [NPCID.SLOG, "Slog"],
  [NPCID.THE_STAIN, "The Stain"],
  [NPCID.THE_STAIN_GREY, "Grey Stain"],
  [NPCID.BROWNIE, "Brownie"],
  [NPCID.BROWNIE_BLACK, "Black Brownie"],
  [NPCID.THE_FORSAKEN, "The Forsaken"],
  [NPCID.THE_FORSAKEN_BLACK, "Black Forsaken"],
  [NPCID.LITTLE_HORN, "Little Horn"],
  [NPCID.LITTLE_HORN_ORANGE, "Orange Little Horn"],
  [NPCID.LITTLE_HORN_BLACK, "Black Little Horn"],
  [NPCID.DARK_BALL, "Dark Ball"],
  [NPCID.DARK_BALL_ORANGE, "Orange Dark Ball"],
  [NPCID.DARK_BALL_BLACK, "Black Dark Ball"],
  [NPCID.RAG_MAN, "Rag Man"],
  [NPCID.RAG_MAN_RED, "Red Rag Man"],
  [NPCID.RAG_MAN_BLACK, "Black Rag Man"],
  [NPCID.RAG_MANS_HEAD, "Rag Man's Head"],
  [NPCID.RAG_MANS_HEAD_RED, "Red Rag Man's Head"],
  [NPCID.RAG_MANS_HEAD_BLACK, "Black Rag Man's Head"],
  [NPCID.ULTRA_GREED, "Ultra Greed"],
  [NPCID.ULTRA_GREEDIER, "Ultra Greedier"],
  [NPCID.HUSH, "Hush"],
  [NPCID.HUSH_SKINLESS, "Skinless Hush"],
  [NPCID.RAG_MEGA, "Rag Mega"],
  [NPCID.PURPLE_BALL, "Purple Ball"],
  [NPCID.RAG_MEGA_REBIRTH_PILLAR, "Rag Mega's Rebirth Pillar"],
  [NPCID.KNIGHT, "Knight"],
  [NPCID.SELFLESS_KNIGHT, "Selfless Knight"],
  [NPCID.LOOSE_KNIGHT, "Loose Knight"],
  [NPCID.BRAINLESS_KNIGHT, "Brainless Knight"],
  [NPCID.BLACK_KNIGHT, "Black Knight"],
  [NPCID.SISTERS_VIS, "Sisters Vis"],
  [NPCID.BIG_HORN, "Big Horn"],
  [NPCID.SMALL_HOLE, "Small Hole"],
  [NPCID.BIG_HOLE, "Big Hole"],
  [NPCID.DELIRIUM, "Delirium"],
  [NPCID.THE_MATRIARCH, "The Matriarch"],
  [NPCID.STONE_GRIMACE, "Stone Grimace"],
  [NPCID.VOMIT_GRIMACE, "Vomit Grimace"],
  [NPCID.TRIPLE_GRIMACE, "Triple Grimace"],
  [NPCID.MONSTRO_II, "Monstro II"],
  [NPCID.MONSTRO_II_RED, "Red Monstro II"],
  [NPCID.GISH, "Gish"],
  [NPCID.POKY, "Poky"],
  [NPCID.SLIDE, "Slide"],
  [NPCID.MOM, "Mom"],
  [NPCID.MOM_BLUE, "Blue Mom"],
  [NPCID.MOM_RED, "Red Mom"],
  [NPCID.MOM_STOMP, "Mom's Stomp"],
  [NPCID.MOM_STOMP_BLUE, "Blue Mom's Stomp"],
  [NPCID.MOM_STOMP_RED, "Red Mom's Stomp"],
  [NPCID.SLOTH, "Sloth"],
  [NPCID.SUPER_SLOTH, "Super Sloth"],
  [NPCID.ULTRA_PRIDE, "Ultra Pride"],
  [NPCID.LUST, "Lust"],
  [NPCID.SUPER_LUST, "Super Lust"],
  [NPCID.WRATH, "Wrath"],
  [NPCID.SUPER_WRATH, "Super Wrath"],
  [NPCID.GLUTTONY, "Gluttony"],
  [NPCID.SUPER_GLUTTONY, "Super Gluttony"],
  [NPCID.GREED, "Greed"],
  [NPCID.SUPER_GREED, "Super Greed"],
  [NPCID.ENVY, "Envy"],
  [NPCID.SUPER_ENVY, "Super Envy"],
  [NPCID.ENVY_BIG, "Big Envy"],
  [NPCID.SUPER_ENVY_BIG, "Big Super Envy"],
  [NPCID.ENVY_MEDIUM, "Medium Envy"],
  [NPCID.SUPER_ENVY_MEDIUM, "Medium Super Envy"],
  [NPCID.ENVY_SMALL, "Small Envy"],
  [NPCID.SUPER_ENVY_SMALL, "Small Super Envy"],
  [NPCID.PRIDE, "Pride"],
  [NPCID.SUPER_PRIDE, "Super Pride"],
  [NPCID.DOPLE, "Dople"],
  [NPCID.EVIL_TWIN, "Evil Twin"],
  [NPCID.FLAMING_HOPPER, "Flaming Hopper"],
  [NPCID.LEECH, "Leech"],
  [NPCID.KAMIKAZE_LEECH, "Kamikaze Leech"],
  [NPCID.HOLY_LEECH, "Holy Leech"],
  [NPCID.LUMP, "Lump"],
  [NPCID.MEMBRAIN, "Membrain"],
  [NPCID.MAMA_GUTS, "Mama Guts"],
  [NPCID.DEAD_MEAT, "Dead Meat"],
  [NPCID.PARA_BITE, "Para Bite"],
  [NPCID.SCARRED_PARA_BITE, "Scarred Para Bite"],
  [NPCID.FRED, "Fred"],
  [NPCID.EYE, "Eye"],
  [NPCID.BLOODSHOT_EYE, "Bloodshot Eye"],
  [NPCID.HOLY_EYE, "Holy Eye"],
  [NPCID.SUCKER, "Sucker"],
  [NPCID.SPIT, "Spit"],
  [NPCID.SOUL_SUCKER, "Soul Sucker"],
  [NPCID.INK, "Ink"],
  [NPCID.MAMA_FLY, "Mama Fly"],
  [NPCID.BULB, "Bulb"],
  [NPCID.BLOODFLY, "Bloodfly"],
  [NPCID.TAINTED_SUCKER, "Tainted Sucker"],
  [NPCID.PIN, "Pin"],
  [NPCID.PIN_GREY, "Grey Pin"],
  [NPCID.SCOLEX, "Scolex"],
  [NPCID.THE_FRAIL, "The Frail"],
  [NPCID.THE_FRAIL_BLACK, "Black Frail"],
  [NPCID.WORMWOOD, "Wormwood"],
  [NPCID.FAMINE, "Famine"],
  [NPCID.FAMINE_BLUE, "Blue Famine"],
  [NPCID.PESTILENCE, "Pestilence"],
  [NPCID.PESTILENCE_GREY, "Grey Pestilence"],
  [NPCID.WAR, "War"],
  [NPCID.WAR_GREY, "Grey War"],
  [NPCID.CONQUEST, "Conquest"],
  [NPCID.WAR_WITHOUT_HORSE, "War Without Horse"],
  [NPCID.WAR_WITHOUT_HORSE_GREY, "Grey War Without Horse"],
  [NPCID.DEATH, "Death"],
  [NPCID.DEATH_BLACK, "Death Black"],
  [NPCID.DEATH_SCYTHE, "Death's Scythe"],
  [NPCID.DEATH_SCYTHE_BLACK, "Death's Scythe Black"],
  [NPCID.DEATH_HORSE, "Death's Horse"],
  [NPCID.DEATH_HORSE_BLACK, "Black Death's Horse"],
  [NPCID.DEATH_WITHOUT_HORSE, "Death Without Horse"],
  [NPCID.DEATH_WITHOUT_HORSE_BLACK, "Black Death Without Horse"],
  [NPCID.THE_DUKE_OF_FLIES, "The Duke Of Flies"],
  [NPCID.THE_DUKE_OF_FLIES_GREEN, "Green Duke Of Flies"],
  [NPCID.THE_DUKE_OF_FLIES_ORANGE, "Orange Duke Of Flies"],
  [NPCID.THE_HUSK, "The Husk"],
  [NPCID.THE_HUSK_BLACK, "Black Husk"],
  [NPCID.THE_HUSK_RED, "Red Husk"],
  [NPCID.PEEP, "Peep"],
  [NPCID.PEEP_YELLOW, "Yellow Peep"],
  [NPCID.PEEP_CYAN, "Cyan Peep"],
  [NPCID.THE_BLOAT, "The Bloat"],
  [NPCID.THE_BLOAT_GREEN, "Green Bloat"],
  [NPCID.PEEP_EYE, "Peep Eye"],
  [NPCID.PEEP_EYE_YELLOW, "Yellow Peep Eye"],
  [NPCID.PEEP_EYE_CYAN, "Cyan Peep Eye"],
  [NPCID.BLOAT_EYE, "Bloat Eye"],
  [NPCID.BLOAT_EYE_GREEN, "Green Bloat Eye"],
  [NPCID.LOKI, "Loki"],
  [NPCID.LOKII, "Lokii"],
  [NPCID.FISTULA, "Fistula"],
  [NPCID.FISTULA_GREY, "Grey Fistula"],
  [NPCID.TERATOMA, "Teratoma"],
  [NPCID.FISTULA_MEDIUM, "Medium Fistula"],
  [NPCID.FISTULA_MEDIUM_GREY, "Medium Grey Fistula"],
  [NPCID.TERATOMA_MEDIUM, "Teratoma Medium"],
  [NPCID.FISTULA_SMALL, "Small Fistula"],
  [NPCID.FISTULA_SMALL_GREY, "Small Grey Fistula"],
  [NPCID.TERATOMA_SMALL, "Small Teratoma"],
  [NPCID.BLASTOCYST, "Blastocyst"],
  [NPCID.BLASTOCYST_MEDIUM, "Medium Blastocyst"],
  [NPCID.BLASTOCYST_SMALL, "Small Blastocyst"],
  [NPCID.EMBRYO, "Embryo"],
  [NPCID.MOMS_HEART, "Mom's Heart"],
  [NPCID.IT_LIVES, "It Lives"],
  [NPCID.MOMS_GUTS, "Mom's Guts"],
  [NPCID.GEMINI, "Gemini"],
  [NPCID.GEMINI_GREEN, "Green Gemini"],
  [NPCID.GEMINI_BLUE, "Blue Gemini"],
  [NPCID.STEVEN, "Steven"],
  [NPCID.GEMINI_BABY, "Gemini Baby"],
  [NPCID.GEMINI_BABY_GREEN, "Green Gemini Baby"],
  [NPCID.GEMINI_BABY_BLUE, "Blue Gemini Baby"],
  [NPCID.STEVEN_BABY, "Steven Baby"],
  [NPCID.THE_BLIGHTED_OVUM_BABY, "The Blighted Ovum Baby"],
  [NPCID.THE_BLIGHTED_OVUM, "The Blighted Ovum"],
  [NPCID.UMBILICAL_CORD, "Umbilical Cord"],
  [NPCID.UMBILICAL_CORD_GREEN, "Green Umbilical Cord"],
  [NPCID.UMBILICAL_CORD_BLUE, "Blue Umbilical Cord"],
  [NPCID.MOTER, "Moter"],
  [NPCID.BLOOD_PUPPY_SMALL, "Blood Puppy"],
  [NPCID.BLOOD_PUPPY_LARGE, "Blood Puppy V2"],
  [NPCID.BLIND_BAT, "Blind Bat"],
  [NPCID.QUAKE_GRIMACE_LEFT, "Left-facing Quake Grimace"],
  [NPCID.QUAKE_GRIMACE_UP, "Up-facing Quake Grimace"],
  [NPCID.QUAKE_GRIMACE_RIGHT, "Right-facing Quake Grimace"],
  [NPCID.QUAKE_GRIMACE_DOWN, "Down-facing Quake Grimace"],
  [NPCID.BISHOP, "Bishop"],
  [NPCID.BUBBLES, "Bubbles"],
  [NPCID.WRAITH, "Wraith"],
  [NPCID.WILLO, "Willo"],
  [NPCID.BOMB_GRIMACE, "Bomb Grimace"],
  [NPCID.THE_FALLEN, "The Fallen"],
  [NPCID.KRAMPUS, "Krampus"],
  [NPCID.SMALL_LEECH, "Small Leech"],
  [NPCID.DEEP_GAPER, "Deep Gaper"],
  [NPCID.DEEP_GAPER_2, "Deep Gaper V2"],
  [NPCID.DEEP_GAPER_3, "Deep Gaper V3"],
  [NPCID.DEEP_GAPER_4, "Deep Gaper V4"],
  [NPCID.DEEP_GAPER_5, "Deep Gaper V5"],
  [NPCID.DEEP_GAPER_6, "Deep Gaper V6"],
  [NPCID.DEEP_GAPER_7, "Deep Gaper V7"],
  [NPCID.SUB_HORF, "Sub Horf"],
  [NPCID.TAINTED_SUB_HORF, "Tainted Sub Horf"],
  [NPCID.BLURB, "Blurb"],
  [NPCID.STRIDER, "Strider"],
  [NPCID.FISSURE, "Fissure"],
  [NPCID.POLTY, "Polty"],
  [NPCID.KINETI, "Kineti"],
  [NPCID.PREY, "Prey"],
  [NPCID.MULLIGHOUL, "Mullighoul"],
  [NPCID.ROCK_SPIDER, "Rock Spider"],
  [NPCID.ROCK_SPIDER_2, "Rock Spider V2"],
  [NPCID.ROCK_SPIDER_3, "Rock Spider V3"],
  [NPCID.ROCK_SPIDER_4, "Rock Spider V4"],
  [NPCID.TINTED_ROCK_SPIDER, "Tinted Rock Spider"],
  [NPCID.TINTED_ROCK_SPIDER_2, "Tinted Rock Spider V2"],
  [NPCID.TINTED_ROCK_SPIDER_3, "Tinted Rock Spider V3"],
  [NPCID.TINTED_ROCK_SPIDER_4, "Tinted Rock Spider V4"],
  [NPCID.COAL_SPIDER, "Coal Spider"],
  [NPCID.COAL_SPIDER_2, "Coal Spider V2"],
  [NPCID.COAL_SPIDER_3, "Coal Spider V3"],
  [NPCID.COAL_SPIDER_4, "Coal Spider V4"],
  [NPCID.FLY_BOMB, "Fly Bomb"],
  [NPCID.ETERNAL_FLY_BOMB, "Eternal Fly Bomb"],
  [NPCID.HEADLESS_HORSEMAN, "Headless Horseman"],
  [NPCID.DANNY, "Danny"],
  [NPCID.COAL_BOY, "Coal Boy"],
  [NPCID.BLASTER, "Blaster"],
  [NPCID.BOUNCER, "Bouncer"],
  [NPCID.QUAKEY, "Quakey"],
  [NPCID.GYRO, "Gyro"],
  [NPCID.GRILLED_GYRO, "Grilled Gyro"],
  [NPCID.FIRE_WORM, "Fire Worm"],
  [NPCID.HARDY, "Hardy"],
  [NPCID.FACELESS, "Faceless"],
  [NPCID.TAINTED_FACELESS, "Tainted Faceless"],
  [NPCID.NECRO, "Necro"],
  [NPCID.MOLE, "Mole"],
  [NPCID.TAINTED_MOLE, "Tainted Mole"],
  [NPCID.HEADLESS_HORSEMAN_HEAD, "Headless Horseman's Head"],
  [NPCID.BIG_BONY, "Big Bony"],
  [NPCID.BIG_BONE, "Big Bone"],
  [NPCID.GUTTED_FATTY, "Gutted Fatty"],
  [NPCID.GUTTED_FATTY_EYE, "Gutted Fatty Eye"],
  [NPCID.FESTERING_GUTS, "Festering Guts"],
  [NPCID.EXORCIST, "Exorcist"],
  [NPCID.FANATIC, "Fanatic"],
  [NPCID.CANDLER, "Candler"],
  [NPCID.WHIPPER, "Whipper"],
  [NPCID.SNAPPER, "Snapper"],
  [NPCID.FLAGELLANT, "Flagellant"],
  [NPCID.PEEPING_FATTY, "Peeping Fatty"],
  [NPCID.PEEPING_FATTY_EYE, "Peeping Fatty Eye"],
  [NPCID.VIS_VERSA, "Vis Versa"],
  [NPCID.HENRY, "Henry"],
  [NPCID.LEVEL_2_WILLO, "Level 2 Willo"],
  [NPCID.STRIFER, "Strifer"],
  [NPCID.SATAN, "Satan"],
  [NPCID.SATAN_STOMP, "Satan Stomp"],
  [NPCID.PON, "Pon"],
  [NPCID.REVENANT, "Revenant"],
  [NPCID.QUAD_REVENANT, "Quad Revenant"],
  [NPCID.NIGHTWATCH, "Nightwatch"],
  [NPCID.CANARY, "Canary"],
  [NPCID.FOREIGNER, "Foreigner"],
  [NPCID.BOMBGAGGER, "Bombgagger"],
  [NPCID.SPIDER, "Spider"],
  [NPCID.LEVEL_2_GAPER, "Level 2 Gaper"],
  [NPCID.LEVEL_2_HORF, "Level 2 Horf"],
  [NPCID.LEVEL_2_GUSHER, "Level 2 Gusher"],
  [NPCID.TWITCHY, "Twitchy"],
  [NPCID.SPIKEBALL, "Spikeball"],
  [NPCID.SMALL_MAGGOT, "Small Maggot"],
  [NPCID.ADULT_LEECH, "Adult Leech"],
  [NPCID.LEVEL_2_CHARGER, "Level 2 Charger"],
  [NPCID.ELLEECH, "Elleech"],
  [NPCID.GASBAG, "Gasbag"],
  [NPCID.COHORT, "Cohort"],
  [NPCID.VESSEL, "Vessel"],
  [NPCID.FLOAST, "Floast"],
  [NPCID.KEEPER, "Keeper"],
  [NPCID.UNBORN, "Unborn"],
  [NPCID.PUSTULE, "Pustule"],
  [NPCID.CYST, "Cyst"],
  [NPCID.MORNINGSTAR, "Morningstar"],
  [NPCID.MORNINGSTAR_2, "Morningstar V2"],
  [NPCID.MORNINGSTAR_3, "Morningstar V3"],
  [NPCID.MOCKULUS, "Mockulus"],
  [NPCID.EVIS, "Evis"],
  [NPCID.EVIS_GUTS, "Evis Guts"],
  [NPCID.DARK_ESAU, "Dark Esau"],
  [NPCID.DARKER_ESAU, "Darker Esau"],
  [NPCID.DARK_ESAUS_PIT, "Dark Esau's Pit"],
  [NPCID.MOTHERS_SHADOW, "Mother's Shadow"],
  [NPCID.ARMY_FLY, "Army Fly"],
  [NPCID.MIGRAINE, "Migraine"],
  [NPCID.GURGLE, "Gurgle"],
  [NPCID.CRACKLE, "Crackle"],
  [NPCID.DRIP, "Drip"],
  [NPCID.SPLURT, "Splurt"],
  [NPCID.CLOGGY, "Cloggy"],
  [NPCID.FLY_TRAP, "Fly Trap"],
  [NPCID.GAS_DWARF, "Gas Dwarf"],
  [NPCID.POOT_MINE, "Poot Mine"],
  [NPCID.DUMP, "Dump"],
  [NPCID.DUMP_HEAD, "Dump Head"],
  [NPCID.GRUDGE, "Grudge"],
  [NPCID.BUTT_SLICKER, "Butt Slicker"],
  [NPCID.BLOATY, "Bloaty"],
  [NPCID.WALKING_BOIL, "Walking Boil"],
  [NPCID.WALKING_GUT, "Walking Gut"],
  [NPCID.WALKING_SACK, "Walking Sack"],
  [NPCID.FLESH_MAIDEN, "Flesh Maiden"],
  [NPCID.NEEDLE, "Needle"],
  [NPCID.PASTY, "Pasty"],
  [NPCID.DUST, "Dust"],
  [NPCID.BABY_BEGOTTEN, "Baby Begotten"],
  [NPCID.SWARM_SPIDER, "Swarm Spider"],
  [NPCID.CULTIST, "Cultist"],
  [NPCID.BLOOD_CULTIST, "Blood Cultist"],
  [NPCID.BONE_TRAP, "Bone Trap"],
  [NPCID.VIS_FATTY, "Vis Fatty"],
  [NPCID.FETAL_DEMON, "Fetal Demon"],
  [NPCID.DUSTY_DEATHS_HEAD, "Dusty Death's Head"],
  [NPCID.SHADY, "Shady"],
  [NPCID.CLICKETY_CLACK, "Clickety Clack"],
  [NPCID.BUTTLICKER, "Buttlicker"],
  [NPCID.MAZE_ROAMER, "Maze Roamer"],
  [NPCID.MAZE_ROAMER_2, "Maze Roamer V2"],
  [NPCID.GOAT, "Goat"],
  [NPCID.BLACK_GOAT, "Black Goat"],
  [NPCID.POOFER, "Poofer"],
  [NPCID.BALL_AND_CHAIN, "Ball And Chain"],
  [NPCID.HANGER, "Hanger"],
  [NPCID.REAP_CREEP, "Reap Creep"],
  [NPCID.LIL_BLUB, "Lil Blub"],
  [NPCID.RAINMAKER, "Rainmaker"],
  [NPCID.THE_VISAGE, "The Visage"],
  [NPCID.VISAGE_MASK, "Visage Mask"],
  [NPCID.VISAGE_CHAIN, "Visage Chain"],
  [NPCID.VISAGE_PLASMA, "Visage Plasma"],
  [NPCID.SIREN, "Siren"],
  [NPCID.SIRENS_SKULL, "Siren's Skull"],
  [NPCID.SIREN_HELPER_PROJECTILE, "Siren Helper Projectile"],
  [NPCID.THE_HERETIC, "The Heretic"],
  [NPCID.HORNFEL, "Hornfel"],
  [NPCID.HORNFEL_DECOY, "Hornfel Decoy"],
  [NPCID.GREAT_GIDEON, "Great Gideon"],
  [NPCID.GREAT_GIDEON_DEFEATED, "Defeated Great Gideon"],
  [NPCID.BABY_PLUM, "Baby Plum"],
  [NPCID.THE_SCOURGE, "The Scourge"],
  [NPCID.THE_SCOURGE_CHAIN, "The Scourge Chain"],
  [NPCID.SWARMER, "Swarmer"],
  [NPCID.CHIMERA, "Chimera"],
  [NPCID.CHIMERA_BODY, "Chimera Body"],
  [NPCID.CHIMERA_HEAD, "Chimera Head"],
  [NPCID.ROTGUT, "Rotgut"],
  [NPCID.ROTGUT_MAGGOT, "Rotgut Maggot"],
  [NPCID.ROTGUT_HEART, "Rotgut Heart"],
  [NPCID.MOTHER_PHASE_1, "Mother Phase 1"],
  [NPCID.MOTHER_PHASE_2, "Mother Phase 2"],
  [NPCID.MOTHER_LEFT_ARM, "Mother's Left Arm"],
  [NPCID.MOTHER_RIGHT_ARM, "Mother's Right Arm"],
  [NPCID.MOTHER_DISAPPEAR, "Disappearing Mother"],
  [NPCID.MOTHER_2, "Mother V2"],
  [NPCID.MOTHER_BALL, "Mother Ball"],
  [NPCID.MOTHER_BALL_MEDIUM, "Medium Mother Ball"],
  [NPCID.MOTHER_BALL_SMALL, "Small Mother Ball"],
  [NPCID.DEAD_ISAAC, "Dead Isaac"],
  [NPCID.MOTHER_WORM, "Mother Worm"],
  [NPCID.MIN_MIN, "Min Min"],
  [NPCID.CLOG, "Clog"],
  [NPCID.SINGE, "Singe"],
  [NPCID.SINGES_BALL, "Singes Ball"],
  [NPCID.BUMBINO, "Bumbino"],
  [NPCID.COLOSTOMIA, "Colostomia"],
  [NPCID.TURDLET, "Turdlet"],
  [NPCID.RAGLICH, "Raglich"],
  [NPCID.RAGLICH_ARM, "Raglich Arm"],
  [NPCID.HEART, "Heart"],
  [NPCID.HALF_HEART, "Half Heart"],
  [NPCID.HALF_HEART_2, "Half Heart V2"],
  [NPCID.HORNY_BOYS, "Horny Boys"],
  [NPCID.CLUTCH, "Clutch"],
  [NPCID.CLUTCH_ORBITAL, "Clutch Orbital"],
  [NPCID.MASK, "Mask"],
  [NPCID.MASK_II, "Mask V2"],
  [NPCID.BIG_SPIDER, "Big Spider"],
  [NPCID.DOGMA, "Dogma"],
  [NPCID.DOGMAS_TV, "Dogmas Tv"],
  [NPCID.DOGMA_ANGEL_BABY, "Dogma Angel Baby"],
  [NPCID.DOGMA_ANGEL, "Dogma Angel"],
  [NPCID.THE_BEAST, "The Beast"],
  [NPCID.STALACTITE, "Stalactite"],
  [NPCID.ULTRA_FAMINE, "Ultra Famine"],
  [NPCID.BACKGROUND_BEAST, "Background Beast"],
  [NPCID.BACKGROUND_FAMINE, "Background Famine"],
  [NPCID.BACKGROUND_PESTILENCE, "Background Pestilence"],
  [NPCID.BACKGROUND_WAR, "Background War"],
  [NPCID.BACKGROUND_DEATH, "Background Death"],
  [NPCID.ULTRA_FAMINE_FLY, "Ultra Famine Fly"],
  [NPCID.BEAST_ROCK_PROJECTILE, "Beast Rock Projectile"],
  [NPCID.ULTRA_PESTILENCE, "Ultra Pestilence"],
  [NPCID.ULTRA_PESTILENCE_FLY, "Ultra Pestilence Fly"],
  [NPCID.ULTRA_PESTILENCE_MAGGOT, "Ultra Pestilence Maggot"],
  [NPCID.ULTRA_PESTILENCE_FLY_BALL, "Ultra Pestilence Fly Ball"],
  [NPCID.BEAST_SOUL, "Beast Soul"],
  [NPCID.ULTRA_WAR, "Ultra War"],
  [NPCID.ULTRA_WAR_BOMB, "Ultra War Bomb"],
  [NPCID.ULTRA_DEATH, "Ultra Death"],
  [NPCID.ULTRA_DEATH_SCYTHE, "Ultra Death Scythe"],
  [NPCID.ULTRA_DEATH_HEAD, "Ultra Death Head"],
  [NPCID.ETERNAL_FLY, "Eternal Fly"],
  [NPCID.GENERIC_PROP, "Generic Prop"],
  [NPCID.MOMS_DRESSER, "Moms Dresser"],
  [NPCID.MOMS_VANITY, "Moms Vanity"],
  [NPCID.COUCH, "Couch"],
  [NPCID.TV, "Tv"],
  [NPCID.FROZEN_ENEMY, "Frozen Enemy"],
  [NPCID.DUMMY, "Dummy"],
  [NPCID.MINECART, "Minecart"],
  [NPCID.SIREN_HELPER, "Siren Helper"],
  [NPCID.HORNFEL_DOOR, "Hornfel Door"],
  [NPCID.MASK_OF_INFAMY, "Mask Of Infamy"],
  [NPCID.MASK_OF_INFAMY_BLACK, "Black Mask Of Infamy"],
  [NPCID.HEART_OF_INFAMY, "Heart Of Infamy"],
  [NPCID.HEART_OF_INFAMY_BLACK, "Black Heart Of Infamy"],
  [NPCID.GURDY_JR, "Gurdy Jr"],
  [NPCID.GURDY_JR_BLUE, "Blue Gurdy Jr"],
  [NPCID.GURDY_JR_YELLOW, "Yellow Gurdy Jr"],
]);

export function getNonModdedNPCName(npcid: NPCID): string | undefined {
  return NPC_NAME_MAP.get(npcid);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\pickupNameMap.ts`:

```````ts
import { PickupID } from "../../../enums/data/ID/PickupID";

const PICKUP_NAME_MAP: ReadonlyMap<PickupID, string> = new Map([
  [PickupID.TROLL_BOMB, "Troll Bomb"],
  [PickupID.DEVIL_CARD, "Devil Card"],
  [PickupID.SCARED_HEART, "Scared Heart"],
  [PickupID.SOUL_OF_BETHANY, "Soul Of Bethany"],
  [PickupID.HIEROPHANT_CARD, "Hierophant Card"],
  [PickupID.QUEEN_OF_HEARTS_CARD, "Queen Of Hearts Card"],
  [PickupID.GOLDEN_PENNY, "Golden Penny"],
  [PickupID.REVERSE_HIEROPHANT_CARD, "Reverse Hierophant Card"],
  [PickupID.KEY, "Key"],
  [PickupID.GOLDEN_BOMB, "Golden Bomb"],
  [PickupID.BLENDED_HEART, "Blended Heart"],
  [PickupID.HAGALAZ_RUNE, "Hagalaz Rune"],
  [PickupID.REVERSE_JUDGEMENT_CARD, "Reverse Judgement Card"],
  [PickupID.WHITE_BLUE_HORSE_PILL, "White-Blue Horse Pill"],
  [PickupID.ANSUZ_RUNE, "Ansuz Rune"],
  [PickupID.SOUL_HEART, "Soul Heart"],
  [PickupID.TWO_OF_HEARTS_CARD, "Two Of Hearts Card"],
  [PickupID.ACE_OF_SPADES_CARD, "Ace Of Spades Card"],
  [PickupID.ORANGE_ORANGE_PILL, "Orange-Orange Pill"],
  [PickupID.ALGIZ_RUNE, "Algiz Rune"],
  [PickupID.JUDGEMENT_CARD, "Judgement Card"],
  [PickupID.GOLD_HEART, "Gold Heart"],
  [PickupID.KEY_RING, "Key Ring"],
  [PickupID.TWO_OF_CLUBS_CARD, "Two Of Clubs Card"],
  [PickupID.SOUL_OF_LILITH, "Soul Of Lilith"],
  [PickupID.ORANGE_ORANGE_HORSE_PILL, "Orange-Orange Horse Pill"],
  [PickupID.BROKEN_SHOVEL, "Broken Shovel"],
  [PickupID.ETERNAL_CHEST, "Eternal Chest"],
  [PickupID.REVERSE_HERMIT_CARD, "Reverse Hermit Card"],
  [PickupID.BLUE_BLUE_HORSE_PILL, "Blue-Blue Horse Pill"],
  [PickupID.YELLOW_ORANGE_HORSE_PILL, "Yellow-Orange Horse Pill"],
  [PickupID.REVERSE_MAGICIAN_CARD, "Reverse Magician Card"],
  [PickupID.BLUE_CADET_BLUE_HORSE_PILL, "Blue-Cadet-Blue Horse Pill"],
  [PickupID.GRAB_BAG, "Grab Bag"],
  [PickupID.REVERSE_WORLD_CARD, "Reverse World Card"],
  [PickupID.GOLDEN_BATTERY, "Golden Battery"],
  [PickupID.SOUL_HEART_HALF, "Soul Heart Half"],
  [PickupID.SOUL_OF_SAMSON, "Soul Of Samson"],
  [PickupID.HIGH_PRIESTESS_CARD, "High Priestess Card"],
  [PickupID.SOUL_OF_JACOB_AND_ESAU, "Soul Of Jacob And Esau"],
  [PickupID.WHITE_WHITE_HORSE_PILL, "White-White Horse Pill"],
  [PickupID.STICKY_NICKEL, "Sticky Nickel"],
  [PickupID.ROTTEN_HEART, "Rotten Heart"],
  [PickupID.PINK_RED_HORSE_PILL, "Pink-Red Horse Pill"],
  [PickupID.REVERSE_HANGED_MAN_CARD, "Reverse Hanged Man Card"],
  [PickupID.DOTS_WHITE_PILL, "Dotted-White Pill"],
  [PickupID.YELLOW_ORANGE_PILL, "Yellow-Orange Pill"],
  [PickupID.WOODEN_CHEST, "Wooden Chest"],
  [PickupID.LUCKY_PENNY, "Lucky Penny"],
  [PickupID.WHITE_AZURE_HORSE_PILL, "White-Azure Horse Pill"],
  [PickupID.REVERSE_HIGH_PRIESTESS_CARD, "Reverse High Priestess Card"],
  [PickupID.DOUBLE_HEART, "Double Heart"],
  [PickupID.DIME, "Dime"],
  [PickupID.NICKEL, "Nickel"],
  [PickupID.TEMPERANCE_CARD, "Temperance Card"],
  [PickupID.MIMIC_CHEST, "Mimic Chest"],
  [PickupID.PINK_RED_PILL, "Pink-Red Pill"],
  [PickupID.HAUNTED_CHEST, "Haunted Chest"],
  [PickupID.REVERSE_STRENGTH_CARD, "Reverse Strength Card"],
  [PickupID.BIG_POOP_NUGGET, "Big Poop Nugget"],
  [PickupID.WORLD_CARD, "World Card"],
  [PickupID.MAGICIAN_CARD, "Magician Card"],
  [PickupID.WHITE_AZURE_PILL, "White-Azure Pill"],
  [PickupID.WHITE_YELLOW_HORSE_PILL, "White-Yellow Horse Pill"],
  [PickupID.SHOP_ITEM, "Shop Item"],
  [PickupID.WHEEL_OF_FORTUNE_CARD, "Wheel Of Fortune Card"],
  [PickupID.MOMS_CHEST, "Moms Chest"],
  [PickupID.LIL_BATTERY, "Lil Battery"],
  [PickupID.HOLY_CARD, "Holy Card"],
  [PickupID.DOTS_RED_HORSE_PILL, "Dotted-Red Horse Pill"],
  [PickupID.CHALLENGE_TROPHY, "Challenge Trophy"],
  [PickupID.REVERSE_EMPEROR_CARD, "Reverse Emperor Card"],
  [PickupID.SOUL_OF_FORGOTTEN, "Soul Of Forgotten"],
  [PickupID.MICRO_BATTERY, "Micro Battery"],
  [PickupID.SOUL_OF_KEEPER, "Soul Of Keeper"],
  [PickupID.SOUL_OF_LOST, "Soul Of Lost"],
  [PickupID.JERA_RUNE, "Jera Rune"],
  [PickupID.DOTS_RED_PILL, "Dotted-Red Pill"],
  [PickupID.GOLD_GOLD_HORSE_PILL, "Gold-Gold Horse Pill"],
  [PickupID.MEGA_BATTERY, "Mega Battery"],
  [PickupID.SOUL_OF_EDEN, "Soul Of Eden"],
  [PickupID.GOLD_GOLD_PILL, "Gold-Gold Pill"],
  [PickupID.BLACK_SACK, "Black Sack"],
  [PickupID.SOUL_OF_EVE, "Soul Of Eve"],
  [PickupID.REVERSE_DEATH_CARD, "Reverse Death Card"],
  [PickupID.BLUE_BLUE_PILL, "Blue-Blue Pill"],
  [PickupID.GIGA_BOMB, "Giga Bomb"],
  [PickupID.REVERSE_EMPRESS_CARD, "Reverse Empress Card"],
  [PickupID.ACE_OF_HEARTS_CARD, "Ace Of Hearts Card"],
  [PickupID.SOUL_OF_LAZARUS, "Soul Of Lazarus"],
  [PickupID.SOUL_OF_BLUE_BABY, "Soul Of Blue Baby"],
  [PickupID.SOUL_OF_JUDAS, "Soul Of Judas"],
  [PickupID.SOUL_OF_CAIN, "Soul Of Cain"],
  [PickupID.RULES_CARD, "Rules Card"],
  [PickupID.WHITE_BLACK_HORSE_PILL, "White-Black Horse Pill"],
  [PickupID.REVERSE_WHEEL_OF_FORTUNE_CARD, "Reverse Wheel Of Fortune Card"],
  [PickupID.SOUL_OF_MAGDALENE, "Soul Of Magdalene"],
  [PickupID.WILD_CARD, "Wild Card"],
  [PickupID.BLUE_CADET_BLUE_PILL, "Blue-Cadet-Blue Pill"],
  [PickupID.SOUL_OF_ISAAC, "Soul Of Isaac"],
  [PickupID.CRACKED_KEY, "Cracked Key"],
  [PickupID.REVERSE_STARS_CARD, "Reverse Stars Card"],
  [PickupID.BOMB, "Bomb"],
  [PickupID.REVERSE_SUN_CARD, "Reverse Sun Card"],
  [PickupID.REVERSE_MOON_CARD, "Reverse Moon Card"],
  [PickupID.REVERSE_JUSTICE_CARD, "Reverse Justice Card"],
  [PickupID.MEGATROLL_BOMB, "Megatroll Bomb"],
  [PickupID.REVERSE_TOWER_CARD, "Reverse Tower Card"],
  [PickupID.REVERSE_DEVIL_CARD, "Reverse Devil Card"],
  [PickupID.REVERSE_TEMPERANCE_CARD, "Reverse Temperance Card"],
  [PickupID.REVERSE_CHARIOT_CARD, "Reverse Chariot Card"],
  [PickupID.BOMB_CHEST, "Bomb Chest"],
  [PickupID.ISAACS_BED, "Isaacs Bed"],
  [PickupID.REVERSE_LOVERS_CARD, "Reverse Lovers Card"],
  [PickupID.MOMS_BED, "Moms Bed"],
  [PickupID.BONE_HEART, "Bone Heart"],
  [PickupID.JOKER_CARD, "Joker Card"],
  [PickupID.REVERSE_FOOL_CARD, "Reverse Fool Card"],
  [PickupID.HERMIT_CARD, "Hermit Card"],
  [PickupID.BLACK_RUNE, "Black Rune"],
  [PickupID.DEATH_CARD, "Death Card"],
  [PickupID.ERA_WALK_CARD, "Era Walk Card"],
  [PickupID.HUGE_GROWTH_CARD, "Huge Growth Card"],
  [PickupID.GOLDEN_KEY, "Golden Key"],
  [PickupID.HANGED_MAN_CARD, "Hanged Man Card"],
  [PickupID.EMERGENCY_CONTACT_CARD, "Emergency Contact Card"],
  [PickupID.DICE_SHARD_CARD, "Dice Shard Card"],
  [PickupID.WHITE_YELLOW_PILL, "White-Yellow Pill"],
  [PickupID.HALF_HEART, "Half Heart"],
  [PickupID.EMPEROR_CARD, "Emperor Card"],
  [PickupID.PENNY, "Penny"],
  [PickupID.WHITE_WHITE_PILL, "White-White Pill"],
  [PickupID.BLACK_YELLOW_HORSE_PILL, "Black-Yellow Horse Pill"],
  [PickupID.WHITE_BLACK_PILL, "White-Black Pill"],
  [PickupID.BLACK_YELLOW_PILL, "Black-Yellow Pill"],
  [PickupID.GET_OUT_OF_JAIL_FREE_CARD, "Get Out Of Jail Free Card"],
  [PickupID.DOUBLE_PENNY, "Double Penny"],
  [PickupID.LOCKED_CHEST, "Locked Chest"],
  [PickupID.STRENGTH_CARD, "Strength Card"],
  [PickupID.SUICIDE_KING_CARD, "Suicide King Card"],
  [PickupID.MEGA_CHEST, "Mega Chest"],
  [PickupID.CARD_AGAINST_HUMANITY, "Card Against Humanity"],
  [PickupID.PERTHRO_RUNE, "Perthro Rune"],
  [PickupID.SOUL_OF_APOLLYON, "Soul Of Apollyon"],
  [PickupID.DOTS_WHITE_HORSE_PILL, "Dotted-White Horse Pill"],
  [PickupID.RED_CHEST, "Red Chest"],
  [PickupID.CREDIT_CARD, "Credit Card"],
  [PickupID.WHITE_BLUE_PILL, "White-Blue Pill"],
  [PickupID.ANCIENT_RECALL_CARD, "Ancient Recall Card"],
  [PickupID.COLLECTIBLE, "Collectible"],
  [PickupID.BLANK_RUNE, "Blank Rune"],
  [PickupID.MOON_CARD, "Moon Card"],
  [PickupID.BERKANO_RUNE, "Berkano Rune"],
  [PickupID.SPIKED_CHEST, "Spiked Chest"],
  [PickupID.EHWAZ_RUNE, "Ehwaz Rune"],
  [PickupID.CHARGED_KEY, "Charged Key"],
  [PickupID.DAGAZ_RUNE, "Dagaz Rune"],
  [PickupID.SOUL_OF_AZAZEL, "Soul Of Azazel"],
  [PickupID.ETERNAL_HEART, "Eternal Heart"],
  [PickupID.QUESTION_MARK_CARD, "Question Mark Card"],
  [PickupID.RUNE_SHARD, "Rune Shard"],
  [PickupID.ACE_OF_DIAMONDS_CARD, "Ace Of Diamonds Card"],
  [PickupID.BLACK_HEART, "Black Heart"],
  [PickupID.DOUBLE_BOMB, "Double Bomb"],
  [PickupID.ACE_OF_CLUBS_CARD, "Ace Of Clubs Card"],
  [PickupID.FOOL_CARD, "Fool Card"],
  [PickupID.CHARIOT_CARD, "Chariot Card"],
  [PickupID.TWO_OF_SPADES_CARD, "Two Of Spades Card"],
  [PickupID.TWO_OF_DIAMONDS_CARD, "Two Of Diamonds Card"],
  [PickupID.SUN_CARD, "Sun Card"],
  [PickupID.BIG_CHEST, "Big Chest"],
  [PickupID.THROWABLE_BOMB, "Throwable Bomb"],
  [PickupID.STARS_CARD, "Stars Card"],
  [PickupID.CHAOS_CARD, "Chaos Card"],
  [PickupID.OLD_CHEST, "Old Chest"],
  [PickupID.CHEST, "Chest"],
  [PickupID.TOWER_CARD, "Tower Card"],
  [PickupID.JUSTICE_CARD, "Justice Card"],
  [PickupID.LOVERS_CARD, "Lovers Card"],
  [PickupID.EMPRESS_CARD, "Empress Card"],
  [PickupID.TRINKET, "Trinket"],
  [PickupID.POOP_NUGGET, "Poop Nugget"],
]);

export function getNonModdedPickupName(pickupID: PickupID): string | undefined {
  return PICKUP_NAME_MAP.get(pickupID);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\pickupTypeNameMap.ts`:

```````ts
import { ReadonlyMap } from "isaacscript-common";
import { PickupType } from "../../../enums/general/PickupType";

const PICKUP_TYPE_NAME_MAP = new ReadonlyMap<PickupType, string>([
  [PickupType.HEART, "Heart"],
  [PickupType.COIN, "Coin"],
  [PickupType.KEY, "Key"],
  [PickupType.BOMB, "Bomb"],
  [PickupType.BATTERY, "Battery"],
  [PickupType.PILL, "Pill"],
  [PickupType.CARD, "Card"],
  [PickupType.RUNE, "Rune"],
  [PickupType.SACK, "Sack"],
  [PickupType.CHEST, "Chest"],
  [PickupType.SHOP_ITEM, "Shop Item"],
  [PickupType.TRINKET, "Trinket"],
  [PickupType.COLLECTIBLE, "Collectible"],
  [PickupType.CHEST, "Chest"],
  [PickupType.MISCELLANEOUS, "Miscellaneous Pickup"],
  [PickupType.POOP, "Poop Pickup"],
  [PickupType.SOUL, "Soul Stone"],
]);

/**
 * Get the name of a pickup type.
 *
 * @param pickupType The pickup type to get the name of.
 * @returns The name of the pickup type.
 * @example pickupTypeToString(PickupType.HEART) -> "Heart"
 * @example pickupTypeToString(PickupType.COIN) -> "Coin"
 * @example pickupTypeToString(PickupType.KEY) -> "Key"
 * @example pickupTypeToString(PickupType.POOP) -> "Poop Pickup"
 */
export function pickupTypeToString(pickupType: PickupType): string {
  const pickupTypeName = PICKUP_TYPE_NAME_MAP.get(pickupType);
  if (pickupTypeName === undefined) {
    error(`No pickup type name found for pickup type ${pickupType}`);
  }

  return pickupTypeName;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\roomTypeNameMap.ts`:

```````ts
import { RoomType } from "isaac-typescript-definitions";

const ROOM_TYPE_TO_NAME_MAP: ReadonlyMap<RoomType, string> = new Map([
  [RoomType.DEFAULT, "Default Room"],
  [RoomType.SHOP, "Shop"],
  [RoomType.ERROR, "Error Room"],
  [RoomType.TREASURE, "Treasure Room"],
  [RoomType.BOSS, "Boss Room"],
  [RoomType.MINI_BOSS, "Miniboss Room"],
  [RoomType.SECRET, "Secret Room"],
  [RoomType.SUPER_SECRET, "Super Secret Room"],
  [RoomType.ARCADE, "Arcade"],
  [RoomType.CURSE, "Curse Room"],
  [RoomType.CHALLENGE, "Challenge Room"],
  [RoomType.LIBRARY, "Library"],
  [RoomType.SACRIFICE, "Sacrifice Room"],
  [RoomType.DEVIL, "Devil Room"],
  [RoomType.ANGEL, "Angel Room"],
  [RoomType.DUNGEON, "Crawl Space"],
  [RoomType.BOSS_RUSH, "Boss Rush"],
  [RoomType.CLEAN_BEDROOM, "Clean Bedroom"],
  [RoomType.DIRTY_BEDROOM, "Dirty Bedroom"],
  [RoomType.VAULT, "the Chest"],
  [RoomType.DICE, "Dice Room"],
  [RoomType.BLACK_MARKET, "Black Market"],
  [RoomType.GREED_EXIT, "Greed Exit Room"],
  [RoomType.PLANETARIUM, "Planetarium"],
  [RoomType.TELEPORTER, "Mausoleum Teleporter Entrance Room"],
  [RoomType.TELEPORTER_EXIT, "Mausoleum Teleporter Exit Room"],
  [RoomType.SECRET_EXIT, "Strange Room"],
  [RoomType.BLUE, "Blue Womb Room"],
  [RoomType.ULTRA_SECRET, "Ultra Secret Room"],
]);

/**
 * Retrieves a printable named version of the specified roomType enum value. Note, this will not
 * always contain the word 'room' afterwards, but should always be understandable.
 *
 * @example RoomType.BOSS_RUSH = "boss rush".
 * @example RoomType.CHALLENGE = "challenge room" (added 'room' to make it clearer).
 */
export function roomTypeToString(roomType: RoomType): string {
  const name = ROOM_TYPE_TO_NAME_MAP.get(roomType);
  if (name === undefined) {
    error(`RoomTypeNameMap: Cannot find Name of RoomType: ${roomType}`);
  }
  return name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\name\tearVariantNameMap.ts`:

```````ts
import { TearVariant } from "isaac-typescript-definitions";
import { ReadonlyMap } from "isaacscript-common";

const TEAR_VARIANT_NAME_MAP = new ReadonlyMap<TearVariant, string>([
  [TearVariant.BLUE, "Blue"],
  [TearVariant.BLOOD, "Blood"],
  [TearVariant.TOOTH, "Tooth"],
  [TearVariant.METALLIC, "Metallic"],
  [TearVariant.BOBS_HEAD, "Bob's Head"],
  [TearVariant.FIRE_MIND, "Fire Mind"],
  [TearVariant.DARK_MATTER, "Dark Matter"],
  [TearVariant.MYSTERIOUS, "Mysterious"],
  [TearVariant.SCHYTHE, "Schythe"],
  [TearVariant.CHAOS_CARD, "Chaos Card"],
  [TearVariant.LOST_CONTACT, "Lost Contact"],
  [TearVariant.CUPID_BLUE, "Blue Cupid"],
  [TearVariant.CUPID_BLOOD, "Cupid Blood"],
  [TearVariant.NAIL, "Nail"],
  [TearVariant.PUPULA, "Pupula"],
  [TearVariant.PUPULA_BLOOD, "Pupula Blood"],
  [TearVariant.GODS_FLESH, "God's Flesh"],
  [TearVariant.GODS_FLESH_BLOOD, "God's Flesh Blood"],
  [TearVariant.DIAMOND, "Diamond"],
  [TearVariant.EXPLOSIVO, "Explosivo"],
  [TearVariant.COIN, "Coin"],
  [TearVariant.MULTIDIMENSIONAL, "Multidimensional"],
  [TearVariant.STONE, "Stone"],
  [TearVariant.NAIL_BLOOD, "Nail Blood"],
  [TearVariant.GLAUCOMA, "Glaucoma"],
  [TearVariant.GLAUCOMA_BLOOD, "Glaucoma Blood"],
  [TearVariant.BOOGER, "Booger"],
  [TearVariant.EGG, "Egg"],
  [TearVariant.RAZOR, "Razor"],
  [TearVariant.BONE, "Bone"],
  [TearVariant.BLACK_TOOTH, "Black Tooth"],
  [TearVariant.NEEDLE, "Needle"],
  [TearVariant.BELIAL, "Belial"],
  [TearVariant.EYE, "Eye"],
  [TearVariant.EYE_BLOOD, "Eye Blood"],
  [TearVariant.BALLOON, "Balloon"],
  [TearVariant.HUNGRY, "Hungry"],
  [TearVariant.BALLOON_BRIMSTONE, "Brimstone Balloon"],
  [TearVariant.BALLOON_BOMB, "Balloon Bomb"],
  [TearVariant.FIST, "Fist"],
  [TearVariant.GRID_ENTITY, "Grid Entity"],
  [TearVariant.ICE, "Ice"],
  [TearVariant.ROCK, "Rock"],
  [TearVariant.KEY, "Key"],
  [TearVariant.KEY_BLOOD, "Key Blood"],
  [TearVariant.ERASER, "Eraser"],
  [TearVariant.FIRE, "Fire"],
  [TearVariant.SWORD_BEAM, "Sword Beam"],
  [TearVariant.SPORE, "Spore"],
  [TearVariant.TECH_SWORD_BEAM, "Tech Sword Beam"],
  [TearVariant.FETUS, "Fetus"],
]);

/**
 * Convert the TearVariant to string form.
 *
 * @example TearVariant.BALLOON -> "Balloon"
 */
export function tearVariantToString(tearVariant: TearVariant): string {
  const name = TEAR_VARIANT_NAME_MAP.get(tearVariant);
  if (name === undefined) {
    error(`Unknown tear variant: ${tearVariant}`);
  }

  return name;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\npc\NPCMaxHitPointsMap.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";

/** Map linking every NPC to their Max HitPoints (HP they start with). */
const NPC_MAX_HITPOINTS_MAP: ReadonlyMap<NPCID, number> = new Map([
  [NPCID.FROWNING_GAPER, 10],
  [NPCID.GAPER, 10],
  [NPCID.FLAMING_GAPER, 9],
  [NPCID.ROTTEN_GAPER, 24],
  [NPCID.ROTTEN_GAPER_2, 24],
  [NPCID.ROTTEN_GAPER_3, 24],
  [NPCID.ROTTEN_GAPER_4, 24],
  [NPCID.ROTTEN_GAPER_5, 24],
  [NPCID.ROTTEN_GAPER_6, 24],
  [NPCID.WIDOW, 130],
  [NPCID.WIDOW_BLACK, 130],
  [NPCID.WIDOW_PINK, 117],
  [NPCID.THE_WRETCHED, 215],
  [NPCID.DADDY_LONG_LEGS, 500],
  [NPCID.TRIACHNID, 500],
  [NPCID.ISAAC, 2000],
  [NPCID.BLUE_BABY, 2000],
  [NPCID.BLUE_BABY_HUSH, 1000],
  [NPCID.GUSHER, 10],
  [NPCID.PACER, 10],
  [NPCID.HORF, 10],
  [NPCID.FLY, 3],
  [NPCID.POOTER, 8],
  [NPCID.SUPER_POOTER, 8],
  [NPCID.TAINTED_POOTER, 75],
  [NPCID.CLOTTY, 15],
  [NPCID.CLOT, 15],
  [NPCID.I_BLOB, 15],
  [NPCID.GRILLED_CLOTTY, 20],
  [NPCID.MULLIGAN, 13],
  [NPCID.MULLIGOON, 13],
  [NPCID.MULLIBOOM, 13],
  [NPCID.SHOPKEEPER, 5],
  [NPCID.SECRET_ROOM_KEEPER, 5],
  [NPCID.ERROR_ROOM_KEEPER, 5],
  [NPCID.SPECIAL_SHOPKEEPER, 5],
  [NPCID.SPECIAL_SECRET_ROOM_KEEPER, 5],
  [NPCID.ATTACK_FLY, 5],
  [NPCID.LARRY_JR, 22],
  [NPCID.LARRY_JR_GREEN, 22],
  [NPCID.LARRY_JR_BLUE, 31.900_001_525_879],
  [NPCID.THE_HOLLOW, 26],
  [NPCID.THE_HOLLOW_GREEN, 26],
  [NPCID.THE_HOLLOW_BLACK, 32.5],
  [NPCID.THE_HOLLOW_YELLOW, 32.5],
  [NPCID.TUFF_TWIN, 35],
  [NPCID.THE_SHELL, 35],
  [NPCID.MONSTRO, 250],
  [NPCID.MONSTRO_RED, 112.5],
  [NPCID.MONSTRO_GREY, 312.5],
  [NPCID.STONE_EYE, 1],
  [NPCID.CONSTANT_STONE_SHOOTER_LEFT, 1],
  [NPCID.CONSTANT_STONE_SHOOTER_UP, 1],
  [NPCID.CONSTANT_STONE_SHOOTER_RIGHT, 1],
  [NPCID.CONSTANT_STONE_SHOOTER_DOWN, 1],
  [NPCID.CROSS_STONE_SHOOTER, 1],
  [NPCID.CROSS_STONE_SHOOTER_2, 1],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON, 1],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON_2, 1],
  [NPCID.BRIMSTONE_HEAD, 1],
  [NPCID.MOBILE_HOST, 14],
  [NPCID.NEST, 20],
  [NPCID.BABY_LONG_LEGS, 20],
  [NPCID.SMALL_BABY_LONG_LEGS, 16],
  [NPCID.CRAZY_LONG_LEGS, 20],
  [NPCID.SMALL_CRAZY_LONG_LEGS, 16],
  [NPCID.FATTY, 20],
  [NPCID.PALE_FATTY, 20],
  [NPCID.FLAMING_FATTY, 18],
  [NPCID.FAT_SACK, 16],
  [NPCID.MAGGOT, 15],
  [NPCID.BLUBBER, 16],
  [NPCID.HALF_SACK, 10],
  [NPCID.DEATHS_HEAD, 20],
  [NPCID.DANK_DEATHS_HEAD, 20],
  [NPCID.CURSED_DEATHS_HEAD, 20],
  [NPCID.BRIMSTONE_DEATHS_HEAD, 20],
  [NPCID.REDSKULL, 80],
  [NPCID.MOMS_HAND, 20],
  [NPCID.LEVEL_2_FLY, 10],
  [NPCID.LEVEL_2_SPIDER, 13],
  [NPCID.SWINGER, 38],
  [NPCID.SWINGER_HEAD, 38],
  [NPCID.SWINGER_NECK, 38],
  [NPCID.DIP, 4],
  [NPCID.CORN, 3],
  [NPCID.BROWNIE_CORN, 3],
  [NPCID.BIG_CORN, 8],
  [NPCID.WALL_HUGGER, 100],
  [NPCID.WIZOOB, 24],
  [NPCID.HIVE, 20],
  [NPCID.DROWNED_HIVE, 18],
  [NPCID.HOLY_MULLIGAN, 43],
  [NPCID.TAINTED_MULLIGAN, 108],
  [NPCID.SQUIRT, 21],
  [NPCID.DANK_SQUIRT, 21],
  [NPCID.COD_WORM, 20],
  [NPCID.RING_FLY, 5],
  [NPCID.DINGA, 62],
  [NPCID.OOB, 100],
  [NPCID.BLACK_MAW, 26],
  [NPCID.SKINNY, 14],
  [NPCID.ROTTY, 21],
  [NPCID.CRISPY, 16],
  [NPCID.BONY, 10],
  [NPCID.HOLY_BONY, 74],
  [NPCID.HOMUNCULUS, 36],
  [NPCID.HOMUNCULUS_CORD, 20],
  [NPCID.TUMOR, 20],
  [NPCID.PLANETOID, 32],
  [NPCID.CHARGER, 20],
  [NPCID.MY_SHADOW, 20],
  [NPCID.DROWNED_CHARGER, 22],
  [NPCID.DANK_CHARGER, 26],
  [NPCID.CARRION_PRINCESS, 26],
  [NPCID.CAMILLO_JR, 32],
  [NPCID.NERVE_ENDING, 20],
  [NPCID.NERVE_ENDING_2, 20],
  [NPCID.ONE_TOOTH, 20],
  [NPCID.GAPING_MAW, 100],
  [NPCID.BROKEN_GAPING_MAW, 100],
  [NPCID.GURGLING, 28],
  [NPCID.GURGLING_BOSS, 60],
  [NPCID.GURGLING_BOSS_YELLOW, 60],
  [NPCID.GURGLING_BOSS_BLACK, 60],
  [NPCID.TURDLING, 50],
  [NPCID.SPLASHER, 12],
  [NPCID.GRUB, 12.5],
  [NPCID.CORPSE_EATER, 50.5],
  [NPCID.CARRION_RIDER, 50.5],
  [NPCID.GLOBIN, 33],
  [NPCID.GAZING_GLOBIN, 33],
  [NPCID.DANK_GLOBIN, 33],
  [NPCID.CURSED_GLOBIN, 33],
  [NPCID.WALL_CREEP, 10],
  [NPCID.SOY_CREEP, 13.5],
  [NPCID.RAG_CREEP, 21],
  [NPCID.TAINTED_SOY_CREEP, 50],
  [NPCID.RAGE_CREEP, 10],
  [NPCID.SPLIT_RAGE_CREEP, 16],
  [NPCID.BLIND_CREEP, 10],
  [NPCID.CONJOINED_SPITTY, 18],
  [NPCID.ROUND_WORM, 10],
  [NPCID.TUBE_WORM, 20],
  [NPCID.TAINTED_ROUND_WORM, 100],
  [NPCID.TAINTED_ROUND_WORM_BUTT, 100],
  [NPCID.TAINTED_TUBE_WORM, 100],
  [NPCID.POOP, 5],
  [NPCID.RAGLING, 13],
  [NPCID.RAG_MANS_RAGLING, 30],
  [NPCID.RAG_MANS_RAGLING_RED, 30],
  [NPCID.RAG_MANS_RAGLING_BLACK, 30],
  [NPCID.FLESH_MOBILE_HOST, 27],
  [NPCID.PSYCHIC_HORF, 10],
  [NPCID.FULL_FLY, 10],
  [NPCID.BOOM_FLY, 11],
  [NPCID.RED_BOOM_FLY, 11],
  [NPCID.DROWNED_BOOM_FLY, 11],
  [NPCID.DRAGON_FLY, 11],
  [NPCID.DRAGON_FLY_X, 11],
  [NPCID.BONE_FLY, 11],
  [NPCID.SICK_BOOM_FLY, 11],
  [NPCID.TAINTED_BOOM_FLY, 20],
  [NPCID.TICKING_SPIDER, 13],
  [NPCID.BEGOTTEN, 60],
  [NPCID.BEGOTTEN_CHAIN, 60],
  [NPCID.NULLS, 30],
  [NPCID.PSY_TUMOR, 40],
  [NPCID.FLOATING_KNIGHT, 20],
  [NPCID.NIGHT_CRAWLER, 35],
  [NPCID.DART_FLY, 5],
  [NPCID.CONJOINED_FATTY, 20],
  [NPCID.BLUE_CONJOINED_FATTY, 60],
  [NPCID.FAT_BAT, 35],
  [NPCID.IMP, 25],
  [NPCID.MAW, 20],
  [NPCID.RED_MAW, 20],
  [NPCID.PSYCHIC_MAW, 20],
  [NPCID.HAUNT, 200],
  [NPCID.HAUNT_BLACK, 200],
  [NPCID.HAUNT_PINK, 100],
  [NPCID.LIL_HAUNT, 25],
  [NPCID.DINGLE, 300],
  [NPCID.DINGLE_RED, 300],
  [NPCID.DINGLE_BLACK, 300],
  [NPCID.DANGLE, 375],
  [NPCID.MEGA_MAW, 350],
  [NPCID.MEGA_MAW_RED, 350],
  [NPCID.MEGA_MAW_BLACK, 350],
  [NPCID.THE_GATE, 500],
  [NPCID.THE_GATE_RED, 500],
  [NPCID.THE_GATE_BLACK, 625],
  [NPCID.MEGA_FATTY, 600],
  [NPCID.MEGA_FATTY_RED, 540],
  [NPCID.MEGA_FATTY_BROWN, 690],
  [NPCID.THE_CAGE, 800],
  [NPCID.THE_CAGE_GREEN, 800],
  [NPCID.THE_CAGE_PINK, 400],
  [NPCID.MAMA_GURDY, 750],
  [NPCID.MAMA_GURDY_LEFT_HAND, 1],
  [NPCID.MAMA_GURDY_RIGHT_HAND, 1],
  [NPCID.DARK_ONE, 400],
  [NPCID.THE_ADVERSARY, 520],
  [NPCID.POLYCEPHALUS, 200],
  [NPCID.POLYCEPHALUS_RED, 200],
  [NPCID.POLYCEPHALUS_PINK, 100],
  [NPCID.THE_PILE, 580],
  [NPCID.HOST, 14],
  [NPCID.RED_HOST, 15],
  [NPCID.HARD_HOST, 15],
  [NPCID.MR_FRED, 500],
  [NPCID.URIEL, 400],
  [NPCID.FALLEN_URIEL, 450],
  [NPCID.GABRIEL, 660],
  [NPCID.FALLEN_GABRIEL, 750],
  [NPCID.THE_LAMB, 2000],
  [NPCID.LAMB_BODY, 600],
  [NPCID.MEGA_SATAN, 3000],
  [NPCID.MEGA_SATANS_RIGHT_HAND, 600],
  [NPCID.MEGA_SATANS_LEFT_HAND, 600],
  [NPCID.MEGA_SATAN_2, 2000],
  [NPCID.MEGA_SATAN_2_RIGHT_HAND, 600],
  [NPCID.MEGA_SATAN_2_LEFT_HAND, 600],
  [NPCID.ROUNDY, 10],
  [NPCID.BLACK_BONY, 10],
  [NPCID.BLACK_GLOBIN, 33],
  [NPCID.BLACK_GLOBINS_HEAD, 20],
  [NPCID.CHUB, 350],
  [NPCID.CHUB_BLUE, 437.5],
  [NPCID.CHUB_ORANGE, 297.5],
  [NPCID.CHAD, 350],
  [NPCID.THE_CARRION_QUEEN, 350],
  [NPCID.THE_CARRION_QUEEN_PINK, 700],
  [NPCID.BLACK_GLOBINS_BODY, 10],
  [NPCID.SWARM, 5],
  [NPCID.MEGA_CLOTTY, 20],
  [NPCID.BONE_KNIGHT, 20],
  [NPCID.CYCLOPIA, 10],
  [NPCID.RED_GHOST, 24],
  [NPCID.FLESH_DEATHS_HEAD, 30],
  [NPCID.MOMS_DEAD_HAND, 20],
  [NPCID.DUKIE, 25],
  [NPCID.ULCER, 10],
  [NPCID.HOPPER, 10],
  [NPCID.TRITE, 10],
  [NPCID.EGGY, 22],
  [NPCID.TAINTED_HOPPER, 80],
  [NPCID.MEATBALL, 15],
  [NPCID.PITFALL, 0],
  [NPCID.SUCTION_PITFALL, 0],
  [NPCID.TELEPORT_PITFALL, 0],
  [NPCID.MOVABLE_TNT, 4],
  [NPCID.MOVABLE_TNT_MINE_CRAFTER, 4],
  [NPCID.ULTRA_GREED_COIN_SPINNER, 50],
  [NPCID.ULTRA_GREED_COIN_KEY, 60],
  [NPCID.ULTRA_GREED_COIN_BOMB, 50],
  [NPCID.ULTRA_GREED_COIN_HEART, 40],
  [NPCID.ULTRA_GREED_DOOR, 0],
  [NPCID.CORN_MINE, 8],
  [NPCID.CORN_MINE_BLACK, 8],
  [NPCID.HUSH_FLY, 10],
  [NPCID.BLUE_GAPER, 18],
  [NPCID.BLUE_BOIL, 20],
  [NPCID.GREED_GAPER, 9],
  [NPCID.BOIL, 20],
  [NPCID.BOIL_BLUE, 20],
  [NPCID.GUT, 20],
  [NPCID.SACK, 20],
  [NPCID.MUSHROOM, 23],
  [NPCID.POISON_MIND, 20],
  [NPCID.STONEY, 50],
  [NPCID.CROSS_STONEY, 50],
  [NPCID.BLISTER, 24],
  [NPCID.THE_THING, 15],
  [NPCID.MINISTRO, 11],
  [NPCID.PORTAL, 14],
  [NPCID.LIL_PORTAL, 21],
  [NPCID.TAR_BOY, 55],
  [NPCID.TAR_BOY_MOUTH, 1],
  [NPCID.FISTULOID, 30],
  [NPCID.GUSH, 20],
  [NPCID.SPITTY, 10],
  [NPCID.TAINTED_SPITTY, 60],
  [NPCID.LEPER, 60],
  [NPCID.LEPER_STAGE_2, 45],
  [NPCID.LEPER_STAGE_3, 30],
  [NPCID.LEPER_STAGE_4, 15],
  [NPCID.LEPER_FLESH, 6.5],
  [NPCID.MR_MINE, 20],
  [NPCID.MR_MINE_NECK, 20],
  [NPCID.BRAIN, 20],
  [NPCID.FIRE_PLACE, 5],
  [NPCID.RED_FIRE_PLACE, 5],
  [NPCID.MOVEABLE_FIREPLACE, 5],
  [NPCID.COAL, 15],
  [NPCID.COAL_2, 15],
  [NPCID.COAL_3, 15],
  [NPCID.COAL_4, 15],
  [NPCID.MOVEABLE_BLUE_FIREPLACE, 5],
  [NPCID.MOVEABLE_PURPLE_FIREPLACE, 5],
  [NPCID.BLUE_FIRE_PLACE, 5],
  [NPCID.PURPLE_FIRE_PLACE, 5],
  [NPCID.WHITE_FIRE_PLACE, 5],
  [NPCID.LEAPER, 25],
  [NPCID.STICKY_LEAPER, 28],
  [NPCID.MR_MAW, 25],
  [NPCID.MR_MAW_HEAD, 25],
  [NPCID.MR_MAW_NECK, 25],
  [NPCID.MR_RED_MAW, 25],
  [NPCID.MR_RED_MAW_HEAD, 10],
  [NPCID.GURDY, 595],
  [NPCID.GURDY_GREEN, 595],
  [NPCID.BABY, 25],
  [NPCID.ANGELIC_BABY, 25],
  [NPCID.ANGELIC_BABY_SMALL, 16],
  [NPCID.ULTRA_PRIDE_BABY, 35],
  [NPCID.WRINKLY_BABY, 25],
  [NPCID.VIS, 25],
  [NPCID.DOUBLE_VIS, 25],
  [NPCID.CHUBBER, 25],
  [NPCID.CHUBBER_PROJECTILE, 1000],
  [NPCID.SCARRED_DOUBLE_VIS, 22],
  [NPCID.GUTS, 25],
  [NPCID.SCARRED_GUTS, 28],
  [NPCID.SLOG, 28],
  [NPCID.THE_STAIN, 400],
  [NPCID.THE_STAIN_GREY, 400],
  [NPCID.BROWNIE, 400],
  [NPCID.BROWNIE_BLACK, 400],
  [NPCID.THE_FORSAKEN, 220],
  [NPCID.THE_FORSAKEN_BLACK, 220],
  [NPCID.LITTLE_HORN, 200],
  [NPCID.LITTLE_HORN_ORANGE, 200],
  [NPCID.LITTLE_HORN_BLACK, 200],
  [NPCID.DARK_BALL, 10],
  [NPCID.DARK_BALL_ORANGE, 10],
  [NPCID.DARK_BALL_BLACK, 10],
  [NPCID.RAG_MAN, 200],
  [NPCID.RAG_MAN_RED, 200],
  [NPCID.RAG_MAN_BLACK, 200],
  [NPCID.RAG_MANS_HEAD, 25],
  [NPCID.RAG_MANS_HEAD_RED, 25],
  [NPCID.RAG_MANS_HEAD_BLACK, 25],
  [NPCID.ULTRA_GREED, 3500],
  [NPCID.ULTRA_GREEDIER, 2500],
  [NPCID.HUSH, 6666],
  [NPCID.HUSH_SKINLESS, 500],
  [NPCID.RAG_MEGA, 120],
  [NPCID.PURPLE_BALL, 10],
  [NPCID.RAG_MEGA_REBIRTH_PILLAR, 10],
  [NPCID.KNIGHT, 20],
  [NPCID.SELFLESS_KNIGHT, 20],
  [NPCID.LOOSE_KNIGHT, 20],
  [NPCID.BRAINLESS_KNIGHT, 20],
  [NPCID.BLACK_KNIGHT, 30],
  [NPCID.SISTERS_VIS, 350],
  [NPCID.BIG_HORN, 480],
  [NPCID.SMALL_HOLE, 480],
  [NPCID.BIG_HOLE, 480],
  [NPCID.DELIRIUM, 10_000],
  [NPCID.THE_MATRIARCH, 700],
  [NPCID.STONE_GRIMACE, 20],
  [NPCID.VOMIT_GRIMACE, 20],
  [NPCID.TRIPLE_GRIMACE, 20],
  [NPCID.MONSTRO_II, 632.5],
  [NPCID.MONSTRO_II_RED, 569.25],
  [NPCID.GISH, 632.5],
  [NPCID.POKY, 100],
  [NPCID.SLIDE, 100],
  [NPCID.MOM, 645],
  [NPCID.MOM_BLUE, 793.350_036_621_09],
  [NPCID.MOM_RED, 645],
  [NPCID.MOM_STOMP, 645],
  [NPCID.MOM_STOMP_BLUE, 793.350_036_621_09],
  [NPCID.MOM_STOMP_RED, 645],
  [NPCID.SLOTH, 80],
  [NPCID.SUPER_SLOTH, 85],
  [NPCID.ULTRA_PRIDE, 85],
  [NPCID.LUST, 80],
  [NPCID.SUPER_LUST, 85],
  [NPCID.WRATH, 84],
  [NPCID.SUPER_WRATH, 90],
  [NPCID.GLUTTONY, 80],
  [NPCID.SUPER_GLUTTONY, 85],
  [NPCID.GREED, 80],
  [NPCID.SUPER_GREED, 85],
  [NPCID.ENVY, 47.5],
  [NPCID.SUPER_ENVY, 47.5],
  [NPCID.ENVY_BIG, 47.5],
  [NPCID.SUPER_ENVY_BIG, 47.5],
  [NPCID.ENVY_MEDIUM, 47.5],
  [NPCID.SUPER_ENVY_MEDIUM, 47.5],
  [NPCID.ENVY_SMALL, 47.5],
  [NPCID.SUPER_ENVY_SMALL, 47.5],
  [NPCID.PRIDE, 80],
  [NPCID.SUPER_PRIDE, 85],
  [NPCID.DOPLE, 20],
  [NPCID.EVIL_TWIN, 20],
  [NPCID.FLAMING_HOPPER, 20],
  [NPCID.LEECH, 25],
  [NPCID.KAMIKAZE_LEECH, 25],
  [NPCID.HOLY_LEECH, 25],
  [NPCID.LUMP, 30],
  [NPCID.MEMBRAIN, 62],
  [NPCID.MAMA_GUTS, 62],
  [NPCID.DEAD_MEAT, 62],
  [NPCID.PARA_BITE, 35],
  [NPCID.SCARRED_PARA_BITE, 35],
  [NPCID.FRED, 20],
  [NPCID.EYE, 20],
  [NPCID.BLOODSHOT_EYE, 20],
  [NPCID.HOLY_EYE, 25],
  [NPCID.SUCKER, 10],
  [NPCID.SPIT, 10],
  [NPCID.SOUL_SUCKER, 18],
  [NPCID.INK, 10],
  [NPCID.MAMA_FLY, 44],
  [NPCID.BULB, 12],
  [NPCID.BLOODFLY, 7],
  [NPCID.TAINTED_SUCKER, 15],
  [NPCID.PIN, 100],
  [NPCID.PIN_GREY, 125],
  [NPCID.SCOLEX, 300],
  [NPCID.THE_FRAIL, 200],
  [NPCID.THE_FRAIL_BLACK, 260],
  [NPCID.WORMWOOD, 200],
  [NPCID.FAMINE, 240],
  [NPCID.FAMINE_BLUE, 240],
  [NPCID.PESTILENCE, 280],
  [NPCID.PESTILENCE_GREY, 280],
  [NPCID.WAR, 500],
  [NPCID.WAR_GREY, 625],
  [NPCID.CONQUEST, 500],
  [NPCID.WAR_WITHOUT_HORSE, 500],
  [NPCID.WAR_WITHOUT_HORSE_GREY, 625],
  [NPCID.DEATH, 450],
  [NPCID.DEATH_BLACK, 562.5],
  [NPCID.DEATH_SCYTHE, 50],
  [NPCID.DEATH_SCYTHE_BLACK, 50],
  [NPCID.DEATH_HORSE, 150],
  [NPCID.DEATH_HORSE_BLACK, 187.5],
  [NPCID.DEATH_WITHOUT_HORSE, 300],
  [NPCID.DEATH_WITHOUT_HORSE_BLACK, 375],
  [NPCID.THE_DUKE_OF_FLIES, 110],
  [NPCID.THE_DUKE_OF_FLIES_GREEN, 110],
  [NPCID.THE_DUKE_OF_FLIES_ORANGE, 137.5],
  [NPCID.THE_HUSK, 150],
  [NPCID.THE_HUSK_BLACK, 233.999_984_741_21],
  [NPCID.THE_HUSK_RED, 150],
  [NPCID.PEEP, 450],
  [NPCID.PEEP_YELLOW, 450],
  [NPCID.PEEP_CYAN, 450],
  [NPCID.THE_BLOAT, 450],
  [NPCID.THE_BLOAT_GREEN, 450],
  [NPCID.PEEP_EYE, 450],
  [NPCID.PEEP_EYE_YELLOW, 450],
  [NPCID.PEEP_EYE_CYAN, 450],
  [NPCID.BLOAT_EYE, 450],
  [NPCID.BLOAT_EYE_GREEN, 450],
  [NPCID.LOKI, 350],
  [NPCID.LOKII, 350],
  [NPCID.FISTULA, 60],
  [NPCID.FISTULA_GREY, 75],
  [NPCID.TERATOMA, 60],
  [NPCID.FISTULA_MEDIUM, 15],
  [NPCID.FISTULA_MEDIUM_GREY, 18.75],
  [NPCID.TERATOMA_MEDIUM, 15],
  [NPCID.FISTULA_SMALL, 8],
  [NPCID.FISTULA_SMALL_GREY, 10],
  [NPCID.TERATOMA_SMALL, 8],
  [NPCID.BLASTOCYST, 300],
  [NPCID.BLASTOCYST_MEDIUM, 75],
  [NPCID.BLASTOCYST_SMALL, 30],
  [NPCID.EMBRYO, 12],
  [NPCID.MOMS_HEART, 950],
  [NPCID.IT_LIVES, 950],
  [NPCID.MOMS_GUTS, 0],
  [NPCID.GEMINI, 140],
  [NPCID.GEMINI_GREEN, 140],
  [NPCID.GEMINI_BLUE, 140],
  [NPCID.STEVEN, 140],
  [NPCID.GEMINI_BABY, 140],
  [NPCID.GEMINI_BABY_GREEN, 140],
  [NPCID.GEMINI_BABY_BLUE, 140],
  [NPCID.STEVEN_BABY, 140],
  [NPCID.THE_BLIGHTED_OVUM_BABY, 140],
  [NPCID.THE_BLIGHTED_OVUM, 140],
  [NPCID.UMBILICAL_CORD, 140],
  [NPCID.UMBILICAL_CORD_GREEN, 140],
  [NPCID.UMBILICAL_CORD_BLUE, 140],
  [NPCID.MOTER, 10],
  [NPCID.BLOOD_PUPPY_SMALL, 20],
  [NPCID.BLOOD_PUPPY_LARGE, 50],
  [NPCID.BLIND_BAT, 18],
  [NPCID.QUAKE_GRIMACE_LEFT, 20],
  [NPCID.QUAKE_GRIMACE_UP, 20],
  [NPCID.QUAKE_GRIMACE_RIGHT, 20],
  [NPCID.QUAKE_GRIMACE_DOWN, 20],
  [NPCID.BISHOP, 18],
  [NPCID.BUBBLES, 20],
  [NPCID.WRAITH, 10],
  [NPCID.WILLO, 6],
  [NPCID.BOMB_GRIMACE, 20],
  [NPCID.THE_FALLEN, 105],
  [NPCID.KRAMPUS, 105],
  [NPCID.SMALL_LEECH, 5],
  [NPCID.DEEP_GAPER, 10],
  [NPCID.DEEP_GAPER_2, 10],
  [NPCID.DEEP_GAPER_3, 10],
  [NPCID.DEEP_GAPER_4, 10],
  [NPCID.DEEP_GAPER_5, 10],
  [NPCID.DEEP_GAPER_6, 10],
  [NPCID.DEEP_GAPER_7, 10],
  [NPCID.SUB_HORF, 14],
  [NPCID.TAINTED_SUB_HORF, 50],
  [NPCID.BLURB, 16],
  [NPCID.STRIDER, 6.5],
  [NPCID.FISSURE, 6.5],
  [NPCID.POLTY, 16.5],
  [NPCID.KINETI, 48],
  [NPCID.PREY, 14],
  [NPCID.MULLIGHOUL, 14],
  [NPCID.ROCK_SPIDER, 12],
  [NPCID.ROCK_SPIDER_2, 12],
  [NPCID.ROCK_SPIDER_3, 12],
  [NPCID.ROCK_SPIDER_4, 12],
  [NPCID.TINTED_ROCK_SPIDER, 22],
  [NPCID.TINTED_ROCK_SPIDER_2, 22],
  [NPCID.TINTED_ROCK_SPIDER_3, 22],
  [NPCID.TINTED_ROCK_SPIDER_4, 22],
  [NPCID.COAL_SPIDER, 15],
  [NPCID.COAL_SPIDER_2, 15],
  [NPCID.COAL_SPIDER_3, 15],
  [NPCID.COAL_SPIDER_4, 15],
  [NPCID.FLY_BOMB, 7],
  [NPCID.ETERNAL_FLY_BOMB, 7],
  [NPCID.HEADLESS_HORSEMAN, 90],
  [NPCID.DANNY, 40],
  [NPCID.COAL_BOY, 40],
  [NPCID.BLASTER, 20],
  [NPCID.BOUNCER, 30],
  [NPCID.QUAKEY, 45],
  [NPCID.GYRO, 18],
  [NPCID.GRILLED_GYRO, 20],
  [NPCID.FIRE_WORM, 10],
  [NPCID.HARDY, 48],
  [NPCID.FACELESS, 20],
  [NPCID.TAINTED_FACELESS, 100],
  [NPCID.NECRO, 22],
  [NPCID.MOLE, 12],
  [NPCID.TAINTED_MOLE, 80],
  [NPCID.HEADLESS_HORSEMAN_HEAD, 100],
  [NPCID.BIG_BONY, 50],
  [NPCID.BIG_BONE, 5],
  [NPCID.GUTTED_FATTY, 80],
  [NPCID.GUTTED_FATTY_EYE, 80],
  [NPCID.FESTERING_GUTS, 22],
  [NPCID.EXORCIST, 25],
  [NPCID.FANATIC, 35],
  [NPCID.CANDLER, 25],
  [NPCID.WHIPPER, 35],
  [NPCID.SNAPPER, 35],
  [NPCID.FLAGELLANT, 42],
  [NPCID.PEEPING_FATTY, 60],
  [NPCID.PEEPING_FATTY_EYE, 60],
  [NPCID.VIS_VERSA, 25],
  [NPCID.HENRY, 80],
  [NPCID.LEVEL_2_WILLO, 20],
  [NPCID.STRIFER, 25],
  [NPCID.SATAN, 600],
  [NPCID.SATAN_STOMP, 600],
  [NPCID.PON, 20],
  [NPCID.REVENANT, 23],
  [NPCID.QUAD_REVENANT, 39],
  [NPCID.NIGHTWATCH, 30],
  [NPCID.CANARY, 18],
  [NPCID.FOREIGNER, 20],
  [NPCID.BOMBGAGGER, 29],
  [NPCID.SPIDER, 6.5],
  [NPCID.LEVEL_2_GAPER, 40],
  [NPCID.LEVEL_2_HORF, 20],
  [NPCID.LEVEL_2_GUSHER, 20],
  [NPCID.TWITCHY, 40],
  [NPCID.SPIKEBALL, 100],
  [NPCID.SMALL_MAGGOT, 10],
  [NPCID.ADULT_LEECH, 90],
  [NPCID.LEVEL_2_CHARGER, 40],
  [NPCID.ELLEECH, 60],
  [NPCID.GASBAG, 80],
  [NPCID.COHORT, 125],
  [NPCID.VESSEL, 60],
  [NPCID.FLOAST, 20],
  [NPCID.KEEPER, 36],
  [NPCID.UNBORN, 32],
  [NPCID.PUSTULE, 19],
  [NPCID.CYST, 25],
  [NPCID.MORNINGSTAR, 60],
  [NPCID.MORNINGSTAR_2, 60],
  [NPCID.MORNINGSTAR_3, 60],
  [NPCID.MOCKULUS, 40],
  [NPCID.EVIS, 40],
  [NPCID.EVIS_GUTS, 0],
  [NPCID.DARK_ESAU, 270],
  [NPCID.DARKER_ESAU, 270],
  [NPCID.DARK_ESAUS_PIT, 100],
  [NPCID.MOTHERS_SHADOW, 270],
  [NPCID.ARMY_FLY, 5],
  [NPCID.MIGRAINE, 16],
  [NPCID.GURGLE, 40],
  [NPCID.CRACKLE, 40],
  [NPCID.DRIP, 4],
  [NPCID.SPLURT, 21],
  [NPCID.CLOGGY, 17],
  [NPCID.FLY_TRAP, 22],
  [NPCID.GAS_DWARF, 13],
  [NPCID.POOT_MINE, 14],
  [NPCID.DUMP, 11],
  [NPCID.DUMP_HEAD, 11],
  [NPCID.GRUDGE, 100],
  [NPCID.BUTT_SLICKER, 19],
  [NPCID.BLOATY, 26],
  [NPCID.WALKING_BOIL, 20],
  [NPCID.WALKING_GUT, 20],
  [NPCID.WALKING_SACK, 20],
  [NPCID.FLESH_MAIDEN, 28],
  [NPCID.NEEDLE, 12],
  [NPCID.PASTY, 12],
  [NPCID.DUST, 22],
  [NPCID.BABY_BEGOTTEN, 21],
  [NPCID.SWARM_SPIDER, 4.699_999_809_265_1],
  [NPCID.CULTIST, 27],
  [NPCID.BLOOD_CULTIST, 27],
  [NPCID.BONE_TRAP, 8],
  [NPCID.VIS_FATTY, 44],
  [NPCID.FETAL_DEMON, 43],
  [NPCID.DUSTY_DEATHS_HEAD, 20],
  [NPCID.SHADY, 80],
  [NPCID.CLICKETY_CLACK, 23],
  [NPCID.BUTTLICKER, 20],
  [NPCID.MAZE_ROAMER, 15],
  [NPCID.MAZE_ROAMER_2, 15],
  [NPCID.GOAT, 21],
  [NPCID.BLACK_GOAT, 29],
  [NPCID.POOFER, 20],
  [NPCID.BALL_AND_CHAIN, 100],
  [NPCID.HANGER, 40],
  [NPCID.REAP_CREEP, 690],
  [NPCID.LIL_BLUB, 200],
  [NPCID.RAINMAKER, 240],
  [NPCID.THE_VISAGE, 620],
  [NPCID.VISAGE_MASK, 100],
  [NPCID.VISAGE_CHAIN, 150],
  [NPCID.VISAGE_PLASMA, 50],
  [NPCID.SIREN, 666],
  [NPCID.SIRENS_SKULL, 20],
  [NPCID.SIREN_HELPER_PROJECTILE, 0],
  [NPCID.THE_HERETIC, 789],
  [NPCID.HORNFEL, 240],
  [NPCID.HORNFEL_DECOY, 4],
  [NPCID.GREAT_GIDEON, 6],
  [NPCID.GREAT_GIDEON_DEFEATED, 6],
  [NPCID.BABY_PLUM, 234],
  [NPCID.THE_SCOURGE, 950],
  [NPCID.THE_SCOURGE_CHAIN, 400],
  [NPCID.SWARMER, 40],
  [NPCID.CHIMERA, 1050],
  [NPCID.CHIMERA_BODY, 1050],
  [NPCID.CHIMERA_HEAD, 1050],
  [NPCID.ROTGUT, 600],
  [NPCID.ROTGUT_MAGGOT, 600],
  [NPCID.ROTGUT_HEART, 600],
  [NPCID.MOTHER_PHASE_1, 2222],
  [NPCID.MOTHER_PHASE_2, 2222],
  [NPCID.MOTHER_LEFT_ARM, 2222],
  [NPCID.MOTHER_RIGHT_ARM, 2222],
  [NPCID.MOTHER_DISAPPEAR, 2222],
  [NPCID.MOTHER_2, 2000],
  [NPCID.MOTHER_BALL, 10],
  [NPCID.MOTHER_BALL_MEDIUM, 10],
  [NPCID.MOTHER_BALL_SMALL, 10],
  [NPCID.DEAD_ISAAC, 40],
  [NPCID.MOTHER_WORM, 1],
  [NPCID.MIN_MIN, 280],
  [NPCID.CLOG, 420],
  [NPCID.SINGE, 444],
  [NPCID.SINGES_BALL, 100],
  [NPCID.BUMBINO, 385],
  [NPCID.COLOSTOMIA, 380],
  [NPCID.TURDLET, 190],
  [NPCID.RAGLICH, 792],
  [NPCID.RAGLICH_ARM, 792],
  [NPCID.HEART, 40],
  [NPCID.HALF_HEART, 40],
  [NPCID.HALF_HEART_2, 40],
  [NPCID.HORNY_BOYS, 707],
  [NPCID.CLUTCH, 500],
  [NPCID.CLUTCH_ORBITAL, 200],
  [NPCID.MASK, 40],
  [NPCID.MASK_II, 40],
  [NPCID.BIG_SPIDER, 20],
  [NPCID.DOGMA, 1200],
  [NPCID.DOGMAS_TV, 1200],
  [NPCID.DOGMA_ANGEL_BABY, 30],
  [NPCID.DOGMA_ANGEL, 1200],
  [NPCID.THE_BEAST, 10_000],
  [NPCID.STALACTITE, 100],
  [NPCID.ULTRA_FAMINE, 2000],
  [NPCID.BACKGROUND_BEAST, 1000],
  [NPCID.BACKGROUND_FAMINE, 1000],
  [NPCID.BACKGROUND_PESTILENCE, 1000],
  [NPCID.BACKGROUND_WAR, 1000],
  [NPCID.BACKGROUND_DEATH, 1000],
  [NPCID.ULTRA_FAMINE_FLY, 10],
  [NPCID.BEAST_ROCK_PROJECTILE, 2.5],
  [NPCID.ULTRA_PESTILENCE, 1800],
  [NPCID.ULTRA_PESTILENCE_FLY, 10],
  [NPCID.ULTRA_PESTILENCE_MAGGOT, 0],
  [NPCID.ULTRA_PESTILENCE_FLY_BALL, 200],
  [NPCID.BEAST_SOUL, 100],
  [NPCID.ULTRA_WAR, 2000],
  [NPCID.ULTRA_WAR_BOMB, 200],
  [NPCID.ULTRA_DEATH, 2000],
  [NPCID.ULTRA_DEATH_SCYTHE, 100],
  [NPCID.ULTRA_DEATH_HEAD, 100],
  [NPCID.ETERNAL_FLY, 300],
  [NPCID.GENERIC_PROP, 1],
  [NPCID.MOMS_DRESSER, 1],
  [NPCID.MOMS_VANITY, 1],
  [NPCID.COUCH, 1],
  [NPCID.TV, 1],
  [NPCID.FROZEN_ENEMY, 10],
  [NPCID.DUMMY, 10_000],
  [NPCID.MINECART, 0],
  [NPCID.SIREN_HELPER, 60],
  [NPCID.HORNFEL_DOOR, 0],
  [NPCID.MASK_OF_INFAMY, 150],
  [NPCID.MASK_OF_INFAMY_BLACK, 187.5],
  [NPCID.HEART_OF_INFAMY, 200],
  [NPCID.HEART_OF_INFAMY_BLACK, 250],
  [NPCID.GURDY_JR, 250],
  [NPCID.GURDY_JR_BLUE, 137.5],
  [NPCID.GURDY_JR_YELLOW, 312.5],
]);

export function _getNonModdedNPCIDMaxHitPoints(
  npcid: NPCID,
): number | undefined {
  return NPC_MAX_HITPOINTS_MAP.get(npcid);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\npc\NPCSizeMap.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";
import { ReadonlyMap } from "isaacscript-common";

const NPC_SIZE_MAP = new ReadonlyMap<NPCID, number>([
  [NPCID.FROWNING_GAPER, 13],
  [NPCID.GAPER, 13],
  [NPCID.FLAMING_GAPER, 13],
  [NPCID.ROTTEN_GAPER, 13],
  [NPCID.ROTTEN_GAPER_2, 13],
  [NPCID.ROTTEN_GAPER_3, 13],
  [NPCID.ROTTEN_GAPER_4, 13],
  [NPCID.ROTTEN_GAPER_5, 13],
  [NPCID.ROTTEN_GAPER_6, 13],
  [NPCID.WIDOW, 35],
  [NPCID.WIDOW_BLACK, 35],
  [NPCID.WIDOW_PINK, 35],
  [NPCID.THE_WRETCHED, 35],
  [NPCID.DADDY_LONG_LEGS, 40],
  [NPCID.TRIACHNID, 40],
  [NPCID.ISAAC, 25],
  [NPCID.BLUE_BABY, 25],
  [NPCID.BLUE_BABY_HUSH, 25],
  [NPCID.GUSHER, 13],
  [NPCID.PACER, 13],
  [NPCID.HORF, 13],
  [NPCID.FLY, 17],
  [NPCID.POOTER, 17],
  [NPCID.SUPER_POOTER, 17],
  [NPCID.TAINTED_POOTER, 20],
  [NPCID.CLOTTY, 13],
  [NPCID.CLOT, 13],
  [NPCID.I_BLOB, 13],
  [NPCID.GRILLED_CLOTTY, 13],
  [NPCID.MULLIGAN, 13],
  [NPCID.MULLIGOON, 13],
  [NPCID.MULLIBOOM, 13],
  [NPCID.SHOPKEEPER, 1],
  [NPCID.SECRET_ROOM_KEEPER, 1],
  [NPCID.ERROR_ROOM_KEEPER, 1],
  [NPCID.SPECIAL_SHOPKEEPER, 1],
  [NPCID.SPECIAL_SECRET_ROOM_KEEPER, 1],
  [NPCID.ATTACK_FLY, 17],
  [NPCID.LARRY_JR, 20],
  [NPCID.LARRY_JR_GREEN, 20],
  [NPCID.LARRY_JR_BLUE, 20],
  [NPCID.THE_HOLLOW, 20],
  [NPCID.THE_HOLLOW_GREEN, 20],
  [NPCID.THE_HOLLOW_BLACK, 20],
  [NPCID.THE_HOLLOW_YELLOW, 20],
  [NPCID.TUFF_TWIN, 20],
  [NPCID.THE_SHELL, 20],
  [NPCID.MONSTRO, 40],
  [NPCID.MONSTRO_RED, 40],
  [NPCID.MONSTRO_GREY, 40],
  [NPCID.STONE_EYE, 13],
  [NPCID.CONSTANT_STONE_SHOOTER_LEFT, 13],
  [NPCID.CONSTANT_STONE_SHOOTER_UP, 13],
  [NPCID.CONSTANT_STONE_SHOOTER_RIGHT, 13],
  [NPCID.CONSTANT_STONE_SHOOTER_DOWN, 13],
  [NPCID.CROSS_STONE_SHOOTER, 13],
  [NPCID.CROSS_STONE_SHOOTER_2, 13],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON, 13],
  [NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON_2, 13],
  [NPCID.BRIMSTONE_HEAD, 13],
  [NPCID.MOBILE_HOST, 13],
  [NPCID.NEST, 13],
  [NPCID.BABY_LONG_LEGS, 13],
  [NPCID.SMALL_BABY_LONG_LEGS, 13],
  [NPCID.CRAZY_LONG_LEGS, 13],
  [NPCID.SMALL_CRAZY_LONG_LEGS, 13],
  [NPCID.FATTY, 13],
  [NPCID.PALE_FATTY, 13],
  [NPCID.FLAMING_FATTY, 13],
  [NPCID.FAT_SACK, 13],
  [NPCID.MAGGOT, 13],
  [NPCID.BLUBBER, 13],
  [NPCID.HALF_SACK, 13],
  [NPCID.DEATHS_HEAD, 13],
  [NPCID.DANK_DEATHS_HEAD, 13],
  [NPCID.CURSED_DEATHS_HEAD, 13],
  [NPCID.BRIMSTONE_DEATHS_HEAD, 13],
  [NPCID.REDSKULL, 14],
  [NPCID.MOMS_HAND, 40],
  [NPCID.LEVEL_2_FLY, 13],
  [NPCID.LEVEL_2_SPIDER, 13],
  [NPCID.SWINGER, 13],
  [NPCID.SWINGER_HEAD, 13],
  [NPCID.SWINGER_NECK, 0],
  [NPCID.DIP, 9],
  [NPCID.CORN, 9],
  [NPCID.BROWNIE_CORN, 9],
  [NPCID.BIG_CORN, 9],
  [NPCID.WALL_HUGGER, 16],
  [NPCID.WIZOOB, 13],
  [NPCID.HIVE, 13],
  [NPCID.DROWNED_HIVE, 13],
  [NPCID.HOLY_MULLIGAN, 13],
  [NPCID.TAINTED_MULLIGAN, 30],
  [NPCID.SQUIRT, 13],
  [NPCID.DANK_SQUIRT, 13],
  [NPCID.COD_WORM, 16],
  [NPCID.RING_FLY, 17],
  [NPCID.DINGA, 17],
  [NPCID.OOB, 18],
  [NPCID.BLACK_MAW, 20],
  [NPCID.SKINNY, 13],
  [NPCID.ROTTY, 13],
  [NPCID.CRISPY, 13],
  [NPCID.BONY, 13],
  [NPCID.HOLY_BONY, 20],
  [NPCID.HOMUNCULUS, 13],
  [NPCID.HOMUNCULUS_CORD, 0],
  [NPCID.TUMOR, 16],
  [NPCID.PLANETOID, 16],
  [NPCID.CHARGER, 13],
  [NPCID.MY_SHADOW, 13],
  [NPCID.DROWNED_CHARGER, 13],
  [NPCID.DANK_CHARGER, 13],
  [NPCID.CARRION_PRINCESS, 13],
  [NPCID.CAMILLO_JR, 16],
  [NPCID.NERVE_ENDING, 13],
  [NPCID.NERVE_ENDING_2, 13],
  [NPCID.ONE_TOOTH, 13],
  [NPCID.GAPING_MAW, 13],
  [NPCID.BROKEN_GAPING_MAW, 13],
  [NPCID.GURGLING, 13],
  [NPCID.GURGLING_BOSS, 13],
  [NPCID.GURGLING_BOSS_YELLOW, 13],
  [NPCID.GURGLING_BOSS_BLACK, 13],
  [NPCID.TURDLING, 13],
  [NPCID.SPLASHER, 13],
  [NPCID.GRUB, 13],
  [NPCID.CORPSE_EATER, 13],
  [NPCID.CARRION_RIDER, 13],
  [NPCID.GLOBIN, 13],
  [NPCID.GAZING_GLOBIN, 13],
  [NPCID.DANK_GLOBIN, 13],
  [NPCID.CURSED_GLOBIN, 13],
  [NPCID.WALL_CREEP, 13],
  [NPCID.SOY_CREEP, 13],
  [NPCID.RAG_CREEP, 13],
  [NPCID.TAINTED_SOY_CREEP, 18],
  [NPCID.RAGE_CREEP, 13],
  [NPCID.SPLIT_RAGE_CREEP, 13],
  [NPCID.BLIND_CREEP, 13],
  [NPCID.CONJOINED_SPITTY, 13],
  [NPCID.ROUND_WORM, 13],
  [NPCID.TUBE_WORM, 13],
  [NPCID.TAINTED_ROUND_WORM, 20],
  [NPCID.TAINTED_ROUND_WORM_BUTT, 12],
  [NPCID.TAINTED_TUBE_WORM, 20],
  [NPCID.POOP, 13],
  [NPCID.RAGLING, 13],
  [NPCID.RAG_MANS_RAGLING, 13],
  [NPCID.RAG_MANS_RAGLING_RED, 13],
  [NPCID.RAG_MANS_RAGLING_BLACK, 13],
  [NPCID.FLESH_MOBILE_HOST, 13],
  [NPCID.PSYCHIC_HORF, 13],
  [NPCID.FULL_FLY, 13],
  [NPCID.BOOM_FLY, 13],
  [NPCID.RED_BOOM_FLY, 13],
  [NPCID.DROWNED_BOOM_FLY, 13],
  [NPCID.DRAGON_FLY, 13],
  [NPCID.DRAGON_FLY_X, 13],
  [NPCID.BONE_FLY, 13],
  [NPCID.SICK_BOOM_FLY, 13],
  [NPCID.TAINTED_BOOM_FLY, 24],
  [NPCID.TICKING_SPIDER, 13],
  [NPCID.BEGOTTEN, 13],
  [NPCID.BEGOTTEN_CHAIN, 13],
  [NPCID.NULLS, 13],
  [NPCID.PSY_TUMOR, 16],
  [NPCID.FLOATING_KNIGHT, 13],
  [NPCID.NIGHT_CRAWLER, 13],
  [NPCID.DART_FLY, 17],
  [NPCID.CONJOINED_FATTY, 13],
  [NPCID.BLUE_CONJOINED_FATTY, 13],
  [NPCID.FAT_BAT, 13],
  [NPCID.IMP, 13],
  [NPCID.MAW, 13],
  [NPCID.RED_MAW, 13],
  [NPCID.PSYCHIC_MAW, 13],
  [NPCID.HAUNT, 26],
  [NPCID.HAUNT_BLACK, 26],
  [NPCID.HAUNT_PINK, 26],
  [NPCID.LIL_HAUNT, 13],
  [NPCID.DINGLE, 20],
  [NPCID.DINGLE_RED, 20],
  [NPCID.DINGLE_BLACK, 20],
  [NPCID.DANGLE, 20],
  [NPCID.MEGA_MAW, 33],
  [NPCID.MEGA_MAW_RED, 33],
  [NPCID.MEGA_MAW_BLACK, 33],
  [NPCID.THE_GATE, 33],
  [NPCID.THE_GATE_RED, 33],
  [NPCID.THE_GATE_BLACK, 33],
  [NPCID.MEGA_FATTY, 40],
  [NPCID.MEGA_FATTY_RED, 40],
  [NPCID.MEGA_FATTY_BROWN, 40],
  [NPCID.THE_CAGE, 40],
  [NPCID.THE_CAGE_GREEN, 40],
  [NPCID.THE_CAGE_PINK, 40],
  [NPCID.MAMA_GURDY, 30],
  [NPCID.MAMA_GURDY_LEFT_HAND, 30],
  [NPCID.MAMA_GURDY_RIGHT_HAND, 30],
  [NPCID.DARK_ONE, 20],
  [NPCID.THE_ADVERSARY, 20],
  [NPCID.POLYCEPHALUS, 20],
  [NPCID.POLYCEPHALUS_RED, 20],
  [NPCID.POLYCEPHALUS_PINK, 20],
  [NPCID.THE_PILE, 20],
  [NPCID.HOST, 13],
  [NPCID.RED_HOST, 13],
  [NPCID.HARD_HOST, 13],
  [NPCID.MR_FRED, 16],
  [NPCID.URIEL, 22],
  [NPCID.FALLEN_URIEL, 22],
  [NPCID.GABRIEL, 22],
  [NPCID.FALLEN_GABRIEL, 22],
  [NPCID.THE_LAMB, 13],
  [NPCID.LAMB_BODY, 13],
  [NPCID.MEGA_SATAN, 50],
  [NPCID.MEGA_SATANS_RIGHT_HAND, 45],
  [NPCID.MEGA_SATANS_LEFT_HAND, 45],
  [NPCID.MEGA_SATAN_2, 50],
  [NPCID.MEGA_SATAN_2_RIGHT_HAND, 45],
  [NPCID.MEGA_SATAN_2_LEFT_HAND, 45],
  [NPCID.ROUNDY, 13],
  [NPCID.BLACK_BONY, 13],
  [NPCID.BLACK_GLOBIN, 13],
  [NPCID.BLACK_GLOBINS_HEAD, 13],
  [NPCID.CHUB, 18],
  [NPCID.CHUB_BLUE, 18],
  [NPCID.CHUB_ORANGE, 18],
  [NPCID.CHAD, 18],
  [NPCID.THE_CARRION_QUEEN, 18],
  [NPCID.THE_CARRION_QUEEN_PINK, 18],
  [NPCID.BLACK_GLOBINS_BODY, 13],
  [NPCID.SWARM, 14],
  [NPCID.MEGA_CLOTTY, 13],
  [NPCID.BONE_KNIGHT, 13],
  [NPCID.CYCLOPIA, 13],
  [NPCID.RED_GHOST, 13],
  [NPCID.FLESH_DEATHS_HEAD, 13],
  [NPCID.MOMS_DEAD_HAND, 40],
  [NPCID.DUKIE, 13],
  [NPCID.ULCER, 13],
  [NPCID.HOPPER, 13],
  [NPCID.TRITE, 13],
  [NPCID.EGGY, 13],
  [NPCID.TAINTED_HOPPER, 18],
  [NPCID.MEATBALL, 13],
  [NPCID.PITFALL, 32],
  [NPCID.SUCTION_PITFALL, 30],
  [NPCID.TELEPORT_PITFALL, 30],
  [NPCID.MOVABLE_TNT, 20],
  [NPCID.MOVABLE_TNT_MINE_CRAFTER, 20],
  [NPCID.ULTRA_GREED_COIN_SPINNER, 28],
  [NPCID.ULTRA_GREED_COIN_KEY, 28],
  [NPCID.ULTRA_GREED_COIN_BOMB, 28],
  [NPCID.ULTRA_GREED_COIN_HEART, 28],
  [NPCID.ULTRA_GREED_DOOR, 10],
  [NPCID.CORN_MINE, 16],
  [NPCID.CORN_MINE_BLACK, 16],
  [NPCID.HUSH_FLY, 9],
  [NPCID.BLUE_GAPER, 13],
  [NPCID.BLUE_BOIL, 13],
  [NPCID.GREED_GAPER, 13],
  [NPCID.BOIL, 13],
  [NPCID.BOIL_BLUE, 13],
  [NPCID.GUT, 13],
  [NPCID.SACK, 13],
  [NPCID.MUSHROOM, 13],
  [NPCID.POISON_MIND, 13],
  [NPCID.STONEY, 13],
  [NPCID.CROSS_STONEY, 13],
  [NPCID.BLISTER, 13],
  [NPCID.THE_THING, 13],
  [NPCID.MINISTRO, 13],
  [NPCID.PORTAL, 13],
  [NPCID.LIL_PORTAL, 8],
  [NPCID.TAR_BOY, 18],
  [NPCID.TAR_BOY_MOUTH, 18],
  [NPCID.FISTULOID, 17],
  [NPCID.GUSH, 13],
  [NPCID.SPITTY, 13],
  [NPCID.TAINTED_SPITTY, 18],
  [NPCID.LEPER, 15],
  [NPCID.LEPER_STAGE_2, 15],
  [NPCID.LEPER_STAGE_3, 15],
  [NPCID.LEPER_STAGE_4, 15],
  [NPCID.LEPER_FLESH, 13],
  [NPCID.MR_MINE, 13],
  [NPCID.MR_MINE_NECK, 13],
  [NPCID.BRAIN, 13],
  [NPCID.FIRE_PLACE, 13],
  [NPCID.RED_FIRE_PLACE, 13],
  [NPCID.MOVEABLE_FIREPLACE, 13],
  [NPCID.COAL, 13],
  [NPCID.COAL_2, 13],
  [NPCID.COAL_3, 13],
  [NPCID.COAL_4, 13],
  [NPCID.MOVEABLE_BLUE_FIREPLACE, 13],
  [NPCID.MOVEABLE_PURPLE_FIREPLACE, 13],
  [NPCID.BLUE_FIRE_PLACE, 13],
  [NPCID.PURPLE_FIRE_PLACE, 13],
  [NPCID.WHITE_FIRE_PLACE, 13],
  [NPCID.LEAPER, 13],
  [NPCID.STICKY_LEAPER, 13],
  [NPCID.MR_MAW, 13],
  [NPCID.MR_MAW_HEAD, 13],
  [NPCID.MR_MAW_NECK, 13],
  [NPCID.MR_RED_MAW, 13],
  [NPCID.MR_RED_MAW_HEAD, 13],
  [NPCID.GURDY, 80],
  [NPCID.GURDY_GREEN, 80],
  [NPCID.BABY, 13],
  [NPCID.ANGELIC_BABY, 13],
  [NPCID.ANGELIC_BABY_SMALL, 13],
  [NPCID.ULTRA_PRIDE_BABY, 13],
  [NPCID.WRINKLY_BABY, 13],
  [NPCID.VIS, 13],
  [NPCID.DOUBLE_VIS, 13],
  [NPCID.CHUBBER, 13],
  [NPCID.CHUBBER_PROJECTILE, 13],
  [NPCID.SCARRED_DOUBLE_VIS, 13],
  [NPCID.GUTS, 13],
  [NPCID.SCARRED_GUTS, 13],
  [NPCID.SLOG, 13],
  [NPCID.THE_STAIN, 35],
  [NPCID.THE_STAIN_GREY, 35],
  [NPCID.BROWNIE, 45],
  [NPCID.BROWNIE_BLACK, 45],
  [NPCID.THE_FORSAKEN, 26],
  [NPCID.THE_FORSAKEN_BLACK, 26],
  [NPCID.LITTLE_HORN, 16],
  [NPCID.LITTLE_HORN_ORANGE, 16],
  [NPCID.LITTLE_HORN_BLACK, 16],
  [NPCID.DARK_BALL, 13],
  [NPCID.DARK_BALL_ORANGE, 13],
  [NPCID.DARK_BALL_BLACK, 13],
  [NPCID.RAG_MAN, 20],
  [NPCID.RAG_MAN_RED, 20],
  [NPCID.RAG_MAN_BLACK, 20],
  [NPCID.RAG_MANS_HEAD, 20],
  [NPCID.RAG_MANS_HEAD_RED, 20],
  [NPCID.RAG_MANS_HEAD_BLACK, 20],
  [NPCID.ULTRA_GREED, 25],
  [NPCID.ULTRA_GREEDIER, 25],
  [NPCID.HUSH, 100],
  [NPCID.HUSH_SKINLESS, 100],
  [NPCID.RAG_MEGA, 35],
  [NPCID.PURPLE_BALL, 13],
  [NPCID.RAG_MEGA_REBIRTH_PILLAR, 13],
  [NPCID.KNIGHT, 13],
  [NPCID.SELFLESS_KNIGHT, 13],
  [NPCID.LOOSE_KNIGHT, 13],
  [NPCID.BRAINLESS_KNIGHT, 13],
  [NPCID.BLACK_KNIGHT, 13],
  [NPCID.SISTERS_VIS, 40],
  [NPCID.BIG_HORN, 62],
  [NPCID.SMALL_HOLE, 20],
  [NPCID.BIG_HOLE, 80],
  [NPCID.DELIRIUM, 40],
  [NPCID.THE_MATRIARCH, 60],
  [NPCID.STONE_GRIMACE, 13],
  [NPCID.VOMIT_GRIMACE, 13],
  [NPCID.TRIPLE_GRIMACE, 13],
  [NPCID.MONSTRO_II, 35],
  [NPCID.MONSTRO_II_RED, 35],
  [NPCID.GISH, 35],
  [NPCID.POKY, 16],
  [NPCID.SLIDE, 13],
  [NPCID.MOM, 35],
  [NPCID.MOM_BLUE, 35],
  [NPCID.MOM_RED, 35],
  [NPCID.MOM_STOMP, 35],
  [NPCID.MOM_STOMP_BLUE, 35],
  [NPCID.MOM_STOMP_RED, 35],
  [NPCID.SLOTH, 13],
  [NPCID.SUPER_SLOTH, 13],
  [NPCID.ULTRA_PRIDE, 13],
  [NPCID.LUST, 13],
  [NPCID.SUPER_LUST, 13],
  [NPCID.WRATH, 13],
  [NPCID.SUPER_WRATH, 13],
  [NPCID.GLUTTONY, 13],
  [NPCID.SUPER_GLUTTONY, 13],
  [NPCID.GREED, 13],
  [NPCID.SUPER_GREED, 13],
  [NPCID.ENVY, 13],
  [NPCID.SUPER_ENVY, 13],
  [NPCID.ENVY_BIG, 13],
  [NPCID.SUPER_ENVY_BIG, 13],
  [NPCID.ENVY_MEDIUM, 13],
  [NPCID.SUPER_ENVY_MEDIUM, 13],
  [NPCID.ENVY_SMALL, 13],
  [NPCID.SUPER_ENVY_SMALL, 13],
  [NPCID.PRIDE, 13],
  [NPCID.SUPER_PRIDE, 13],
  [NPCID.DOPLE, 13],
  [NPCID.EVIL_TWIN, 13],
  [NPCID.FLAMING_HOPPER, 13],
  [NPCID.LEECH, 13],
  [NPCID.KAMIKAZE_LEECH, 13],
  [NPCID.HOLY_LEECH, 13],
  [NPCID.LUMP, 13],
  [NPCID.MEMBRAIN, 13],
  [NPCID.MAMA_GUTS, 13],
  [NPCID.DEAD_MEAT, 13],
  [NPCID.PARA_BITE, 13],
  [NPCID.SCARRED_PARA_BITE, 13],
  [NPCID.FRED, 13],
  [NPCID.EYE, 13],
  [NPCID.BLOODSHOT_EYE, 13],
  [NPCID.HOLY_EYE, 13],
  [NPCID.SUCKER, 17],
  [NPCID.SPIT, 17],
  [NPCID.SOUL_SUCKER, 17],
  [NPCID.INK, 17],
  [NPCID.MAMA_FLY, 17],
  [NPCID.BULB, 17],
  [NPCID.BLOODFLY, 17],
  [NPCID.TAINTED_SUCKER, 20],
  [NPCID.PIN, 13],
  [NPCID.PIN_GREY, 13],
  [NPCID.SCOLEX, 13],
  [NPCID.THE_FRAIL, 13],
  [NPCID.THE_FRAIL_BLACK, 13],
  [NPCID.WORMWOOD, 13],
  [NPCID.FAMINE, 25],
  [NPCID.FAMINE_BLUE, 25],
  [NPCID.PESTILENCE, 25],
  [NPCID.PESTILENCE_GREY, 25],
  [NPCID.WAR, 25],
  [NPCID.WAR_GREY, 25],
  [NPCID.CONQUEST, 25],
  [NPCID.WAR_WITHOUT_HORSE, 20],
  [NPCID.WAR_WITHOUT_HORSE_GREY, 20],
  [NPCID.DEATH, 25],
  [NPCID.DEATH_BLACK, 25],
  [NPCID.DEATH_SCYTHE, 25],
  [NPCID.DEATH_SCYTHE_BLACK, 25],
  [NPCID.DEATH_HORSE, 25],
  [NPCID.DEATH_HORSE_BLACK, 25],
  [NPCID.DEATH_WITHOUT_HORSE, 25],
  [NPCID.DEATH_WITHOUT_HORSE_BLACK, 25],
  [NPCID.THE_DUKE_OF_FLIES, 35],
  [NPCID.THE_DUKE_OF_FLIES_GREEN, 35],
  [NPCID.THE_DUKE_OF_FLIES_ORANGE, 35],
  [NPCID.THE_HUSK, 35],
  [NPCID.THE_HUSK_BLACK, 35],
  [NPCID.THE_HUSK_RED, 35],
  [NPCID.PEEP, 27],
  [NPCID.PEEP_YELLOW, 27],
  [NPCID.PEEP_CYAN, 27],
  [NPCID.THE_BLOAT, 27],
  [NPCID.THE_BLOAT_GREEN, 27],
  [NPCID.PEEP_EYE, 13],
  [NPCID.PEEP_EYE_YELLOW, 13],
  [NPCID.PEEP_EYE_CYAN, 13],
  [NPCID.BLOAT_EYE, 13],
  [NPCID.BLOAT_EYE_GREEN, 13],
  [NPCID.LOKI, 20],
  [NPCID.LOKII, 20],
  [NPCID.FISTULA, 40],
  [NPCID.FISTULA_GREY, 40],
  [NPCID.TERATOMA, 40],
  [NPCID.FISTULA_MEDIUM, 25],
  [NPCID.FISTULA_MEDIUM_GREY, 25],
  [NPCID.TERATOMA_MEDIUM, 25],
  [NPCID.FISTULA_SMALL, 13],
  [NPCID.FISTULA_SMALL_GREY, 13],
  [NPCID.TERATOMA_SMALL, 13],
  [NPCID.BLASTOCYST, 40],
  [NPCID.BLASTOCYST_MEDIUM, 30],
  [NPCID.BLASTOCYST_SMALL, 20],
  [NPCID.EMBRYO, 13],
  [NPCID.MOMS_HEART, 35],
  [NPCID.IT_LIVES, 35],
  [NPCID.MOMS_GUTS, 0],
  [NPCID.GEMINI, 13],
  [NPCID.GEMINI_GREEN, 13],
  [NPCID.GEMINI_BLUE, 13],
  [NPCID.STEVEN, 13],
  [NPCID.GEMINI_BABY, 13],
  [NPCID.GEMINI_BABY_GREEN, 13],
  [NPCID.GEMINI_BABY_BLUE, 13],
  [NPCID.STEVEN_BABY, 13],
  [NPCID.THE_BLIGHTED_OVUM_BABY, 13],
  [NPCID.THE_BLIGHTED_OVUM, 13],
  [NPCID.UMBILICAL_CORD, 13],
  [NPCID.UMBILICAL_CORD_GREEN, 13],
  [NPCID.UMBILICAL_CORD_BLUE, 13],
  [NPCID.MOTER, 17],
  [NPCID.BLOOD_PUPPY_SMALL, 13],
  [NPCID.BLOOD_PUPPY_LARGE, 16],
  [NPCID.BLIND_BAT, 13],
  [NPCID.QUAKE_GRIMACE_LEFT, 13],
  [NPCID.QUAKE_GRIMACE_UP, 13],
  [NPCID.QUAKE_GRIMACE_RIGHT, 13],
  [NPCID.QUAKE_GRIMACE_DOWN, 13],
  [NPCID.BISHOP, 13],
  [NPCID.BUBBLES, 13],
  [NPCID.WRAITH, 13],
  [NPCID.WILLO, 17],
  [NPCID.BOMB_GRIMACE, 13],
  [NPCID.THE_FALLEN, 20],
  [NPCID.KRAMPUS, 20],
  [NPCID.SMALL_LEECH, 17],
  [NPCID.DEEP_GAPER, 13],
  [NPCID.DEEP_GAPER_2, 13],
  [NPCID.DEEP_GAPER_3, 13],
  [NPCID.DEEP_GAPER_4, 13],
  [NPCID.DEEP_GAPER_5, 13],
  [NPCID.DEEP_GAPER_6, 13],
  [NPCID.DEEP_GAPER_7, 13],
  [NPCID.SUB_HORF, 13],
  [NPCID.TAINTED_SUB_HORF, 16],
  [NPCID.BLURB, 13],
  [NPCID.STRIDER, 13],
  [NPCID.FISSURE, 13],
  [NPCID.POLTY, 13],
  [NPCID.KINETI, 13],
  [NPCID.PREY, 13],
  [NPCID.MULLIGHOUL, 13],
  [NPCID.ROCK_SPIDER, 13],
  [NPCID.ROCK_SPIDER_2, 13],
  [NPCID.ROCK_SPIDER_3, 13],
  [NPCID.ROCK_SPIDER_4, 13],
  [NPCID.TINTED_ROCK_SPIDER, 13],
  [NPCID.TINTED_ROCK_SPIDER_2, 13],
  [NPCID.TINTED_ROCK_SPIDER_3, 13],
  [NPCID.TINTED_ROCK_SPIDER_4, 13],
  [NPCID.COAL_SPIDER, 13],
  [NPCID.COAL_SPIDER_2, 13],
  [NPCID.COAL_SPIDER_3, 13],
  [NPCID.COAL_SPIDER_4, 13],
  [NPCID.FLY_BOMB, 13],
  [NPCID.ETERNAL_FLY_BOMB, 13],
  [NPCID.HEADLESS_HORSEMAN, 20],
  [NPCID.DANNY, 13],
  [NPCID.COAL_BOY, 13],
  [NPCID.BLASTER, 13],
  [NPCID.BOUNCER, 13],
  [NPCID.QUAKEY, 13],
  [NPCID.GYRO, 13],
  [NPCID.GRILLED_GYRO, 13],
  [NPCID.FIRE_WORM, 13],
  [NPCID.HARDY, 13],
  [NPCID.FACELESS, 13],
  [NPCID.TAINTED_FACELESS, 13],
  [NPCID.NECRO, 13],
  [NPCID.MOLE, 13],
  [NPCID.TAINTED_MOLE, 16],
  [NPCID.HEADLESS_HORSEMAN_HEAD, 16],
  [NPCID.BIG_BONY, 13],
  [NPCID.BIG_BONE, 13],
  [NPCID.GUTTED_FATTY, 20],
  [NPCID.GUTTED_FATTY_EYE, 13],
  [NPCID.FESTERING_GUTS, 13],
  [NPCID.EXORCIST, 13],
  [NPCID.FANATIC, 13],
  [NPCID.CANDLER, 13],
  [NPCID.WHIPPER, 13],
  [NPCID.SNAPPER, 13],
  [NPCID.FLAGELLANT, 13],
  [NPCID.PEEPING_FATTY, 13],
  [NPCID.PEEPING_FATTY_EYE, 13],
  [NPCID.VIS_VERSA, 13],
  [NPCID.HENRY, 22],
  [NPCID.LEVEL_2_WILLO, 13],
  [NPCID.STRIFER, 13],
  [NPCID.SATAN, 30],
  [NPCID.SATAN_STOMP, 55],
  [NPCID.PON, 13],
  [NPCID.REVENANT, 13],
  [NPCID.QUAD_REVENANT, 13],
  [NPCID.NIGHTWATCH, 13],
  [NPCID.CANARY, 13],
  [NPCID.FOREIGNER, 13],
  [NPCID.BOMBGAGGER, 13],
  [NPCID.SPIDER, 13],
  [NPCID.LEVEL_2_GAPER, 16],
  [NPCID.LEVEL_2_HORF, 16],
  [NPCID.LEVEL_2_GUSHER, 13],
  [NPCID.TWITCHY, 13],
  [NPCID.SPIKEBALL, 13],
  [NPCID.SMALL_MAGGOT, 17],
  [NPCID.ADULT_LEECH, 24],
  [NPCID.LEVEL_2_CHARGER, 16],
  [NPCID.ELLEECH, 16],
  [NPCID.GASBAG, 40],
  [NPCID.COHORT, 40],
  [NPCID.VESSEL, 13],
  [NPCID.FLOAST, 13],
  [NPCID.KEEPER, 13],
  [NPCID.UNBORN, 13],
  [NPCID.PUSTULE, 13],
  [NPCID.CYST, 13],
  [NPCID.MORNINGSTAR, 28],
  [NPCID.MORNINGSTAR_2, 28],
  [NPCID.MORNINGSTAR_3, 28],
  [NPCID.MOCKULUS, 13],
  [NPCID.EVIS, 13],
  [NPCID.EVIS_GUTS, 15],
  [NPCID.DARK_ESAU, 13],
  [NPCID.DARKER_ESAU, 13],
  [NPCID.DARK_ESAUS_PIT, 13],
  [NPCID.MOTHERS_SHADOW, 30],
  [NPCID.ARMY_FLY, 14],
  [NPCID.MIGRAINE, 13],
  [NPCID.GURGLE, 13],
  [NPCID.CRACKLE, 13],
  [NPCID.DRIP, 9],
  [NPCID.SPLURT, 13],
  [NPCID.CLOGGY, 13],
  [NPCID.FLY_TRAP, 13],
  [NPCID.GAS_DWARF, 13],
  [NPCID.POOT_MINE, 13],
  [NPCID.DUMP, 13],
  [NPCID.DUMP_HEAD, 13],
  [NPCID.GRUDGE, 16],
  [NPCID.BUTT_SLICKER, 13],
  [NPCID.BLOATY, 13],
  [NPCID.WALKING_BOIL, 13],
  [NPCID.WALKING_GUT, 13],
  [NPCID.WALKING_SACK, 13],
  [NPCID.FLESH_MAIDEN, 13],
  [NPCID.NEEDLE, 14],
  [NPCID.PASTY, 14],
  [NPCID.DUST, 13],
  [NPCID.BABY_BEGOTTEN, 13],
  [NPCID.SWARM_SPIDER, 13],
  [NPCID.CULTIST, 13],
  [NPCID.BLOOD_CULTIST, 13],
  [NPCID.BONE_TRAP, 16],
  [NPCID.VIS_FATTY, 13],
  [NPCID.FETAL_DEMON, 13],
  [NPCID.DUSTY_DEATHS_HEAD, 13],
  [NPCID.SHADY, 13],
  [NPCID.CLICKETY_CLACK, 13],
  [NPCID.BUTTLICKER, 13],
  [NPCID.MAZE_ROAMER, 13],
  [NPCID.MAZE_ROAMER_2, 13],
  [NPCID.GOAT, 13],
  [NPCID.BLACK_GOAT, 13],
  [NPCID.POOFER, 13],
  [NPCID.BALL_AND_CHAIN, 15],
  [NPCID.HANGER, 13],
  [NPCID.REAP_CREEP, 35],
  [NPCID.LIL_BLUB, 35],
  [NPCID.RAINMAKER, 20],
  [NPCID.THE_VISAGE, 20],
  [NPCID.VISAGE_MASK, 20],
  [NPCID.VISAGE_CHAIN, 8],
  [NPCID.VISAGE_PLASMA, 10],
  [NPCID.SIREN, 20],
  [NPCID.SIRENS_SKULL, 13],
  [NPCID.SIREN_HELPER_PROJECTILE, 10],
  [NPCID.THE_HERETIC, 26],
  [NPCID.HORNFEL, 20],
  [NPCID.HORNFEL_DECOY, 20],
  [NPCID.GREAT_GIDEON, 48],
  [NPCID.GREAT_GIDEON_DEFEATED, 48],
  [NPCID.BABY_PLUM, 20],
  [NPCID.THE_SCOURGE, 20],
  [NPCID.THE_SCOURGE_CHAIN, 20],
  [NPCID.SWARMER, 13],
  [NPCID.CHIMERA, 20],
  [NPCID.CHIMERA_BODY, 20],
  [NPCID.CHIMERA_HEAD, 20],
  [NPCID.ROTGUT, 58],
  [NPCID.ROTGUT_MAGGOT, 74],
  [NPCID.ROTGUT_HEART, 70],
  [NPCID.MOTHER_PHASE_1, 90],
  [NPCID.MOTHER_PHASE_2, 90],
  [NPCID.MOTHER_LEFT_ARM, 90],
  [NPCID.MOTHER_RIGHT_ARM, 90],
  [NPCID.MOTHER_DISAPPEAR, 90],
  [NPCID.MOTHER_2, 110],
  [NPCID.MOTHER_BALL, 40],
  [NPCID.MOTHER_BALL_MEDIUM, 25],
  [NPCID.MOTHER_BALL_SMALL, 13],
  [NPCID.DEAD_ISAAC, 13],
  [NPCID.MOTHER_WORM, 13],
  [NPCID.MIN_MIN, 35],
  [NPCID.CLOG, 45],
  [NPCID.SINGE, 20],
  [NPCID.SINGES_BALL, 17],
  [NPCID.BUMBINO, 30],
  [NPCID.COLOSTOMIA, 30],
  [NPCID.TURDLET, 20],
  [NPCID.RAGLICH, 12],
  [NPCID.RAGLICH_ARM, 12],
  [NPCID.HEART, 13],
  [NPCID.HALF_HEART, 13],
  [NPCID.HALF_HEART_2, 13],
  [NPCID.HORNY_BOYS, 30],
  [NPCID.CLUTCH, 30],
  [NPCID.CLUTCH_ORBITAL, 12],
  [NPCID.MASK, 13],
  [NPCID.MASK_II, 13],
  [NPCID.BIG_SPIDER, 13],
  [NPCID.DOGMA, 26],
  [NPCID.DOGMAS_TV, 48],
  [NPCID.DOGMA_ANGEL_BABY, 12],
  [NPCID.DOGMA_ANGEL, 36],
  [NPCID.THE_BEAST, 166],
  [NPCID.STALACTITE, 220],
  [NPCID.ULTRA_FAMINE, 70],
  [NPCID.BACKGROUND_BEAST, 0],
  [NPCID.BACKGROUND_FAMINE, 0],
  [NPCID.BACKGROUND_PESTILENCE, 0],
  [NPCID.BACKGROUND_WAR, 0],
  [NPCID.BACKGROUND_DEATH, 0],
  [NPCID.ULTRA_FAMINE_FLY, 10],
  [NPCID.BEAST_ROCK_PROJECTILE, 5],
  [NPCID.ULTRA_PESTILENCE, 70],
  [NPCID.ULTRA_PESTILENCE_FLY, 10],
  [NPCID.ULTRA_PESTILENCE_MAGGOT, 18],
  [NPCID.ULTRA_PESTILENCE_FLY_BALL, 28],
  [NPCID.BEAST_SOUL, 8],
  [NPCID.ULTRA_WAR, 70],
  [NPCID.ULTRA_WAR_BOMB, 34],
  [NPCID.ULTRA_DEATH, 70],
  [NPCID.ULTRA_DEATH_SCYTHE, 26],
  [NPCID.ULTRA_DEATH_HEAD, 40],
  [NPCID.ETERNAL_FLY, 13],
  [NPCID.GENERIC_PROP, 26],
  [NPCID.MOMS_DRESSER, 58],
  [NPCID.MOMS_VANITY, 40],
  [NPCID.COUCH, 86],
  [NPCID.TV, 48],
  [NPCID.FROZEN_ENEMY, 13],
  [NPCID.DUMMY, 26],
  [NPCID.MINECART, 13],
  [NPCID.SIREN_HELPER, 17],
  [NPCID.HORNFEL_DOOR, 20],
  [NPCID.MASK_OF_INFAMY, 20],
  [NPCID.MASK_OF_INFAMY_BLACK, 20],
  [NPCID.HEART_OF_INFAMY, 30],
  [NPCID.HEART_OF_INFAMY_BLACK, 30],
  [NPCID.GURDY_JR, 35],
  [NPCID.GURDY_JR_BLUE, 35],
  [NPCID.GURDY_JR_YELLOW, 35],
]);

export function _getNonModdedNPCSize(npcID: NPCID): number | undefined {
  return NPC_SIZE_MAP.get(npcID);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\pickups\collectibles\collectibleTypeItemPoolMap.ts`:

```````ts
import { CollectibleType, ItemPoolType } from "isaac-typescript-definitions";

export const itemPools = new Map<CollectibleType, ItemPoolType[]>([
  [
    CollectibleType.SAD_ONION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.INNER_EYE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SPOON_BENDER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CRICKETS_HEAD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MY_REFLECTION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.NUMBER_ONE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BLOOD_OF_THE_MARTYR,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.BROTHER_BOBBY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.SKATOLE, [ItemPoolType.SHELL_GAME]],
  [
    CollectibleType.HALO_OF_FLIES,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.ONE_UP,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.MAGIC_MUSHROOM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.VIRUS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.ROID_RAGE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BOSS,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.HEART,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_BOSS, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.RAW_LIVER,
    [ItemPoolType.SECRET, ItemPoolType.GREED_BOSS, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.SKELETON_KEY,
    [ItemPoolType.TREASURE, ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [CollectibleType.BOOM, [ItemPoolType.TREASURE]],
  [
    CollectibleType.TRANSCENDENCE,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.COMPASS,
    [ItemPoolType.SHOP, ItemPoolType.BEGGAR, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.LUNCH,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.DINNER,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.DESSERT,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.BREAKFAST,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.ROTTEN_MEAT,
    [
      ItemPoolType.BOSS,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [
    CollectibleType.WOODEN_SPOON,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.WOODEN_CHEST],
  ],
  [
    CollectibleType.BELT,
    [ItemPoolType.BOSS, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.MOMS_UNDERWEAR,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.MOMS_HEELS,
    [
      ItemPoolType.BOSS,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.MOMS_LIPSTICK,
    [
      ItemPoolType.BOSS,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.WIRE_COAT_HANGER,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.BIBLE,
    [ItemPoolType.SHOP, ItemPoolType.ANGEL, ItemPoolType.LIBRARY],
  ],
  [
    CollectibleType.BOOK_OF_BELIAL,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.NECRONOMICON,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.SECRET,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [CollectibleType.POOP, [ItemPoolType.TREASURE, ItemPoolType.SHELL_GAME]],
  [
    CollectibleType.MR_BOOM,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.TAMMYS_HEAD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MOMS_BRA,
    [ItemPoolType.TREASURE, ItemPoolType.MOMS_CHEST, ItemPoolType.OLD_CHEST],
  ],
  [
    CollectibleType.KAMIKAZE,
    [ItemPoolType.TREASURE, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.MOMS_PAD,
    [ItemPoolType.TREASURE, ItemPoolType.MOMS_CHEST, ItemPoolType.OLD_CHEST],
  ],
  [
    CollectibleType.BOBS_ROTTEN_HEAD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [CollectibleType.TELEPORT, [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.YUM_HEART,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.LUCKY_FOOT,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.DOCTORS_REMOTE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CUPIDS_ARROW,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.SHOOP_DA_WHOOP,
    [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.STEVEN, [ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.PENTAGRAM,
    [
      ItemPoolType.BOSS,
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.DR_FETUS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.MAGNETO, [ItemPoolType.TREASURE, ItemPoolType.ULTRA_SECRET]],
  [CollectibleType.TREASURE_MAP, [ItemPoolType.SHOP, ItemPoolType.BEGGAR]],
  [
    CollectibleType.MOMS_EYE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.LEMON_MISHAP,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.DISTANT_ADMIRATION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BOOK_OF_SHADOWS,
    [ItemPoolType.TREASURE, ItemPoolType.LIBRARY],
  ],
  [CollectibleType.LADDER, [ItemPoolType.SHOP, ItemPoolType.WOODEN_CHEST]],
  [
    CollectibleType.CHARM_OF_THE_VAMPIRE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BATTERY,
    [
      ItemPoolType.SHOP,
      ItemPoolType.BATTERY_BUM,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.STEAM_SALE,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ANARCHIST_COOKBOOK,
    [ItemPoolType.TREASURE, ItemPoolType.LIBRARY, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.HOURGLASS, [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.SISTER_MAGGY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.TECHNOLOGY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CHOCOLATE_MILK,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GROWTH_HORMONES,
    [ItemPoolType.BOSS, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [CollectibleType.MINI_MUSH, [ItemPoolType.TREASURE, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.ROSARY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.CUBE_OF_MEAT,
    [
      ItemPoolType.GREED_BOSS,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.QUARTER,
    [ItemPoolType.DEVIL, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.PHD,
    [ItemPoolType.TREASURE, ItemPoolType.SHOP, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.XRAY_VISION,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.MY_LITTLE_UNICORN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.BOOK_OF_REVELATIONS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.MARK,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.PACT,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.DEAD_CAT,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.LORD_OF_THE_PIT,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.NAIL,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.WE_NEED_TO_GO_DEEPER,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.DECK_OF_CARDS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHOP,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [CollectibleType.MONSTROS_TOOTH, [ItemPoolType.TREASURE]],
  [
    CollectibleType.LOKIS_HORNS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.LITTLE_CHUBBY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.SPIDER_BITE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [CollectibleType.SMALL_ROCK, [ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.SPELUNKER_HAT,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [CollectibleType.SUPER_BANDAGE, [ItemPoolType.TREASURE, ItemPoolType.BOSS]],
  [
    CollectibleType.GAMEKID,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.SACK_OF_PENNIES,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ROBO_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LITTLE_CHAD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BOOK_OF_SIN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.RELIC,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LITTLE_GISH,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LITTLE_STEVEN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.HALO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.MOMS_BOTTLE_OF_PILLS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHOP,
      ItemPoolType.BEGGAR,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.COMMON_COLD,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PARASITE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.D6,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.MR_MEGA,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.PINKING_SHEARS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.WAFER,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MONEY_EQUALS_POWER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.MOMS_CONTACTS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.BEAN,
    [ItemPoolType.TREASURE, ItemPoolType.BEGGAR, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GUARDIAN_ANGEL,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.DEMON_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.MOMS_KNIFE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.OUIJA_BOARD,
    [ItemPoolType.TREASURE, ItemPoolType.DEVIL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.NINE_VOLT,
    [
      ItemPoolType.SHOP,
      ItemPoolType.BATTERY_BUM,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.DEAD_BIRD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BRIMSTONE,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.BLOOD_BAG, [ItemPoolType.ULTRA_SECRET]],
  [
    CollectibleType.ODD_MUSHROOM_THIN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.ODD_MUSHROOM_LARGE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.WHORE_OF_BABYLON,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.MONSTER_MANUAL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.DEAD_SEA_SCROLLS,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BOBBY_BOMB,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.RAZOR_BLADE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_CURSE,
    ],
  ],
  [
    CollectibleType.FORGET_ME_NOW,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.SECRET,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.FOREVER_ALONE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.BUCKET_OF_LARD, [ItemPoolType.TREASURE]],
  [
    CollectibleType.BOMB_BAG,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LUMP_OF_COAL,
    [
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.GUPPYS_PAW,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.GUPPYS_TAIL,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [CollectibleType.IV_BAG, [ItemPoolType.ULTRA_SECRET]],
  [
    CollectibleType.BEST_FRIEND,
    [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.REMOTE_DETONATOR,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHOP,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BOMB_BUM,
    ],
  ],
  [
    CollectibleType.STIGMATA,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.MOMS_PURSE,
    [
      ItemPoolType.SHOP,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.BOBS_CURSE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.RED_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BOMB_BUM,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [CollectibleType.PAGEANT_BOY, [ItemPoolType.BOSS]],
  [
    CollectibleType.SCAPULAR,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SPEED_BALL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BOSS,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.BUM_FRIEND,
    [ItemPoolType.TREASURE, ItemPoolType.BEGGAR, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.GUPPYS_HEAD,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.PRAYER_CARD,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.NOTCHED_AXE, [ItemPoolType.SHOP, ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.INFESTATION,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.IPECAC,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.TOUGH_LOVE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MULLIGAN,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.TECHNOLOGY_2,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MUTANT_SPIDER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CHEMICAL_PEEL,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PEEPER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.HABIT,
    [ItemPoolType.SHOP, ItemPoolType.ANGEL, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.BLOODY_LUST,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SPIRIT_OF_THE_NIGHT,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [CollectibleType.CRACK_THE_SKY, [ItemPoolType.TREASURE]],
  [CollectibleType.ANKH, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.CELTIC_CROSS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.GHOST_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.CANDLE, [ItemPoolType.SHOP]],
  [CollectibleType.CAT_O_NINE_TAILS, [ItemPoolType.BOSS]],
  [
    CollectibleType.D20,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.HARLEQUIN_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.EPIC_FETUS,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.POLYPHEMUS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.DADDY_LONGLEGS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.SPIDER_BUTT, [ItemPoolType.TREASURE]],
  [
    CollectibleType.SACRIFICIAL_DAGGER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.MITRE, [ItemPoolType.TREASURE, ItemPoolType.ANGEL]],
  [
    CollectibleType.RAINBOW_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DADS_KEY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.STEM_CELLS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BOSS,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.PORTABLE_SLOT,
    [ItemPoolType.SHOP, ItemPoolType.BEGGAR, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.HOLY_WATER,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.FATE, [ItemPoolType.GOLDEN_CHEST]],
  [CollectibleType.BLACK_BEAN, [ItemPoolType.TREASURE, ItemPoolType.BEGGAR]],
  [
    CollectibleType.SACRED_HEART,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.TOOTH_PICKS,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.WOODEN_CHEST],
  ],
  [CollectibleType.HOLY_GRAIL, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [CollectibleType.DEAD_DOVE, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.BLOOD_RIGHTS,
    [ItemPoolType.TREASURE, ItemPoolType.DEVIL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GUPPYS_HAIRBALL,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.ABEL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.SMB_SUPER_FAN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.PYRO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.BOMB_BUM,
    ],
  ],
  [
    CollectibleType.THREE_DOLLAR_BILL,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.TELEPATHY_BOOK,
    [ItemPoolType.TREASURE, ItemPoolType.LIBRARY, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MEAT,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.MAGIC_8_BALL,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MOMS_COIN_PURSE,
    [
      ItemPoolType.SHOP,
      ItemPoolType.BOSS,
      ItemPoolType.BEGGAR,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.SQUEEZY,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.JESUS_JUICE,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.BOX,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.MOMS_KEY,
    [
      ItemPoolType.SHOP,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.MOMS_EYESHADOW,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.IRON_BAR,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.MIDAS_TOUCH, [ItemPoolType.TREASURE]],
  [CollectibleType.HUMBLEING_BUNDLE, [ItemPoolType.SHOP]],
  [
    CollectibleType.FANNY_PACK,
    [ItemPoolType.SHOP, ItemPoolType.BEGGAR, ItemPoolType.GREED_SHOP],
  ],
  [CollectibleType.SHARP_PLUG, [ItemPoolType.SHOP, ItemPoolType.BATTERY_BUM]],
  [
    CollectibleType.GUILLOTINE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BALL_OF_BANDAGES,
    [ItemPoolType.GREED_BOSS, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.CHAMPION_BELT,
    [
      ItemPoolType.SHOP,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.BUTT_BOMBS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHELL_GAME,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BOMB_BUM,
    ],
  ],
  [
    CollectibleType.GNAWED_LEAF,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.SPIDERBABY, [ItemPoolType.TREASURE]],
  [
    CollectibleType.GUPPYS_COLLAR,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.LOST_CONTACT,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.ANEMIC,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [CollectibleType.GOAT_HEAD, [ItemPoolType.DEVIL, ItemPoolType.CURSE]],
  [
    CollectibleType.CEREMONIAL_ROBES,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.MOMS_WIG,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [CollectibleType.PLACENTA, [ItemPoolType.BOSS]],
  [CollectibleType.OLD_BANDAGE, [ItemPoolType.BOSS]],
  [
    CollectibleType.SAD_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.RUBBER_CEMENT,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ANTI_GRAVITY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PYROMANIAC,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CRICKETS_BODY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GIMPY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.BLACK_LOTUS,
    [
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.PIGGY_BANK,
    [ItemPoolType.TREASURE, ItemPoolType.SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.MOMS_PERFUME,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.MONSTROS_LUNG,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ABADDON,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.BALL_OF_TAR,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.STOP_WATCH, [ItemPoolType.SHOP, ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.TINY_PLANET,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.INFESTATION_2,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.E_COLI,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.DEATHS_TOUCH,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.EXPERIMENTAL_TREATMENT,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BOSS,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.CONTRACT_FROM_BELOW,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR, ItemPoolType.CURSE],
  ],
  [
    CollectibleType.INFAMY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.TRINITY_SHIELD,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.TECH_5,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.TWENTY_TWENTY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BLUE_MAP,
    [ItemPoolType.SHOP, ItemPoolType.BEGGAR, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.BFFS,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.HIVE_MIND, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [CollectibleType.THERES_OPTIONS, [ItemPoolType.SHOP]],
  [CollectibleType.BOGO_BOMBS, [ItemPoolType.SHOP]],
  [
    CollectibleType.STARTER_DECK,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [CollectibleType.LITTLE_BAGGY, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.MAGIC_SCAB,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.BLOOD_CLOT,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SCREW,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.HOT_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.FIRE_MIND,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MISSING_NO,
    [
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.DARK_MATTER,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.BLACK_CANDLE,
    [
      ItemPoolType.SHOP,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
    ],
  ],
  [
    CollectibleType.PROPTOSIS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.MISSING_PAGE_2,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.SECRET,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.CLEAR_RUNE,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.SMART_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DRY_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.JUICY_SACK,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.ROBO_BABY_2,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.ROTTEN_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [
    CollectibleType.HEADLESS_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LEECH,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_DEVIL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.MYSTERY_SACK,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.BBF,
    [ItemPoolType.TREASURE, ItemPoolType.KEY_MASTER, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.BOBS_BRAIN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [
    CollectibleType.BEST_BUD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LIL_BRIMSTONE,
    [ItemPoolType.TREASURE, ItemPoolType.DEVIL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.ISAACS_HEART,
    [ItemPoolType.TREASURE, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.LIL_HAUNT,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DARK_BUM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BIG_FAN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.SISSY_LONGLEGS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.PUNCHING_BAG,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.HOW_TO_JUMP, [ItemPoolType.TREASURE, ItemPoolType.LIBRARY]],
  [
    CollectibleType.D100,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.D4,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.D10,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.BLANK_CARD,
    [
      ItemPoolType.SHOP,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.BOOK_OF_SECRETS,
    [ItemPoolType.TREASURE, ItemPoolType.SECRET, ItemPoolType.LIBRARY],
  ],
  [
    CollectibleType.BOX_OF_SPIDERS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.RED_CANDLE,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.JAR, [ItemPoolType.SHOP]],
  [CollectibleType.FLUSH, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.SATANIC_BIBLE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [CollectibleType.BUTTER_BEAN, [ItemPoolType.TREASURE, ItemPoolType.BEGGAR]],
  [CollectibleType.MAGIC_FINGERS, [ItemPoolType.TREASURE, ItemPoolType.SHOP]],
  [CollectibleType.CONVERTER, [ItemPoolType.SHOP]],
  [
    CollectibleType.BLUE_BOX,
    [ItemPoolType.SHOP, ItemPoolType.RED_CHEST, ItemPoolType.GREED_SHOP],
  ],
  [CollectibleType.UNICORN_STUMP, [ItemPoolType.TREASURE]],
  [
    CollectibleType.TAURUS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.ARIES, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.CANCER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.LEO, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [CollectibleType.VIRGO, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [CollectibleType.LIBRA, [ItemPoolType.TREASURE]],
  [
    CollectibleType.SCORPIO,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SAGITTARIUS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CAPRICORN,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.AQUARIUS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PISCES,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EVES_MASCARA,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.JUDAS_SHADOW,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.MAGGYS_BOW,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.HOLY_MANTLE,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.THUNDER_THIGHS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.STRANGE_ATTRACTOR,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CURSED_EYE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.RED_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.MYSTERIOUS_LIQUID,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GEMINI,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CAINS_OTHER_EYE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BLUE_BABYS_ONLY_FRIEND,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.SAMSONS_CHAINS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.MONGO_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.ISAACS_TEARS, [ItemPoolType.TREASURE]],
  [CollectibleType.UNDEFINED, [ItemPoolType.TREASURE]],
  [
    CollectibleType.SCISSORS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.BREATH_OF_LIFE, [ItemPoolType.ANGEL]],
  [
    CollectibleType.LUDOVICO_TECHNIQUE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SOY_MILK,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.GODHEAD, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.LAZARUS_RAGS,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MIND,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.BODY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SOUL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.DEAD_ONION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [CollectibleType.BROKEN_WATCH, [ItemPoolType.SHOP, ItemPoolType.CRANE_GAME]],
  [CollectibleType.BOOMERANG, [ItemPoolType.SHOP, ItemPoolType.CRANE_GAME]],
  [CollectibleType.SAFETY_PIN, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.CAFFEINE_PILL,
    [ItemPoolType.BOSS, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.TORN_PHOTO,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [CollectibleType.BLUE_CAP, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.LATCH_KEY,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.MATCH_BOOK,
    [ItemPoolType.BOSS, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.SYNTHOIL,
    [ItemPoolType.BOSS, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [CollectibleType.SNACK, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [CollectibleType.DIPLOPIA, [ItemPoolType.SHOP]],
  [
    CollectibleType.PLACEBO,
    [
      ItemPoolType.SHOP,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.WOODEN_NICKEL,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.WOODEN_CHEST],
  ],
  [CollectibleType.TOXIC_SHOCK, [ItemPoolType.TREASURE]],
  [
    CollectibleType.MEGA_BEAN,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GLASS_CANNON,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.BOMBER_BOY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.CRACK_JACKS,
    [ItemPoolType.BOSS, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.MOMS_PEARLS,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.CAR_BATTERY,
    [ItemPoolType.SHOP, ItemPoolType.BATTERY_BUM, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.BOX_OF_FRIENDS,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [CollectibleType.WIZ, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.EIGHT_INCH_NAILS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.INCUBUS,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.FATES_REWARD,
    [ItemPoolType.TREASURE, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.LIL_CHEST,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.SWORN_PROTECTOR,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.FRIEND_ZONE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LOST_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.SCATTER_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.STICKY_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.EPIPHORA,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CONTINUUM,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MR_DOLLY,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CURSE_OF_THE_TOWER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_CURSE,
    ],
  ],
  [
    CollectibleType.CHARGED_BABY,
    [
      ItemPoolType.SHOP,
      ItemPoolType.BATTERY_BUM,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DEAD_EYE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.HOLY_LIGHT,
    [ItemPoolType.TREASURE, ItemPoolType.ANGEL, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.HOST_HAT,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.RESTOCK, [ItemPoolType.SHOP, ItemPoolType.BEGGAR]],
  [
    CollectibleType.BURSTING_SACK,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.NUMBER_TWO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHELL_GAME,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.PUPULA_DUPLEX,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PAY_TO_PLAY,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.GREED_SHOP],
  ],
  [CollectibleType.EDENS_BLESSING, [ItemPoolType.TREASURE]],
  [
    CollectibleType.FRIEND_BALL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.TEAR_DETONATOR,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.LIL_GURDY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BUMBO,
    [ItemPoolType.TREASURE, ItemPoolType.BEGGAR, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.D12,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [CollectibleType.CENSER, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.KEY_BUM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.RUNE_BAG,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.SERAPHIM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BETRAYAL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.ZODIAC,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SERPENTS_KISS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MARKED,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.TECH_X,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [CollectibleType.VENTRICLE_RAZOR, [ItemPoolType.SHOP]],
  [
    CollectibleType.TRACTOR_BEAM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.GODS_FLESH,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MAW_OF_THE_VOID,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.SPEAR_OF_DESTINY,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.EXPLOSIVO,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.CHAOS,
    [
      ItemPoolType.SHOP,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.SPIDER_MOD,
    [
      ItemPoolType.SHOP,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.FARTING_BABY,
    [ItemPoolType.TREASURE, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.GB_BUG,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.D8,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.PURITY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.ATHAME,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.EMPTY_VESSEL,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.EVIL_EYE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LUSTY_BLOOD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.CAMBION_CONCEPTION,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.IMMACULATE_CONCEPTION,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.MORE_OPTIONS, [ItemPoolType.SHOP]],
  [
    CollectibleType.CROWN_OF_LIGHT,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.DEEP_POCKETS,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.GREED_SHOP],
  ],
  [CollectibleType.SUCCUBUS, [ItemPoolType.DEVIL, ItemPoolType.BABY_SHOP]],
  [CollectibleType.FRUIT_CAKE, [ItemPoolType.TREASURE]],
  [
    CollectibleType.TELEPORT_2,
    [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.BLACK_POWDER,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.KIDNEY_BEAN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.GLOWING_HOUR_GLASS,
    [ItemPoolType.TREASURE, ItemPoolType.SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.CIRCLE_OF_PROTECTION,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.SACK_HEAD,
    [ItemPoolType.SHOP, ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.NIGHT_LIGHT,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.OBSESSED_FAN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.MINE_CRAFTER,
    [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.PJS,
    [ItemPoolType.BOSS, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.PAPA_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.MULTIDIMENSIONAL_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.GLITTER_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [CollectibleType.MY_SHADOW, [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL]],
  [
    CollectibleType.JAR_OF_FLIES,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.LIL_LOKI,
    [ItemPoolType.TREASURE, ItemPoolType.ULTRA_SECRET, ItemPoolType.BABY_SHOP],
  ],
  [CollectibleType.MILK, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [CollectibleType.D7, [ItemPoolType.TREASURE, ItemPoolType.CRANE_GAME]],
  [
    CollectibleType.BINKY,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MOMS_BOX,
    [
      ItemPoolType.SHOP,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.OLD_CHEST,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.KIDNEY_STONE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.MEGA_BLAST, [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL]],
  [
    CollectibleType.DARK_PRINCES_CROWN,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.APPLE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.LEAD_PENCIL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.DOG_TOOTH,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.DEAD_TOOTH,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LINGER_BEAN,
    [ItemPoolType.TREASURE, ItemPoolType.BEGGAR, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SHARD_OF_GLASS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.METAL_PLATE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EYE_OF_GREED,
    [
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.TAROT_CLOTH,
    [
      ItemPoolType.SHOP,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.VARICOSE_VEINS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.COMPOUND_FRACTURE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.POLYDACTYLY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.DADS_LOST_COIN,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.MIDNIGHT_SNACK,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_BOSS,
    ],
  ],
  [
    CollectibleType.CONE_HEAD,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BELLY_BUTTON,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SINUS_INFECTION,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GLAUCOMA,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.PARASITOID,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EYE_OF_BELIAL,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.SULFURIC_ACID,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GLYPH_OF_BALANCE,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.ANALOG_STICK,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.CONTAGION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.FINGER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SHADE,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DEPRESSION,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.HUSHY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LIL_MONSTRO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.KING_BABY,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.BIG_CHUBBY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.PLAN_C,
    [
      ItemPoolType.SHOP,
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.D1,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.VOID,
    [ItemPoolType.DEVIL, ItemPoolType.ANGEL, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.PAUSE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [CollectibleType.SMELTER, [ItemPoolType.SHOP]],
  [CollectibleType.COMPOST, [ItemPoolType.SHOP, ItemPoolType.ROTTEN_BEGGAR]],
  [
    CollectibleType.DATAMINER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.CLICKER, [ItemPoolType.TREASURE, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.MAMA_MEGA,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.CROOKED_PENNY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHOP,
      ItemPoolType.BEGGAR,
      ItemPoolType.GREED_SHOP,
    ],
  ],
  [CollectibleType.DULL_RAZOR, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.POTATO_PEELER,
    [ItemPoolType.SHOP, ItemPoolType.DEMON_BEGGAR, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.METRONOME,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.D_INFINITY,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [CollectibleType.EDENS_SOUL, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [CollectibleType.ACID_BABY, [ItemPoolType.TREASURE, ItemPoolType.BABY_SHOP]],
  [
    CollectibleType.YO_LISTEN,
    [ItemPoolType.TREASURE, ItemPoolType.KEY_MASTER, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.ADRENALINE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.JACOBS_LADDER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BATTERY_BUM,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.GHOST_PEPPER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EUTHANASIA,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_CURSE,
    ],
  ],
  [
    CollectibleType.CAMO_UNDIES,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.DUALITY, [ItemPoolType.DEVIL, ItemPoolType.ANGEL]],
  [CollectibleType.EUCHARIST, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.SACK_OF_SACKS,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.GREEDS_GULLET,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.LARGE_ZIT,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LITTLE_HORN,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.BROWN_NUGGET,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHELL_GAME,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.POKE_GO,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.BACKSTABBER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SHARP_STRAW,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MOMS_RAZOR,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.BLOODSHOT_EYE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.DELIRIOUS, [ItemPoolType.ANGEL]],
  [
    CollectibleType.ANGRY_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BLACK_HOLE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
    ],
  ],
  [CollectibleType.BOZO, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.BROKEN_MODEM,
    [ItemPoolType.SHOP, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MYSTERY_GIFT,
    [
      ItemPoolType.SHOP,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.SPRINKLER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.FAST_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.BUDDY_IN_A_BOX,
    [
      ItemPoolType.SHOP,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LIL_DELIRIUM,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.JUMPER_CABLES,
    [ItemPoolType.SHOP, ItemPoolType.BATTERY_BUM, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.COUPON, [ItemPoolType.SHOP]],
  [
    CollectibleType.TELEKINESIS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.MOVING_BOX, [ItemPoolType.SHOP]],
  [
    CollectibleType.TECHNOLOGY_ZERO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.LEPROSY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SEVEN_SEALS,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.MR_ME,
    [
      ItemPoolType.SHOP,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.ANGELIC_PRISM,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.POP, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [CollectibleType.DEATHS_LIST, [ItemPoolType.DEVIL]],
  [
    CollectibleType.HAEMOLACRIA,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.LACHRYPHAGY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.TRISAGION, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.SCHOOLBAG,
    [ItemPoolType.SHOP, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_SHOP],
  ],
  [CollectibleType.BLANKET, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.SACRIFICIAL_ALTAR,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.LIL_SPEWER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.MARBLES,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.MYSTERY_EGG,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.FLAT_STONE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MARROW,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.SLIPPED_RIB,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.HALLOWED_GROUND,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.POINTY_RIB,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BOOK_OF_THE_DEAD,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.LIBRARY,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.DADS_RING,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET, ItemPoolType.OLD_CHEST],
  ],
  [
    CollectibleType.DIVORCE_PAPERS,
    [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS, ItemPoolType.OLD_CHEST],
  ],
  [
    CollectibleType.JAW_BONE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BRITTLE_BONES,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MUCORMYCOSIS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.TWO_SPOOKY,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.GOLDEN_RAZOR,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SULFUR,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.FORTUNE_COOKIE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EYE_SORE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ONE_HUNDRED_TWENTY_VOLT,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.BATTERY_BUM,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.IT_HURTS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ALMOND_MILK,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ROCK_BOTTOM,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.NANCY_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [CollectibleType.BAR_OF_SOAP, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.BLOOD_PUPPY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [CollectibleType.DREAM_CATCHER, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.PASCHAL_CANDLE,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.DIVINE_INTERVENTION,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.BLOOD_OATH,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
    ],
  ],
  [
    CollectibleType.PLAYDOUGH_COOKIE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.ORPHAN_SOCKS,
    [ItemPoolType.SECRET, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.EYE_OF_THE_OCCULT,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.IMMACULATE_HEART,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.MONSTRANCE, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.INTRUDER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.DIRTY_MIND,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SHELL_GAME,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [CollectibleType.DAMOCLES, [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL]],
  [
    CollectibleType.FREE_LEMONADE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SPIRIT_SWORD,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.RED_KEY,
    [
      ItemPoolType.SECRET,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.PSY_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [CollectibleType.WAVY_CAP, [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET]],
  [
    CollectibleType.ROCKET_IN_A_JAR,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.BOOK_OF_VIRTUES,
    [ItemPoolType.ANGEL, ItemPoolType.LIBRARY, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.ALABASTER_BOX, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [CollectibleType.STAIRWAY, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [CollectibleType.SOL, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.LUNA, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.MERCURIUS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.VENUS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.TERRA, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.MARS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.JUPITER, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.SATURNUS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.URANUS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.NEPTUNUS, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.PLUTO, [ItemPoolType.PLANETARIUM]],
  [CollectibleType.VOODOO_HEAD, [ItemPoolType.SHOP, ItemPoolType.CRANE_GAME]],
  [CollectibleType.EYE_DROPS, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.ACT_OF_CONTRITION,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.MEMBER_CARD, [ItemPoolType.SHOP]],
  [
    CollectibleType.BATTERY_PACK,
    [ItemPoolType.SHOP, ItemPoolType.BATTERY_BUM, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.MOMS_BRACELET,
    [
      ItemPoolType.SHOP,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.OLD_CHEST,
    ],
  ],
  [
    CollectibleType.SCOOPER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.OCULAR_RIFT,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.BOILED_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.FREEZER_BABY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.ETERNAL_D6,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.BIRD_CAGE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.LARYNX,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LOST_SOUL,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BLOOD_BOMBS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BOMB_BUM,
    ],
  ],
  [
    CollectibleType.LIL_DUMPY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BIRDS_EYE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.LODESTONE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.ROTTEN_TOMATO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [CollectibleType.BIRTHRIGHT, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.RED_STEW,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.ULTRA_SECRET],
  ],
  [CollectibleType.GENESIS, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [CollectibleType.SHARP_KEY, [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP]],
  [
    CollectibleType.BOOSTER_PACK,
    [
      ItemPoolType.SHOP,
      ItemPoolType.BOSS,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.MEGA_MUSH,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.DEATH_CERTIFICATE,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.BOT_FLY,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.MEAT_CLEAVER,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EVIL_CHARM,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.PURGATORY,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.ANGEL,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.GREED_ANGEL,
    ],
  ],
  [
    CollectibleType.STITCHES,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.R_KEY,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.KNOCKOUT_DROPS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.ERASER,
    [ItemPoolType.SHOP, ItemPoolType.GREED_SHOP, ItemPoolType.CRANE_GAME],
  ],
  [
    CollectibleType.YUCK_HEART,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ROTTEN_BEGGAR,
    ],
  ],
  [
    CollectibleType.URN_OF_SOULS,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.AKELDAMA,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.MAGIC_SKIN,
    [
      ItemPoolType.SHOP,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
    ],
  ],
  [CollectibleType.REVELATION, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.CONSOLATION_PRIZE,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.TINYTOMA,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BRIMSTONE_BOMBS,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.FOUR_FIVE_VOLT,
    [ItemPoolType.SHOP, ItemPoolType.BATTERY_BUM, ItemPoolType.GREED_SHOP],
  ],
  [
    CollectibleType.FRUITY_PLUM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.PLUM_FLUTE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.STAR_OF_BETHLEHEM,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [
    CollectibleType.CUBE_BABY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.VADE_RETRO, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.FALSE_PHD,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.RED_CHEST,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SPIN_TO_WIN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.VASCULITIS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.GIANT_CELL,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [CollectibleType.TROPICAMIDE, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [CollectibleType.CARD_READING, [ItemPoolType.SHOP]],
  [
    CollectibleType.QUINTS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.TOOTH_AND_NAIL,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.BINGE_EATER,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.GUPPYS_EYE,
    [ItemPoolType.DEVIL, ItemPoolType.RED_CHEST, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.STRAWMAN,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [CollectibleType.SAUSAGE, [ItemPoolType.SECRET, ItemPoolType.GREED_SECRET]],
  [CollectibleType.OPTIONS, [ItemPoolType.SHOP]],
  [
    CollectibleType.CANDY_HEART,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.POUND_OF_FLESH,
    [ItemPoolType.DEVIL, ItemPoolType.DEMON_BEGGAR],
  ],
  [
    CollectibleType.SPIRIT_SHACKLES,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.CRACKED_ORB,
    [ItemPoolType.TREASURE, ItemPoolType.SECRET, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.EMPTY_HEART,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEMON_BEGGAR,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.ASTRAL_PROJECTION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.C_SECTION,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LIL_ABADDON,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.MONTEZUMAS_REVENGE,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.LIL_PORTAL,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.WORM_FRIEND,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
      ItemPoolType.BABY_SHOP,
    ],
  ],
  [
    CollectibleType.BONE_SPURS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.HUNGRY_SOUL,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.JAR_OF_WISPS,
    [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL],
  ],
  [CollectibleType.SOUL_LOCKET, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [
    CollectibleType.FRIEND_FINDER,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.INNER_CHILD,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.GLITCHED_CROWN,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.JELLY_BELLY,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.SACRED_ORB,
    [
      ItemPoolType.ANGEL,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_ANGEL,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.SANGUINE_BOND,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.SWARM,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.KEY_MASTER,
      ItemPoolType.GREED_TREASURE,
    ],
  ],
  [
    CollectibleType.HEARTBREAK,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.BLOODY_GUST,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [CollectibleType.SALVATION, [ItemPoolType.ANGEL, ItemPoolType.GREED_ANGEL]],
  [CollectibleType.VANISHING_TWIN, [ItemPoolType.SECRET, ItemPoolType.CURSE]],
  [
    CollectibleType.TWISTED_PAIR,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.BABY_SHOP],
  ],
  [
    CollectibleType.AZAZELS_RAGE,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.ECHO_CHAMBER,
    [
      ItemPoolType.SECRET,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.ISAACS_TOMB,
    [ItemPoolType.SECRET, ItemPoolType.GREED_SHOP, ItemPoolType.GREED_SECRET],
  ],
  [
    CollectibleType.VENGEFUL_SPIRIT,
    [
      ItemPoolType.DEVIL,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.ESAU_JR,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.BERSERK,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.DARK_ARTS,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.ABYSS,
    [ItemPoolType.DEVIL, ItemPoolType.GREED_DEVIL, ItemPoolType.ULTRA_SECRET],
  ],
  [
    CollectibleType.SUPPER,
    [ItemPoolType.BOSS, ItemPoolType.BEGGAR, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.STAPLER,
    [ItemPoolType.BOSS, ItemPoolType.GOLDEN_CHEST, ItemPoolType.GREED_BOSS],
  ],
  [
    CollectibleType.SUPLEX,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.BAG_OF_CRAFTING,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.FLIP,
    [
      ItemPoolType.SECRET,
      ItemPoolType.CURSE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_CURSE,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.LEMEGETON,
    [ItemPoolType.DEVIL, ItemPoolType.LIBRARY, ItemPoolType.GREED_DEVIL],
  ],
  [
    CollectibleType.SUMPTORIUM,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.KEEPERS_SACK,
    [
      ItemPoolType.SHOP,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.KEEPERS_KIN,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.KEEPERS_BOX,
    [
      ItemPoolType.SHOP,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.WOODEN_CHEST,
    ],
  ],
  [
    CollectibleType.EVERYTHING_JAR,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.TMTRAINER,
    [
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
    ],
  ],
  [
    CollectibleType.ANIMA_SOLA,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
    ],
  ],
  [
    CollectibleType.SPINDOWN_DICE,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.SECRET,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_SHOP,
      ItemPoolType.GREED_SECRET,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [
    CollectibleType.HYPERCOAGULATION,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [CollectibleType.IBS, [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE]],
  [
    CollectibleType.HEMOPTYSIS,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.GHOST_BOMBS,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE, ItemPoolType.BOMB_BUM],
  ],
  [
    CollectibleType.GELLO,
    [
      ItemPoolType.TREASURE,
      ItemPoolType.DEVIL,
      ItemPoolType.GREED_TREASURE,
      ItemPoolType.GREED_DEVIL,
      ItemPoolType.ULTRA_SECRET,
    ],
  ],
  [
    CollectibleType.DECAP_ATTACK,
    [ItemPoolType.TREASURE, ItemPoolType.GREED_TREASURE],
  ],
  [
    CollectibleType.GLASS_EYE,
    [
      ItemPoolType.BOSS,
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.GREED_BOSS,
      ItemPoolType.CRANE_GAME,
    ],
  ],
  [CollectibleType.STYE, [ItemPoolType.BOSS, ItemPoolType.GREED_BOSS]],
  [
    CollectibleType.MOMS_RING,
    [
      ItemPoolType.GOLDEN_CHEST,
      ItemPoolType.MOMS_CHEST,
      ItemPoolType.GREED_SHOP,
    ],
  ],
]);

/** Get a non-modded collectible's ItemPools. */
export function _getNonModdedCollectibleTypeItemPools(
  collectibleType: CollectibleType,
): readonly ItemPoolType[] {
  const itemPool = itemPools.get(collectibleType);
  if (itemPool === undefined) {
    error(`No itemPoolAttributes found for ${collectibleType}.`);
  }

  return itemPool;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\pickups\collectibles\modded\moddedCollectibleTypeItemPoolMap.ts`:

```````ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ItemPoolType } from "isaac-typescript-definitions";
import { ReadonlyMap, getCollectibleName } from "isaacscript-common";

const moddedCollectibleTypeItemPoolMap = new ReadonlyMap<
  string,
  ItemPoolType[]
>([["Name", [ItemPoolType.ANGEL]]]);

/**
 * Get a modded collectible's ItemPools (if the mod is tracked). If the mod is not tracked, return
 * undefined.
 */
export function _getModdedCollectibleTypeItemPools(
  collectibleType: CollectibleType,
): ItemPoolType[] | undefined {
  const name = getCollectibleName(collectibleType);
  return moddedCollectibleTypeItemPoolMap.get(name);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\data\sounds\soundLengths.ts`:

```````ts
import type { SoundEffect } from "isaac-typescript-definitions";

// eslint-disable-next-line isaacscript/require-capital-read-only
const SOUND_LENGTHS_MAP = new Map<number, number>([
  [1, 0.29],
  [2, 0.33],
  [3, 0.6],
  [4, 0.75],
  [5, 1.89],
  [6, 1.13],
  [7, 1.89],
  [8, 0.51],
  [9, 1.24],
  [10, 1.65],
  [11, 1.4],
  [12, 0.53],
  [13, 0.55],
  [14, 0.41],
  [15, 0.65],
  [16, 1.05],
  [17, 0.91],
  [18, 1.2],
  [21, 0.38],
  [22, 0.49],
  [23, 2.58],
  [24, 0.54],
  [25, 0.53],
  [27, 0.87],
  [28, 1.79],
  [29, 1.36],
  [30, 0.49],
  [33, 3.93],
  [34, 3.37],
  [35, 1.4],
  [36, 1.12],
  [37, 0.69],
  [38, 0.17],
  [40, 0.16],
  [43, 1.21],
  [44, 0.98],
  [45, 0.82],
  [46, 1.33],
  [47, 1.19],
  [48, 1.76],
  [49, 0.51],
  [51, 3.76],
  [52, 1.99],
  [53, 1.17],
  [54, 1.42],
  [55, 0.38],
  [56, 0.47],
  [57, 0.47],
  [58, 0.44],
  [59, 0.25],
  [60, 0.27],
  [64, 0.83],
  [66, 1.05],
  [68, 0.41],
  [69, 0.05],
  [70, 0.16],
  [72, 0.13],
  [77, 0.28],
  [78, 0.69],
  [79, 0.93],
  [80, 1.33],
  [81, 0.24],
  [82, 3.16],
  [84, 2.88],
  [85, 4.46],
  [86, 2.89],
  [87, 0.34],
  [90, 0.62],
  [93, 0.45],
  [97, 0.4],
  [101, 0.6],
  [104, 0.4],
  [106, 0.46],
  [108, 0.38],
  [112, 0.46],
  [114, 0.65],
  [115, 0.87],
  [116, 0.89],
  [117, 0.99],
  [118, 0.9],
  [119, 0.61],
  [122, 0.85],
  [128, 0.97],
  [129, 2.07],
  [130, 2.62],
  [132, 1.57],
  [133, 0.57],
  [134, 0.5],
  [135, 1.23],
  [136, 1.23],
  [137, 1.33],
  [138, 1.27],
  [139, 1.13],
  [141, 2.06],
  [142, 0.25],
  [143, 1.01],
  [146, 0.49],
  [149, 0.7],
  [150, 0.16],
  [153, 0.24],
  [156, 0.4],
  [157, 0.69],
  [158, 0.34],
  [159, 1.15],
  [160, 2.59],
  [161, 7.89],
  [162, 1.32],
  [163, 13.04],
  [165, 0.94],
  [166, 0.1],
  [167, 0.66],
  [169, 0.33],
  [170, 0.69],
  [171, 0.08],
  [172, 1.5],
  [173, 1],
  [174, 1.24],
  [175, 0.31],
  [178, 0.19],
  [181, 0.31],
  [182, 1.03],
  [183, 1],
  [184, 2.41],
  [185, 0.32],
  [186, 1.41],
  [187, 0.73],
  [190, 1.8],
  [194, 0.04],
  [195, 0.04],
  [197, 0.5],
  [198, 0.72],
  [199, 2.41],
  [200, 1.25],
  [201, 0.07],
  [204, 5.04],
  [205, 0.05],
  [207, 0.61],
  [211, 2.98],
  [212, 0.73],
  [213, 0.65],
  [214, 0.19],
  [215, 0.2],
  [217, 1.09],
  [218, 0.69],
  [219, 0.07],
  [221, 0.19],
  [224, 0.13],
  [226, 0.47],
  [229, 1.35],
  [231, 0.6],
  [232, 1.22],
  [233, 1.18],
  [234, 0.67],
  [237, 0.14],
  [238, 2.08],
  [239, 2.02],
  [240, 1.84],
  [241, 3.87],
  [242, 3.42],
  [243, 3.05],
  [245, 2.8],
  [246, 3.15],
  [249, 0.08],
  [252, 0.11],
  [255, 0.43],
  [258, 0.04],
  [261, 0.55],
  [262, 0.2],
  [263, 0.88],
  [265, 1.16],
  [266, 4.26],
  [267, 0.38],
  [268, 0.19],
  [269, 15.04],
  [270, 3.5],
  [271, 1.22],
  [272, 1.47],
  [273, 1.94],
  [274, 1.08],
  [275, 0.74],
  [276, 2.11],
  [277, 1.98],
  [278, 2.5],
  [279, 7.54],
  [280, 1.36],
  [281, 10.02],
  [282, 0.33],
  [283, 0.9],
  [284, 0.82],
  [286, 0.44],
  [300, 2.03],
  [301, 1.38],
  [302, 0.92],
  [303, 0.57],
  [304, 0.61],
  [305, 1.4],
  [306, 0.62],
  [307, 1.75],
  [308, 1.29],
  [309, 1.73],
  [310, 0.78],
  [311, 3.16],
  [312, 1.11],
  [313, 0.48],
  [314, 0.47],
  [315, 0.67],
  [316, 2.4],
  [317, 0.65],
  [318, 0.13],
  [319, 0.27],
  [320, 4.39],
  [321, 1.74],
  [322, 1.13],
  [323, 0.47],
  [324, 2.88],
  [325, 1.32],
  [326, 0.94],
  [327, 0.99],
  [328, 2.87],
  [329, 1.28],
  [330, 1.64],
  [331, 1.17],
  [332, 1.94],
  [333, 2.4],
  [334, 1.35],
  [335, 1.17],
  [336, 1.13],
  [337, 0.66],
  [338, 0.97],
  [339, 3.53],
  [340, 1.03],
  [341, 1.09],
  [342, 1.53],
  [343, 1.4],
  [344, 1.3],
  [345, 1.83],
  [346, 0.77],
  [347, 0.64],
  [348, 0.92],
  [349, 0.88],
  [350, 1.13],
  [351, 1.52],
  [352, 1.41],
  [353, 1.96],
  [354, 0.82],
  [355, 1.57],
  [356, 2.28],
  [357, 0.87],
  [358, 1.8],
  [359, 1.31],
  [360, 1.21],
  [361, 1.28],
  [362, 2.62],
  [363, 1.68],
  [364, 1.34],
  [365, 1.01],
  [366, 1.66],
  [367, 1.36],
  [368, 1.01],
  [369, 1.98],
  [370, 1.1],
  [371, 1.21],
  [372, 0.94],
  [373, 0.91],
  [374, 1.23],
  [375, 0.96],
  [376, 1.62],
  [377, 0.84],
  [378, 1.2],
  [379, 1.82],
  [380, 1.12],
  [381, 1.05],
  [382, 1.1],
  [383, 1.19],
  [384, 0.97],
  [385, 1.06],
  [386, 0.88],
  [387, 1.57],
  [388, 1.63],
  [389, 1.71],
  [390, 1.7],
  [391, 1.73],
  [392, 0.64],
  [393, 1.04],
  [394, 1.08],
  [395, 0.95],
  [396, 5.05],
  [397, 0.4],
  [398, 0.14],
  [399, 1],
  [400, 1.73],
  [401, 1.81],
  [402, 1.65],
  [403, 1.26],
  [404, 1.81],
  [405, 1.84],
  [406, 0.76],
  [407, 1.32],
  [408, 1.15],
  [409, 1.77],
  [410, 1.88],
  [411, 1.79],
  [412, 2.42],
  [413, 1],
  [414, 0.44],
  [415, 0.42],
  [416, 0.47],
  [417, 1],
  [418, 3.25],
  [419, 0.75],
  [420, 1.62],
  [421, 2.01],
  [422, 4.98],
  [423, 5.74],
  [424, 1.2],
  [425, 1.82],
  [426, 2.04],
  [427, 4.26],
  [428, 3.92],
  [429, 3.43],
  [430, 6],
  [431, 6.06],
  [432, 2.37],
  [433, 1.94],
  [434, 0.41],
  [435, 3.02],
  [436, 1.24],
  [437, 1],
  [438, 1.13],
  [439, 1.24],
  [440, 5.35],
  [441, 1.16],
  [442, 3.61],
  [443, 1.37],
  [444, 1.32],
  [445, 1],
  [446, 2.78],
  [447, 1.73],
  [448, 0.68],
  [449, 1.46],
  [450, 1.54],
  [451, 0.91],
  [452, 1.97],
  [453, 1.44],
  [454, 1.48],
  [455, 1.62],
  [456, 1.75],
  [457, 1.66],
  [458, 0.17],
  [459, 0.88],
  [460, 4.21],
  [461, 0.71],
  [462, 0.58],
  [463, 0.81],
  [464, 0.46],
  [465, 1.34],
  [466, 0.24],
  [467, 0.32],
  [468, 1.42],
  [469, 0.26],
  [470, 2.19],
  [471, 1.12],
  [472, 7.99],
  [473, 5.25],
  [474, 1.81],
  [475, 7.98],
  [476, 7.65],
  [477, 2],
  [478, 0.39],
  [479, 0.65],
  [480, 10.16],
  [481, 1.68],
  [482, 1.7],
  [483, 2.92],
  [484, 1.35],
  [485, 0.31],
  [486, 4.1],
  [487, 0.45],
  [488, 5.56],
  [489, 5.53],
  [490, 2.17],
  [491, 0.61],
  [492, 0.42],
  [493, 0.68],
  [494, 0.5],
  [495, 0.81],
  [496, 1.4],
  [497, 0.89],
  [498, 1.24],
  [499, 0.2],
  [500, 0.43],
  [501, 0.7],
  [503, 0.5],
  [504, 2.77],
  [505, 4.82],
  [506, 0.82],
  [507, 0.43],
  [508, 0.5],
  [509, 0.35],
  [510, 0.26],
  [511, 1.33],
  [512, 0.96],
  [513, 1.05],
  [514, 1.82],
  [515, 1.23],
  [516, 0.91],
  [517, 1.2],
  [518, 1.12],
  [519, 1.21],
  [520, 0.88],
  [521, 0.84],
  [522, 1.73],
  [523, 1.01],
  [524, 1.62],
  [525, 0.66],
  [526, 1.1],
  [527, 0.94],
  [528, 1.06],
  [529, 1.19],
  [530, 1.1],
  [531, 0.97],
  [532, 0.92],
  [533, 0.88],
  [534, 1.79],
  [535, 8.18],
  [536, 0.75],
  [537, 1.77],
  [538, 0.74],
  [539, 0.7],
  [540, 0.8],
  [541, 4.01],
  [542, 3.84],
  [543, 9.75],
  [544, 1.45],
  [545, 6.63],
  [546, 5.38],
  [547, 1.71],
  [548, 4.14],
  [549, 1.14],
  [550, 0.9],
  [551, 2.43],
  [552, 2.5],
  [553, 48.54],
  [554, 3.75],
  [555, 4.99],
  [556, 2.42],
  [557, 1.62],
  [558, 16],
  [559, 2.62],
  [560, 2.67],
  [561, 2.03],
  [562, 1.33],
  [563, 2.67],
  [564, 4],
  [565, 1.33],
  [566, 0.89],
  [567, 1.76],
  [568, 2.16],
  [569, 1.61],
  [570, 2.84],
  [571, 0.82],
  [572, 0.69],
  [573, 0.52],
  [574, 1.28],
  [575, 2.94],
  [576, 3.02],
  [577, 2.97],
  [578, 5.68],
  [579, 0.84],
  [580, 3.77],
  [581, 0.89],
  [582, 1.95],
  [583, 1.59],
  [584, 0.88],
  [585, 1.21],
  [586, 0.92],
  [587, 1],
  [588, 1.2],
  [589, 1.42],
  [590, 1.48],
  [591, 0.98],
  [592, 5.5],
  [593, 4],
  [594, 2.5],
  [595, 0.35],
  [596, 3.81],
  [597, 3.81],
  [602, 0.79],
  [603, 0.98],
  [604, 2.17],
  [605, 0.4],
  [606, 0.84],
  [607, 0.27],
  [608, 1.99],
  [609, 1.45],
  [610, 1.63],
  [611, 1.87],
  [612, 4.46],
  [613, 0.88],
  [614, 0.89],
  [615, 3.05],
  [616, 3.12],
  [617, 1.71],
  [618, 2.77],
  [619, 3.25],
  [620, 1.03],
  [621, 0.98],
  [622, 0.73],
  [623, 1.4],
  [624, 2.75],
  [625, 2.14],
  [626, 0.98],
  [627, 0.58],
  [628, 1.98],
  [629, 2.28],
  [630, 1.54],
  [631, 1.16],
  [632, 0.81],
  [633, 0.99],
  [634, 0.69],
  [635, 1.39],
  [636, 2.22],
  [637, 1.45],
  [638, 1.13],
  [639, 1.41],
  [640, 6.31],
  [641, 1.01],
  [642, 0.5],
  [643, 0.89],
  [644, 1.62],
  [645, 2.56],
  [646, 1.26],
  [647, 1.9],
  [648, 2.16],
  [649, 2.55],
  [650, 1.14],
  [651, 1.49],
  [652, 1.27],
  [653, 2.39],
  [654, 1.34],
  [655, 2.09],
  [656, 0.74],
  [657, 0.87],
  [658, 5.87],
  [659, 1.03],
  [660, 0.75],
  [661, 0.7],
  [662, 1.83],
  [663, 1.81],
  [664, 1.86],
  [665, 1.14],
  [666, 1.88],
  [667, 1.96],
  [668, 1.26],
  [669, 0.7],
  [670, 0.64],
  [671, 0.95],
  [672, 1.41],
  [673, 1.29],
  [674, 1.72],
  [675, 2.18],
  [676, 0.79],
  [677, 2.9],
  [678, 1.31],
  [679, 1.58],
  [680, 1.24],
  [681, 2.07],
  [682, 1.24],
  [683, 1.96],
  [684, 0.85],
  [685, 0.75],
  [686, 1.84],
  [687, 2.3],
  [688, 1.05],
  [689, 1.71],
  [690, 1.88],
  [691, 3.68],
  [692, 1.42],
  [693, 0.85],
  [694, 0.79],
  [695, 0.78],
  [696, 1.92],
  [697, 0.84],
  [698, 2.94],
  [699, 3.32],
  [700, 1.64],
  [701, 1.36],
  [702, 6.13],
  [703, 1],
  [704, 2.34],
  [705, 8.14],
  [706, 1.82],
  [707, 3.88],
  [708, 3.03],
  [709, 2.88],
  [710, 2.5],
  [711, 5.17],
  [712, 2.15],
  [713, 3.29],
  [714, 3.58],
  [715, 1.92],
  [716, 3.35],
  [717, 14.86],
  [719, 2.82],
  [720, 3.84],
  [721, 1.35],
  [722, 1.75],
  [723, 1.5],
  [724, 1.7],
  [725, 1.48],
  [726, 1.97],
  [727, 7.81],
  [728, 6.88],
  [729, 6.23],
  [730, 6.88],
  [731, 0.83],
  [732, 5.25],
  [733, 2.09],
  [734, 1.47],
  [735, 1.91],
  [736, 2.28],
  [737, 1.65],
  [738, 1.62],
  [739, 1.96],
  [740, 1.47],
  [741, 1.6],
  [742, 1.55],
  [743, 2.13],
  [744, 2.82],
  [745, 2.11],
  [746, 2.05],
  [747, 1.8],
  [748, 1.91],
  [749, 2.52],
  [750, 1.81],
  [751, 2.05],
  [752, 1.94],
  [753, 2.28],
  [754, 2.75],
  [755, 2.56],
  [756, 2.05],
  [757, 2.41],
  [758, 1.82],
  [759, 2.78],
  [760, 1.75],
  [761, 1.5],
  [762, 2.57],
  [763, 1.9],
  [764, 3.63],
  [765, 1.24],
  [766, 1.47],
  [767, 2.26],
  [768, 2.34],
  [769, 1.91],
  [770, 1.94],
  [771, 2.04],
  [772, 1.47],
  [773, 2.47],
  [774, 1.19],
  [775, 2.18],
  [776, 1.28],
  [777, 1.96],
  [778, 1.05],
  [779, 1.62],
  [780, 2.75],
  [781, 2.02],
  [782, 1.67],
  [783, 2.92],
  [784, 2.9],
  [785, 1.98],
  [786, 2.94],
  [787, 2.84],
  [788, 1.01],
  [789, 1.89],
  [790, 2.15],
  [791, 1.04],
  [792, 2.26],
  [793, 3.01],
  [794, 1.76],
  [795, 2],
  [796, 1.94],
  [797, 2.92],
  [798, 1.96],
  [799, 2.24],
  [800, 2.5],
  [801, 3.15],
  [802, 1.71],
  [803, 0.81],
  [804, 0.9],
  [805, 3.56],
  [806, 0.98],
  [807, 2.2],
  [808, 2.01],
  [809, 2.62],
  [810, 1.37],
  [811, 0.79],
  [812, 5.72],
  [813, 1.03],
  [814, 0.9],
  [815, 2.28],
  [816, 1.77],
  [817, 1.22],
]);

/**
 * Get the length of a non-modded sound effect in seconds, to 2 decimal places. If a sound effect
 * enum has multiple sounds attached to it, will return the length of the first one.
 */
export function getSoundEffectLength(
  soundEffect: SoundEffect,
  pitch = 1,
): number | undefined {
  const length = SOUND_LENGTHS_MAP.get(soundEffect as number);
  if (length === undefined) {
    error(`Sound effect ${soundEffect} length not found`);
  }
  return length / pitch;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\JERUSALEMData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const JERUSALEMData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_MYDOOM.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\modeInitMap.ts`:

```````ts
import { Mode } from "../../enums/modes/Mode";
import {
  battleyeModeFin,
  battleyeModeSetup,
} from "../../features/modes/BATTLEYE/BATTLEYE";
import {
  cryptolockerModeFin,
  cryptolockerModeSetup,
} from "../../features/modes/CRYPTOLOCKER/CRYPTOLOCKER";
import {
  happy99ModeFin,
  happy99ModeSetup,
} from "../../features/modes/HAPPY99/HAPPY99";
import {
  hicurdismosModeFin,
  hicurdismosModeSetup,
} from "../../features/modes/HICURDISMOS/HICURDISMOS";
import {
  iLoveYouModeFin,
  iLoveYouModeSetup,
} from "../../features/modes/ILOVEYOU/ILOVEYOU";
import {
  jerusalemModeFin,
  jerusalemModeSetup,
} from "../../features/modes/JERUSALEM/JERUSALEM";
import { memzModeFin, memzModeInit } from "../../features/modes/MEMZ/MEMZ";
import {
  morrisModeFin,
  morrisModeSetup,
} from "../../features/modes/MORRIS/MORRIS";
import {
  mydoomModeFin,
  mydoomModeSetup,
} from "../../features/modes/MYDOOM/MYDOOM";
import {
  revetonModeFin,
  revetonModeSetup,
} from "../../features/modes/REVETON/REVETON";
import {
  sophosModeFin,
  sophosModeSetup,
} from "../../features/modes/SOPHOS/SOPHOS";
import {
  spywiperModeFin,
  spywiperModeSetup,
} from "../../features/modes/SPYWIPER/SPYWIPER";
import { vcsModeFin, vcsModeSetup } from "../../features/modes/VCS/VCS";
import {
  zipbomberModeFin,
  zipbomberModeSetup,
} from "../../features/modes/ZIPBOMBER/ZIPBOMBER";

/** Maps each Mode type to their respective setup function. */
const MODE_INIT_MAP: ReadonlyMap<Mode, (player: EntityPlayer) => void> =
  new Map([
    [
      Mode.HAPPY99,
      (player: EntityPlayer) => {
        happy99ModeSetup(player);
      },
    ],
    [
      Mode.ILOVEYOU,
      (player: EntityPlayer) => {
        iLoveYouModeSetup(player);
      },
    ],
    [
      Mode.MORRIS,
      (player: EntityPlayer) => {
        morrisModeSetup(player);
      },
    ],
    [
      Mode.ZIPBOMBER,
      (player: EntityPlayer) => {
        zipbomberModeSetup(player);
      },
    ],
    [
      Mode.MYDOOM,
      (player: EntityPlayer) => {
        mydoomModeSetup(player);
      },
    ],
    [
      Mode.CRYPTOLOCKER,
      (player: EntityPlayer) => {
        cryptolockerModeSetup(player);
      },
    ],
    [
      Mode.SPYWIPER,
      (player: EntityPlayer) => {
        spywiperModeSetup(player);
      },
    ],
    [
      Mode.REVETON,
      (player: EntityPlayer) => {
        revetonModeSetup(player);
      },
    ],
    [
      Mode.HICURDISMOS,
      (player: EntityPlayer) => {
        hicurdismosModeSetup(player);
      },
    ],
    [
      Mode.JERUSALEM,
      (player: EntityPlayer) => {
        jerusalemModeSetup(player);
      },
    ],
    [
      Mode.VCS,
      (player: EntityPlayer) => {
        vcsModeSetup(player);
      },
    ],
    [
      Mode.REVETON,
      (player: EntityPlayer) => {
        revetonModeSetup(player);
      },
    ],
    [
      Mode.MEMZ,
      (player: EntityPlayer) => {
        memzModeInit(player);
      },
    ],
    [
      Mode.SOPHOS,
      (player: EntityPlayer) => {
        sophosModeSetup(player);
      },
    ],
    [
      Mode.BATTLEYE,
      (player: EntityPlayer) => {
        battleyeModeSetup(player);
      },
    ],
  ]);

/** Maps each Mode type to their respective finalization function. */
const MODE_FIN_MAP: ReadonlyMap<Mode, (player: EntityPlayer) => void> = new Map(
  [
    [
      Mode.HAPPY99,
      (player: EntityPlayer) => {
        happy99ModeFin(player);
      },
    ],
    [
      Mode.ILOVEYOU,
      (player: EntityPlayer) => {
        iLoveYouModeFin(player);
      },
    ],
    [
      Mode.MORRIS,
      (player: EntityPlayer) => {
        morrisModeFin(player);
      },
    ],
    [
      Mode.ZIPBOMBER,
      (player: EntityPlayer) => {
        zipbomberModeFin(player);
      },
    ],
    [
      Mode.MYDOOM,
      (player: EntityPlayer) => {
        mydoomModeFin(player);
      },
    ],
    [
      Mode.CRYPTOLOCKER,
      (player: EntityPlayer) => {
        cryptolockerModeFin(player);
      },
    ],
    [
      Mode.SPYWIPER,
      (player: EntityPlayer) => {
        spywiperModeFin(player);
      },
    ],
    [
      Mode.REVETON,
      (player: EntityPlayer) => {
        revetonModeFin(player);
      },
    ],
    [
      Mode.HICURDISMOS,
      (player: EntityPlayer) => {
        hicurdismosModeFin(player);
      },
    ],
    [
      Mode.JERUSALEM,
      (player: EntityPlayer) => {
        jerusalemModeFin(player);
      },
    ],
    [
      Mode.VCS,
      (player: EntityPlayer) => {
        vcsModeFin(player);
      },
    ],
    [
      Mode.REVETON,
      (player: EntityPlayer) => {
        revetonModeFin(player);
      },
    ],
    [
      Mode.MEMZ,
      (player: EntityPlayer) => {
        memzModeFin(player);
      },
    ],
    [
      Mode.SOPHOS,
      (player: EntityPlayer) => {
        sophosModeFin(player);
      },
    ],
    [
      Mode.BATTLEYE,
      (player: EntityPlayer) => {
        battleyeModeFin(player);
      },
    ],
  ],
);

/**
 * Returns the modes' initialization function, responsible for setting up the specific mode for the
 * first time.
 */
export function getModeInit(mode: Mode): (player: EntityPlayer) => void {
  const modeInit = MODE_INIT_MAP.get(mode);
  if (modeInit !== undefined) {
    return modeInit;
  }
  error("modeInitMap: Mode init not found!");
}

/**
 * Returns the modes' finalization function, responsible for handling any necessary closing features
 * once the mode is swapped out of.
 */
export function getModeFin(mode: Mode): (player: EntityPlayer) => void {
  const modeFin = MODE_FIN_MAP.get(mode);
  if (modeFin !== undefined) {
    return modeFin;
  }
  error("modeInitMap: Mode init not found!");
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\modeMap.ts`:

```````ts
import type { PlayerType, SoundEffect } from "isaac-typescript-definitions";
import { PlayerTypeCustom } from "../../enums/general/PlayerTypeCustom";
import { SoundEffectCustom } from "../../enums/general/SoundEffectCustom";
import { Mode } from "../../enums/modes/Mode";
import { fprint } from "../../helper/printHelper";
import type { ModeData } from "../../interfaces/modes/ModeData";
import { BATTLEYEData } from "../../objects/modes/BATTLEYEData";
import { CRYPTOLOCKERData } from "../../objects/modes/CRYPTOLOCKERData";
import { HAPPY99Data } from "../../objects/modes/HAPPY99Data";
import { HICURDISMOSData } from "../../objects/modes/HICURDISMOSData";
import { ILOVEYOUData } from "../../objects/modes/ILOVEYOUData";
import { JERUSALEMData } from "../../objects/modes/JERUSALEMData";
import { MEMZData } from "../../objects/modes/MEMZData";
import { MORRISData } from "../../objects/modes/MORRISData";
import { MYDOOMData } from "../../objects/modes/MYDOOMData";
import { REVETONData } from "../../objects/modes/REVETONData";
import { SOPHOSData } from "../../objects/modes/SOPHOSData";
import { SPYWIPERData } from "../../objects/modes/SPYWIPERData";
import { VCSData } from "../../objects/modes/VCSData";
import { ZIPBOMBERData } from "../../objects/modes/ZIPBOMBERData";

/** Maps each Mode type to their respective data object. */
export const MODE_DATA_MAP: ReadonlyMap<Mode, ModeData> = new Map([
  [Mode.HAPPY99, HAPPY99Data],
  [Mode.ILOVEYOU, ILOVEYOUData],
  [Mode.MORRIS, MORRISData],
  [Mode.ZIPBOMBER, ZIPBOMBERData],
  [Mode.MYDOOM, MYDOOMData],
  [Mode.SOPHOS, SOPHOSData],
  [Mode.BATTLEYE, BATTLEYEData],
  [Mode.CRYPTOLOCKER, CRYPTOLOCKERData],
  [Mode.SPYWIPER, SPYWIPERData],
  [Mode.JERUSALEM, JERUSALEMData],
  [Mode.HICURDISMOS, HICURDISMOSData],
  [Mode.VCS, VCSData],
  [Mode.MEMZ, MEMZData],
  [Mode.MYDOOM, MYDOOMData],
  [Mode.REVETON, REVETONData],
]);

/** Maps each mode to their respective PlayerType. */
export const MODE_PLAYERTYPE_MAP: ReadonlyMap<Mode, PlayerType> = new Map([
  [Mode.HAPPY99, PlayerTypeCustom.DELETED_HAPPY99],
  [Mode.ILOVEYOU, PlayerTypeCustom.DELETED_ILOVEYOU],
  [Mode.MORRIS, PlayerTypeCustom.DELETED_MORRIS],
  [Mode.ZIPBOMBER, PlayerTypeCustom.DELETED_ZIPBOMBER],
  [Mode.CRYPTOLOCKER, PlayerTypeCustom.DELETED_CRYPTOLOCKER],
  [Mode.SPYWIPER, PlayerTypeCustom.DELETED_SPYWIPER],
  [Mode.JERUSALEM, PlayerTypeCustom.DELETED_JERUSALEM],
  [Mode.HICURDISMOS, PlayerTypeCustom.DELETED_HICURDISMOS],
  [Mode.MYDOOM, PlayerTypeCustom.DELETED_MYDOOM],
  [Mode.VCS, PlayerTypeCustom.DELETED_VCS],
  [Mode.MEMZ, PlayerTypeCustom.DELETED_MEMZ],
  [Mode.REVETON, PlayerTypeCustom.DELETED_REVETON],
  [Mode.SOPHOS, PlayerTypeCustom.T_DELETED_SOPHOS],
  [Mode.BATTLEYE, PlayerTypeCustom.T_DELETED_BATTLEYE],
]);

/** Maps each PlayerType to their respective Mode. */
export const PLAYERTYPE_MODE_MAP: ReadonlyMap<PlayerType, Mode> = new Map([
  [PlayerTypeCustom.DELETED_HAPPY99, Mode.HAPPY99],
  [PlayerTypeCustom.DELETED_ILOVEYOU, Mode.ILOVEYOU],
  [PlayerTypeCustom.DELETED_MORRIS, Mode.MORRIS],
  [PlayerTypeCustom.DELETED_ZIPBOMBER, Mode.ZIPBOMBER],
  [PlayerTypeCustom.DELETED_CRYPTOLOCKER, Mode.CRYPTOLOCKER],
  [PlayerTypeCustom.DELETED_SPYWIPER, Mode.SPYWIPER],
  [PlayerTypeCustom.DELETED_JERUSALEM, Mode.JERUSALEM],
  [PlayerTypeCustom.DELETED_HICURDISMOS, Mode.HICURDISMOS],
  [PlayerTypeCustom.DELETED_VCS, Mode.VCS],
  [PlayerTypeCustom.DELETED_MEMZ, Mode.MEMZ],
  [PlayerTypeCustom.DELETED_REVETON, Mode.REVETON],
  [PlayerTypeCustom.DELETED_MYDOOM, Mode.MYDOOM],
  [PlayerTypeCustom.T_DELETED_SOPHOS, Mode.SOPHOS],
  [PlayerTypeCustom.T_DELETED_BATTLEYE, Mode.BATTLEYE],
]);

export const MODE_VOICEOVER_MAP: ReadonlyMap<Mode, SoundEffect> = new Map([
  [Mode.HAPPY99, SoundEffectCustom.VO_HAPPY99],
  [Mode.ILOVEYOU, SoundEffectCustom.VO_ILOVEYOU],
  [Mode.MORRIS, SoundEffectCustom.VO_MORRIS],
  [Mode.ZIPBOMBER, SoundEffectCustom.VO_ZIPBOMBER],
  [Mode.CRYPTOLOCKER, SoundEffectCustom.VO_CRYPTOLOCKER],
  [Mode.SPYWIPER, SoundEffectCustom.VO_SPYWIPER],
  [Mode.JERUSALEM, SoundEffectCustom.VO_JERUSALEM],
  [Mode.HICURDISMOS, SoundEffectCustom.VO_HICURDISMOS],
  [Mode.MYDOOM, SoundEffectCustom.VO_MYDOOM],
  [Mode.VCS, SoundEffectCustom.VO_VCS],
  [Mode.MEMZ, SoundEffectCustom.VO_MEMZ],
  [Mode.REVETON, SoundEffectCustom.VO_REVETON],
]);

/** Retrieve a Mode's ModeData. */
export function getModeData(mode: Mode): ModeData {
  const modeData = MODE_DATA_MAP.get(mode);
  if (modeData !== undefined) {
    return modeData;
  }
  error(`Mode data for mode ${mode} does not exist!`);
}

/** Retrieve a Mode's PlayerType. */
export function getModePlayerType(mode: Mode): PlayerType {
  const playerType = MODE_PLAYERTYPE_MAP.get(mode);
  if (playerType !== undefined) {
    return playerType;
  }
  error(`Player type for mode ${mode} does not exist!`);
}

/** Retrieve the mode corresponding to the PlayerType. */
export function getModeFromPlayerType(
  playerType: PlayerType,
): Mode | undefined {
  return PLAYERTYPE_MODE_MAP.get(playerType);
}

/**
 * Retrieve the ModeData from the deleted player. Will error if the passed player is not of type
 * Deleted (tainted or non-tainted).
 */
export function getModeDataFromPlayer(player: EntityPlayer): ModeData {
  const mode = getModeFromPlayerType(player.GetPlayerType());
  if (mode === undefined) {
    error(`Failed to get the mode from the player type (${player.Type})`);
  }
  return getModeData(mode);
}

/** Get the narrators voiceover for the Mode, if it exists. */
export function getModeVoiceover(mode: Mode): SoundEffect | undefined {
  const voiceover = MODE_VOICEOVER_MAP.get(mode);
  if (voiceover !== undefined) {
    return voiceover;
  }
  fprint(`Voiceover for mode ${mode} does not exist!`);
  return undefined;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\MYDOOMData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const MYDOOMData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_MYDOOM.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\SOPHOSData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { CharacterType } from "../../enums/general/CharacterType";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const SOPHOSData: ModeData = {
  description: "This is ILOVEYOU's description",
  birthright: "This is ILOVEYOU's birthright description",
  characterType: CharacterType.TAINTED,
  startingBombs: 0,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 0,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.5],
    [CacheFlag.SPEED, 1.1],
  ]),
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\maps\modes\ZIPBOMBER\extractPickupBurnTimeMap.ts`:

```````ts
import { getEntityID, ReadonlyMap } from "isaacscript-common";
import type { PickupID } from "../../../enums/data/ID/PickupID";

/** Time is in seconds that a pickup takes to 'extract'. */
const EXTRACT_PICKUP_BURN_TIME_MAP = new ReadonlyMap<PickupID, number>([]);

/** The size of the explosion from the pickup when extracted. */
const EXTRACT_PICKUP_EXPLOSION_DMG_MAP = new ReadonlyMap<PickupID, number>([]);

/** Get the amount of seconds a pickup should take to blow up with the Extract item. */
export function getPickupExtractBurnTime(
  pickup: EntityPickup,
): number | undefined {
  return EXTRACT_PICKUP_BURN_TIME_MAP.get(getEntityID(pickup) as PickupID);
}

/** Get the DMG of the explosion from the pickup when extracted. */
export function getPickupExtractExplosionDmg(
  pickup: EntityPickup,
): number | undefined {
  return EXTRACT_PICKUP_EXPLOSION_DMG_MAP.get(getEntityID(pickup) as PickupID);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\mod.ts`:

```````ts
import { CacheFlag, PlayerType } from "isaac-typescript-definitions";
import { ISCFeature, upgradeMod } from "isaacscript-common";
import { MOD_NAME } from "./constants/mod/modConstants";
import { fprint } from "./helper/printHelper";

const modVanilla = RegisterMod(MOD_NAME, 1);
const MOD_FEATURES = [
  ISCFeature.RUN_IN_N_FRAMES,
  ISCFeature.CUSTOM_HOTKEYS,
  ISCFeature.SAVE_DATA_MANAGER,
  ISCFeature.EXTRA_CONSOLE_COMMANDS,
  ISCFeature.FAST_RESET,
  ISCFeature.FADE_IN_REMOVER,
  ISCFeature.GAME_REORDERED_CALLBACKS,
  ISCFeature.PICKUP_INDEX_CREATION,
  ISCFeature.CHARACTER_STATS,
  ISCFeature.MODDED_ELEMENT_DETECTION,
  ISCFeature.MODDED_ELEMENT_SETS,
  ISCFeature.COLLECTIBLE_ITEM_POOL_TYPE,
  ISCFeature.PERSISTENT_ENTITIES,
  ISCFeature.PAUSE,
  ISCFeature.ROOM_HISTORY,
  ISCFeature.DISABLE_INPUTS,
  ISCFeature.PLAYER_COLLECTIBLE_TRACKING,
  ISCFeature.CUSTOM_REVIVE,
] as const;
// export const ItemDisplayLibrary = CCO.ItemDisplay.API;

export const mod = upgradeMod(modVanilla, MOD_FEATURES);
mod.registerCharacterStats(
  PlayerType.ISAAC,
  new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
);

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\BATTLEYEData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { CharacterType } from "../../enums/general/CharacterType";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const BATTLEYEData: ModeData = {
  description: "This is BATTLEYE's description",
  birthright: "This is BATTLEYE's birthright description",
  characterType: CharacterType.TAINTED,
  startingBombs: 0,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 0,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 4.0],
    [CacheFlag.SPEED, 1.1],
    [CacheFlag.FIRE_DELAY, 2.5],
  ]),
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\CRYPTOLOCKERData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const CRYPTOLOCKERData: ModeData = {
  description: "This is CRYPTOLOCKER's description",
  birthright: "This is CRYPTOLOCKER's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.BITFLIP,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_CRYPTOLOCKER.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: false,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\HAPPY99Data.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import type { ModeData } from "../../interfaces/modes/ModeData";

/** Information about HAPPY99. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const HAPPY99Data: ModeData = {
  description: "This is HAPPY99's description",
  birthright: "This is HAPPY99's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.BITFLIP,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 3, // For testing.
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  mainColor: DeletedColor.HAPPY_YELLOW,
  anm2File: "gfx/001.000_player_HAPPY99.anm2",
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_HAPPY_DEFAULT,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\HICURDISMOSData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about HICURDISMOS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const HICURDISMOSData: ModeData = {
  description: "This is HICURDISMOS's description",
  birthright: "This is HICURDISMOS's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.BITFLIP_BLUE,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 0,
    hearts: 0,
    eternalHearts: 0,
    soulHearts: 6,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL, HeartSubType.SOUL, HeartSubType.SOUL],
  },
  mainColor: DeletedColor.WINDOWS_BLUE,
  anm2File: "gfx/001.000_player_HICURDISMOS.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_HICURDISMOS_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\ILOVEYOUData.ts`:

```````ts
import { CacheFlag } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about ILOVEYOU. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const ILOVEYOUData: ModeData = {
  description: "This is ILOVEYOU's description",
  birthright: "This is ILOVEYOU's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.BITFLIP_PINK,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 4,
    hearts: 4,
    eternalHearts: 0,
    soulHearts: 0,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [],
  },
  mainColor: DeletedColor.LOVE_PINK,
  anm2File: "gfx/001.000_player_ILOVEYOU.anm2",
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_ILOVEYOU_DEFAULT,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\JERUSALEMData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import type { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const JERUSALEMData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_JERUSALEM.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\MEMZData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const MEMZData: ModeData = {
  description: "This is ILOVEYOU's description",
  birthright: "This is ILOVEYOU's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.D14,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  mainColor: DeletedColor.WORM_TURQUOISE,
  anm2File: "gfx/001.000_player_MEMZ.anm2",
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MORRIS_DEFAULT,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\MORRISData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const MORRISData: ModeData = {
  description: "This is ILOVEYOU's description",
  birthright: "This is ILOVEYOU's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.D14,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  mainColor: DeletedColor.WORM_TURQUOISE,
  anm2File: "gfx/001.000_player_MORRIS.anm2",
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MORRIS_DEFAULT,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\MYDOOMData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import type { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const MYDOOMData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_MYDOOM.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\REVETONData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const REVETONData: ModeData = {
  description: "This is REVETON's description",
  birthright: "This is REVETON's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  anm2File: "gfx/001.000_player_REVETON.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_REVETON_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\SOPHOSData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { CharacterType } from "../../enums/general/CharacterType";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const SOPHOSData: ModeData = {
  description: "This is ILOVEYOU's description",
  birthright: "This is ILOVEYOU's birthright description",
  characterType: CharacterType.TAINTED,
  startingBombs: 0,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 0,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.5],
    [CacheFlag.SPEED, 1.1],
  ]),
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\SPYWIPERData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const SPYWIPERData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_SPYWIPER.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\VCSData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { InvertedItemActionSetBuilderReference } from "../../enums/corruption/actionSets/ActionSetBuilders";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MYDOOM. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const VCSData: ModeData = {
  description: "This is MYDOOM's description",
  birthright: "This is MYDOOM's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.MYDOOM_EYE_STAGE_3,
  startingBombs: 1,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.BLACK],
  },
  mainColor: DeletedColor.DEATH_BLACK,
  anm2File: "gfx/001.000_player_VCS.anm2",
  itemActionSetBuilderReference:
    InvertedItemActionSetBuilderReference.INVERTED_ITEM_ACTION_SET_MYDOOM_DEFAULT,
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
  startInverted: true,
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\objects\modes\ZIPBOMBERData.ts`:

```````ts
import { CacheFlag, HeartSubType } from "isaac-typescript-definitions";
import { CharacterType } from "../../enums/general/CharacterType";
import { CollectibleTypeCustom } from "../../enums/general/CollectibleTypeCustom";
import { DeletedColor } from "../../enums/general/DeletedColor";
import { ModeData } from "../../interfaces/modes/ModeData";

/** Information about MORRIS. */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const ZIPBOMBERData: ModeData = {
  description: "This is ZIP BOMBER's description",
  birthright: "This is ZIP BOMBER's birthright description",
  characterType: CharacterType.NORMAL,
  startingPocket: CollectibleTypeCustom.EXTRACT,
  startingBombs: 13,
  startingKeys: 0,
  startingCoins: 0,
  startingHealth: {
    maxHearts: 2,
    hearts: 2,
    eternalHearts: 0,
    soulHearts: 2,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [HeartSubType.SOUL],
  },
  mainColor: DeletedColor.ANGRY_RED,
  anm2File: "gfx/001.000_player_ZIPBOMBER.anm2",
  characterStats: new Map<CacheFlag, number>([
    [CacheFlag.DAMAGE, 3.4],
    [CacheFlag.SPEED, 0.9],
  ]),
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\data\modded\ModdedFlyingNPCSet.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import { ReadonlySet } from "isaacscript-common";
import { FiendFolioNPCNameSubTypes } from "../../../enums/data/ID/modded/fiendFolio/FiendFolioNPCNameSubTypes";
import { getNameSubTypeFromModdedEntityID } from "../../../maps/data/moddedEntityIDToNameSubType";

const MODDED_FLYING_SET = new ReadonlySet<string>([
  // Fiend Folio.
  FiendFolioNPCNameSubTypes.ALEYA,
  FiendFolioNPCNameSubTypes.ARCHER,
  FiendFolioNPCNameSubTypes.ASTROSKULL,
  FiendFolioNPCNameSubTypes.BABA,
  FiendFolioNPCNameSubTypes.BACKDROP_REPLACER,
  FiendFolioNPCNameSubTypes.BALLGAG_PROJECTILE,
  FiendFolioNPCNameSubTypes.BARO,
  FiendFolioNPCNameSubTypes.BATTIE,
  FiendFolioNPCNameSubTypes.BEACON,
  FiendFolioNPCNameSubTypes.BEAD_FLY,
  FiendFolioNPCNameSubTypes.BEEBEE,
  FiendFolioNPCNameSubTypes.BEETER,
  FiendFolioNPCNameSubTypes.BELLOW,
  FiendFolioNPCNameSubTypes.BENIGN,
  FiendFolioNPCNameSubTypes.BESERKER,
  FiendFolioNPCNameSubTypes.BIG_PIPE,
  FiendFolioNPCNameSubTypes.BLASTCORE,
  FiendFolioNPCNameSubTypes.BLAZER,
  FiendFolioNPCNameSubTypes.BLUE_RAMBLEPOINT,
  FiendFolioNPCNameSubTypes.BOBBY_FLY,
  FiendFolioNPCNameSubTypes.BONE_ROCKET,
  FiendFolioNPCNameSubTypes.BRIAR,
  FiendFolioNPCNameSubTypes.BROOD,
  FiendFolioNPCNameSubTypes.BROOTER,
  FiendFolioNPCNameSubTypes.BUBBLE_TINY,
  FiendFolioNPCNameSubTypes.BUBBLE_BAT,
  FiendFolioNPCNameSubTypes.BUBBLE_BLOWING_DOUBLE_BABY,
  FiendFolioNPCNameSubTypes.BUBBY,
  FiendFolioNPCNameSubTypes.BUCKSHOT,
  FiendFolioNPCNameSubTypes.BUMBLER,
  FiendFolioNPCNameSubTypes.BUNCH,
  FiendFolioNPCNameSubTypes.BURIED_FOSSIL_GRAPHIC,
  FiendFolioNPCNameSubTypes.BUSTER,
  FiendFolioNPCNameSubTypes.BUTT_FLY,
  FiendFolioNPCNameSubTypes.BUTTERY_COMPOST_BIN,
  FiendFolioNPCNameSubTypes.CACAMANCERS_BALL,
  FiendFolioNPCNameSubTypes.CASTED,
  FiendFolioNPCNameSubTypes.CATFISH,
  FiendFolioNPCNameSubTypes.CAULDRON,
  FiendFolioNPCNameSubTypes.CHAMP,
  FiendFolioNPCNameSubTypes.CHERUB,
  FiendFolioNPCNameSubTypes.CHERUBSKULL,
  FiendFolioNPCNameSubTypes.CHOMPY_FLY,
  FiendFolioNPCNameSubTypes.CHORUS,
  FiendFolioNPCNameSubTypes.CHUMMER,
  FiendFolioNPCNameSubTypes.CLERGY,
  FiendFolioNPCNameSubTypes.COLONEL,
  FiendFolioNPCNameSubTypes.COMMISSION,
  FiendFolioNPCNameSubTypes.CONGRESSING_EMMISSION,
  FiendFolioNPCNameSubTypes.CORRUPTED_SUTURE,
  FiendFolioNPCNameSubTypes.CORTEX,
  FiendFolioNPCNameSubTypes.CRACKER,
  FiendFolioNPCNameSubTypes.CRATERFACE,
  FiendFolioNPCNameSubTypes.CRAZY_STONEY_SLAMMER,
  FiendFolioNPCNameSubTypes.CREEPTERUM,
  FiendFolioNPCNameSubTypes.CROSSEYES,
  FiendFolioNPCNameSubTypes.CUFFS,
  FiendFolioNPCNameSubTypes.CUSTOM_MOTER,
  FiendFolioNPCNameSubTypes.DANGEROUS_DISC,
  FiendFolioNPCNameSubTypes.DANGLER,
  FiendFolioNPCNameSubTypes.DEADFLY,
  FiendFolioNPCNameSubTypes.DEATHANY,
  FiendFolioNPCNameSubTypes.DEWDROP,
  FiendFolioNPCNameSubTypes.DIAGETIC,
  FiendFolioNPCNameSubTypes.DIMS_SOUL,
  FiendFolioNPCNameSubTypes.DIZZY,
  FiendFolioNPCNameSubTypes.DOG_DOO_GFX,
  FiendFolioNPCNameSubTypes.DOGMEAT,
  FiendFolioNPCNameSubTypes.DOLPHIN,
  FiendFolioNPCNameSubTypes.DOOM_FLY,
  FiendFolioNPCNameSubTypes.DOOMER,
  FiendFolioNPCNameSubTypes.DOPES_HEAD_PROJECTILE,
  FiendFolioNPCNameSubTypes.DRAINER,
  FiendFolioNPCNameSubTypes.DRAINFLY,
  FiendFolioNPCNameSubTypes.DREAD_MAW,
  FiendFolioNPCNameSubTypes.DREAD_WEAVER,
  FiendFolioNPCNameSubTypes.DROOLER,
  FiendFolioNPCNameSubTypes.DROOLIE,
  FiendFolioNPCNameSubTypes.DUKES_DEMON,
  FiendFolioNPCNameSubTypes.DUNGEON_MASTER,
  FiendFolioNPCNameSubTypes.DUSK,
  FiendFolioNPCNameSubTypes.DUSKS_HAND,
  FiendFolioNPCNameSubTypes.DWELLER_BROTHER,
  FiendFolioNPCNameSubTypes.EFFIGY,
  FiendFolioNPCNameSubTypes.EMMISSION,
  FiendFolioNPCNameSubTypes.EMMISSION_PROJECTILE,
  FiendFolioNPCNameSubTypes.EMPATH,
  FiendFolioNPCNameSubTypes.ETERNAL_FLICKERSPIRIT,
  FiendFolioNPCNameSubTypes.ETERNAL_FLY,
  FiendFolioNPCNameSubTypes.FF_MEMBER_CARD_RELOCATOR,
  FiendFolioNPCNameSubTypes.FERRWAITING,
  FiendFolioNPCNameSubTypes.FIEND_FOLIO_SHOPKEEPER,
  FiendFolioNPCNameSubTypes.FINGORES_SCRUPULATOR,
  FiendFolioNPCNameSubTypes.FIRESWIRL,
  FiendFolioNPCNameSubTypes.FLAGPOLE,
  FiendFolioNPCNameSubTypes.FLAMIN,
  FiendFolioNPCNameSubTypes.FLAMIN_CHAIN,
  FiendFolioNPCNameSubTypes.FLESH_SISTREN,
  FiendFolioNPCNameSubTypes.FLICKERSPIRIT,
  FiendFolioNPCNameSubTypes.FLINTY,
  FiendFolioNPCNameSubTypes.FLY_BUNDLE,
  FiendFolioNPCNameSubTypes.FOAMY,
  FiendFolioNPCNameSubTypes.FOE,
  FiendFolioNPCNameSubTypes.FORESEER,
  FiendFolioNPCNameSubTypes.FOSSIL,
  FiendFolioNPCNameSubTypes.FOSSILIZED_BOOM_FLY,
  FiendFolioNPCNameSubTypes.FOUNT,
  FiendFolioNPCNameSubTypes.FROG,
  FiendFolioNPCNameSubTypes.FUMEGEIST,
  FiendFolioNPCNameSubTypes.FURNACE,
  FiendFolioNPCNameSubTypes.GANDER,
  FiendFolioNPCNameSubTypes.GHOSTBUSTER,
  FiendFolioNPCNameSubTypes.GHOSTBUSTER_DEATH_HITBOX,
  FiendFolioNPCNameSubTypes.GHOSTSE,
  FiendFolioNPCNameSubTypes.GHOSTSE_EASY_MODE,
  FiendFolioNPCNameSubTypes.GLEEK,
  FiendFolioNPCNameSubTypes.GNAWFUL,
  FiendFolioNPCNameSubTypes.GOLDEN_BOOM_FLY,
  FiendFolioNPCNameSubTypes.GOLDEN_FLY_BOMB,
  FiendFolioNPCNameSubTypes.GOLDEN_MIGHTFLY,
  FiendFolioNPCNameSubTypes.GRAVEDIGGER,
  FiendFolioNPCNameSubTypes.GRIMOIRE,
  FiendFolioNPCNameSubTypes.GRITTY,
  FiendFolioNPCNameSubTypes.GUNK,
  FiendFolioNPCNameSubTypes.HANGMAN,
  FiendFolioNPCNameSubTypes.HARLETWIN,
  FiendFolioNPCNameSubTypes.HARLEY,
  FiendFolioNPCNameSubTypes.HEAD_HONCHO,
  FiendFolioNPCNameSubTypes.HERMIT,
  FiendFolioNPCNameSubTypes.HITCHERS_PITCHFORK,
  FiendFolioNPCNameSubTypes.HOLY_WOBBLES,
  FiendFolioNPCNameSubTypes.HOMER,
  FiendFolioNPCNameSubTypes.HONEY_EYE,
  FiendFolioNPCNameSubTypes.HONEYDRIP,
  FiendFolioNPCNameSubTypes.HORSE_PROJECTILE,
  FiendFolioNPCNameSubTypes.HOVER,
  FiendFolioNPCNameSubTypes.ICE_HAZARD_MORSELS,
  FiendFolioNPCNameSubTypes.ICE_HAZARD_SLAMMER,
  FiendFolioNPCNameSubTypes.ICKY_FLY,
  FiendFolioNPCNameSubTypes.IGNIS,
  FiendFolioNPCNameSubTypes.IMMURAL,
  FiendFolioNPCNameSubTypes.INCISOR,
  FiendFolioNPCNameSubTypes.JAWBONE,
  FiendFolioNPCNameSubTypes.KUKODEMON,
  FiendFolioNPCNameSubTypes.LIGHTNING_FLY,
  FiendFolioNPCNameSubTypes.LIL_JON,
  FiendFolioNPCNameSubTypes.LIL_JUNKIE,
  FiendFolioNPCNameSubTypes.LITTLE_JOHN,
  FiendFolioNPCNameSubTypes.LITTLE_JOHN_POINT,
  FiendFolioNPCNameSubTypes.LOOKSEE,
  FiendFolioNPCNameSubTypes.LURCH,
  FiendFolioNPCNameSubTypes.LURCH_GUT_TIP,
  FiendFolioNPCNameSubTypes.LURKER,
  FiendFolioNPCNameSubTypes.LURKER_BRAIN,
  FiendFolioNPCNameSubTypes.LURKER_BRIDGE_PROJECTILE,
  FiendFolioNPCNameSubTypes.LURKER_COLLIDER,
  FiendFolioNPCNameSubTypes.LURKER_CORE,
  FiendFolioNPCNameSubTypes.LURKER_PSEUDO_DEFAULT_SEGMENT,
  FiendFolioNPCNameSubTypes.LURKER_STOMA,
  FiendFolioNPCNameSubTypes.LURKER_STRETCH,
  FiendFolioNPCNameSubTypes.LURKER_STRETCH_COLLIDER,
  FiendFolioNPCNameSubTypes.LURKER_TOOTH,
  FiendFolioNPCNameSubTypes.MADHAT,
  FiendFolioNPCNameSubTypes.MADOMMES_SKULL,
  FiendFolioNPCNameSubTypes.MAGNIFIER,
  FiendFolioNPCNameSubTypes.MANIC_FLY,
  FiendFolioNPCNameSubTypes.MARZLAMMER,
  FiendFolioNPCNameSubTypes.MASTER_ATOM,
  FiendFolioNPCNameSubTypes.MAW_MR,
  FiendFolioNPCNameSubTypes.MAYFLY,
  FiendFolioNPCNameSubTypes.MEGA_HAEMOLACRIA_PROJECTILE,
  FiendFolioNPCNameSubTypes.MENACE,
  FiendFolioNPCNameSubTypes.MIGHTFLY,
  FiendFolioNPCNameSubTypes.MILK_TOOTH,
  FiendFolioNPCNameSubTypes.MINAMITSU_MURASA,
  FiendFolioNPCNameSubTypes.MINIMOON,
  FiendFolioNPCNameSubTypes.MOANER,
  FiendFolioNPCNameSubTypes.MOLAR_ORBITAL,
  FiendFolioNPCNameSubTypes.MOLAR_SYSTEM,
  FiendFolioNPCNameSubTypes.MOLD,
  FiendFolioNPCNameSubTypes.MOTE,
  FiendFolioNPCNameSubTypes.MOTHER_ORB,
  FiendFolioNPCNameSubTypes.MR_DEAD,
  FiendFolioNPCNameSubTypes.MR_DEADS_EYE,
  FiendFolioNPCNameSubTypes.MURASAS_ANCHOR,
  FiendFolioNPCNameSubTypes.MURMUR,
  FiendFolioNPCNameSubTypes.MUSK,
  FiendFolioNPCNameSubTypes.MYIASIS,
  FiendFolioNPCNameSubTypes.MYIASIS_PROJECTILE,
  FiendFolioNPCNameSubTypes.NEONATE,
  FiendFolioNPCNameSubTypes.NERVIE_POINT,
  FiendFolioNPCNameSubTypes.NIGHT_TERRORS,
  FiendFolioNPCNameSubTypes.NIMBUS_CLOUD,
  FiendFolioNPCNameSubTypes.NUCHAL,
  FiendFolioNPCNameSubTypes.NUCHAL_CORD,
  FiendFolioNPCNameSubTypes.OBSERVER,
  FiendFolioNPCNameSubTypes.ONLOOKER,
  FiendFolioNPCNameSubTypes.ONLYFAN,
  FiendFolioNPCNameSubTypes.PEEKABOO,
  FiendFolioNPCNameSubTypes.PEEPLING,
  FiendFolioNPCNameSubTypes.PHOENIX,
  FiendFolioNPCNameSubTypes.PILLAR_JOHN,
  FiendFolioNPCNameSubTypes.PILLAR_JOHN_QUAKE,
  FiendFolioNPCNameSubTypes.PITCHFORK_HITCHER,
  FiendFolioNPCNameSubTypes.POISON_CLOUD_MAKER,
  FiendFolioNPCNameSubTypes.POOBOTTLE,
  FiendFolioNPCNameSubTypes.POTLUCK,
  FiendFolioNPCNameSubTypes.PRIMEMIND,
  FiendFolioNPCNameSubTypes.PSILING,
  FiendFolioNPCNameSubTypes.PSION,
  FiendFolioNPCNameSubTypes.PSLEECH,
  FiendFolioNPCNameSubTypes.PSYCHO_FLY,
  FiendFolioNPCNameSubTypes.PUNK,
  FiendFolioNPCNameSubTypes.PUNTED,
  FiendFolioNPCNameSubTypes.PYROCLASM,
  FiendFolioNPCNameSubTypes.QUAKER,
  FiendFolioNPCNameSubTypes.RANCOR,
  FiendFolioNPCNameSubTypes.REAPER,
  FiendFolioNPCNameSubTypes.RED_KEY_FIEND,
  FiendFolioNPCNameSubTypes.RED_RAMBLEPOINT,
  FiendFolioNPCNameSubTypes.REHEATED_FLY,
  FiendFolioNPCNameSubTypes.RESIDUUM,
  FiendFolioNPCNameSubTypes.RIBBONE,
  FiendFolioNPCNameSubTypes.RIBEYE,
  FiendFolioNPCNameSubTypes.RING_LEADER,
  FiendFolioNPCNameSubTypes.RING_OF_RING_FLIES,
  FiendFolioNPCNameSubTypes.RIPCORD,
  FiendFolioNPCNameSubTypes.ROASTY,
  FiendFolioNPCNameSubTypes.ROTSPIN_MOON,
  FiendFolioNPCNameSubTypes.SEPTIC,
  FiendFolioNPCNameSubTypes.SMORE,
  FiendFolioNPCNameSubTypes.SACKY_FLY,
  FiendFolioNPCNameSubTypes.SAGGING_SPIT,
  FiendFolioNPCNameSubTypes.SAGGING_SUCKER,
  FiendFolioNPCNameSubTypes.SCREW_PROJECTILE,
  FiendFolioNPCNameSubTypes.SCYTHE_RIDER,
  FiendFolioNPCNameSubTypes.SENSORY_GRIMACE,
  FiendFolioNPCNameSubTypes.SENTRY,
  FiendFolioNPCNameSubTypes.SEPTIC_GHOSTSE,
  FiendFolioNPCNameSubTypes.SEPTIC_PIPE,
  FiendFolioNPCNameSubTypes.SEWER_PIPE,
  FiendFolioNPCNameSubTypes.SHAKER,
  FiendFolioNPCNameSubTypes.SHI,
  FiendFolioNPCNameSubTypes.SHINE_SPIT,
  FiendFolioNPCNameSubTypes.SHIRK_SPOT,
  FiendFolioNPCNameSubTypes.SHOCK_COLLAR,
  FiendFolioNPCNameSubTypes.SHOT_FLY,
  FiendFolioNPCNameSubTypes.SHOTER,
  FiendFolioNPCNameSubTypes.SHRUNKEN_HEAD,
  FiendFolioNPCNameSubTypes.SIZZLE,
  FiendFolioNPCNameSubTypes.SKULLTIST,
  FiendFolioNPCNameSubTypes.SLAMMER,
  FiendFolioNPCNameSubTypes.SLINGER_HEAD,
  FiendFolioNPCNameSubTypes.SLUDGE_PIPE,
  FiendFolioNPCNameSubTypes.SMASHER,
  FiendFolioNPCNameSubTypes.SMOKIN,
  FiendFolioNPCNameSubTypes.SNAGGER,
  FiendFolioNPCNameSubTypes.SPECTURN,
  FiendFolioNPCNameSubTypes.SPELEO,
  FiendFolioNPCNameSubTypes.SPHINCTER,
  FiendFolioNPCNameSubTypes.SPINNING_BLOOD_CELL,
  FiendFolioNPCNameSubTypes.SPINNY,
  FiendFolioNPCNameSubTypes.SPITFIRE,
  FiendFolioNPCNameSubTypes.SPITROAST,
  FiendFolioNPCNameSubTypes.SPLIT_PIPE,
  FiendFolioNPCNameSubTypes.SPONGE,
  FiendFolioNPCNameSubTypes.SPOOP,
  FiendFolioNPCNameSubTypes.SPORE_PROJECTILE,
  FiendFolioNPCNameSubTypes.SQUARE_FLY,
  FiendFolioNPCNameSubTypes.SQUID,
  FiendFolioNPCNameSubTypes.STERALIS,
  FiendFolioNPCNameSubTypes.STINGLER,
  FiendFolioNPCNameSubTypes.STOMPY,
  FiendFolioNPCNameSubTypes.STONEY_SLAMMER,
  FiendFolioNPCNameSubTypes.SUPER_GRIMACE,
  FiendFolioNPCNameSubTypes.SUPER_TNT,
  FiendFolioNPCNameSubTypes.TAGBAG,
  FiendFolioNPCNameSubTypes.TANGO,
  FiendFolioNPCNameSubTypes.TAP,
  FiendFolioNPCNameSubTypes.TECHNICIAN,
  FiendFolioNPCNameSubTypes.THE_BINDING_OF_ISAAC_REHEATED,
  FiendFolioNPCNameSubTypes.THE_FREEZER,
  FiendFolioNPCNameSubTypes.THE_WHISPERS,
  FiendFolioNPCNameSubTypes.THOUSAND_EYES,
  FiendFolioNPCNameSubTypes.THRALL,
  FiendFolioNPCNameSubTypes.THREAD,
  FiendFolioNPCNameSubTypes.THUMBS_UP_FLY,
  FiendFolioNPCNameSubTypes.THWAMMY,
  FiendFolioNPCNameSubTypes.TICKING_FLY,
  FiendFolioNPCNameSubTypes.TITTLE,
  FiendFolioNPCNameSubTypes.TRAILBLAZER,
  FiendFolioNPCNameSubTypes.TRICKLE_FLYING,
  FiendFolioNPCNameSubTypes.TRICKO,
  FiendFolioNPCNameSubTypes.ULTIMATE_SMOKIN,
  FiendFolioNPCNameSubTypes.UNPAWTUNATE,
  FiendFolioNPCNameSubTypes.UNPAWTUNATE_SKULL,
  FiendFolioNPCNameSubTypes.UTERO_PILLAR,
  FiendFolioNPCNameSubTypes.VISCERSPIRIT,
  FiendFolioNPCNameSubTypes.VOLT,
  FiendFolioNPCNameSubTypes.WARBLE,
  FiendFolioNPCNameSubTypes.WARDEN,
  FiendFolioNPCNameSubTypes.WARHEAD,
  FiendFolioNPCNameSubTypes.WARP_ZONE,
  FiendFolioNPCNameSubTypes.WEAVER,
  FiendFolioNPCNameSubTypes.WEAVER_SR,
  FiendFolioNPCNameSubTypes.WETSTONE,
  FiendFolioNPCNameSubTypes.WHALE,
  FiendFolioNPCNameSubTypes.WHISPER_MARKER,
  FiendFolioNPCNameSubTypes.WHISPERS_CONTROLLER,
  FiendFolioNPCNameSubTypes.WIMPY,
  FiendFolioNPCNameSubTypes.WOBBLES,
  FiendFolioNPCNameSubTypes.WOMB_PILLAR,
  FiendFolioNPCNameSubTypes.YAWNER,
  FiendFolioNPCNameSubTypes.ZAPBLADDER,
  FiendFolioNPCNameSubTypes.ZEPHYR,
  FiendFolioNPCNameSubTypes.ZINGLING,
  FiendFolioNPCNameSubTypes.ZINGY,
  FiendFolioNPCNameSubTypes.ZTEWIE,
  FiendFolioNPCNameSubTypes.ZTEWIE_STINGER,
  FiendFolioNPCNameSubTypes.BLUE_KEY_FIEND,
  FiendFolioNPCNameSubTypes.BUBBLE_SMALL,
  FiendFolioNPCNameSubTypes.EFFIGY_CORD,
  FiendFolioNPCNameSubTypes.ELITE_JON,
  FiendFolioNPCNameSubTypes.FLAILER_HEAD,
  FiendFolioNPCNameSubTypes.FOETU,
  FiendFolioNPCNameSubTypes.G_HOST_SPIRIT,
  FiendFolioNPCNameSubTypes.GASSY_COMPOST_BIN,
  FiendFolioNPCNameSubTypes.GRAPE,
  FiendFolioNPCNameSubTypes.HARLETWIN_CORD,
  FiendFolioNPCNameSubTypes.HOMING_STINGER_PROJECTILE,
  FiendFolioNPCNameSubTypes.MR_PSYCHIC_MAW_HEAD,
  FiendFolioNPCNameSubTypes.PHOENIX_CORPSE,
  FiendFolioNPCNameSubTypes.ROTSKULL,
  FiendFolioNPCNameSubTypes.SENTRY_SHELL,
  FiendFolioNPCNameSubTypes.THRALL_CORD,
  FiendFolioNPCNameSubTypes.TRAILBLAZER_FLAME_SEGMENT,
  FiendFolioNPCNameSubTypes.BUBBLE_ISOPOLY,
  FiendFolioNPCNameSubTypes.FOETUS_CORD,
  FiendFolioNPCNameSubTypes.WARBLE_TAIL,
  FiendFolioNPCNameSubTypes.PULSE_EFFECT_BIG,
  FiendFolioNPCNameSubTypes.PULSE_EFFECT_SMALL,
  FiendFolioNPCNameSubTypes.BUBBLE_MEDIUM,
  FiendFolioNPCNameSubTypes.GREEN_KEY_FIEND,
  FiendFolioNPCNameSubTypes.PHOENIX_REVIVED,
  FiendFolioNPCNameSubTypes.RETURNING_STINGER_PROJECTILE,
  FiendFolioNPCNameSubTypes.SCENTED_COMPOST_BIN,
  FiendFolioNPCNameSubTypes.RETIRED_COLONEL,
  FiendFolioNPCNameSubTypes.TOMA_CHUNK,
  FiendFolioNPCNameSubTypes.SOUNDMAKER_FLY,
  FiendFolioNPCNameSubTypes.BUBBLE_LARGE,
  FiendFolioNPCNameSubTypes.UNSTABLE_COMPOST_BIN,
  FiendFolioNPCNameSubTypes.TAINTED_SPIT,
  FiendFolioNPCNameSubTypes.ALEYA_FIRE_PLACE,
  FiendFolioNPCNameSubTypes.BUBBLE_FLY,
  FiendFolioNPCNameSubTypes.BUBBLE_SPIDER,
  FiendFolioNPCNameSubTypes.BUBBLE_EXPLOSIVE,
  FiendFolioNPCNameSubTypes.BUBBLE_SMALL_WATERY,
  FiendFolioNPCNameSubTypes.BUBBLE_MEDIUM_WATERY,
  FiendFolioNPCNameSubTypes.BUBBLE_LARGE_WATERY,
]);

export function _isModdedNPCIDFlying(id: EntityID): boolean | undefined {
  const nameSubType = getNameSubTypeFromModdedEntityID(id);
  if (nameSubType === undefined) {
    return undefined;
  }

  return MODDED_FLYING_SET.has(nameSubType);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\data\npc\BossNPCSet.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";

/** Set of non-modded NPCs that are considered bosses. */
const BOSS_NPC_SET: ReadonlySet<NPCID> = new Set([
  NPCID.WIDOW,
  NPCID.WIDOW_BLACK,
  NPCID.WIDOW_PINK,
  NPCID.THE_WRETCHED,
  NPCID.DADDY_LONG_LEGS,
  NPCID.TRIACHNID,
  NPCID.ISAAC,
  NPCID.BLUE_BABY,
  NPCID.BLUE_BABY_HUSH,
  NPCID.LARRY_JR,
  NPCID.LARRY_JR_GREEN,
  NPCID.LARRY_JR_BLUE,
  NPCID.THE_HOLLOW,
  NPCID.THE_HOLLOW_GREEN,
  NPCID.THE_HOLLOW_BLACK,
  NPCID.THE_HOLLOW_YELLOW,
  NPCID.TUFF_TWIN,
  NPCID.THE_SHELL,
  NPCID.MONSTRO,
  NPCID.MONSTRO_RED,
  NPCID.MONSTRO_GREY,
  NPCID.GURGLING_BOSS,
  NPCID.GURGLING_BOSS_YELLOW,
  NPCID.GURGLING_BOSS_BLACK,
  NPCID.TURDLING,
  NPCID.HAUNT,
  NPCID.HAUNT_BLACK,
  NPCID.HAUNT_PINK,
  NPCID.DINGLE,
  NPCID.DINGLE_RED,
  NPCID.DINGLE_BLACK,
  NPCID.DANGLE,
  NPCID.MEGA_MAW,
  NPCID.MEGA_MAW_RED,
  NPCID.MEGA_MAW_BLACK,
  NPCID.THE_GATE,
  NPCID.THE_GATE_RED,
  NPCID.THE_GATE_BLACK,
  NPCID.MEGA_FATTY,
  NPCID.MEGA_FATTY_RED,
  NPCID.MEGA_FATTY_BROWN,
  NPCID.THE_CAGE,
  NPCID.THE_CAGE_GREEN,
  NPCID.THE_CAGE_PINK,
  NPCID.MAMA_GURDY,
  NPCID.MAMA_GURDY_LEFT_HAND,
  NPCID.MAMA_GURDY_RIGHT_HAND,
  NPCID.DARK_ONE,
  NPCID.THE_ADVERSARY,
  NPCID.POLYCEPHALUS,
  NPCID.POLYCEPHALUS_RED,
  NPCID.POLYCEPHALUS_PINK,
  NPCID.THE_PILE,
  NPCID.MR_FRED,
  NPCID.URIEL,
  NPCID.FALLEN_URIEL,
  NPCID.GABRIEL,
  NPCID.FALLEN_GABRIEL,
  NPCID.THE_LAMB,
  NPCID.LAMB_BODY,
  NPCID.MEGA_SATAN,
  NPCID.MEGA_SATANS_RIGHT_HAND,
  NPCID.MEGA_SATANS_LEFT_HAND,
  NPCID.MEGA_SATAN_2,
  NPCID.MEGA_SATAN_2_RIGHT_HAND,
  NPCID.MEGA_SATAN_2_LEFT_HAND,
  NPCID.CHUB,
  NPCID.CHUB_BLUE,
  NPCID.CHUB_ORANGE,
  NPCID.CHAD,
  NPCID.THE_CARRION_QUEEN,
  NPCID.THE_CARRION_QUEEN_PINK,
  NPCID.ULTRA_GREED_DOOR,
  NPCID.GURDY,
  NPCID.GURDY_GREEN,
  NPCID.ULTRA_PRIDE_BABY,
  NPCID.THE_STAIN,
  NPCID.THE_STAIN_GREY,
  NPCID.BROWNIE,
  NPCID.BROWNIE_BLACK,
  NPCID.THE_FORSAKEN,
  NPCID.THE_FORSAKEN_BLACK,
  NPCID.LITTLE_HORN,
  NPCID.LITTLE_HORN_ORANGE,
  NPCID.LITTLE_HORN_BLACK,
  NPCID.RAG_MAN,
  NPCID.RAG_MAN_RED,
  NPCID.RAG_MAN_BLACK,
  NPCID.ULTRA_GREED,
  NPCID.ULTRA_GREEDIER,
  NPCID.HUSH,
  NPCID.HUSH_SKINLESS,
  NPCID.RAG_MEGA,
  NPCID.SISTERS_VIS,
  NPCID.BIG_HORN,
  NPCID.SMALL_HOLE,
  NPCID.BIG_HOLE,
  NPCID.DELIRIUM,
  NPCID.THE_MATRIARCH,
  NPCID.MONSTRO_II,
  NPCID.MONSTRO_II_RED,
  NPCID.GISH,
  NPCID.MOM,
  NPCID.MOM_BLUE,
  NPCID.MOM_RED,
  NPCID.MOM_STOMP,
  NPCID.MOM_STOMP_BLUE,
  NPCID.MOM_STOMP_RED,
  NPCID.SLOTH,
  NPCID.SUPER_SLOTH,
  NPCID.ULTRA_PRIDE,
  NPCID.LUST,
  NPCID.SUPER_LUST,
  NPCID.WRATH,
  NPCID.SUPER_WRATH,
  NPCID.GLUTTONY,
  NPCID.SUPER_GLUTTONY,
  NPCID.GREED,
  NPCID.SUPER_GREED,
  NPCID.ENVY,
  NPCID.SUPER_ENVY,
  NPCID.ENVY_BIG,
  NPCID.SUPER_ENVY_BIG,
  NPCID.ENVY_MEDIUM,
  NPCID.SUPER_ENVY_MEDIUM,
  NPCID.ENVY_SMALL,
  NPCID.SUPER_ENVY_SMALL,
  NPCID.PRIDE,
  NPCID.SUPER_PRIDE,
  NPCID.PIN,
  NPCID.PIN_GREY,
  NPCID.SCOLEX,
  NPCID.THE_FRAIL,
  NPCID.THE_FRAIL_BLACK,
  NPCID.WORMWOOD,
  NPCID.FAMINE,
  NPCID.FAMINE_BLUE,
  NPCID.PESTILENCE,
  NPCID.PESTILENCE_GREY,
  NPCID.WAR,
  NPCID.WAR_GREY,
  NPCID.CONQUEST,
  NPCID.WAR_WITHOUT_HORSE,
  NPCID.WAR_WITHOUT_HORSE_GREY,
  NPCID.DEATH,
  NPCID.DEATH_BLACK,
  NPCID.DEATH_HORSE,
  NPCID.DEATH_HORSE_BLACK,
  NPCID.DEATH_WITHOUT_HORSE,
  NPCID.DEATH_WITHOUT_HORSE_BLACK,
  NPCID.THE_DUKE_OF_FLIES,
  NPCID.THE_DUKE_OF_FLIES_GREEN,
  NPCID.THE_DUKE_OF_FLIES_ORANGE,
  NPCID.THE_HUSK,
  NPCID.THE_HUSK_BLACK,
  NPCID.THE_HUSK_RED,
  NPCID.PEEP,
  NPCID.PEEP_YELLOW,
  NPCID.PEEP_CYAN,
  NPCID.THE_BLOAT,
  NPCID.THE_BLOAT_GREEN,
  NPCID.LOKI,
  NPCID.LOKII,
  NPCID.FISTULA,
  NPCID.FISTULA_GREY,
  NPCID.TERATOMA,
  NPCID.FISTULA_MEDIUM,
  NPCID.FISTULA_MEDIUM_GREY,
  NPCID.TERATOMA_MEDIUM,
  NPCID.FISTULA_SMALL,
  NPCID.FISTULA_SMALL_GREY,
  NPCID.TERATOMA_SMALL,
  NPCID.BLASTOCYST,
  NPCID.BLASTOCYST_MEDIUM,
  NPCID.BLASTOCYST_SMALL,
  NPCID.MOMS_HEART,
  NPCID.IT_LIVES,
  NPCID.GEMINI,
  NPCID.GEMINI_GREEN,
  NPCID.GEMINI_BLUE,
  NPCID.STEVEN,
  NPCID.GEMINI_BABY,
  NPCID.GEMINI_BABY_GREEN,
  NPCID.GEMINI_BABY_BLUE,
  NPCID.STEVEN_BABY,
  NPCID.THE_BLIGHTED_OVUM_BABY,
  NPCID.THE_BLIGHTED_OVUM,
  NPCID.THE_FALLEN,
  NPCID.KRAMPUS,
  NPCID.HEADLESS_HORSEMAN,
  NPCID.HEADLESS_HORSEMAN_HEAD,
  NPCID.SATAN,
  NPCID.SATAN_STOMP,
  NPCID.DARK_ESAU,
  NPCID.DARKER_ESAU,
  NPCID.MOTHERS_SHADOW,
  NPCID.REAP_CREEP,
  NPCID.LIL_BLUB,
  NPCID.RAINMAKER,
  NPCID.THE_VISAGE,
  NPCID.VISAGE_MASK,
  NPCID.SIREN,
  NPCID.THE_HERETIC,
  NPCID.HORNFEL,
  NPCID.HORNFEL_DECOY,
  NPCID.GREAT_GIDEON,
  NPCID.GREAT_GIDEON_DEFEATED,
  NPCID.BABY_PLUM,
  NPCID.THE_SCOURGE,
  NPCID.THE_SCOURGE_CHAIN,
  NPCID.CHIMERA,
  NPCID.CHIMERA_BODY,
  NPCID.CHIMERA_HEAD,
  NPCID.ROTGUT,
  NPCID.ROTGUT_MAGGOT,
  NPCID.ROTGUT_HEART,
  NPCID.MOTHER_PHASE_1,
  NPCID.MOTHER_PHASE_2,
  NPCID.MOTHER_LEFT_ARM,
  NPCID.MOTHER_RIGHT_ARM,
  NPCID.MOTHER_DISAPPEAR,
  NPCID.MOTHER_2,
  NPCID.MOTHER_BALL,
  NPCID.MOTHER_BALL_MEDIUM,
  NPCID.MOTHER_BALL_SMALL,
  NPCID.MOTHER_WORM,
  NPCID.MIN_MIN,
  NPCID.CLOG,
  NPCID.SINGE,
  NPCID.BUMBINO,
  NPCID.COLOSTOMIA,
  NPCID.TURDLET,
  NPCID.RAGLICH,
  NPCID.RAGLICH_ARM,
  NPCID.HORNY_BOYS,
  NPCID.CLUTCH,
  NPCID.DOGMA,
  NPCID.DOGMAS_TV,
  NPCID.DOGMA_ANGEL,
  NPCID.THE_BEAST,
  NPCID.ULTRA_FAMINE,
  NPCID.BACKGROUND_BEAST,
  NPCID.BACKGROUND_FAMINE,
  NPCID.BACKGROUND_PESTILENCE,
  NPCID.BACKGROUND_WAR,
  NPCID.BACKGROUND_DEATH,
  NPCID.ULTRA_PESTILENCE,
  NPCID.ULTRA_WAR,
  NPCID.ULTRA_DEATH,
  NPCID.DUMMY,
  NPCID.MASK_OF_INFAMY,
  NPCID.MASK_OF_INFAMY_BLACK,
  NPCID.HEART_OF_INFAMY,
  NPCID.HEART_OF_INFAMY_BLACK,
  NPCID.GURDY_JR,
  NPCID.GURDY_JR_BLUE,
  NPCID.GURDY_JR_YELLOW,
]);

export function getNonModdedBossNPCIDSet(): ReadonlySet<NPCID> {
  return BOSS_NPC_SET;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\data\npc\FlyingNPCSet.ts`:

```````ts
import { NPCID } from "isaac-typescript-definitions";

/** Set of non-modded NPCs that are considered to be flying. */
export const FLYING_NPC_SET: ReadonlySet<NPCID> = new Set([
  NPCID.FLY,
  NPCID.POOTER,
  NPCID.SUPER_POOTER,
  NPCID.TAINTED_POOTER,
  NPCID.SHOPKEEPER,
  NPCID.SECRET_ROOM_KEEPER,
  NPCID.ERROR_ROOM_KEEPER,
  NPCID.SPECIAL_SHOPKEEPER,
  NPCID.SPECIAL_SECRET_ROOM_KEEPER,
  NPCID.ATTACK_FLY,
  NPCID.LARRY_JR,
  NPCID.LARRY_JR_GREEN,
  NPCID.LARRY_JR_BLUE,
  NPCID.THE_HOLLOW,
  NPCID.THE_HOLLOW_GREEN,
  NPCID.THE_HOLLOW_BLACK,
  NPCID.THE_HOLLOW_YELLOW,
  NPCID.TUFF_TWIN,
  NPCID.STONE_EYE,
  NPCID.CONSTANT_STONE_SHOOTER_LEFT,
  NPCID.CONSTANT_STONE_SHOOTER_UP,
  NPCID.CONSTANT_STONE_SHOOTER_RIGHT,
  NPCID.CONSTANT_STONE_SHOOTER_DOWN,
  NPCID.CROSS_STONE_SHOOTER,
  NPCID.CROSS_STONE_SHOOTER_2,
  NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON,
  NPCID.CROSS_STONE_SHOOTER_ALWAYS_ON_2,
  NPCID.BRIMSTONE_HEAD,
  NPCID.DEATHS_HEAD,
  NPCID.DANK_DEATHS_HEAD,
  NPCID.CURSED_DEATHS_HEAD,
  NPCID.BRIMSTONE_DEATHS_HEAD,
  NPCID.REDSKULL,
  NPCID.LEVEL_2_FLY,
  NPCID.SWINGER_HEAD,
  NPCID.SWINGER_NECK,
  NPCID.RING_FLY,
  NPCID.OOB,
  NPCID.BLACK_MAW,
  NPCID.HOMUNCULUS_CORD,
  NPCID.TUMOR,
  NPCID.PLANETOID,
  NPCID.CAMILLO_JR,
  NPCID.ONE_TOOTH,
  NPCID.GAPING_MAW,
  NPCID.BROKEN_GAPING_MAW,
  NPCID.FULL_FLY,
  NPCID.BOOM_FLY,
  NPCID.RED_BOOM_FLY,
  NPCID.DROWNED_BOOM_FLY,
  NPCID.DRAGON_FLY,
  NPCID.DRAGON_FLY_X,
  NPCID.BONE_FLY,
  NPCID.SICK_BOOM_FLY,
  NPCID.TAINTED_BOOM_FLY,
  NPCID.FLOATING_KNIGHT,
  NPCID.DART_FLY,
  NPCID.FAT_BAT,
  NPCID.IMP,
  NPCID.MAW,
  NPCID.RED_MAW,
  NPCID.PSYCHIC_MAW,
  NPCID.HAUNT,
  NPCID.HAUNT_BLACK,
  NPCID.HAUNT_PINK,
  NPCID.LIL_HAUNT,
  NPCID.DARK_ONE,
  NPCID.THE_ADVERSARY,
  NPCID.URIEL,
  NPCID.FALLEN_URIEL,
  NPCID.GABRIEL,
  NPCID.FALLEN_GABRIEL,
  NPCID.THE_LAMB,
  NPCID.MEGA_SATAN,
  NPCID.MEGA_SATANS_RIGHT_HAND,
  NPCID.MEGA_SATANS_LEFT_HAND,
  NPCID.MEGA_SATAN_2,
  NPCID.MEGA_SATAN_2_RIGHT_HAND,
  NPCID.MEGA_SATAN_2_LEFT_HAND,
  NPCID.SWARM,
  NPCID.FLESH_DEATHS_HEAD,
  NPCID.DUKIE,
  NPCID.ULTRA_GREED_DOOR,
  NPCID.HUSH_FLY,
  NPCID.PORTAL,
  NPCID.LIL_PORTAL,
  NPCID.TAR_BOY_MOUTH,
  NPCID.FISTULOID,
  NPCID.LEPER_FLESH,
  NPCID.MR_MINE,
  NPCID.MR_MINE_NECK,
  NPCID.FIRE_PLACE,
  NPCID.RED_FIRE_PLACE,
  NPCID.MOVEABLE_FIREPLACE,
  NPCID.MOVEABLE_BLUE_FIREPLACE,
  NPCID.MOVEABLE_PURPLE_FIREPLACE,
  NPCID.BLUE_FIRE_PLACE,
  NPCID.PURPLE_FIRE_PLACE,
  NPCID.WHITE_FIRE_PLACE,
  NPCID.MR_MAW_HEAD,
  NPCID.MR_MAW_NECK,
  NPCID.MR_RED_MAW_HEAD,
  NPCID.BABY,
  NPCID.ANGELIC_BABY,
  NPCID.ANGELIC_BABY_SMALL,
  NPCID.ULTRA_PRIDE_BABY,
  NPCID.WRINKLY_BABY,
  NPCID.CHUBBER_PROJECTILE,
  NPCID.STONE_GRIMACE,
  NPCID.VOMIT_GRIMACE,
  NPCID.TRIPLE_GRIMACE,
  NPCID.MOM,
  NPCID.MOM_BLUE,
  NPCID.MOM_RED,
  NPCID.MOM_STOMP,
  NPCID.MOM_STOMP_BLUE,
  NPCID.MOM_STOMP_RED,
  NPCID.ENVY,
  NPCID.SUPER_ENVY,
  NPCID.ENVY_BIG,
  NPCID.SUPER_ENVY_BIG,
  NPCID.ENVY_MEDIUM,
  NPCID.SUPER_ENVY_MEDIUM,
  NPCID.ENVY_SMALL,
  NPCID.SUPER_ENVY_SMALL,
  NPCID.LEECH,
  NPCID.KAMIKAZE_LEECH,
  NPCID.HOLY_LEECH,
  NPCID.FRED,
  NPCID.SUCKER,
  NPCID.SPIT,
  NPCID.SOUL_SUCKER,
  NPCID.INK,
  NPCID.MAMA_FLY,
  NPCID.BULB,
  NPCID.BLOODFLY,
  NPCID.TAINTED_SUCKER,
  NPCID.WORMWOOD,
  NPCID.FAMINE,
  NPCID.FAMINE_BLUE,
  NPCID.PESTILENCE,
  NPCID.PESTILENCE_GREY,
  NPCID.DEATH,
  NPCID.DEATH_BLACK,
  NPCID.DEATH_SCYTHE,
  NPCID.DEATH_SCYTHE_BLACK,
  NPCID.DEATH_HORSE,
  NPCID.DEATH_HORSE_BLACK,
  NPCID.DEATH_WITHOUT_HORSE,
  NPCID.DEATH_WITHOUT_HORSE_BLACK,
  NPCID.PEEP_EYE,
  NPCID.PEEP_EYE_YELLOW,
  NPCID.PEEP_EYE_CYAN,
  NPCID.BLOAT_EYE,
  NPCID.BLOAT_EYE_GREEN,
  NPCID.FISTULA,
  NPCID.FISTULA_GREY,
  NPCID.TERATOMA,
  NPCID.FISTULA_MEDIUM,
  NPCID.FISTULA_MEDIUM_GREY,
  NPCID.TERATOMA_MEDIUM,
  NPCID.FISTULA_SMALL,
  NPCID.FISTULA_SMALL_GREY,
  NPCID.TERATOMA_SMALL,
  NPCID.MOMS_HEART,
  NPCID.IT_LIVES,
  NPCID.MOMS_GUTS,
  NPCID.UMBILICAL_CORD,
  NPCID.UMBILICAL_CORD_GREEN,
  NPCID.UMBILICAL_CORD_BLUE,
  NPCID.MOTER,
  NPCID.BLIND_BAT,
  NPCID.QUAKE_GRIMACE_LEFT,
  NPCID.QUAKE_GRIMACE_UP,
  NPCID.QUAKE_GRIMACE_RIGHT,
  NPCID.QUAKE_GRIMACE_DOWN,
  NPCID.WILLO,
  NPCID.BOMB_GRIMACE,
  NPCID.THE_FALLEN,
  NPCID.KRAMPUS,
  NPCID.POLTY,
  NPCID.KINETI,
  NPCID.FLY_BOMB,
  NPCID.ETERNAL_FLY_BOMB,
  NPCID.HEADLESS_HORSEMAN,
  NPCID.FIRE_WORM,
  NPCID.HEADLESS_HORSEMAN_HEAD,
  NPCID.GUTTED_FATTY_EYE,
  NPCID.CANDLER,
  NPCID.PEEPING_FATTY_EYE,
  NPCID.SATAN,
  NPCID.SATAN_STOMP,
  NPCID.ADULT_LEECH,
  NPCID.FLOAST,
  NPCID.UNBORN,
  NPCID.MORNINGSTAR,
  NPCID.MORNINGSTAR_2,
  NPCID.MORNINGSTAR_3,
  NPCID.MOCKULUS,
  NPCID.DARK_ESAUS_PIT,
  NPCID.ARMY_FLY,
  NPCID.FLESH_MAIDEN,
  NPCID.NEEDLE,
  NPCID.PASTY,
  NPCID.DUST,
  NPCID.BABY_BEGOTTEN,
  NPCID.CULTIST,
  NPCID.BLOOD_CULTIST,
  NPCID.BONE_TRAP,
  NPCID.FETAL_DEMON,
  NPCID.DUSTY_DEATHS_HEAD,
  NPCID.HANGER,
  NPCID.REAP_CREEP,
  NPCID.RAINMAKER,
  NPCID.THE_VISAGE,
  NPCID.VISAGE_MASK,
  NPCID.VISAGE_CHAIN,
  NPCID.VISAGE_PLASMA,
  NPCID.SIRENS_SKULL,
  NPCID.THE_HERETIC,
  NPCID.HORNFEL,
  NPCID.HORNFEL_DECOY,
  NPCID.GREAT_GIDEON,
  NPCID.GREAT_GIDEON_DEFEATED,
  NPCID.BABY_PLUM,
  NPCID.THE_SCOURGE,
  NPCID.THE_SCOURGE_CHAIN,
  NPCID.SWARMER,
  NPCID.ROTGUT_MAGGOT,
  NPCID.ROTGUT_HEART,
  NPCID.MOTHER_PHASE_1,
  NPCID.MOTHER_PHASE_2,
  NPCID.MOTHER_LEFT_ARM,
  NPCID.MOTHER_RIGHT_ARM,
  NPCID.MOTHER_DISAPPEAR,
  NPCID.MOTHER_2,
  NPCID.MOTHER_BALL,
  NPCID.MOTHER_BALL_MEDIUM,
  NPCID.MOTHER_BALL_SMALL,
  NPCID.MOTHER_WORM,
  NPCID.MIN_MIN,
  NPCID.RAGLICH,
  NPCID.RAGLICH_ARM,
  NPCID.HORNY_BOYS,
  NPCID.CLUTCH,
  NPCID.CLUTCH_ORBITAL,
  NPCID.DOGMA,
  NPCID.DOGMA_ANGEL_BABY,
  NPCID.DOGMA_ANGEL,
  NPCID.THE_BEAST,
  NPCID.STALACTITE,
  NPCID.ULTRA_FAMINE,
  NPCID.BACKGROUND_BEAST,
  NPCID.BACKGROUND_FAMINE,
  NPCID.BACKGROUND_PESTILENCE,
  NPCID.BACKGROUND_WAR,
  NPCID.BACKGROUND_DEATH,
  NPCID.ULTRA_FAMINE_FLY,
  NPCID.BEAST_ROCK_PROJECTILE,
  NPCID.ULTRA_PESTILENCE,
  NPCID.ULTRA_PESTILENCE_FLY,
  NPCID.ULTRA_PESTILENCE_MAGGOT,
  NPCID.ULTRA_PESTILENCE_FLY_BALL,
  NPCID.BEAST_SOUL,
  NPCID.ULTRA_WAR,
  NPCID.ULTRA_WAR_BOMB,
  NPCID.ULTRA_DEATH,
  NPCID.ULTRA_DEATH_SCYTHE,
  NPCID.ULTRA_DEATH_HEAD,
  NPCID.ETERNAL_FLY,
  NPCID.SIREN_HELPER,
  NPCID.HORNFEL_DOOR,
]);

/** Get all the non-modded FlyingNPCs. */
export function getNonModdedFlyingNPCIDSet(): ReadonlySet<NPCID> {
  return FLYING_NPC_SET;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\funnyActionTexts.ts`:

```````ts
import { getRandomInt } from "isaacscript-common";
import { getRandomInteger } from "../helper/randomHelper";

export const FUNNY_ACTION_TEXT_SET: ReadonlySet<string> = new Set([
  "upon uninstalling Isaac,",
  "upon opening discord,",
  "upon selling your organs to the black market,",
  "after winning the game,",
  "instead of being born once,",
  "upon doing literally nothing,",
  "on cooking with mama,",
  "a wise man once said:",
  "upon writing the obituary,",
  "don't",
  "upon standing still for two days,",
  "upon updating to windows 11,",
  "every 3-7 days,",
  "every 3-7 business days,",
  "upon donating to charity,",
  "upon twisting and shouting,",
  "upon twirling your mustache,",
  "upon menstruating,",
  `every 2-${getRandomInteger(1, 24)} hours,`,
  "on updating this mod,",
  "instead of leaving a cookie out for santa,",
  "instead of picking up this item,",
  "upon circling a tinted rock 20 times,",
  "upon going back and fourth through a door 33 times,",
  "instead of going to The Chest,",
  "when the moon passes between the sun and the earth,",
  "when you forget to turn off the oven,",
  "after screaming loudly into the mic,",
  "after turning your pc off,",
  "every blink,",
  "every time you think an original thought,",
  "every time you [REDACTED],",
  "every time you comment on this mod's Steam page with '[DELETED]',",
  "every time you receive an anonymous love letter,",
  "every time you erase henry,",
  "every time you use Book of Shadows at game coordinates 23.76, 32.39 while playing as blue baby,",
  "instead of spending all your money on used pokemon cards, eventually going bankrupt and resorting to a life of crime and violence,",
]);

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\workingCollectibleEffects.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";

/** A set of CollectibleTypes which work with the TemporaryEffect AddCollectibleEffect() method. */
const WORKING_PASSIVE_COLLECTIBLE_EFFECTS: ReadonlySet<CollectibleType> =
  new Set([
    CollectibleType.SAD_ONION,
    CollectibleType.INNER_EYE,
    CollectibleType.SPOON_BENDER,
    CollectibleType.MY_REFLECTION,
    CollectibleType.NUMBER_ONE,
    CollectibleType.BROTHER_BOBBY,
    CollectibleType.MAGIC_MUSHROOM,
    CollectibleType.VIRUS,
    CollectibleType.ROID_RAGE,
    CollectibleType.TRANSCENDENCE,
    CollectibleType.MOMS_UNDERWEAR,
    CollectibleType.MOMS_HEELS,
    CollectibleType.MOMS_LIPSTICK,
    CollectibleType.MOMS_EYE,
    CollectibleType.DISTANT_ADMIRATION,
    CollectibleType.SISTER_MAGGY,
    CollectibleType.GROWTH_HORMONES,
    CollectibleType.MINI_MUSH,
    CollectibleType.CUBE_OF_MEAT,
    CollectibleType.LITTLE_CHUBBY,
    CollectibleType.LITTLE_CHAD,
    CollectibleType.SACK_OF_PENNIES,
    CollectibleType.ROBO_BABY,
    CollectibleType.RELIC,
    CollectibleType.LITTLE_GISH,
    CollectibleType.LITTLE_STEVEN,
    CollectibleType.WAFER,
    CollectibleType.MOMS_CONTACTS,
    CollectibleType.GUARDIAN_ANGEL,
    CollectibleType.DEMON_BABY,
    CollectibleType.MOMS_KNIFE,
    CollectibleType.OUIJA_BOARD,
    CollectibleType.BRIMSTONE,
    CollectibleType.ODD_MUSHROOM_THIN,
    CollectibleType.ODD_MUSHROOM_LARGE,
    CollectibleType.FOREVER_ALONE,
    CollectibleType.BOMB_BAG,
    CollectibleType.SPEED_BALL,
    CollectibleType.BUM_FRIEND,
    CollectibleType.TOUGH_LOVE,
    CollectibleType.GHOST_BABY,
    CollectibleType.HARLEQUIN_BABY,
    CollectibleType.DADDY_LONGLEGS,
    CollectibleType.SACRIFICIAL_DAGGER,
    CollectibleType.RAINBOW_BABY,
    CollectibleType.HOLY_WATER,
    CollectibleType.GUPPYS_HAIRBALL,
    CollectibleType.ABEL,
    CollectibleType.MOMS_KEY,
    CollectibleType.MOMS_EYESHADOW,
    CollectibleType.IRON_BAR,
    CollectibleType.GUILLOTINE,
    CollectibleType.BALL_OF_BANDAGES,
    CollectibleType.ANEMIC,
    CollectibleType.MOMS_WIG,
    CollectibleType.MOMS_PERFUME,
    CollectibleType.DEATHS_TOUCH,
    CollectibleType.HIVE_MIND,
    CollectibleType.FIRE_MIND,
    CollectibleType.DARK_MATTER,
    CollectibleType.PROPTOSIS,
    CollectibleType.SMART_FLY,
    CollectibleType.DRY_BABY,
    CollectibleType.JUICY_SACK,
    CollectibleType.ROBO_BABY_2,
    CollectibleType.ROTTEN_BABY,
    CollectibleType.HEADLESS_BABY,
    CollectibleType.LEECH,
    CollectibleType.MYSTERY_SACK,
    CollectibleType.BBF,
    CollectibleType.BOBS_BRAIN,
    CollectibleType.LIL_BRIMSTONE,
    CollectibleType.LIL_HAUNT,
    CollectibleType.DARK_BUM,
    CollectibleType.BIG_FAN,
    CollectibleType.SISSY_LONGLEGS,
    CollectibleType.PUNCHING_BAG,
    CollectibleType.LEO,
    CollectibleType.HOLY_MANTLE,
    CollectibleType.MYSTERIOUS_LIQUID,
    CollectibleType.GEMINI,
    CollectibleType.CAINS_OTHER_EYE,
    CollectibleType.BLUE_BABYS_ONLY_FRIEND,
    CollectibleType.SAMSONS_CHAINS,
    CollectibleType.MONGO_BABY,
    CollectibleType.BLUE_CAP,
    CollectibleType.SYNTHOIL,
    CollectibleType.MOMS_PEARLS,
    CollectibleType.WIZ,
    CollectibleType.INCUBUS,
    CollectibleType.FATES_REWARD,
    CollectibleType.LIL_CHEST,
    CollectibleType.SWORN_PROTECTOR,
    CollectibleType.FRIEND_ZONE,
    CollectibleType.LOST_FLY,
    CollectibleType.CHARGED_BABY,
    CollectibleType.HOLY_LIGHT,
    CollectibleType.LIL_GURDY,
    CollectibleType.BUMBO,
    CollectibleType.CENSER,
    CollectibleType.KEY_BUM,
    CollectibleType.RUNE_BAG,
    CollectibleType.SERAPHIM,
    CollectibleType.GODS_FLESH,
    CollectibleType.SPIDER_MOD,
    CollectibleType.FARTING_BABY,
    CollectibleType.SUCCUBUS,
    CollectibleType.FRUIT_CAKE,
    CollectibleType.OBSESSED_FAN,
    CollectibleType.HEAD_OF_THE_KEEPER,
    CollectibleType.PAPA_FLY,
    CollectibleType.MULTIDIMENSIONAL_BABY,
    CollectibleType.LIL_LOKI,
    CollectibleType.FINGER,
    CollectibleType.SHADE,
    CollectibleType.DEPRESSION,
    CollectibleType.HUSHY,
    CollectibleType.LIL_MONSTRO,
    CollectibleType.KING_BABY,
    CollectibleType.BIG_CHUBBY,
    CollectibleType.ACID_BABY,
    CollectibleType.YO_LISTEN,
    CollectibleType.ADRENALINE,
    CollectibleType.EUTHANASIA,
    CollectibleType.CAMO_UNDIES,
    CollectibleType.SACK_OF_SACKS,
    CollectibleType.MOMS_RAZOR,
    CollectibleType.BLOODSHOT_EYE,
    CollectibleType.ANGRY_FLY,
    CollectibleType.BUDDY_IN_A_BOX,
    CollectibleType.LIL_DELIRIUM,
    CollectibleType.SEVEN_SEALS,
    CollectibleType.ANGELIC_PRISM,
    CollectibleType.LIL_SPEWER,
    CollectibleType.MYSTERY_EGG,
    CollectibleType.SLIPPED_RIB,
    CollectibleType.HALLOWED_GROUND,
    CollectibleType.POINTY_RIB,
    CollectibleType.JAW_BONE,
    CollectibleType.BLOOD_PUPPY,
    CollectibleType.PSY_FLY,
    CollectibleType.URANUS,
    CollectibleType.BOILED_BABY,
    CollectibleType.FREEZER_BABY,
    CollectibleType.LIL_DUMPY,
    CollectibleType.BOT_FLY,
    CollectibleType.TINYTOMA,
    CollectibleType.FRUITY_PLUM,
    CollectibleType.CUBE_BABY,
    CollectibleType.LIL_ABADDON,
    CollectibleType.LIL_PORTAL,
    CollectibleType.WORM_FRIEND,
    CollectibleType.TWISTED_PAIR,
    CollectibleType.MOMS_RING,
  ]);

/**
 * A set of CollectibleTypes which partly work with the TemporaryEffect AddCollectibleEffect()
 * method. They may only emulate part of the item.
 */
const PARTLY_WORKING_PASSIVE_COLLECTIBLE_EFFECTS: ReadonlySet<CollectibleType> =
  new Set([
    CollectibleType.DEAD_BIRD,
    CollectibleType.WHORE_OF_BABYLON,
    CollectibleType.PEEPER,
    CollectibleType.ANEMIC,
    CollectibleType.EXPERIMENTAL_TREATMENT,
    CollectibleType.TWENTY_TWENTY,
    CollectibleType.BEST_BUD,
    CollectibleType.TRACTOR_BEAM,
    CollectibleType.EMPTY_VESSEL,
    CollectibleType.LUSTY_BLOOD,
    CollectibleType.CROWN_OF_LIGHT,
    CollectibleType.MILK,
    CollectibleType.DARK_PRINCES_CROWN,
    CollectibleType.PASCHAL_CANDLE,
    CollectibleType.EYE_OF_THE_OCCULT,
    CollectibleType.INTRUDER,
    CollectibleType.MARS,
    CollectibleType.BIRD_CAGE,
    CollectibleType.ASTRAL_PROJECTION,
    CollectibleType.INNER_CHILD,
  ]);

/**
 * Checks if the CollectibleType works using its corresponding CollectibleEffect.
 *
 * @param collectibleType The CollectibleType you want to check.
 * @param includePartlyWorking Will also return true if it is part of the 'partly working' set,
 *                             which may only replicate part of the collectible.
 */
export function doesCollectibleEffectWork(
  collectibleType: CollectibleType,
  includePartlyWorking: boolean,
): boolean {
  const inWorking = WORKING_PASSIVE_COLLECTIBLE_EFFECTS.has(collectibleType);
  if (!inWorking) {
    if (includePartlyWorking) {
      return PARTLY_WORKING_PASSIVE_COLLECTIBLE_EFFECTS.has(collectibleType);
    }
  }
  return inWorking;
}

/**
 * If the Temporary Collectible effect works, adds it, otherwise adds the collectible (with no logic
 * for removal).
 */
export function addTemporaryCollectibleOrNormalCollectible(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  partlyWorking = true,
): void {
  if (doesCollectibleEffectWork(collectibleType, partlyWorking)) {
    player
      .GetEffects()
      .AddCollectibleEffect(collectibleType as TemporaryCollectibleType);
  } else {
    player.AddCollectible(collectibleType);
  }
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\sets\zazzSets.ts`:

```````ts
import { CollectibleType } from "isaac-typescript-definitions";
import { CollectibleTypeCustom } from "../enums/general/CollectibleTypeCustom";

/** Set of all passive Zazzinator items. */
export const ZAZZINATOR_PASSIVE_SET: ReadonlySet<CollectibleType> = new Set([
  CollectibleTypeCustom.ZAZZ,
]);

/** Set of all Zazzinator items, passive or active. */
export const ZAZZINATOR_SET: ReadonlySet<CollectibleType> = new Set([
  CollectibleTypeCustom.ZAZZ,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12_COPY,
]);

/** Contains all ZAZZ Actives, including copies. */
export const ZAZZINATOR_ACTIVE_SET: ReadonlySet<CollectibleType> = new Set([
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11_COPY,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12,
  CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12_COPY,
]);

/** Only contains ZAZZ copies. */
export const ZAZZINATOR_ACTIVE_COPY_SET: ReadonlySet<CollectibleType> = new Set(
  [
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_0_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_1_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_2_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_3_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_4_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_5_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_6_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_7_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_8_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_9_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_10_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_11_COPY,
    CollectibleTypeCustom.ZAZZ_ACTIVE_NORMAL_12_COPY,
  ],
);

/** Checks if collectibleType is a ZAZZ active copy. */
export function isZazzinatorActiveCopy(collectible: CollectibleType): boolean {
  return ZAZZINATOR_ACTIVE_COPY_SET.has(collectible);
}

/** Checks if a collectibleType is a ZAZZ active. */
export function isZazzinatorActive(collectible: CollectibleType): boolean {
  return ZAZZINATOR_ACTIVE_SET.has(collectible);
}

/** Checks if a collectibleType is a ZAZZ. */
export function isZazzinatorAny(collectible: CollectibleType): boolean {
  return ZAZZINATOR_SET.has(collectible);
}

/** Checks if a collectibleType is a ZAZZ passive. */
export function isZazzinatorPassive(collectible: CollectibleType): boolean {
  return ZAZZINATOR_PASSIVE_SET.has(collectible);
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\corruption\LogicResponseUnion.ts`:

```````ts
import type { IfThenElseResponse } from "../../classes/corruption/responses/IfThenElseResponse";
import type { IfThenResponse } from "../../classes/corruption/responses/IfThenResponse";
import type { TriggerInQueueResponse } from "../../classes/corruption/responses/TriggerInQueueResponse";
import type { TriggerInSequenceResponse } from "../../classes/corruption/responses/TriggerInSequenceResponse";
import type { TriggerRandomResponse } from "../../classes/corruption/responses/TriggerRandomResponse";

/**
 * Type union of Responses which are responsible for triggering other responses using logic 'AND',
 * 'OR', 'IF THEN', or 'IF THEN ELSE'. These Responses will always return a Response when triggered.
 */
export type LogicResponseUnion =
  | TriggerRandomResponse
  | TriggerInSequenceResponse
  | TriggerInQueueResponse
  | IfThenElseResponse
  | IfThenResponse;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\corruption\SpawnResponseUnion.ts`:

```````ts
import type { SpawnEffectResponse } from "../../classes/corruption/responses/SpawnEffectResponse";
import type { SpawnLiveBombResponse } from "../../classes/corruption/responses/SpawnLiveBombResponse";
import type { SpawnNPCResponse } from "../../classes/corruption/responses/SpawnNPCResponse";
import type { SpawnPickupResponse } from "../../classes/corruption/responses/SpawnPickupResponse";
import type { SpawnSlotResponse } from "../../classes/corruption/responses/SpawnSlotResponse";
import type { SpawnTearResponse } from "../../classes/corruption/responses/SpawnTearResponse";

/** Type union of Responses which spawn non-grid Entities. */
export type SpawnResponseUnion =
  | SpawnEffectResponse
  | SpawnNPCResponse
  | SpawnLiveBombResponse
  | SpawnPickupResponse
  | SpawnSlotResponse
  | SpawnTearResponse;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\data\IDTypes.ts`:

```````ts
import type { EntityID } from "isaacscript-common";
import type { PickupID } from "../../enums/data/ID/PickupID";
import type { FamiliarID } from "../../enums/data/ID/FamiliarID";
import type { EffectID } from "../../enums/data/ID/EffectID";
import type { NPCID } from "isaac-typescript-definitions";

export type EntityIDTypeUnion =
  | EntityID
  | PickupID
  | FamiliarID
  | EffectID
  | NPCID;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\data\nameSubType.ts`:

```````ts
/**
 * Due to loaded mods not being confirmed until game start, we don't know the EntityID for modded
 * entities until then. We can derive the EntityID from the entities' name and subtype, which is
 * what this type is for. EntityType and Variant are derived using their name and respective 'Isaac'
 * class functions, while the subtype is given.
 *
 * @problem If the entity's subtype is not specified, and there are multiple entities with the same
 *          EntityType and Variant, then the EntityID will be incorrect (it will always return '0'
 *          as the subtype).
 */
export type NameSubType = `${string}.${string}`;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\general\Builder.ts`:

```````ts
import { ActionSet } from "../../classes/corruption/actionSets/ActionSet";
import { InvertedActiveActionSet } from "../../classes/corruption/actionSets/Inverted/InvertedActiveActionSet";
import { ActionSetBuilderInput } from "../../interfaces/corruption/actionSets/ActionSetBuilderInput";

export type Builder<Type> = (...args: any[]) => Type;

export type ActionSetBuilder = (inputs?: ActionSetBuilderInput) => ActionSet;

export type InvertedItemActionSetBuilder = (
  inputs?: ActionSetBuilderInput,
) => InvertedActiveActionSet;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\general\EntityUnion.ts`:

```````ts
/** A union of Entity and GridEntity types. */
export type EntityOrGridEntity = Entity | GridEntity;

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\general\Mutable.ts`:

```````ts
/** Make a readonly value writeable. */
export type Mutable<T> = {
  -readonly [k in keyof T]: T[k];
};

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\general\Percentage.ts`:

```````ts
import { getRandomInt } from "isaacscript-common";
import { getRandomInteger } from "../../helper/randomHelper";

/** Number between 0 and 100. */
export type Percentage = number;

/** Type guard to check if a number is a Percentage. */
export function isPercentage(number: number): number is Percentage {
  return number <= 100 && number >= 0;
}

/** Errors if number is not a valid Percentage. */
export function createPercentage(number: number): Percentage {
  if (number > 100 || number < 0) {
    error("Percentage: Percentage outside of bounds (0-100).");
  }
  return number;
}

/**
 * Rolls a percentage chance that can either be true or false. 100% is always true and 0% is always
 * false. Precision up to 2 decimal point (e.g 0.01%).
 */
export function rollPercentage(
  percentageChance: Percentage,
  seed?: Seed,
): boolean {
  return getRandomInteger(0, 9999, seed) * 0.01 < percentageChance;
}

```````

`\\?\C:\Users\james\OneDrive\Desktop\stuff\stuff-large\programming\isaac\thedeleted\src\types\general\Range.ts`:

```````ts
import { deepCopy, getRandomInt } from "isaacscript-common";
import { getRandomInteger } from "../../helper/randomHelper";

/** Range between two numbers. Left number is minimum, right is maximum. */
export type Range = [number, number];

/** Get a random number in the range, inclusive on both ends. */
export function randomInRange(range: Range, seedOrRNG?: Seed | RNG): number {
  return getRandomInteger(range[0], range[1], seedOrRNG);
}

/**
 * Get a random number in the range, inclusive on both ends. If a number is inputted to the
 * function, it will be returned.
 */
export function randomInRangeOrNumber(
  rangeOrNumber: Range | number,
  seedOrRNG?: Seed | RNG,
): number {
  if (typeof rangeOrNumber === "number") {
    return rangeOrNumber;
  }

  return randomInRange(rangeOrNumber, seedOrRNG);
}

/**
 * Modifies the range to make sure the right number is equal or higher to the left.
 *
 * @param range
 * @param config
 * @param minValue The minimum value (default 1).
 * @param notSame Ensures values are not same (default true) Increments right side if they are the
 *                same.
 * @param config.minValue
 * @param config.notSame
 */
export function validifyRange(
  range: Range,
  config: { minValue?: number; notSame?: boolean } = {},
): Range {
  config.minValue ??= 1;
  if (config.notSame === undefined) {
    config.notSame = true;
  }
  range[0] = range[0] >= config.minValue ? range[0] : config.minValue;
  range[1] = range[1] >= config.minValue ? range[1] : config.minValue;
  range = range[0] <= range[1] ? range : [range[1], range[0]];
  if (config.notSame && range[0] === range[1]) {
    range[1]++;
  }
  return range;
}

/** Returns the range as a string, ready to print. */
export function rangeToString(range: Range): string {
  return `${range[0]}-${range[1]}`;
}

/** If a Range is involved, returns a range, otherwise returns a number. */
export function multiplyRangesOrNumbers(
  numberOrRange1: number | Range,
  numberOrRange2: number | Range,
): number | Range {
  if (typeof numberOrRange1 === "number") {
    if (typeof numberOrRange2 === "number") {
      return numberOrRange1 * numberOrRange2;
    }
    return [
      numberOrRange2[0] * numberOrRange1,
      numberOrRange2[1] * numberOrRange1,
    ];
  }
  if (typeof numberOrRange2 === "number") {
    return [
      numberOrRange1[0] * numberOrRange2,
      numberOrRange1[1] * numberOrRange2,
    ];
  }
  return multiplyRanges(numberOrRange1, numberOrRange2);
}

/** Multiply two Ranges together, like a matrix. */
export function multiplyRanges(range1: Range, range2: Range): Range {
  return [range1[0] * range2[0], range1[1] * range2[1]];
}

/** Multiply a Range by a number, e.g [1,1] * 5 = [5,5]. Creates a new Object! */
export function multiplyRangeConstituents(
  range: Range,
  multiplier: number,
): Range {
  return [range[0] * multiplier, range[1] * multiplier];
}

/**
 * Returns a random number in the range, inclusive on both ends, with the specified number of
 * decimal places. E.g: randomInRangeWithDecimalPrecision([1, 5], 2) could return 1.23, 2.34, 3.45,
 * 4.56, or 5.00.
 *
 * @param range The range to get a random number from.
 * @param decimals The number of decimal places to round to.
 * @returns A random number in the range, inclusive on both ends, with the specified number of
 *          decimal places.
 */
export function randomInRangeWithDecimalPrecision(
  range: Range,
  decimals: number,
): number {
  const rangeWithMultiplier = [
    range[0] * 10 ** decimals,
    range[1] * 10 ** decimals,
  ] as Range;
  const random = randomInRange(rangeWithMultiplier);
  return random / 10 ** decimals;
}

```````