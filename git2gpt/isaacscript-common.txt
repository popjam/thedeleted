The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
cachedEnumValues.ts
// These cached enum value arrays are only meant to be used internally within `isaacscript-common`.

import {
  ActiveSlot,
  BossID,
  CacheFlag,
  ControllerIndex,
  DoorSlot,
  DoorSlotFlag,
  GridEntityType,
  GridEntityXMLType,
  ItemConfigCardType,
  ItemConfigTag,
  ItemPoolType,
  Keyboard,
  PillColor,
  PlayerForm,
  PocketItemSlot,
  RoomShape,
  SeedEffect,
  SoundEffect,
  TrinketSlot,
} from "isaac-typescript-definitions";
import { HealthType } from "./enums/HealthType";
import { ModCallbackCustom } from "./enums/ModCallbackCustom";
import { PlayerStat } from "./enums/PlayerStat";
import { SerializationBrand } from "./enums/private/SerializationBrand";
import { getEnumValues } from "./functions/enums";

export const ACTIVE_SLOT_VALUES = getEnumValues(ActiveSlot);

export const BOSS_ID_VALUES = getEnumValues(BossID);

export const CACHE_FLAG_VALUES = getEnumValues(CacheFlag);

export const CONTROLLER_INDEX_VALUES = getEnumValues(ControllerIndex);

export const DOOR_SLOT_FLAG_VALUES = getEnumValues(DoorSlotFlag);

export const DOOR_SLOT_VALUES = getEnumValues(DoorSlot);

export const GRID_ENTITY_TYPE_VALUES = getEnumValues(GridEntityType);

export const GRID_ENTITY_XML_TYPE_VALUES = getEnumValues(GridEntityXMLType);

export const MOD_CALLBACK_CUSTOM_VALUES = getEnumValues(ModCallbackCustom);

export const ITEM_CONFIG_TAG_VALUES = getEnumValues(ItemConfigTag);

export const ITEM_CONFIG_CARD_TYPE_VALUES = getEnumValues(ItemConfigCardType);

export const ITEM_POOL_TYPE_VALUES = getEnumValues(ItemPoolType);

export const KEYBOARD_VALUES = getEnumValues(Keyboard);

export const HEALTH_TYPE_VALUES = getEnumValues(HealthType);

export const PILL_COLOR_VALUES = getEnumValues(PillColor);

export const PLAYER_FORM_VALUES = getEnumValues(PlayerForm);

export const POCKET_ITEM_SLOT_VALUES = getEnumValues(PocketItemSlot);

export const ROOM_SHAPE_VALUES = getEnumValues(RoomShape);

export const SEED_EFFECTS = getEnumValues(SeedEffect);

export const SERIALIZATION_BRAND_VALUES = getEnumValues(SerializationBrand);

export const SOUND_EFFECT_VALUES = getEnumValues(SoundEffect);

export const PLAYER_STAT_VALUES = getEnumValues(PlayerStat);

export const TRINKET_SLOT_VALUES = getEnumValues(TrinketSlot);

----
callbackClasses.ts
// We must put the callback classes in a separate file as a workaround for Lua having a limit of 200
// local variables.

export { EntityTakeDmgFilter } from "./classes/callbacks/EntityTakeDmgFilter";
export { EntityTakeDmgPlayer } from "./classes/callbacks/EntityTakeDmgPlayer";
export { InputActionFilter } from "./classes/callbacks/InputActionFilter";
export { InputActionPlayer } from "./classes/callbacks/InputActionPlayer";
export { PostAmbushFinished } from "./classes/callbacks/PostAmbushFinished";
export { PostAmbushStarted } from "./classes/callbacks/PostAmbushStarted";
export { PostBombExploded } from "./classes/callbacks/PostBombExploded";
export { PostBombInitFilter } from "./classes/callbacks/PostBombInitFilter";
export { PostBombInitLate } from "./classes/callbacks/PostBombInitLate";
export { PostBombRenderFilter } from "./classes/callbacks/PostBombRenderFilter";
export { PostBombUpdateFilter } from "./classes/callbacks/PostBombUpdateFilter";
export { PostBoneSwing } from "./classes/callbacks/PostBoneSwing";
export { PostCollectibleEmpty } from "./classes/callbacks/PostCollectibleEmpty";
export { PostCursedTeleport } from "./classes/callbacks/PostCursedTeleport";
export { PostCustomRevive } from "./classes/callbacks/PostCustomRevive";
export { PostDiceRoomActivated } from "./classes/callbacks/PostDiceRoomActivated";
export { PostDoorRender } from "./classes/callbacks/PostDoorRender";
export { PostDoorUpdate } from "./classes/callbacks/PostDoorUpdate";
export { PostEffectInitFilter } from "./classes/callbacks/PostEffectInitFilter";
export { PostEffectInitLate } from "./classes/callbacks/PostEffectInitLate";
export { PostEffectRenderFilter } from "./classes/callbacks/PostEffectRenderFilter";
export { PostEffectStateChanged } from "./classes/callbacks/PostEffectStateChanged";
export { PostEffectUpdateFilter } from "./classes/callbacks/PostEffectUpdateFilter";
export { PostEntityKillFilter } from "./classes/callbacks/PostEntityKillFilter";
export { PostEsauJr } from "./classes/callbacks/PostEsauJr";
export { PostFamiliarInitFilter } from "./classes/callbacks/PostFamiliarInitFilter";
export { PostFamiliarInitLate } from "./classes/callbacks/PostFamiliarInitLate";
export { PostFamiliarRenderFilter } from "./classes/callbacks/PostFamiliarRenderFilter";
export { PostFamiliarStateChanged } from "./classes/callbacks/PostFamiliarStateChanged";
export { PostFamiliarUpdateFilter } from "./classes/callbacks/PostFamiliarUpdateFilter";
export { PostFirstEsauJr } from "./classes/callbacks/PostFirstEsauJr";
export { PostFirstFlip } from "./classes/callbacks/PostFirstFlip";
export { PostFlip } from "./classes/callbacks/PostFlip";
export { PostGameEndFilter } from "./classes/callbacks/PostGameEndFilter";
export { PostGameStartedReordered } from "./classes/callbacks/PostGameStartedReordered";
export { PostGameStartedReorderedLast } from "./classes/callbacks/PostGameStartedReorderedLast";
export { PostGreedModeWave } from "./classes/callbacks/PostGreedModeWave";
export { PostGridEntityBroken } from "./classes/callbacks/PostGridEntityBroken";
export { PostGridEntityCollision } from "./classes/callbacks/PostGridEntityCollision";
export { PostGridEntityCustomBroken } from "./classes/callbacks/PostGridEntityCustomBroken";
export { PostGridEntityCustomCollision } from "./classes/callbacks/PostGridEntityCustomCollision";
export { PostGridEntityCustomInit } from "./classes/callbacks/PostGridEntityCustomInit";
export { PostGridEntityCustomRemove } from "./classes/callbacks/PostGridEntityCustomRemove";
export { PostGridEntityCustomRender } from "./classes/callbacks/PostGridEntityCustomRender";
export { PostGridEntityCustomStateChanged } from "./classes/callbacks/PostGridEntityCustomStateChanged";
export { PostGridEntityCustomUpdate } from "./classes/callbacks/PostGridEntityCustomUpdate";
export { PostGridEntityInit } from "./classes/callbacks/PostGridEntityInit";
export { PostGridEntityRemove } from "./classes/callbacks/PostGridEntityRemove";
export { PostGridEntityRender } from "./classes/callbacks/PostGridEntityRender";
export { PostGridEntityStateChanged } from "./classes/callbacks/PostGridEntityStateChanged";
export { PostGridEntityUpdate } from "./classes/callbacks/PostGridEntityUpdate";
export { PostHolyMantleRemoved } from "./classes/callbacks/PostHolyMantleRemoved";
export { PostItemDischarge } from "./classes/callbacks/PostItemDischarge";
export { PostItemPickup } from "./classes/callbacks/PostItemPickup";
export { PostKeyboardChanged as PostKeyboardPressed } from "./classes/callbacks/PostKeyboardChanged";
export { PostKnifeInitFilter } from "./classes/callbacks/PostKnifeInitFilter";
export { PostKnifeInitLate } from "./classes/callbacks/PostKnifeInitLate";
export { PostKnifeRenderFilter } from "./classes/callbacks/PostKnifeRenderFilter";
export { PostKnifeUpdateFilter } from "./classes/callbacks/PostKnifeUpdateFilter";
export { PostLaserInitFilter } from "./classes/callbacks/PostLaserInitFilter";
export { PostLaserInitLate } from "./classes/callbacks/PostLaserInitLate";
export { PostLaserRenderFilter } from "./classes/callbacks/PostLaserRenderFilter";
export { PostLaserUpdateFilter } from "./classes/callbacks/PostLaserUpdateFilter";
export { PostNPCDeathFilter } from "./classes/callbacks/PostNPCDeathFilter";
export { PostNPCInitFilter } from "./classes/callbacks/PostNPCInitFilter";
export { PostNPCInitLate } from "./classes/callbacks/PostNPCInitLate";
export { PostNPCRenderFilter } from "./classes/callbacks/PostNPCRenderFilter";
export { PostNPCStateChanged } from "./classes/callbacks/PostNPCStateChanged";
export { PostNPCUpdateFilter } from "./classes/callbacks/PostNPCUpdateFilter";
export { PostNewLevelReordered } from "./classes/callbacks/PostNewLevelReordered";
export { PostNewRoomEarly } from "./classes/callbacks/PostNewRoomEarly";
export { PostNewRoomReordered } from "./classes/callbacks/PostNewRoomReordered";
export { PostPEffectUpdateReordered } from "./classes/callbacks/PostPEffectUpdateReordered";
export { PostPickupChanged } from "./classes/callbacks/PostPickupChanged";
export { PostPickupCollect } from "./classes/callbacks/PostPickupCollect";
export { PostPickupInitFilter } from "./classes/callbacks/PostPickupInitFilter";
export { PostPickupInitFirst } from "./classes/callbacks/PostPickupInitFirst";
export { PostPickupInitLate } from "./classes/callbacks/PostPickupInitLate";
export { PostPickupRenderFilter } from "./classes/callbacks/PostPickupRenderFilter";
export { PostPickupSelectionFilter } from "./classes/callbacks/PostPickupSelectionFilter";
export { PostPickupStateChanged } from "./classes/callbacks/PostPickupStateChanged";
export { PostPickupUpdateFilter } from "./classes/callbacks/PostPickupUpdateFilter";
export { PostPitRender } from "./classes/callbacks/PostPitRender";
export { PostPitUpdate } from "./classes/callbacks/PostPitUpdate";
export { PostPlayerChangeHealth } from "./classes/callbacks/PostPlayerChangeHealth";
export { PostPlayerChangeStat } from "./classes/callbacks/PostPlayerChangeStat";
export { PostPlayerChangeType } from "./classes/callbacks/PostPlayerChangeType";
export { PostPlayerCollectibleAdded } from "./classes/callbacks/PostPlayerCollectibleAdded";
export { PostPlayerCollectibleRemoved } from "./classes/callbacks/PostPlayerCollectibleRemoved";
export { PostPlayerFatalDamage } from "./classes/callbacks/PostPlayerFatalDamage";
export { PostPlayerInitFirst } from "./classes/callbacks/PostPlayerInitFirst";
export { PostPlayerInitLate } from "./classes/callbacks/PostPlayerInitLate";
export { PostPlayerRenderReordered } from "./classes/callbacks/PostPlayerRenderReordered";
export { PostPlayerUpdateReordered } from "./classes/callbacks/PostPlayerUpdateReordered";
export { PostPoopRender } from "./classes/callbacks/PostPoopRender";
export { PostPoopUpdate } from "./classes/callbacks/PostPoopUpdate";
export { PostPressurePlateRender } from "./classes/callbacks/PostPressurePlateRender";
export { PostPressurePlateUpdate } from "./classes/callbacks/PostPressurePlateUpdate";
export { PostProjectileInitFilter } from "./classes/callbacks/PostProjectileInitFilter";
export { PostProjectileInitLate } from "./classes/callbacks/PostProjectileInitLate";
export { PostProjectileKill } from "./classes/callbacks/PostProjectileKill";
export { PostProjectileRenderFilter } from "./classes/callbacks/PostProjectileRenderFilter";
export { PostProjectileUpdateFilter } from "./classes/callbacks/PostProjectileUpdateFilter";
export { PostPurchase } from "./classes/callbacks/PostPurchase";
export { PostRockRender } from "./classes/callbacks/PostRockRender";
export { PostRockUpdate } from "./classes/callbacks/PostRockUpdate";
export { PostRoomClearChanged } from "./classes/callbacks/PostRoomClearChanged";
export { PostSacrifice } from "./classes/callbacks/PostSacrifice";
export { PostSlotAnimationChanged } from "./classes/callbacks/PostSlotAnimationChanged";
export { PostSlotCollision } from "./classes/callbacks/PostSlotCollision";
export { PostSlotDestroyed } from "./classes/callbacks/PostSlotDestroyed";
export { PostSlotInit } from "./classes/callbacks/PostSlotInit";
export { PostSlotRender } from "./classes/callbacks/PostSlotRender";
export { PostSlotUpdate } from "./classes/callbacks/PostSlotUpdate";
export { PostSpikesRender } from "./classes/callbacks/PostSpikesRender";
export { PostSpikesUpdate } from "./classes/callbacks/PostSpikesUpdate";
export { PostTNTRender } from "./classes/callbacks/PostTNTRender";
export { PostTNTUpdate } from "./classes/callbacks/PostTNTUpdate";
export { PostTearInitFilter } from "./classes/callbacks/PostTearInitFilter";
export { PostTearInitLate } from "./classes/callbacks/PostTearInitLate";
export { PostTearInitVeryLate } from "./classes/callbacks/PostTearInitVeryLate";
export { PostTearKill } from "./classes/callbacks/PostTearKill";
export { PostTearRenderFilter } from "./classes/callbacks/PostTearRenderFilter";
export { PostTearUpdateFilter } from "./classes/callbacks/PostTearUpdateFilter";
export { PostTransformation } from "./classes/callbacks/PostTransformation";
export { PostTrinketBreak } from "./classes/callbacks/PostTrinketBreak";
export { PostUsePillFilter } from "./classes/callbacks/PostUsePillFilter";
export { PreBerserkDeath } from "./classes/callbacks/PreBerserkDeath";
export { PreBombCollisionFilter } from "./classes/callbacks/PreBombCollisionFilter";
export { PreCustomRevive } from "./classes/callbacks/PreCustomRevive";
export { PreEntitySpawnFilter } from "./classes/callbacks/PreEntitySpawnFilter";
export { PreFamiliarCollisionFilter } from "./classes/callbacks/PreFamiliarCollisionFilter";
export { PreGetPedestal } from "./classes/callbacks/PreGetPedestal";
export { PreItemPickup } from "./classes/callbacks/PreItemPickup";
export { PreKnifeCollisionFilter } from "./classes/callbacks/PreKnifeCollisionFilter";
export { PreNPCCollisionFilter } from "./classes/callbacks/PreNPCCollisionFilter";
export { PreNPCUpdateFilter } from "./classes/callbacks/PreNPCUpdateFilter";
export { PreNewLevel } from "./classes/callbacks/PreNewLevel";
export { PreProjectileCollisionFilter } from "./classes/callbacks/PreProjectileCollisionFilter";
export { PreRoomEntitySpawnFilter } from "./classes/callbacks/PreRoomEntitySpawnFilter";
export { PreTearCollisionFilter } from "./classes/callbacks/PreTearCollisionFilter";

----
callbacks.ts
import { MOD_CALLBACK_CUSTOM_VALUES } from "./cachedEnumValues";
import * as cc from "./callbackClasses";
import { ModCallbackCustom } from "./enums/ModCallbackCustom";
import type { AnyClass } from "./types/AnyClass";

const MOD_CALLBACK_CUSTOM_TO_CLASS = {
  [ModCallbackCustom.ENTITY_TAKE_DMG_FILTER]: cc.EntityTakeDmgFilter,
  [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER]: cc.EntityTakeDmgPlayer,
  [ModCallbackCustom.INPUT_ACTION_FILTER]: cc.InputActionFilter,
  [ModCallbackCustom.INPUT_ACTION_PLAYER]: cc.InputActionPlayer,
  [ModCallbackCustom.POST_AMBUSH_FINISHED]: cc.PostAmbushFinished,
  [ModCallbackCustom.POST_AMBUSH_STARTED]: cc.PostAmbushStarted,
  [ModCallbackCustom.POST_BOMB_EXPLODED]: cc.PostBombExploded,
  [ModCallbackCustom.POST_BOMB_INIT_FILTER]: cc.PostBombInitFilter,
  [ModCallbackCustom.POST_BOMB_INIT_LATE]: cc.PostBombInitLate,
  [ModCallbackCustom.POST_BOMB_RENDER_FILTER]: cc.PostBombRenderFilter,
  [ModCallbackCustom.POST_BOMB_UPDATE_FILTER]: cc.PostBombUpdateFilter,
  [ModCallbackCustom.POST_BONE_SWING]: cc.PostBoneSwing,
  [ModCallbackCustom.POST_COLLECTIBLE_EMPTY]: cc.PostCollectibleEmpty,
  [ModCallbackCustom.POST_CURSED_TELEPORT]: cc.PostCursedTeleport,
  [ModCallbackCustom.POST_CUSTOM_REVIVE]: cc.PostCustomRevive,
  [ModCallbackCustom.POST_DICE_ROOM_ACTIVATED]: cc.PostDiceRoomActivated,
  [ModCallbackCustom.POST_DOOR_RENDER]: cc.PostDoorRender,
  [ModCallbackCustom.POST_DOOR_UPDATE]: cc.PostDoorUpdate,
  [ModCallbackCustom.POST_EFFECT_INIT_FILTER]: cc.PostEffectInitFilter,
  [ModCallbackCustom.POST_EFFECT_INIT_LATE]: cc.PostEffectInitLate,
  [ModCallbackCustom.POST_EFFECT_RENDER_FILTER]: cc.PostEffectRenderFilter,
  [ModCallbackCustom.POST_EFFECT_STATE_CHANGED]: cc.PostEffectStateChanged,
  [ModCallbackCustom.POST_EFFECT_UPDATE_FILTER]: cc.PostEffectUpdateFilter,
  [ModCallbackCustom.POST_ENTITY_KILL_FILTER]: cc.PostEntityKillFilter,
  [ModCallbackCustom.POST_ESAU_JR]: cc.PostEsauJr,
  [ModCallbackCustom.POST_FAMILIAR_INIT_FILTER]: cc.PostFamiliarInitFilter,
  [ModCallbackCustom.POST_FAMILIAR_INIT_LATE]: cc.PostFamiliarInitLate,
  [ModCallbackCustom.POST_FAMILIAR_RENDER_FILTER]: cc.PostFamiliarRenderFilter,
  [ModCallbackCustom.POST_FAMILIAR_STATE_CHANGED]: cc.PostFamiliarStateChanged,
  [ModCallbackCustom.POST_FAMILIAR_UPDATE_FILTER]: cc.PostFamiliarUpdateFilter,
  [ModCallbackCustom.POST_FIRST_FLIP]: cc.PostFirstFlip,
  [ModCallbackCustom.POST_FIRST_ESAU_JR]: cc.PostFirstEsauJr,
  [ModCallbackCustom.POST_FLIP]: cc.PostFlip,
  [ModCallbackCustom.POST_GAME_END_FILTER]: cc.PostGameEndFilter,
  [ModCallbackCustom.POST_GAME_STARTED_REORDERED]: cc.PostGameStartedReordered,
  [ModCallbackCustom.POST_GAME_STARTED_REORDERED_LAST]:
    cc.PostGameStartedReorderedLast,
  [ModCallbackCustom.POST_GREED_MODE_WAVE]: cc.PostGreedModeWave,
  [ModCallbackCustom.POST_GRID_ENTITY_BROKEN]: cc.PostGridEntityBroken,
  [ModCallbackCustom.POST_GRID_ENTITY_COLLISION]: cc.PostGridEntityCollision,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_BROKEN]:
    cc.PostGridEntityCustomBroken,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_COLLISION]:
    cc.PostGridEntityCustomCollision,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_INIT]: cc.PostGridEntityCustomInit,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_REMOVE]:
    cc.PostGridEntityCustomRemove,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_RENDER]:
    cc.PostGridEntityCustomRender,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_STATE_CHANGED]:
    cc.PostGridEntityCustomStateChanged,
  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE]:
    cc.PostGridEntityCustomUpdate,
  [ModCallbackCustom.POST_GRID_ENTITY_INIT]: cc.PostGridEntityInit,
  [ModCallbackCustom.POST_GRID_ENTITY_REMOVE]: cc.PostGridEntityRemove,
  [ModCallbackCustom.POST_GRID_ENTITY_RENDER]: cc.PostGridEntityRender,
  [ModCallbackCustom.POST_GRID_ENTITY_STATE_CHANGED]:
    cc.PostGridEntityStateChanged,
  [ModCallbackCustom.POST_GRID_ENTITY_UPDATE]: cc.PostGridEntityUpdate,
  [ModCallbackCustom.POST_HOLY_MANTLE_REMOVED]: cc.PostHolyMantleRemoved,
  [ModCallbackCustom.POST_ITEM_DISCHARGE]: cc.PostItemDischarge,
  [ModCallbackCustom.POST_ITEM_PICKUP]: cc.PostItemPickup,
  [ModCallbackCustom.POST_KEYBOARD_CHANGED]: cc.PostKeyboardPressed,
  [ModCallbackCustom.POST_KNIFE_INIT_FILTER]: cc.PostKnifeInitFilter,
  [ModCallbackCustom.POST_KNIFE_INIT_LATE]: cc.PostKnifeInitLate,
  [ModCallbackCustom.POST_KNIFE_RENDER_FILTER]: cc.PostKnifeRenderFilter,
  [ModCallbackCustom.POST_KNIFE_UPDATE_FILTER]: cc.PostKnifeUpdateFilter,
  [ModCallbackCustom.POST_LASER_INIT_FILTER]: cc.PostLaserInitFilter,
  [ModCallbackCustom.POST_LASER_INIT_LATE]: cc.PostLaserInitLate,
  [ModCallbackCustom.POST_LASER_RENDER_FILTER]: cc.PostLaserRenderFilter,
  [ModCallbackCustom.POST_LASER_UPDATE_FILTER]: cc.PostLaserUpdateFilter,
  [ModCallbackCustom.POST_NEW_LEVEL_REORDERED]: cc.PostNewLevelReordered,
  [ModCallbackCustom.POST_NEW_ROOM_EARLY]: cc.PostNewRoomEarly,
  [ModCallbackCustom.POST_NEW_ROOM_REORDERED]: cc.PostNewRoomReordered,
  [ModCallbackCustom.POST_NPC_DEATH_FILTER]: cc.PostNPCDeathFilter,
  [ModCallbackCustom.POST_NPC_INIT_FILTER]: cc.PostNPCInitFilter,
  [ModCallbackCustom.POST_NPC_INIT_LATE]: cc.PostNPCInitLate,
  [ModCallbackCustom.POST_NPC_RENDER_FILTER]: cc.PostNPCRenderFilter,
  [ModCallbackCustom.POST_NPC_STATE_CHANGED]: cc.PostNPCStateChanged,
  [ModCallbackCustom.POST_NPC_UPDATE_FILTER]: cc.PostNPCUpdateFilter,
  [ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED]:
    cc.PostPEffectUpdateReordered,
  [ModCallbackCustom.POST_PICKUP_CHANGED]: cc.PostPickupChanged,
  [ModCallbackCustom.POST_PICKUP_COLLECT]: cc.PostPickupCollect,
  [ModCallbackCustom.POST_PICKUP_INIT_FILTER]: cc.PostPickupInitFilter,
  [ModCallbackCustom.POST_PICKUP_INIT_FIRST]: cc.PostPickupInitFirst,
  [ModCallbackCustom.POST_PICKUP_INIT_LATE]: cc.PostPickupInitLate,
  [ModCallbackCustom.POST_PICKUP_RENDER_FILTER]: cc.PostPickupRenderFilter,
  [ModCallbackCustom.POST_PICKUP_SELECTION_FILTER]:
    cc.PostPickupSelectionFilter,
  [ModCallbackCustom.POST_PICKUP_STATE_CHANGED]: cc.PostPickupStateChanged,
  [ModCallbackCustom.POST_PICKUP_UPDATE_FILTER]: cc.PostPickupUpdateFilter,
  [ModCallbackCustom.POST_PIT_RENDER]: cc.PostPitRender,
  [ModCallbackCustom.POST_PIT_UPDATE]: cc.PostPitUpdate,
  [ModCallbackCustom.POST_PLAYER_CHANGE_HEALTH]: cc.PostPlayerChangeHealth,
  [ModCallbackCustom.POST_PLAYER_CHANGE_STAT]: cc.PostPlayerChangeStat,
  [ModCallbackCustom.POST_PLAYER_CHANGE_TYPE]: cc.PostPlayerChangeType,
  [ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED]:
    cc.PostPlayerCollectibleAdded,
  [ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED]:
    cc.PostPlayerCollectibleRemoved,
  [ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE]: cc.PostPlayerFatalDamage,
  [ModCallbackCustom.POST_PLAYER_INIT_FIRST]: cc.PostPlayerInitFirst,
  [ModCallbackCustom.POST_PLAYER_INIT_LATE]: cc.PostPlayerInitLate,
  [ModCallbackCustom.POST_PLAYER_RENDER_REORDERED]:
    cc.PostPlayerRenderReordered,
  [ModCallbackCustom.POST_PLAYER_UPDATE_REORDERED]:
    cc.PostPlayerUpdateReordered,
  [ModCallbackCustom.POST_POOP_RENDER]: cc.PostPoopRender,
  [ModCallbackCustom.POST_POOP_UPDATE]: cc.PostPoopUpdate,
  [ModCallbackCustom.POST_PRESSURE_PLATE_RENDER]: cc.PostPressurePlateRender,
  [ModCallbackCustom.POST_PRESSURE_PLATE_UPDATE]: cc.PostPressurePlateUpdate,
  [ModCallbackCustom.POST_PROJECTILE_INIT_FILTER]: cc.PostProjectileInitFilter,
  [ModCallbackCustom.POST_PROJECTILE_INIT_LATE]: cc.PostProjectileInitLate,
  [ModCallbackCustom.POST_PROJECTILE_KILL]: cc.PostProjectileKill,
  [ModCallbackCustom.POST_PROJECTILE_RENDER_FILTER]:
    cc.PostProjectileRenderFilter,
  [ModCallbackCustom.POST_PROJECTILE_UPDATE_FILTER]:
    cc.PostProjectileUpdateFilter,
  [ModCallbackCustom.POST_PURCHASE]: cc.PostPurchase,
  [ModCallbackCustom.POST_ROCK_RENDER]: cc.PostRockRender,
  [ModCallbackCustom.POST_ROCK_UPDATE]: cc.PostRockUpdate,
  [ModCallbackCustom.POST_ROOM_CLEAR_CHANGED]: cc.PostRoomClearChanged,
  [ModCallbackCustom.POST_SACRIFICE]: cc.PostSacrifice,
  [ModCallbackCustom.POST_SLOT_ANIMATION_CHANGED]: cc.PostSlotAnimationChanged,
  [ModCallbackCustom.POST_SLOT_COLLISION]: cc.PostSlotCollision,
  [ModCallbackCustom.POST_SLOT_DESTROYED]: cc.PostSlotDestroyed,
  [ModCallbackCustom.POST_SLOT_INIT]: cc.PostSlotInit,
  [ModCallbackCustom.POST_SLOT_RENDER]: cc.PostSlotRender,
  [ModCallbackCustom.POST_SLOT_UPDATE]: cc.PostSlotUpdate,
  [ModCallbackCustom.POST_SPIKES_RENDER]: cc.PostSpikesRender,
  [ModCallbackCustom.POST_SPIKES_UPDATE]: cc.PostSpikesUpdate,
  [ModCallbackCustom.POST_TEAR_INIT_FILTER]: cc.PostTearInitFilter,
  [ModCallbackCustom.POST_TEAR_INIT_LATE]: cc.PostTearInitLate,
  [ModCallbackCustom.POST_TEAR_INIT_VERY_LATE]: cc.PostTearInitVeryLate,
  [ModCallbackCustom.POST_TEAR_KILL]: cc.PostTearKill,
  [ModCallbackCustom.POST_TEAR_RENDER_FILTER]: cc.PostTearRenderFilter,
  [ModCallbackCustom.POST_TEAR_UPDATE_FILTER]: cc.PostTearUpdateFilter,
  [ModCallbackCustom.POST_TNT_RENDER]: cc.PostTNTRender,
  [ModCallbackCustom.POST_TNT_UPDATE]: cc.PostTNTUpdate,
  [ModCallbackCustom.POST_TRANSFORMATION]: cc.PostTransformation,
  [ModCallbackCustom.POST_TRINKET_BREAK]: cc.PostTrinketBreak,
  [ModCallbackCustom.POST_USE_PILL_FILTER]: cc.PostUsePillFilter,
  [ModCallbackCustom.PRE_BERSERK_DEATH]: cc.PreBerserkDeath,
  [ModCallbackCustom.PRE_BOMB_COLLISION_FILTER]: cc.PreBombCollisionFilter,
  [ModCallbackCustom.PRE_CUSTOM_REVIVE]: cc.PreCustomRevive,
  [ModCallbackCustom.PRE_ENTITY_SPAWN_FILTER]: cc.PreEntitySpawnFilter,
  [ModCallbackCustom.PRE_FAMILIAR_COLLISION_FILTER]:
    cc.PreFamiliarCollisionFilter,
  [ModCallbackCustom.PRE_GET_PEDESTAL]: cc.PreGetPedestal,
  [ModCallbackCustom.PRE_ITEM_PICKUP]: cc.PreItemPickup,
  [ModCallbackCustom.PRE_KNIFE_COLLISION_FILTER]: cc.PreKnifeCollisionFilter,
  [ModCallbackCustom.PRE_NEW_LEVEL]: cc.PreNewLevel,
  [ModCallbackCustom.PRE_NPC_COLLISION_FILTER]: cc.PreNPCCollisionFilter,
  [ModCallbackCustom.PRE_NPC_UPDATE_FILTER]: cc.PreNPCUpdateFilter,
  [ModCallbackCustom.PRE_PROJECTILE_COLLISION_FILTER]:
    cc.PreProjectileCollisionFilter,
  [ModCallbackCustom.PRE_ROOM_ENTITY_SPAWN_FILTER]: cc.PreRoomEntitySpawnFilter,
  [ModCallbackCustom.PRE_TEAR_COLLISION_FILTER]: cc.PreTearCollisionFilter,
} as const satisfies Record<ModCallbackCustom, AnyClass>;

export type ModCallbackCustomToClass = {
  readonly [K in keyof typeof MOD_CALLBACK_CUSTOM_TO_CLASS]: InstanceType<
    (typeof MOD_CALLBACK_CUSTOM_TO_CLASS)[K]
  >;
};

export function getCallbacks(): ModCallbackCustomToClass {
  const instantiatedClasses: Record<number, unknown> = {};

  for (const modCallbackCustom of MOD_CALLBACK_CUSTOM_VALUES) {
    const constructor = MOD_CALLBACK_CUSTOM_TO_CLASS[modCallbackCustom];
    instantiatedClasses[modCallbackCustom] = new constructor();
  }

  return instantiatedClasses as unknown as ModCallbackCustomToClass;
}

----
classes\DefaultMap.ts
import { isFunction, isPrimitive } from "../functions/types";

/**
 * `DefaultMap` is a data structure that makes working with default values easier. It extends a
 * `Map` and adds additional methods.
 *
 * It is a common pattern to look up a value in a `Map`, and then, if the value does not exist, set
 * a default value for the key, and then return the default value. `DefaultMap` abstracts this
 * operation away by providing the `getAndSetDefault` method.
 *
 * Using a `DefaultMap` is nice because it makes code more declarative, since you specify what the
 * default value is alongside the types of the keys/values.
 *
 * When instantiating a new `DefaultMap`, you must specify default value as the first argument. (The
 * default value is the initial value that will be assigned to every new entry in the
 * `getAndSetDefault` method.) For example:
 *
 * ```ts
 * // Initializes a new empty DefaultMap with a default value of "foo".
 * const defaultMapWithString = new DefaultMap<string, string>("foo");
 *
 * const value = defaultMapWithString.getAndSetDefault("bar");
 * // value is now "foo" and an entry for "bar" is now set.
 * ```
 *
 * Sometimes, instead of having a static initial value for every entry in the map, you will want a
 * dynamic initial value that is contingent upon the key or some other variable. In these cases, you
 * can instead specify that the `DefaultMap` should run a function that will return the initial
 * value. (This is referred to as a "factory function".) For example:
 *
 * ```ts
 * // Initializes a new empty DefaultMap with a default value based on "someGlobalVariable".
 * const factoryFunction = () => someGlobalVariable ? 0 : 1;
 * const defaultMapWithFactoryFunction = new DefaultMap<string, string>(factoryFunction);
 * ```
 *
 * Note that in TypeScript and Lua, booleans, numbers, and strings are "passed by value". This means
 * that when the `DefaultMap` creates a new entry, if the default value is one of these 3 types, the
 * values will be copied. On the other hand, arrays and maps and other complex data structures are
 * "passed by reference". This means that when the `DefaultMap` creates a new entry, if the default
 * value is an array, then it would not be copied. Instead, the same shared array would be assigned
 * to every entry. Thus, to solve this problem, any variable that is passed by reference must be
 * created using a factory function to ensure that each copy is unique. For example:
 *
 * ```ts
 * // Initializes a new empty DefaultMap with a default value of a new empty array.
 * const factoryFunction = () => [];
 * const defaultMapWithArray = new DefaultMap<string, string[]>(factoryFunction);
 * ```
 *
 * In the previous two examples, the factory functions did not have any arguments. But you can also
 * specify a factory function that takes one or more arguments:
 *
 * ```ts
 * const factoryFunction = (arg: boolean) => arg ? 0 : 1;
 * const defaultMapWithArg = new DefaultMap<string, string, [arg: boolean]>(factoryFunction);
 * ```
 *
 * Similar to a normal `Map`, you can also include an initializer list in the constructor as the
 * second argument:
 *
 * ```ts
 * // Initializes a DefaultMap with a default value of "foo" and some initial values.
 * const defaultMapWithInitialValues = new DefaultMap<string, string>("foo", [
 *   ["a1", "a2"],
 *   ["b1", "b2"],
 * ], );
 * ```
 *
 * Finally, note that `DefaultMap` has the following additional utility methods:
 *
 * - `getAndSetDefault` - The method that is called inside the overridden `get` method. In most
 *   cases, you can use the overridden `get` method instead of calling this function directly.
 *   However, if a factory function was provided during instantiation, and the factory function has
 *   one or more arguments, then you must call this method instead (and provide the corresponding
 *   arguments).
 * - `getDefaultValue` - Returns the default value to be used for a new key. (If a factory function
 *   was provided during instantiation, this will execute the factory function.)
 * - `getConstructorArg` - Helper method for cloning the map. Returns either the default value or
 *   the reference to the factory function.
 */
export class DefaultMap<Key, Value, Args extends unknown[] = []> extends Map<
  Key,
  Value
> {
  private readonly defaultValue: Value | undefined;
  private readonly defaultValueFactory:
    | FactoryFunction<Value, Args>
    | undefined;

  /**
   * See the main `DefaultMap` documentation:
   * https://isaacscript.github.io/isaacscript-common/other/classes/DefaultMap
   */
  constructor(
    defaultValueOrFactoryFunction: Value | FactoryFunction<Value, Args>,
    initializerArray?: Iterable<[Key, Value]>,
  ) {
    const argIsPrimitive = isPrimitive(defaultValueOrFactoryFunction);
    const argIsFunction = isFunction(defaultValueOrFactoryFunction);
    if (!argIsPrimitive && !argIsFunction) {
      error(
        `Failed to instantiate a DefaultMap since the provided default value was of type "${typeof defaultValueOrFactoryFunction}". This error usually means that you are trying to use an array (or some other non-primitive data structure that is passed by reference) as the default value. Instead, return the data structure in a factory function, like "() => []". See the DefaultMap documentation for more details.`,
      );
    }

    super(initializerArray);

    if (argIsFunction) {
      this.defaultValue = undefined;
      this.defaultValueFactory = defaultValueOrFactoryFunction;
    } else {
      this.defaultValue = defaultValueOrFactoryFunction;
      this.defaultValueFactory = undefined;
    }
  }

  /**
   * If the key exists, this will return the same thing as the normal `Map.get` method. Otherwise,
   * it will set a default value for the provided key, and then return the default value.
   *
   * @allowEmptyVariadic
   */
  public getAndSetDefault(key: Key, ...args: Args): Value {
    const value = super.get(key);
    if (value !== undefined) {
      return value;
    }

    const defaultValue = this.getDefaultValue(...args);
    this.set(key, defaultValue);
    return defaultValue;
  }

  /**
   * Returns the default value to be used for a new key. (If a factory function was provided during
   * instantiation, this will execute the factory function.)
   */
  public getDefaultValue(...args: Args): Value {
    if (this.defaultValue !== undefined) {
      return this.defaultValue;
    }

    if (this.defaultValueFactory !== undefined) {
      return this.defaultValueFactory(...args);
    }

    error("A DefaultMap was incorrectly instantiated.");
  }

  /**
   * Helper method for cloning the map. Returns either the default value or a reference to the
   * factory function.
   */
  public getConstructorArg(): Value | FactoryFunction<Value, Args> {
    if (this.defaultValue !== undefined) {
      return this.defaultValue;
    }

    if (this.defaultValueFactory !== undefined) {
      return this.defaultValueFactory;
    }

    error("A DefaultMap was incorrectly instantiated.");
  }
}

// eslint-disable-next-line isaacscript/complete-sentences-jsdoc
/**
 * A function that creates the default value for your `DefaultMap`. For example, if it was a
 * `DefaultMap` containing maps, the factory function would be: `() => new Map()`
 */
export type FactoryFunction<V, Args extends unknown[]> = (...args: Args) => V;

/* eslint-disable @typescript-eslint/no-unused-vars */
function test() {
  // Boolean
  const myDefaultMapBoolean = new DefaultMap<string, boolean>(false);
  const myDefaultMapBooleanFactory = new DefaultMap<string, boolean>(
    () => false,
  );
  const myDefaultMapBooleanWithoutParams = new DefaultMap(false);

  // Number
  const myDefaultMapNumber = new DefaultMap<string, number>(123);
  const myDefaultMapNumberFactory = new DefaultMap<string, number>(() => 123);
  const myDefaultMapNumberWithoutParams = new DefaultMap(123);

  // String
  const myDefaultMapString = new DefaultMap<string, string>("foo");
  const myDefaultMapStringFactory = new DefaultMap<string, string>(() => "foo");
  const myDefaultMapStringWithoutParams = new DefaultMap("foo");

  // Array
  const myDefaultMapArray = new DefaultMap<string, string[]>(() => []);
  const myDefaultMapArrayWithoutParams = new DefaultMap(() => []);

  // Map
  const myDefaultMapMap = new DefaultMap<string, Map<string, string>>(
    () => new Map(),
  );
  const myDefaultMapMapWithoutParams = new DefaultMap(() => new Map());
}
/* eslint-enable @typescript-eslint/no-unused-vars */

----
classes\ModFeature.ts
import type {
  CallbackPriority,
  ModCallback,
} from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../enums/ModCallbackCustom";
import { isArray } from "../functions/array";
import {
  getTSTLClassConstructor,
  getTSTLClassName,
} from "../functions/tstlClass";
import { isFunction, isInteger, isTable } from "../functions/types";
import { assertDefined } from "../functions/utils";
import type { TSTLClassMetatable } from "../interfaces/TSTLClassMetatable";
import type { AnyFunction } from "../types/AnyFunction";
import type { ModUpgraded } from "./ModUpgraded";

export const MOD_FEATURE_CALLBACKS_KEY = "__callbacks";
export const MOD_FEATURE_CUSTOM_CALLBACKS_KEY = "__customCallbacks";
const WRAPPED_CALLBACK_METHODS_KEY = "__wrappedCallbackMethods";
const WRAPPED_CUSTOM_CALLBACK_METHODS_KEY = "__wrappedCustomCallbacksMethods";

type ModFeatureConstructor = TSTLClassMetatable["constructor"] & {
  [MOD_FEATURE_CALLBACKS_KEY]:
    | [
        modCallback: ModCallback,
        callbackFunc: AnyFunction,
        parameters: unknown[],
      ]
    | undefined;
  [MOD_FEATURE_CUSTOM_CALLBACKS_KEY]:
    | [
        modCallbackCustom: ModCallbackCustom,
        callbackFunc: AnyFunction,
        parameters: unknown[],
      ]
    | undefined;
  [WRAPPED_CALLBACK_METHODS_KEY]: Map<ModCallback, AnyFunction> | undefined;
  [WRAPPED_CUSTOM_CALLBACK_METHODS_KEY]:
    | Map<ModCallbackCustom, AnyFunction>
    | undefined;
};

/**
 * Helper class for mods that want to represent their individual features as classes. Extend your
 * mod features from this class in order to enable the `@Callback` and `@CustomCallback` decorators
 * that automatically subscribe to callbacks.
 *
 * It is recommended that you use the `initModFeatures` helper function to instantiate all of your
 * mod classes (instead of instantiating them yourself). This is so that any attached `v` objects
 * are properly registered with the save data manager; see below.
 *
 * If you are manually instantiating a mod feature yourself, then:
 *
 * - You must pass your upgraded mod as the first argument to the constructor.
 * - In almost all cases, you will want the callback functions to be immediately subscribed after
 *   instantiating the class. However, if this is not the case, you can pass `false` as the optional
 *   second argument to the constructor.
 *
 * If your mod feature has a property called `v`, it will be assumed that these are variables that
 * should be managed by the save data manager. Unfortunately, due to technical limitations with
 * classes, this registration will only occur if you initialize the class with the `initModFeatures`
 * helper function. (This is because the parent class does not have access to the child's properties
 * upon first construction.)
 */
export class ModFeature {
  private readonly mod: ModUpgraded;

  /**
   * An optional method that allows for conditional callback execution. If specified, any class
   * method that is annotated with a `@Callback` or `@CallbackCustom` decorator will only be fired
   * if the executed conditional function returns true.
   *
   * This property is used to easily turn entire mod features on and off (rather than repeating
   * conditional logic and early returning at the beginning of every callback function).
   *
   * Since the specific information for the firing callback is passed as arguments into the
   * conditional method, you can also write logic that would only apply to a specific type of
   * callback.
   *
   * By default, this is set to null, which means that all callback methods will fire
   * unconditionally. Override this property in your class if you need to use it.
   *
   * The function has the following signature:
   *
   * ```ts
   * <T extends boolean>(
   *   vanilla: T, // Whether this is a vanilla or custom callback.
   *   modCallback: T extends true ? ModCallback : ModCallbackCustom,
   *   ...callbackArgs: unknown[] // This would be e.g. `pickup: EntityPickup` for the `POST_PICKUP_INIT` callback.
   * ) => boolean;
   * ```
   */
  protected shouldCallbackMethodsFire:
    | (<T extends boolean>(
        vanilla: T,
        modCallback: T extends true ? ModCallback : ModCallbackCustom,
        ...callbackArgs: readonly unknown[]
      ) => boolean)
    | null = null;

  /**
   * Whether the feature has registered its callbacks yet.
   *
   * This will almost always be equal to true unless you explicitly passed `false` to the second
   * argument of the constructor.
   */
  public initialized = false;

  constructor(mod: ModUpgraded, init = true) {
    this.mod = mod;

    if (init) {
      this.init();
    }
  }

  /**
   * Runs the `Mod.AddCallback` and `ModUpgraded.AddCallbackCustom` methods for all of the decorated
   * callbacks. Also registers/unregisters the "v" variable on the save data manager.
   *
   * @param init Optional. Whether to initialize or uninitialize. Default is true.
   */
  public init(init = true): void {
    if (this.initialized === init) {
      return;
    }
    this.initialized = init;

    const constructor = getTSTLClassConstructor(this);
    assertDefined(
      constructor,
      "Failed to get the TSTL class constructor for a mod feature.",
    );

    const tstlClassName = getTSTLClassName(this);
    assertDefined(
      tstlClassName,
      "Failed to get the TSTL class name for a mod feature.",
    );

    initDecoratedCallbacks(this, constructor, tstlClassName, true, init);
    initDecoratedCallbacks(this, constructor, tstlClassName, false, init);
    initSaveDataManager(this, tstlClassName, init);
  }

  /**
   * Runs the `Mod.RemoveCallback` and `ModUpgraded.RemoveCallbackCustom` methods for all of the
   * decorated callbacks.
   *
   * This is just an alias for `ModFeature.init(false)`.
   */
  public uninit(): void {
    this.init(false);
  }
}

function initDecoratedCallbacks(
  modFeature: ModFeature,
  constructor: TSTLClassMetatable["constructor"],
  tstlClassName: string,
  vanilla: boolean,
  init: boolean,
) {
  const modFeatureConstructor = constructor as ModFeatureConstructor;
  const callbackTuplesKey = vanilla
    ? MOD_FEATURE_CALLBACKS_KEY
    : MOD_FEATURE_CUSTOM_CALLBACKS_KEY;
  const callbackTuples = modFeatureConstructor[callbackTuplesKey];
  if (callbackTuples === undefined) {
    return;
  }

  if (!isArray(callbackTuples)) {
    error(
      `Failed to initialize/uninitialize the decorated callbacks on a mod feature since the callback arguments on the key of "${callbackTuplesKey}" was not an array and was instead of type: ${type(
        callbackTuples,
      )}`,
    );
  }

  for (const callbackTuple of callbackTuples) {
    if (!isArray(callbackTuple)) {
      error(
        `Failed to initialize/uninitialize the decorated callbacks on a mod feature since one of the callback arguments on the key of "${callbackTuplesKey}" was not an array and was instead of type: ${type(
          callbackTuple,
        )}`,
      );
    }

    const modCallback = callbackTuple[0];
    if (!isInteger(modCallback)) {
      error(
        `Failed to get the callback number from the callback tuple for class: ${tstlClassName}`,
      );
    }

    const priority = callbackTuple[1];
    if (!isInteger(priority)) {
      error(
        `Failed to get the callback priority from the callback tuple for class: ${tstlClassName}`,
      );
    }

    const callback = callbackTuple[2];
    if (!isFunction(callback)) {
      error(
        `Failed to get the callback function from the callback tuple for class: ${tstlClassName}`,
      );
    }

    const parameters = callbackTuple[3];
    // We must pass false as the second argument to `isArray` since the callback parameters may not
    // necessarily be contiguous. (They might be separated by `undefined` values.)
    if (!isArray(parameters, false)) {
      error(
        `Failed to get the callback parameters from the callback tuple for class: ${tstlClassName}`,
      );
    }

    // eslint-disable-next-line @typescript-eslint/dot-notation, @typescript-eslint/prefer-destructuring
    const mod = modFeature["mod"];

    if (init) {
      addCallback(
        modFeature,
        modFeatureConstructor,
        mod,
        modCallback, // eslint-disable-line isaacscript/strict-enums
        priority,
        callback,
        parameters,
        vanilla,
      );
    } else {
      removeCallback(
        modFeatureConstructor,
        mod,
        modCallback, // eslint-disable-line isaacscript/strict-enums
        vanilla,
      );
    }
  }
}

function addCallback(
  modFeature: ModFeature,
  modFeatureConstructor: ModFeatureConstructor,
  mod: ModUpgraded,
  modCallback: ModCallback | ModCallbackCustom,
  priority: CallbackPriority | int,
  callback: Function, // eslint-disable-line @typescript-eslint/ban-types
  parameters: readonly unknown[],
  vanilla: boolean,
) {
  // We need to wrap the callback in a new function so that we can explicitly pass the class as the
  // first argument. (Otherwise, the method will not be able to properly access `this`.
  const wrappedCallback = (...callbackArgs: readonly unknown[]) => {
    // eslint-disable-next-line @typescript-eslint/dot-notation
    const conditionalFunc = modFeature["shouldCallbackMethodsFire"];
    if (conditionalFunc !== null) {
      const shouldRun = conditionalFunc(vanilla, modCallback, ...callbackArgs);
      if (!shouldRun) {
        return undefined;
      }
    }

    const castedCallback = callback as (
      this: void,
      ...args: readonly unknown[]
    ) => unknown;
    return castedCallback(modFeature, ...callbackArgs);
  };

  // We need to save the wrapped function for later (so we can unregister them).
  if (vanilla) {
    const modCallbackVanilla = modCallback as ModCallback;
    let wrappedMethodsMap = modFeatureConstructor[WRAPPED_CALLBACK_METHODS_KEY];
    if (wrappedMethodsMap === undefined) {
      wrappedMethodsMap = new Map();
      modFeatureConstructor[WRAPPED_CALLBACK_METHODS_KEY] = wrappedMethodsMap;
    }
    wrappedMethodsMap.set(modCallbackVanilla, wrappedCallback);
  } else {
    const modCallbackCustom = modCallback as ModCallbackCustom;
    let wrappedMethodsMap =
      modFeatureConstructor[WRAPPED_CUSTOM_CALLBACK_METHODS_KEY];
    if (wrappedMethodsMap === undefined) {
      wrappedMethodsMap = new Map();
      modFeatureConstructor[WRAPPED_CUSTOM_CALLBACK_METHODS_KEY] =
        wrappedMethodsMap;
    }
    wrappedMethodsMap.set(modCallbackCustom, wrappedCallback);
  }

  if (vanilla) {
    (mod.AddPriorityCallback as AnyFunction)(
      modCallback,
      priority,
      wrappedCallback,
      ...parameters,
    );
  } else {
    (mod.AddPriorityCallbackCustom as AnyFunction)(
      modCallback,
      priority,
      wrappedCallback,
      ...parameters,
    );
  }
}

function removeCallback(
  modFeatureConstructor: ModFeatureConstructor,
  mod: ModUpgraded,
  modCallback: ModCallback | ModCallbackCustom,
  vanilla: boolean,
) {
  if (vanilla) {
    const modCallbackVanilla = modCallback as ModCallback;
    const wrappedMethodsMap =
      modFeatureConstructor[WRAPPED_CALLBACK_METHODS_KEY];
    if (wrappedMethodsMap === undefined) {
      return;
    }

    const wrappedCallback = wrappedMethodsMap.get(modCallbackVanilla);
    (mod.RemoveCallback as AnyFunction)(modCallback, wrappedCallback);
  } else {
    const modCallbackCustom = modCallback as ModCallbackCustom;
    const wrappedMethodsMap =
      modFeatureConstructor[WRAPPED_CUSTOM_CALLBACK_METHODS_KEY];
    if (wrappedMethodsMap === undefined) {
      return;
    }

    const wrappedCallback = wrappedMethodsMap.get(modCallbackCustom);
    (mod.RemoveCallbackCustom as AnyFunction)(modCallback, wrappedCallback);
  }
}

/**
 * This will only work for end-users who are calling the `ModFeature.init` method explicitly. (See
 * the discussion in the `ModFeature` comment.)
 */
function initSaveDataManager(
  modFeature: ModFeature,
  tstlClassName: string,
  init: boolean,
) {
  // Do nothing if this class does not have any variables.
  const { v } = modFeature as unknown as Record<string, unknown>;
  if (v === undefined) {
    return;
  }

  if (!isTable(v)) {
    error(
      'Failed to initialize a mod feature class due to having a "v" property that is not an object. (The "v" property is supposed to be an object that holds the variables for the class, managed by the save data manager.)',
    );
  }

  // Do nothing if we have not enabled the save data manager.
  // eslint-disable-next-line @typescript-eslint/dot-notation
  const mod = modFeature["mod"] as unknown as Record<string, unknown>;
  const saveDataManagerMethodName = init
    ? "saveDataManager"
    : "saveDataManagerRemove";
  const saveDataManagerMethod = mod[saveDataManagerMethodName] as
    | AnyFunction
    | undefined;
  assertDefined(
    saveDataManagerMethod,
    'Failed to initialize a mod feature class due to having a "v" object and not having the save data manager initialized. You must pass "ISCFeature.SAVE_DATA_MANAGER" to the "upgradeMod" function.',
  );

  if (typeof saveDataManagerMethod !== "function") {
    error(
      `The "${saveDataManagerMethodName}" property of the "ModUpgraded" object was not a function.`,
    );
  }

  if (init) {
    saveDataManagerMethod(tstlClassName, v);
  } else {
    saveDataManagerMethod(tstlClassName);
  }
}

----
classes\ModUpgraded.ts
import { CallbackPriority, ModCallback } from "isaac-typescript-definitions";
import { getCallbacks } from "../callbacks";
import { EXPORTED_METHOD_NAMES_KEY } from "../decorators";
import { ISCFeature } from "../enums/ISCFeature";
import { ModCallbackCustom } from "../enums/ModCallbackCustom";
import { getFeatures } from "../features";
import { getElapsedTimeSince, getTime } from "../functions/debugFunctions";
import { isEnumValue } from "../functions/enums";
import { getParentFunctionDescription, log } from "../functions/log";
import {
  getTSTLClassConstructor,
  getTSTLClassName,
} from "../functions/tstlClass";
import { parseIntSafe } from "../functions/types";
import { assertDefined } from "../functions/utils";
import type { AddCallbackParametersCustom } from "../interfaces/private/AddCallbackParametersCustom";
import type { ModUpgradedInterface } from "../interfaces/private/ModUpgradedInterface";
import type { AnyFunction } from "../types/AnyFunction";
import type { FunctionTuple } from "../types/FunctionTuple";
import type { Feature } from "./private/Feature";

/**
 * `isaacscript-common` has many custom callbacks that you can use in your mods. Instead of
 * hijacking the vanilla `Mod` object, we provide a `ModUpgraded` object for you to use, which
 * extends the base class and adds a new method of `AddCallbackCustom`.
 *
 * To upgrade your mod, use the `upgradeMod` helper function.
 *
 * By specifying one or more optional features when upgrading your mod, you will get a version of
 * `ModUpgraded` that has extra methods corresponding to the features that were specified. (This
 * corresponds to the internal-type `ModUpgradedWithFeatures` type, which extends `ModUpgraded`.)
 */
export class ModUpgraded implements Mod {
  // -----------------
  // Vanilla variables
  // -----------------

  public Name: string;

  // ----------------
  // Custom variables
  // ----------------

  /** We store a copy of the original mod object so that we can re-implement its functions. */
  private readonly mod: Mod;

  private readonly debug: boolean;
  private readonly timeThreshold: float | undefined;

  private readonly callbacks;
  private readonly features;

  // -----------
  // Constructor
  // -----------

  constructor(mod: Mod, debug: boolean, timeThreshold?: float) {
    this.Name = mod.Name;
    this.mod = mod;
    this.debug = debug;
    this.timeThreshold = timeThreshold;
    this.callbacks = getCallbacks();
    this.features = getFeatures(
      this as unknown as ModUpgradedInterface,
      this.callbacks,
    );
  }

  // ---------------
  // Vanilla methods
  // ---------------

  public AddCallback<T extends keyof AddCallbackParameters | string>(
    modCallback: T,
    ...args: T extends keyof AddCallbackParameters
      ? AddCallbackParameters[T]
      : unknown[]
  ): void {
    this.AddPriorityCallback(modCallback, CallbackPriority.DEFAULT, ...args);
  }

  public AddPriorityCallback<T extends keyof AddCallbackParameters | string>(
    modCallback: T,
    priority: CallbackPriority | int,
    ...args: T extends keyof AddCallbackParameters
      ? AddCallbackParameters[T]
      : unknown[]
  ): void {
    if (this.debug) {
      const callback = args[0];
      const optionalArg = args[1];

      const parentFunctionDescription = getParentFunctionDescription();
      const customCallback = type(modCallback) === "string";
      const callbackName = customCallback
        ? `${modCallback} (custom callback)`
        : `ModCallback.${ModCallback[modCallback as ModCallback]}`;
      const signature =
        parentFunctionDescription === undefined
          ? callbackName
          : `${parentFunctionDescription} - ${callbackName}`;

      /**
       * We don't use the "log" helper function here since it will always show the same "unknown"
       * prefix.
       */
      const callbackWithLogger: typeof callback = (
        // @ts-expect-error The compiler is not smart enough to know that the callback args should
        // match the callback.
        ...callbackArgs: Parameters<typeof callback>
      ) => {
        const startTime = getTime();
        Isaac.DebugString(`${signature} - START`);

        // @ts-expect-error The compiler is not smart enough to know that the callback args should
        // match the callback.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const returnValue = callback(...callbackArgs);

        const elapsedTime = getElapsedTimeSince(startTime);
        if (
          this.timeThreshold === undefined ||
          this.timeThreshold <= elapsedTime
        ) {
          Isaac.DebugString(`${signature} - END - time: ${elapsedTime}`);
        } else {
          Isaac.DebugString(`${signature} - END`);
        }

        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return returnValue;
      };

      const newArgs = [callbackWithLogger, optionalArg];
      // @ts-expect-error The compiler is not smart enough to know that the callback args should
      // match the callback.
      this.mod.AddPriorityCallback(modCallback, priority, ...newArgs);
    } else {
      this.mod.AddPriorityCallback(modCallback, priority, ...args);
    }
  }

  public HasData(): boolean {
    return this.mod.HasData();
  }

  public LoadData(): string {
    return this.mod.LoadData();
  }

  public RemoveCallback<T extends ModCallback>(
    modCallback: T,
    callback: AddCallbackParameters[T][0],
  ): void {
    this.mod.RemoveCallback(modCallback, callback);
  }

  public RemoveData(): void {
    this.mod.RemoveData();
  }

  public SaveData(data: string): void {
    this.mod.SaveData(data);
  }

  // ---------------------
  // Custom public methods
  // ---------------------

  /**
   * Registers a function to be executed when an in-game event happens.
   *
   * This method is specifically for events that are provided by the IsaacScript standard library.
   * For example, the `ModCallbackCustom.POST_BOMB_EXPLODE` event corresponds to when a bomb
   * explodes.
   */
  public AddCallbackCustom<T extends ModCallbackCustom>(
    modCallbackCustom: T,
    ...args: AddCallbackParametersCustom[T]
  ): void {
    this.AddPriorityCallbackCustom(
      modCallbackCustom,
      CallbackPriority.DEFAULT,
      ...args,
    );
  }

  /**
   * The same as the `ModUpgraded.AddCallbackCustom` method, but allows setting a custom priority.
   * By default, callbacks are added with a priority of 0, so this allows you to add early or late
   * callbacks as necessary. See the `CallbackPriority` enum.
   */
  public AddPriorityCallbackCustom<T extends ModCallbackCustom>(
    modCallbackCustom: T,
    priority: CallbackPriority | int,
    ...args: AddCallbackParametersCustom[T]
  ): void {
    const callbackClass = this.callbacks[modCallbackCustom];
    // @ts-expect-error The compiler is not smart enough to figure out that the parameters match.
    // eslint-disable-next-line isaacscript/require-variadic-function-argument
    callbackClass.addSubscriber(priority, ...args);
    this.initFeature(callbackClass);
  }

  /**
   * Unregisters a function that was previously registered with the `AddCallbackCustom` method.
   *
   * This method is specifically for events that are provided by the IsaacScript standard library.
   * For example, the `ModCallbackCustom.POST_BOMB_EXPLODE` event corresponds to when a bomb
   * explodes.
   *
   * This method does not care about the tertiary argument. In other words, regardless of the
   * conditions of how you registered the callback, it will be removed.
   */
  public RemoveCallbackCustom<T extends ModCallbackCustom>(
    modCallbackCustom: T,
    callback: AddCallbackParametersCustom[T][0],
  ): void {
    const callbackClass = this.callbacks[modCallbackCustom];
    // @ts-expect-error The compiler is not smart enough to figure out that the parameters match.
    callbackClass.removeSubscriber(callback);
    this.uninitFeature(callbackClass);
  }

  /**
   * Logs every custom callback or extra feature that is currently enabled. Useful for debugging or
   * profiling.
   */
  public logUsedFeatures(): void {
    // Custom callbacks
    for (const [modCallbackCustomString, callbackClass] of Object.entries(
      this.callbacks,
    )) {
      if (callbackClass.numConsumers === 0) {
        continue;
      }

      const modCallbackCustom = parseIntSafe(modCallbackCustomString);
      assertDefined(
        modCallbackCustom,
        `Failed to convert the string "${modCallbackCustomString}" representing a "ModCallbackCustom" value to a number.`,
      );

      if (!isEnumValue(modCallbackCustom, ModCallbackCustom)) {
        error(
          `Failed to convert the number ${modCallbackCustom} to a "ModCallbackCustom" value.`,
        );
      }

      log(
        `- ModCallbackCustom.${ModCallbackCustom[modCallbackCustom]} (${modCallbackCustom})`,
      );
    }

    // Extra features
    for (const [iscFeatureString, featureClass] of Object.entries(
      this.features,
    )) {
      if (featureClass.numConsumers === 0) {
        continue;
      }

      const iscFeature = parseIntSafe(iscFeatureString);
      assertDefined(
        iscFeature,
        `Failed to convert the string "${iscFeatureString}" representing a "ISCFeature" value to a number.`,
      );

      if (!isEnumValue(iscFeature, ISCFeature)) {
        error(
          `Failed to convert the number ${iscFeature} to a "ISCFeature" value.`,
        );
      }

      log(`- ISCFeature.${ISCFeature[iscFeature]} (${iscFeature})`);
    }
  }

  // ----------------------
  // Custom private methods
  // ----------------------

  /**
   * This is used to initialize both custom callbacks and "extra features".
   *
   * This mirrors the `uninitFeature` method.
   */
  private initFeature(feature: Feature): void {
    feature.numConsumers++;

    if (feature.initialized) {
      return;
    }

    feature.initialized = true;

    if (feature.v !== undefined) {
      if (feature.featuresUsed === undefined) {
        feature.featuresUsed = [];
      }
      if (!feature.featuresUsed.includes(ISCFeature.SAVE_DATA_MANAGER)) {
        feature.featuresUsed.unshift(ISCFeature.SAVE_DATA_MANAGER);
      }
    }

    if (feature.featuresUsed !== undefined) {
      for (const featureUsed of feature.featuresUsed) {
        const featureClass = this.features[featureUsed];
        this.initFeature(featureClass);
      }
    }

    if (feature.callbacksUsed !== undefined) {
      for (const callbackTuple of feature.callbacksUsed) {
        const [modCallback, callbackFunc, optionalArgs] = callbackTuple;
        // TypeScript is not smart enough to know that the arguments match the function.
        (this.AddPriorityCallback as AnyFunction)(
          modCallback,
          CallbackPriority.IMPORTANT,
          callbackFunc,
          ...(optionalArgs ?? []),
        );
      }
    }

    if (feature.customCallbacksUsed !== undefined) {
      for (const callbackTuple of feature.customCallbacksUsed) {
        const [modCallback, callbackFunc, optionalArgs] = callbackTuple;
        // TypeScript is not smart enough to know that the arguments match the function.
        (this.AddPriorityCallbackCustom as AnyFunction)(
          modCallback,
          CallbackPriority.IMPORTANT,
          callbackFunc,
          ...(optionalArgs ?? []),
        );
      }
    }

    if (feature.v !== undefined) {
      const className = getTSTLClassName(feature);
      assertDefined(className, "Failed to get the name of a feature.");

      const saveDataManagerClass = this.features[ISCFeature.SAVE_DATA_MANAGER];
      saveDataManagerClass.saveDataManager(
        className,
        feature.v,
        feature.vConditionalFunc,
      );
    }
  }

  /**
   * This is used to uninitialize both custom callbacks and "extra features".
   *
   * This mirrors the `initFeature` method.
   */
  private uninitFeature(feature: Feature): void {
    if (feature.numConsumers <= 0) {
      const className = getTSTLClassName(feature) ?? "unknown";
      error(
        `Failed to uninit feature "${className}" since it has ${feature.numConsumers} consumers, which should never happen.`,
      );
    }

    if (!feature.initialized) {
      const className = getTSTLClassName(feature) ?? "unknown";
      error(
        `Failed to uninit feature "${className}" since it was not initialized, which should never happen.`,
      );
    }

    feature.numConsumers--;

    if (feature.numConsumers > 0) {
      return;
    }

    feature.initialized = false;

    if (feature.featuresUsed !== undefined) {
      for (const featureUsed of feature.featuresUsed) {
        const featureClass = this.features[featureUsed];
        this.uninitFeature(featureClass);
      }
    }

    if (feature.callbacksUsed !== undefined) {
      for (const callbackTuple of feature.callbacksUsed) {
        const [modCallback, callbackFunc] = callbackTuple;
        this.RemoveCallback(modCallback, callbackFunc);
      }
    }

    if (feature.customCallbacksUsed !== undefined) {
      for (const callbackTuple of feature.customCallbacksUsed) {
        const [modCallback, callbackFunc] = callbackTuple;
        this.RemoveCallbackCustom(modCallback, callbackFunc);
      }
    }

    if (feature.v !== undefined) {
      const className = getTSTLClassName(feature);
      assertDefined(className, "Failed to get the name of a feature.");

      const saveDataManagerClass = this.features[ISCFeature.SAVE_DATA_MANAGER];
      saveDataManagerClass.saveDataManagerRemove(className);
    }
  }

  /**
   * Returns the names of the exported class methods from the features that were added. This is
   * called from the "upgradeMod" function, but we want to mark it as private so that end-users
   * don't have access to it.
   */
  private initOptionalFeature(feature: ISCFeature): readonly FunctionTuple[] {
    const featureClass = this.features[feature];
    this.initFeature(featureClass);

    return getExportedMethodsFromFeature(featureClass);
  }
}

/**
 * In this context, "exported" methods are methods that are annotated with the "@Exported"
 * decorator, which signify that the method should be attached to the `ModUpgraded` class.
 *
 * Exported methods are stored in an internal static array on the class that is created by the
 * decorator.
 */
function getExportedMethodsFromFeature(
  featureClass: unknown,
): readonly FunctionTuple[] {
  const constructor = getTSTLClassConstructor(featureClass) as Record<
    string,
    unknown
  >;
  const exportedMethodNames = constructor[EXPORTED_METHOD_NAMES_KEY] as
    | string[]
    | undefined;

  if (exportedMethodNames === undefined) {
    return [];
  }

  return exportedMethodNames.map((name) => {
    const featureClassRecord = featureClass as Record<string, AnyFunction>;

    // We cannot split out the method to a separate variable or else the "self" parameter will not
    // be properly passed to the method.
    if (featureClassRecord[name] === undefined) {
      error(`Failed to find a decorated exported method: ${name}`);
    }

    // In order for "this" to work properly in the method, we have to wrap the method invocation in
    // an arrow function.
    const wrappedMethod = (...args: readonly unknown[]) =>
      // We use a non-null assertion since we have already validated that the function exists. (See
      // the above comment.)
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      featureClassRecord[name]!(...args);

    return [name, wrappedMethod];
  });
}

----
classes\callbacks\EntityTakeDmgFilter.ts
import type { DamageFlag } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class EntityTakeDmgFilter extends CustomCallback<ModCallbackCustom.ENTITY_TAKE_DMG_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 11
      [ModCallback.ENTITY_TAKE_DMG, this.entityTakeDmg],
    ];
  }

  protected override shouldFire = shouldFireEntity;

  // ModCallback.ENTITY_TAKE_DMG (11)
  private readonly entityTakeDmg = (
    entity: Entity,
    amount: number,
    damageFlags: BitFlags<DamageFlag>,
    source: EntityRef,
    countdownFrames: number,
  ) => this.fire(entity, amount, damageFlags, source, countdownFrames);
}

----
classes\callbacks\EntityTakeDmgPlayer.ts
import type { DamageFlag } from "isaac-typescript-definitions";
import { EntityType, ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class EntityTakeDmgPlayer extends CustomCallback<ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 11
      [
        ModCallback.ENTITY_TAKE_DMG,
        this.entityTakeDmgPlayer,
        [EntityType.PLAYER],
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallback.ENTITY_TAKE_DMG (11)
  private readonly entityTakeDmgPlayer = (
    entity: Entity,
    amount: number,
    damageFlags: BitFlags<DamageFlag>,
    source: EntityRef,
    countdownFrames: number,
  ) => {
    const player = entity.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    return this.fire(player, amount, damageFlags, source, countdownFrames);
  };
}

----
classes\callbacks\InputActionFilter.ts
import type { ButtonAction, InputHook } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.INPUT_ACTION_FILTER;

export class InputActionFilter extends CustomCallback<T> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 13
      [ModCallback.INPUT_ACTION, this.inputAction],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_entity, inputHook, buttonAction] = fireArgs;
    const [callbackInputHook, callbackButtonAction] = optionalArgs;

    return (
      (callbackInputHook === undefined || callbackInputHook === inputHook) &&
      (callbackButtonAction === undefined ||
        callbackButtonAction === buttonAction)
    );
  };

  // ModCallback.INPUT_ACTION (13)
  private readonly inputAction = (
    entity: Entity | undefined,
    inputHook: InputHook,
    buttonAction: ButtonAction,
  ): boolean | float | undefined => this.fire(entity, inputHook, buttonAction);
}

----
classes\callbacks\InputActionPlayer.ts
import type { ButtonAction, InputHook } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.INPUT_ACTION_PLAYER;

export class InputActionPlayer extends CustomCallback<T> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 13
      [ModCallback.INPUT_ACTION, this.inputAction],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [player, inputHook, buttonAction] = fireArgs;
    const [
      callbackPlayerVariant,
      callbackCharacter,
      callbackInputHook,
      callbackButtonAction,
    ] = optionalArgs;

    const character = player.GetPlayerType();

    return (
      (callbackPlayerVariant === undefined ||
        callbackPlayerVariant === player.Variant) &&
      (callbackCharacter === undefined || callbackCharacter === character) &&
      (callbackInputHook === undefined || callbackInputHook === inputHook) &&
      (callbackButtonAction === undefined ||
        callbackButtonAction === buttonAction)
    );
  };

  // ModCallback.INPUT_ACTION (13)
  private readonly inputAction = (
    entity: Entity | undefined,
    inputHook: InputHook,
    buttonAction: ButtonAction,
  ): boolean | float | undefined => {
    if (entity === undefined) {
      return undefined;
    }

    const player = entity.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    return this.fire(player, inputHook, buttonAction);
  };
}

----
classes\callbacks\PostAmbushFinished.ts
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getAmbushType } from "../../functions/ambush";
import { shouldFireAmbush } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    ambushDone: false,
  },
};

export class PostAmbushFinished extends CustomCallback<ModCallbackCustom.POST_AMBUSH_FINISHED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireAmbush;

  private readonly postUpdate = (): void => {
    if (v.room.ambushDone) {
      return;
    }

    const room = game.GetRoom();
    const ambushDone = room.IsAmbushDone();
    if (!ambushDone) {
      return;
    }
    v.room.ambushDone = true;

    const ambushType = getAmbushType();
    if (ambushType !== undefined) {
      this.fire(ambushType);
    }
  };
}

----
classes\callbacks\PostAmbushStarted.ts
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getAmbushType } from "../../functions/ambush";
import { shouldFireAmbush } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    ambushActive: false,
  },
};

export class PostAmbushStarted extends CustomCallback<ModCallbackCustom.POST_AMBUSH_STARTED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireAmbush;

  private readonly postUpdate = (): void => {
    if (v.room.ambushActive) {
      return;
    }

    const room = game.GetRoom();
    const ambushActive = room.IsAmbushActive();
    if (!ambushActive) {
      return;
    }
    v.room.ambushActive = true;

    const ambushType = getAmbushType();
    if (ambushType !== undefined) {
      this.fire(ambushType);
    }
  };
}

----
classes\callbacks\PostBombExploded.ts
import { ModCallback } from "isaac-typescript-definitions";
import { BOMB_EXPLODE_FRAME } from "../../core/constants";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostBombExploded extends CustomCallback<ModCallbackCustom.POST_BOMB_EXPLODED> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 58
      [ModCallback.POST_BOMB_UPDATE, this.postBombUpdate],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.POST_BOMB_UPDATE (58)
  private readonly postBombUpdate = (bomb: EntityBomb): void => {
    if (bomb.FrameCount === BOMB_EXPLODE_FRAME) {
      this.fire(bomb);
    }
  };
}

----
classes\callbacks\PostBombInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostBombInitFilter extends CustomCallback<ModCallbackCustom.POST_BOMB_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 57
      [ModCallback.POST_BOMB_INIT, this.postBombInit],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.POST_BOMB_INIT (57)
  private readonly postBombInit = (bomb: EntityBomb) => {
    this.fire(bomb);
  };
}

----
classes\callbacks\PostBombInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostBombInitLate extends CustomCallback<ModCallbackCustom.POST_BOMB_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 58
      [ModCallback.POST_BOMB_UPDATE, this.postBombUpdate],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.POST_BOMB_UPDATE (58)
  private readonly postBombUpdate = (bomb: EntityBomb): void => {
    const ptrHash = GetPtrHash(bomb);
    if (!v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(bomb);
    }
  };
}

----
classes\callbacks\PostBombRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostBombRenderFilter extends CustomCallback<ModCallbackCustom.POST_BOMB_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 59
      [ModCallback.POST_BOMB_RENDER, this.postBombUpdate],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.POST_BOMB_RENDER (59)
  private readonly postBombUpdate = (
    bomb: EntityBomb,
    renderOffset: Vector,
  ) => {
    this.fire(bomb, renderOffset);
  };
}

----
classes\callbacks\PostBombUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostBombUpdateFilter extends CustomCallback<ModCallbackCustom.POST_BOMB_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 58
      [ModCallback.POST_BOMB_UPDATE, this.postBombUpdate],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.POST_BOMB_UPDATE (58)
  private readonly postBombUpdate = (bomb: EntityBomb) => {
    this.fire(bomb);
  };
}

----
classes\callbacks\PostBoneSwing.ts
import { KnifeVariant, ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { ReadonlySet } from "../../types/ReadonlySet";
import { CustomCallback } from "../private/CustomCallback";

const BONE_SWING_ANIMATIONS = new ReadonlySet<string>([
  "Swing",
  "Swing2",
  "Spin",
]);

const v = {
  room: {
    boneClubAnimations: new Map<PtrHash, string>(),
  },
};

export class PostBoneSwing extends CustomCallback<ModCallbackCustom.POST_BONE_SWING> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 52
      [ModCallback.POST_KNIFE_RENDER, this.postKnifeRender],
    ];
  }

  // ModCallback.POST_KNIFE_RENDER (52)
  private readonly postKnifeRender = (knife: EntityKnife): void => {
    // The tertiary argument of the `POST_KNIFE_RENDER` callback takes sub-types instead of knife
    // variants.
    if (knife.Variant === KnifeVariant.BONE_CLUB) {
      this.postKnifeRenderBoneClub(knife);
    }
  };

  // ModCallback.POST_KNIFE_RENDER (52)
  // KnifeVariant.BONE_CLUB (1)
  private postKnifeRenderBoneClub(knife: EntityKnife): void {
    const sprite = knife.GetSprite();
    const animation = sprite.GetAnimation();
    const ptrHash = GetPtrHash(knife);

    const animationOnLastFrame = v.room.boneClubAnimations.get(ptrHash);
    v.room.boneClubAnimations.set(ptrHash, animation);

    if (
      animationOnLastFrame !== undefined &&
      animation !== animationOnLastFrame
    ) {
      this.boneClubAnimationChanged(knife, animation);
    }
  }

  private boneClubAnimationChanged(
    knife: EntityKnife,
    animation: string,
  ): void {
    if (BONE_SWING_ANIMATIONS.has(animation)) {
      this.fire(knife);
    }
  }
}

----
classes\callbacks\PostCollectibleEmpty.ts
import {
  CollectibleType,
  ModCallback,
  PickupVariant,
} from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_COLLECTIBLE_EMPTY;

const v = {
  room: {
    collectibleTypeMap: new Map<PtrHash, CollectibleType>(),
  },
};

export class PostCollectibleEmpty extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 35
      [
        ModCallback.POST_PICKUP_UPDATE,
        this.postPickupUpdateCollectible,
        [PickupVariant.COLLECTIBLE],
      ],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_collectible, oldCollectibleType] = fireArgs;
    const [callbackCollectibleType] = optionalArgs;

    return (
      callbackCollectibleType === undefined ||
      callbackCollectibleType === oldCollectibleType
    );
  };

  // ModCallback.POST_PICKUP_UPDATE (35)
  // PickupVariant.COLLECTIBLE (100)
  private readonly postPickupUpdateCollectible = (
    pickup: EntityPickup,
  ): void => {
    const collectible = pickup as EntityPickupCollectible;

    const ptrHash = GetPtrHash(collectible);
    let oldCollectibleType = v.room.collectibleTypeMap.get(ptrHash);
    if (oldCollectibleType === undefined) {
      oldCollectibleType = collectible.SubType;
    }
    v.room.collectibleTypeMap.set(ptrHash, collectible.SubType);

    if (oldCollectibleType !== collectible.SubType) {
      this.collectibleTypeChanged(collectible, oldCollectibleType);
    }
  };

  private collectibleTypeChanged(
    collectible: EntityPickupCollectible,
    oldCollectibleType: CollectibleType,
  ): void {
    if (collectible.SubType === CollectibleType.NULL) {
      this.fire(collectible, oldCollectibleType);
    }
  }
}

----
classes\callbacks\PostCursedTeleport.ts
import {
  CollectibleType,
  DamageFlag,
  PlayerVariant,
  RoomType,
  TrinketType,
} from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { hasFlag } from "../../functions/flag";
import { onGameFrame } from "../../functions/frames";
import {
  mapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import { getPlayerNumHitsRemaining } from "../../functions/players";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersDamageFrameMap: new Map<
      PlayerIndex,
      [lastDamageFrame: int, callbackFiredOnThisFrame: boolean]
    >(),
  },

  level: {
    numSacrifices: 0,
  },
};

export class PostCursedTeleport extends CustomCallback<ModCallbackCustom.POST_CURSED_TELEPORT> {
  public override v = v;

  protected override shouldFire = shouldFirePlayer;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
      [
        ModCallbackCustom.POST_PLAYER_RENDER_REORDERED,
        this.postPlayerRenderReorderedPlayer,
        [PlayerVariant.PLAYER], // Co-op babies cannot perform Cursed Eye teleports.
      ],
    ];
  }

  // ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER
  private readonly entityTakeDmgPlayer = (
    player: EntityPlayer,
    _amount: float,
    damageFlags: BitFlags<DamageFlag>,
    _source: EntityRef,
    _countdownFrames: int,
  ): boolean | undefined => {
    this.incrementNumSacrifices(damageFlags); // Has to be before setting the damage frame.
    this.setDamageFrame(player, damageFlags);

    return undefined;
  };

  private incrementNumSacrifices(damageFlags: BitFlags<DamageFlag>): void {
    const room = game.GetRoom();
    const roomType = room.GetType();
    const isSpikeDamage = hasFlag(damageFlags, DamageFlag.SPIKES);

    if (roomType === RoomType.SACRIFICE && isSpikeDamage) {
      v.level.numSacrifices++;
    }
  }

  private setDamageFrame(
    player: EntityPlayer,
    damageFlags: BitFlags<DamageFlag>,
  ): void {
    const gameFrameCount = game.GetFrameCount();

    // Don't do anything if we already activated the callback on this frame.
    const trackingArray = mapGetPlayer(v.run.playersDamageFrameMap, player);
    if (trackingArray !== undefined) {
      const [lastDamageFrame, callbackFiredOnThisFrame] = trackingArray;
      if (lastDamageFrame === gameFrameCount && callbackFiredOnThisFrame) {
        return;
      }
    }

    // Don't do anything if this could be a Sacrifice Room teleport.
    if (this.isPotentialNaturalTeleportFromSacrificeRoom(damageFlags)) {
      return;
    }

    const newTrackingArray = [gameFrameCount, false];
    mapSetPlayer(v.run.playersDamageFrameMap, player, newTrackingArray);
  }

  private isPotentialNaturalTeleportFromSacrificeRoom(
    damageFlags: BitFlags<DamageFlag>,
  ): boolean {
    const room = game.GetRoom();
    const roomType = room.GetType();
    const isSpikeDamage = hasFlag(damageFlags, DamageFlag.SPIKES);

    // Don't record the frame if we are potentially going to the Angel Room or the Dark Room from a
    // Sacrifice Room.
    return (
      roomType === RoomType.SACRIFICE &&
      isSpikeDamage &&
      (v.level.numSacrifices === 6 || v.level.numSacrifices >= 12)
    );
  }

  // ModCallbackCustom.POST_PLAYER_RENDER_REORDERED
  // PlayerVariant.PLAYER (0)
  private readonly postPlayerRenderReorderedPlayer = (
    player: EntityPlayer,
    _renderOffset: Vector,
  ): void => {
    // Retrieve information about this player.
    const trackingArray = mapGetPlayer(v.run.playersDamageFrameMap, player);
    if (trackingArray === undefined) {
      return;
    }
    const [lastDamageFrame, callbackActivatedOnThisFrame] = trackingArray;

    if (!this.playerIsTeleportingFromCursedTeleport(player, lastDamageFrame)) {
      return;
    }

    // Do nothing if the callback already fired on this frame.
    if (callbackActivatedOnThisFrame) {
      return;
    }

    const gameFrameCount = game.GetFrameCount();
    const newTrackingArray = [gameFrameCount, true];
    mapSetPlayer(v.run.playersDamageFrameMap, player, newTrackingArray);

    this.fire(player);
  };

  private playerIsTeleportingFromCursedTeleport(
    player: EntityPlayer,
    lastDamageFrame: int,
  ) {
    // Check to see if this is the frame that we last took damage.
    if (!onGameFrame(lastDamageFrame)) {
      return false;
    }

    // Check to see if this is the 1st frame that we are teleporting.
    const sprite = player.GetSprite();
    if (
      !sprite.IsPlaying("TeleportUp") ||
      sprite.GetFrame() !== 1 // The 0th frame never fires
    ) {
      return false;
    }

    if (player.HasCollectible(CollectibleType.CURSED_EYE)) {
      return true;
    }

    const numHitsRemaining = getPlayerNumHitsRemaining(player);
    if (player.HasTrinket(TrinketType.CURSED_SKULL) && numHitsRemaining === 1) {
      return true;
    }

    return false;
  }
}

----
classes\callbacks\PostCustomRevive.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_CUSTOM_REVIVE;

export class PostCustomRevive extends CustomCallback<ModCallbackCustom.POST_CUSTOM_REVIVE> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.CUSTOM_REVIVE];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_player, revivalType] = fireArgs;
    const [callbackRevivalType] = optionalArgs;

    return (
      callbackRevivalType === undefined || revivalType === callbackRevivalType
    );
  };
}

----
classes\callbacks\PostDiceRoomActivated.ts
import type { DiceFloorSubType } from "isaac-typescript-definitions";
import { EffectVariant, ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isCloseEnoughToTriggerDiceFloor } from "../../functions/effects";
import { getClosestPlayer } from "../../functions/players";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_DICE_ROOM_ACTIVATED;

const v = {
  room: {
    diceRoomActivated: false,
  },
};

export class PostDiceRoomActivated extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 55
      [
        ModCallback.POST_EFFECT_UPDATE,
        this.postEffectUpdateDiceFloor,
        [EffectVariant.DICE_FLOOR],
      ],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_player, diceFloorSubType] = fireArgs;
    const [callbackDiceFloorSubType] = optionalArgs;

    return (
      callbackDiceFloorSubType === undefined ||
      diceFloorSubType === callbackDiceFloorSubType
    );
  };

  // ModCallback.POST_EFFECT_UPDATE (55)
  // EffectVariant.DICE_FLOOR (76)
  private readonly postEffectUpdateDiceFloor = (effect: EntityEffect): void => {
    if (v.room.diceRoomActivated) {
      return;
    }

    // When using the debug console to go to a dice room, the player can appear on top of the dice
    // floor before they snap to the door.
    if (effect.FrameCount === 0) {
      return;
    }

    const closestPlayer = getClosestPlayer(effect.Position);
    if (isCloseEnoughToTriggerDiceFloor(closestPlayer, effect)) {
      v.room.diceRoomActivated = true;
      this.fire(closestPlayer, effect.SubType as DiceFloorSubType);
    }
  };
}

----
classes\callbacks\PostDoorRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getDoors } from "../../functions/doors";
import { shouldFireDoor } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostDoorRender extends CustomCallback<ModCallbackCustom.POST_DOOR_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFireDoor;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const door of getDoors()) {
      this.fire(door);
    }
  };
}

----
classes\callbacks\PostDoorUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getDoors } from "../../functions/doors";
import { shouldFireDoor } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostDoorUpdate extends CustomCallback<ModCallbackCustom.POST_DOOR_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireDoor;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const door of getDoors()) {
      this.fire(door);
    }
  };
}

----
classes\callbacks\PostEffectInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEffect } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostEffectInitFilter extends CustomCallback<ModCallbackCustom.POST_EFFECT_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 54
      [ModCallback.POST_EFFECT_INIT, this.postEffectInit],
    ];
  }

  protected override shouldFire = shouldFireEffect;

  // ModCallback.POST_EFFECT_INIT (54)
  private readonly postEffectInit = (effect: EntityEffect) => {
    this.fire(effect);
  };
}

----
classes\callbacks\PostEffectInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEffect } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostEffectInitLate extends CustomCallback<ModCallbackCustom.POST_EFFECT_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 55
      [ModCallback.POST_EFFECT_UPDATE, this.postEffectUpdate],
    ];
  }

  protected override shouldFire = shouldFireEffect;

  // ModCallback.POST_EFFECT_UPDATE (55)
  private readonly postEffectUpdate = (effect: EntityEffect): void => {
    const index = GetPtrHash(effect);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(effect);
    }
  };
}

----
classes\callbacks\PostEffectRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEffect } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostEffectRenderFilter extends CustomCallback<ModCallbackCustom.POST_EFFECT_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 56
      [ModCallback.POST_EFFECT_RENDER, this.postEffectRender],
    ];
  }

  protected override shouldFire = shouldFireEffect;

  // ModCallback.POST_EFFECT_RENDER (56)
  private readonly postEffectRender = (
    effect: EntityEffect,
    renderOffset: Vector,
  ) => {
    this.fire(effect, renderOffset);
  };
}

----
classes\callbacks\PostEffectStateChanged.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEffect } from "../../shouldFire";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    stateMap: new DefaultMap<PtrHash, int, [int]>((state) => state),
  },
};

export class PostEffectStateChanged extends CustomCallback<ModCallbackCustom.POST_EFFECT_STATE_CHANGED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 55
      [ModCallback.POST_EFFECT_UPDATE, this.postEffectUpdate],
    ];
  }

  protected override shouldFire = shouldFireEffect;

  // ModCallback.POST_EFFECT_UPDATE (55)
  private readonly postEffectUpdate = (effect: EntityEffect): void => {
    const ptrHash = GetPtrHash(effect);
    const previousState = v.run.stateMap.getAndSetDefault(
      ptrHash,
      effect.State,
    );
    const currentState = effect.State;
    v.run.stateMap.set(ptrHash, currentState);

    if (previousState !== currentState) {
      this.fire(effect, previousState, currentState);
    }
  };
}

----
classes\callbacks\PostEffectUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEffect } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostEffectUpdateFilter extends CustomCallback<ModCallbackCustom.POST_EFFECT_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 55
      [ModCallback.POST_EFFECT_UPDATE, this.postEffectUpdate],
    ];
  }

  protected override shouldFire = shouldFireEffect;

  // ModCallback.POST_EFFECT_UPDATE (55)
  private readonly postEffectUpdate = (effect: EntityEffect) => {
    this.fire(effect);
  };
}

----
classes\callbacks\PostEntityKillFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostEntityKillFilter extends CustomCallback<ModCallbackCustom.POST_ENTITY_KILL_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 68
      [ModCallback.POST_ENTITY_KILL, this.postEntityKill],
    ];
  }

  protected override shouldFire = shouldFireEntity;

  // ModCallback.POST_ENTITY_KILL (68)
  private readonly postEntityKill = (entity: Entity) => {
    this.fire(entity);
  };
}

----
classes\callbacks\PostEsauJr.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { CustomCallback } from "../private/CustomCallback";

export class PostEsauJr extends CustomCallback<ModCallbackCustom.POST_ESAU_JR> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.ESAU_JR_DETECTION];
  }
}

----
classes\callbacks\PostFamiliarInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostFamiliarInitFilter extends CustomCallback<ModCallbackCustom.POST_FAMILIAR_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 7
      [ModCallback.POST_FAMILIAR_INIT, this.postFamiliarInit],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.POST_FAMILIAR_INIT (7)
  private readonly postFamiliarInit = (familiar: EntityFamiliar) => {
    this.fire(familiar);
  };
}

----
classes\callbacks\PostFamiliarInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostFamiliarInitLate extends CustomCallback<ModCallbackCustom.POST_FAMILIAR_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 6
      [ModCallback.POST_FAMILIAR_UPDATE, this.postFamiliarUpdate],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.POST_FAMILIAR_UPDATE (6)
  private readonly postFamiliarUpdate = (familiar: EntityFamiliar): void => {
    const index = GetPtrHash(familiar);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(familiar);
    }
  };
}

----
classes\callbacks\PostFamiliarRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostFamiliarRenderFilter extends CustomCallback<ModCallbackCustom.POST_FAMILIAR_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 25
      [ModCallback.POST_FAMILIAR_RENDER, this.postFamiliarRender],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.POST_FAMILIAR_UPDATE (6)
  private readonly postFamiliarRender = (
    familiar: EntityFamiliar,
    renderOffset: Vector,
  ) => {
    this.fire(familiar, renderOffset);
  };
}

----
classes\callbacks\PostFamiliarStateChanged.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    stateMap: new DefaultMap<PtrHash, int, [int]>((state) => state),
  },
};

export class PostFamiliarStateChanged extends CustomCallback<ModCallbackCustom.POST_FAMILIAR_STATE_CHANGED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 6
      [ModCallback.POST_FAMILIAR_UPDATE, this.postFamiliarUpdate],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.POST_FAMILIAR_UPDATE (6)
  private readonly postFamiliarUpdate = (familiar: EntityFamiliar): void => {
    const ptrHash = GetPtrHash(familiar);
    const previousState = v.run.stateMap.getAndSetDefault(
      ptrHash,
      familiar.State,
    );
    const currentState = familiar.State;
    v.run.stateMap.set(ptrHash, currentState);

    if (previousState !== currentState) {
      this.fire(familiar, previousState, currentState);
    }
  };
}

----
classes\callbacks\PostFamiliarUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostFamiliarUpdateFilter extends CustomCallback<ModCallbackCustom.POST_FAMILIAR_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 6
      [ModCallback.POST_FAMILIAR_UPDATE, this.postFamiliarUpdate],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.POST_FAMILIAR_UPDATE (6)
  private readonly postFamiliarUpdate = (familiar: EntityFamiliar) => {
    this.fire(familiar);
  };
}

----
classes\callbacks\PostFirstEsauJr.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { CustomCallback } from "../private/CustomCallback";

export class PostFirstEsauJr extends CustomCallback<ModCallbackCustom.POST_FIRST_ESAU_JR> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.ESAU_JR_DETECTION];
  }
}

----
classes\callbacks\PostFirstFlip.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { CustomCallback } from "../private/CustomCallback";

export class PostFirstFlip extends CustomCallback<ModCallbackCustom.POST_FIRST_FLIP> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.FLIP_DETECTION];
  }
}

----
classes\callbacks\PostFlip.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { CustomCallback } from "../private/CustomCallback";

export class PostFlip extends CustomCallback<ModCallbackCustom.POST_FLIP> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.FLIP_DETECTION];
  }
}

----
classes\callbacks\PostGameEndFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBoolean } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGameEndFilter extends CustomCallback<ModCallbackCustom.POST_GAME_END_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 16
      [ModCallback.POST_GAME_END, this.postGameEnd],
    ];
  }

  protected override shouldFire = shouldFireBoolean;

  // ModCallback.POST_GAME_END (16)
  private readonly postGameEnd = (isGameOver: boolean) => {
    this.fire(isGameOver);
  };
}

----
classes\callbacks\PostGameStartedReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBoolean } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGameStartedReordered extends CustomCallback<ModCallbackCustom.POST_GAME_STARTED_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GAME_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFireBoolean;
}

----
classes\callbacks\PostGameStartedReorderedLast.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBoolean } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGameStartedReorderedLast extends CustomCallback<ModCallbackCustom.POST_GAME_STARTED_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GAME_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFireBoolean;
}

----
classes\callbacks\PostGreedModeWave.ts
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    currentGreedWave: 0,
  },
};

export class PostGreedModeWave extends CustomCallback<ModCallbackCustom.POST_GREED_MODE_WAVE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    if (!game.IsGreedMode()) {
      return;
    }

    const level = game.GetLevel();
    const newWave = level.GreedModeWave;
    const oldWave = v.run.currentGreedWave;
    v.run.currentGreedWave = newWave;

    if (newWave > oldWave) {
      this.fire(oldWave, newWave);
    }
  };
}

----
classes\callbacks\PostGridEntityBroken.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityBroken extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_BROKEN> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntity;
}

----
classes\callbacks\PostGridEntityCollision.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_GRID_ENTITY_COLLISION;

export class PostGridEntityCollision extends CustomCallback<T> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_COLLISION_DETECTION];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [gridEntity, entity] = fireArgs;
    const [
      callbackGridEntityType,
      callbackGridEntityVariant,
      callbackEntityType,
      callbackEntityVariant,
      callbackEntitySubType,
    ] = optionalArgs;

    const gridEntityType = gridEntity.GetType();
    const gridEntityVariant = gridEntity.GetVariant();

    return (
      (callbackGridEntityType === undefined ||
        callbackGridEntityType === gridEntityType) &&
      (callbackGridEntityVariant === undefined ||
        callbackGridEntityVariant === gridEntityVariant) &&
      (callbackEntityType === undefined ||
        callbackEntityType === entity.Type) &&
      (callbackEntityVariant === undefined ||
        callbackEntityVariant === entity.Variant) &&
      (callbackEntitySubType === undefined ||
        callbackEntitySubType === entity.SubType)
    );
  };
}

----
classes\callbacks\PostGridEntityCustomBroken.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntityCustom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityCustomBroken extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_BROKEN> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntityCustom;
}

----
classes\callbacks\PostGridEntityCustomCollision.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_COLLISION;

export class PostGridEntityCustomCollision extends CustomCallback<T> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_COLLISION_DETECTION];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_gridEntity, gridEntityTypeCustom, entity] = fireArgs;
    const [
      callbackGridEntityTypeCustom,
      callbackEntityType,
      callbackEntityVariant,
      callbackEntitySubType,
    ] = optionalArgs;

    return (
      (callbackGridEntityTypeCustom === undefined ||
        callbackGridEntityTypeCustom === gridEntityTypeCustom) &&
      (callbackEntityType === undefined ||
        callbackEntityType === entity.Type) &&
      (callbackEntityVariant === undefined ||
        callbackEntityVariant === entity.Variant) &&
      (callbackEntitySubType === undefined ||
        callbackEntitySubType === entity.SubType)
    );
  };
}

----
classes\callbacks\PostGridEntityCustomInit.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntityCustom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityCustomInit extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_INIT> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntityCustom;
}

----
classes\callbacks\PostGridEntityCustomRemove.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_REMOVE;

export class PostGridEntityCustomRemove extends CustomCallback<T> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_gridIndex, gridEntityTypeCustom] = fireArgs;
    const [callbackGridEntityTypeCustom] = optionalArgs;

    return (
      callbackGridEntityTypeCustom === undefined ||
      callbackGridEntityTypeCustom === gridEntityTypeCustom
    );
  };
}

----
classes\callbacks\PostGridEntityCustomRender.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntityCustom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityCustomRender extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_RENDER> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_RENDER_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntityCustom;
}

----
classes\callbacks\PostGridEntityCustomStateChanged.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntityCustom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityCustomStateChanged extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_STATE_CHANGED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntityCustom;
}

----
classes\callbacks\PostGridEntityCustomUpdate.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntityCustom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityCustomUpdate extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntityCustom;
}

----
classes\callbacks\PostGridEntityInit.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityInit extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_INIT> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntity;
}

----
classes\callbacks\PostGridEntityRemove.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_GRID_ENTITY_REMOVE;

export class PostGridEntityRemove extends CustomCallback<T> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_gridIndex, gridEntityType, variant] = fireArgs;
    const [callbackGridEntityType, callbackVariant] = optionalArgs;

    return (
      (callbackGridEntityType === undefined ||
        callbackGridEntityType === gridEntityType) &&
      (callbackVariant === undefined || callbackVariant === variant)
    );
  };
}

----
classes\callbacks\PostGridEntityRender.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityRender extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_RENDER> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_RENDER_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntity;
}

----
classes\callbacks\PostGridEntityStateChanged.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityStateChanged extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_STATE_CHANGED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntity;
}

----
classes\callbacks\PostGridEntityUpdate.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireGridEntity } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostGridEntityUpdate extends CustomCallback<ModCallbackCustom.POST_GRID_ENTITY_UPDATE> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GRID_ENTITY_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireGridEntity;
}

----
classes\callbacks\PostHolyMantleRemoved.ts
import { CollectibleType } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isAfterRoomFrame } from "../../functions/frames";
import {
  defaultMapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersHolyMantleMap: new DefaultMap<PlayerIndex, int>(0),
  },
};

export class PostHolyMantleRemoved extends CustomCallback<ModCallbackCustom.POST_HOLY_MANTLE_REMOVED> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (
    player: EntityPlayer,
  ): void => {
    const effects = player.GetEffects();
    const newNumHolyMantles = effects.GetCollectibleEffectNum(
      CollectibleType.HOLY_MANTLE,
    );
    const oldNumHolyMantles = defaultMapGetPlayer(
      v.run.playersHolyMantleMap,
      player,
    );
    mapSetPlayer(v.run.playersHolyMantleMap, player, newNumHolyMantles);

    // We check for being after room frame 0 to prevent the callback from firing when the player
    // loses a lost curse from a white fire. (In this case, the player will have a Holy Mantle
    // effect from the lost curse, and then when losing the curse, they will also lose the Holy
    // Mantle.)
    if (newNumHolyMantles < oldNumHolyMantles && isAfterRoomFrame(0)) {
      this.fire(player, oldNumHolyMantles, newNumHolyMantles);
    }
  };
}

----
classes\callbacks\PostItemDischarge.ts
import type { ActiveSlot, CollectibleType } from "isaac-typescript-definitions";
import {
  EntityType,
  ModCallback,
  SuckerVariant,
} from "isaac-typescript-definitions";
import { ACTIVE_SLOT_VALUES } from "../../cachedEnumValues";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getTotalCharge } from "../../functions/charge";
import {
  defaultMapGetPlayer,
  mapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_ITEM_DISCHARGE;

// Unfortunately, we cannot use a nested `DefaultMap` here due to limitations with the save data
// manager.
type ActiveSlotToCollectibleTypeMap = Map<ActiveSlot, CollectibleType>;
type ActiveSlotToChargeMap = Map<ActiveSlot, int>;

const v = {
  run: {
    playersActiveItemMap: new DefaultMap<
      PlayerIndex,
      ActiveSlotToCollectibleTypeMap
    >(() => new Map()),
    playersActiveChargeMap: new DefaultMap<PlayerIndex, ActiveSlotToChargeMap>(
      () => new Map(),
    ),
  },

  room: {
    playersBulbLastCollisionFrame: new Map<PlayerIndex, int>(),
  },
};

export class PostItemDischarge extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 30
      [
        ModCallback.PRE_NPC_COLLISION,
        this.preNPCCollisionSucker,
        [EntityType.SUCKER],
      ],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_player, collectibleType] = fireArgs;
    const [callbackCollectibleType] = optionalArgs;

    return (
      callbackCollectibleType === undefined ||
      callbackCollectibleType === collectibleType
    );
  };

  // ModCallback.PRE_NPC_COLLISION (30)
  // EntityType.SUCKER (61)
  private readonly preNPCCollisionSucker = (
    npc: EntityNPC,
    collider: Entity,
  ): boolean | undefined => {
    if (npc.Variant === SuckerVariant.BULB) {
      return this.preNPCCollisionBulb(npc, collider);
    }

    return undefined;
  };

  // ModCallback.PRE_NPC_COLLISION (30)
  // EntityType.SUCKER (61)
  private preNPCCollisionBulb(
    _npc: EntityNPC,
    collider: Entity,
  ): boolean | undefined {
    this.checkPlayerCollidedWithBulb(collider);
    return undefined;
  }

  /**
   * The algorithm for detecting a discharge is checking if the current charge is less than the
   * charge on the previous frame. Thus, when a Bulb zaps a player and drains their charge, this
   * will be a false position, so Bulbs have to be handled.
   *
   * When Bulbs zap a player, they go to `NPCState.STATE_JUMP` for a frame. However, this only
   * happens on the frame after the player is discharged, which is too late to be of any use.
   *
   * Instead, we track the frames that Bulbs collide with players and assume that a collision means
   * a zap has occurred.
   */
  private checkPlayerCollidedWithBulb(collider: Entity) {
    const player = collider.ToPlayer();
    if (player === undefined) {
      return;
    }

    const gameFrameCount = game.GetFrameCount();
    mapSetPlayer(v.room.playersBulbLastCollisionFrame, player, gameFrameCount);
  }

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const activeItemMap = defaultMapGetPlayer(
      v.run.playersActiveItemMap,
      player,
    );
    const chargeMap = defaultMapGetPlayer(v.run.playersActiveChargeMap, player);

    for (const activeSlot of ACTIVE_SLOT_VALUES) {
      const currentActiveItem = player.GetActiveItem();
      let previousActiveItem = activeItemMap.get(activeSlot);
      if (previousActiveItem === undefined) {
        previousActiveItem = currentActiveItem;
      }
      activeItemMap.set(activeSlot, currentActiveItem);

      if (currentActiveItem !== previousActiveItem) {
        // The player swapped out their active item for something else, so it should be impossible
        // for the discharge callback to fire on this frame.
        continue;
      }

      const currentCharge = getTotalCharge(player, activeSlot);
      let previousCharge = chargeMap.get(activeSlot);
      if (previousCharge === undefined) {
        previousCharge = currentCharge;
      }
      chargeMap.set(activeSlot, currentCharge);

      if (this.playerRecentlyCollidedWithBulb(player)) {
        continue;
      }

      if (currentCharge < previousCharge) {
        const collectibleType = player.GetActiveItem(activeSlot);
        this.fire(player, collectibleType, activeSlot);
      }
    }
  };

  /**
   * If the player collided with a Bulb on either this frame or the last frame, then assume a zap
   * has occurred. (We do not want to fire the discharge callback if this is the case.)
   */
  private playerRecentlyCollidedWithBulb(player: EntityPlayer) {
    const gameFrameCount = game.GetFrameCount();
    const bulbLastCollisionFrame = mapGetPlayer(
      v.room.playersBulbLastCollisionFrame,
      player,
    );

    const collidedOnThisFrame = gameFrameCount === bulbLastCollisionFrame;
    const collidedOnLastFrame = gameFrameCount - 1 === bulbLastCollisionFrame;

    return collidedOnThisFrame || collidedOnLastFrame;
  }
}

----
classes\callbacks\PostItemPickup.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireItemPickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostItemPickup extends CustomCallback<ModCallbackCustom.POST_ITEM_PICKUP> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.ITEM_PICKUP_DETECTION];
  }

  protected override shouldFire = shouldFireItemPickup;
}

----
classes\callbacks\PostKeyboardChanged.ts
import type { Keyboard } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { KEYBOARD_VALUES } from "../../cachedEnumValues";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isKeyboardPressed } from "../../functions/input";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_KEYBOARD_CHANGED;

const v = {
  run: {
    pressedKeys: new Set<Keyboard>(),
  },
};

export class PostKeyboardChanged extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [keyboard, pressed] = fireArgs;
    const [callbackKeyboard, callbackPressed] = optionalArgs;

    return (
      (callbackKeyboard === undefined || callbackKeyboard === keyboard) &&
      (callbackPressed === undefined || callbackPressed === pressed)
    );
  };

  private readonly postRender = () => {
    for (const keyboard of v.run.pressedKeys) {
      if (!isKeyboardPressed(keyboard)) {
        v.run.pressedKeys.delete(keyboard);
        this.fire(keyboard, false);
      }
    }

    for (const keyboard of KEYBOARD_VALUES) {
      if (v.run.pressedKeys.has(keyboard)) {
        continue;
      }

      if (isKeyboardPressed(keyboard)) {
        v.run.pressedKeys.add(keyboard);
        this.fire(keyboard, true);
      }
    }
  };
}

----
classes\callbacks\PostKnifeInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireKnife } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostKnifeInitFilter extends CustomCallback<ModCallbackCustom.POST_KNIFE_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 50
      [ModCallback.POST_KNIFE_INIT, this.postKnifeInit],
    ];
  }

  protected override shouldFire = shouldFireKnife;

  // ModCallback.POST_KNIFE_INIT (50)
  private readonly postKnifeInit = (knife: EntityKnife) => {
    this.fire(knife);
  };
}

----
classes\callbacks\PostKnifeInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireKnife } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostKnifeInitLate extends CustomCallback<ModCallbackCustom.POST_KNIFE_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 51
      [ModCallback.POST_KNIFE_UPDATE, this.postKnifeUpdate],
    ];
  }

  protected override shouldFire = shouldFireKnife;

  // ModCallback.POST_KNIFE_UPDATE (51)
  private readonly postKnifeUpdate = (knife: EntityKnife): void => {
    const ptrHash = GetPtrHash(knife);
    if (!v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(knife);
    }
  };
}

----
classes\callbacks\PostKnifeRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireKnife } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostKnifeRenderFilter extends CustomCallback<ModCallbackCustom.POST_KNIFE_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 52
      [ModCallback.POST_KNIFE_RENDER, this.postKnifeRender],
    ];
  }

  protected override shouldFire = shouldFireKnife;

  // ModCallback.POST_KNIFE_RENDER (52)
  private readonly postKnifeRender = (
    knife: EntityKnife,
    renderOffset: Vector,
  ) => {
    this.fire(knife, renderOffset);
  };
}

----
classes\callbacks\PostKnifeUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireKnife } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostKnifeUpdateFilter extends CustomCallback<ModCallbackCustom.POST_KNIFE_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 51
      [ModCallback.POST_KNIFE_UPDATE, this.postKnifeUpdate],
    ];
  }

  protected override shouldFire = shouldFireKnife;

  // ModCallback.POST_KNIFE_UPDATE (51)
  private readonly postKnifeUpdate = (knife: EntityKnife) => {
    this.fire(knife);
  };
}

----
classes\callbacks\PostLaserInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireLaser } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostLaserInitFilter extends CustomCallback<ModCallbackCustom.POST_LASER_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 47
      [ModCallback.POST_LASER_INIT, this.postLaserInit],
    ];
  }

  protected override shouldFire = shouldFireLaser;

  // ModCallback.POST_LASER_INIT (47)
  private readonly postLaserInit = (laser: EntityLaser) => {
    this.fire(laser);
  };
}

----
classes\callbacks\PostLaserInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireLaser } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostLaserInitLate extends CustomCallback<ModCallbackCustom.POST_LASER_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 48
      [ModCallback.POST_LASER_UPDATE, this.postLaserUpdate],
    ];
  }

  protected override shouldFire = shouldFireLaser;

  // ModCallback.POST_LASER_UPDATE (48)
  private readonly postLaserUpdate = (laser: EntityLaser) => {
    const index = GetPtrHash(laser);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(laser);
    }
  };
}

----
classes\callbacks\PostLaserRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireLaser } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostLaserRenderFilter extends CustomCallback<ModCallbackCustom.POST_LASER_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 49
      [ModCallback.POST_LASER_RENDER, this.postLaserRender],
    ];
  }

  protected override shouldFire = shouldFireLaser;

  // ModCallback.POST_LASER_RENDER (49)
  private readonly postLaserRender = (
    laser: EntityLaser,
    renderOffset: Vector,
  ) => {
    this.fire(laser, renderOffset);
  };
}

----
classes\callbacks\PostLaserUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireLaser } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostLaserUpdateFilter extends CustomCallback<ModCallbackCustom.POST_LASER_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 48
      [ModCallback.POST_LASER_UPDATE, this.postLaserUpdate],
    ];
  }

  protected override shouldFire = shouldFireLaser;

  // ModCallback.POST_LASER_UPDATE (48)
  private readonly postLaserUpdate = (laser: EntityLaser) => {
    this.fire(laser);
  };
}

----
classes\callbacks\PostNPCDeathFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNPCDeathFilter extends CustomCallback<ModCallbackCustom.POST_NPC_DEATH_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 29
      [ModCallback.POST_NPC_DEATH, this.postNPCDeath],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_DEATH (29)
  private readonly postNPCDeath = (npc: EntityNPC) => {
    this.fire(npc);
  };
}

----
classes\callbacks\PostNPCInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNPCInitFilter extends CustomCallback<ModCallbackCustom.POST_NPC_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 27
      [ModCallback.POST_NPC_INIT, this.postNPCInit],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_INIT (27)
  private readonly postNPCInit = (npc: EntityNPC) => {
    this.fire(npc);
  };
}

----
classes\callbacks\PostNPCInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostNPCInitLate extends CustomCallback<ModCallbackCustom.POST_NPC_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 0
      [ModCallback.POST_NPC_UPDATE, this.postNPCUpdate],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_UPDATE (0)
  private readonly postNPCUpdate = (npc: EntityNPC) => {
    const index = GetPtrHash(npc);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(npc);
    }
  };
}

----
classes\callbacks\PostNPCRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNPCRenderFilter extends CustomCallback<ModCallbackCustom.POST_NPC_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 28
      [ModCallback.POST_NPC_RENDER, this.postNPCRender],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_RENDER (28)
  private readonly postNPCRender = (npc: EntityNPC, renderOffset: Vector) => {
    this.fire(npc, renderOffset);
  };
}

----
classes\callbacks\PostNPCStateChanged.ts
import type { NPCState } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    stateMap: new DefaultMap<PtrHash, NPCState, [NPCState]>(
      (state) => state, // eslint-disable-line isaacscript/strict-enums
    ),
  },
};

export class PostNPCStateChanged extends CustomCallback<ModCallbackCustom.POST_NPC_STATE_CHANGED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 0
      [ModCallback.POST_NPC_UPDATE, this.postNPCUpdate],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_UPDATE (0)
  private readonly postNPCUpdate = (npc: EntityNPC) => {
    const ptrHash = GetPtrHash(npc);
    const previousState = v.run.stateMap.getAndSetDefault(ptrHash, npc.State);
    const currentState = npc.State;
    v.run.stateMap.set(ptrHash, currentState);

    if (previousState !== currentState) {
      this.fire(npc, previousState, currentState);
    }
  };
}

----
classes\callbacks\PostNPCUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNPCUpdateFilter extends CustomCallback<ModCallbackCustom.POST_NPC_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 0
      [ModCallback.POST_NPC_UPDATE, this.postNPCUpdate],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.POST_NPC_INIT (0)
  private readonly postNPCUpdate = (npc: EntityNPC) => {
    this.fire(npc);
  };
}

----
classes\callbacks\PostNewLevelReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireLevel } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNewLevelReordered extends CustomCallback<ModCallbackCustom.POST_NEW_LEVEL_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GAME_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFireLevel;
}

----
classes\callbacks\PostNewRoomEarly.ts
import type { EntityType } from "isaac-typescript-definitions";
import { GridEntityType, ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import {
  getTopLeftWallGridIndex,
  spawnGridEntity,
} from "../../functions/gridEntities";
import { logError } from "../../functions/log";
import { shouldFireRoom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNewRoomEarly extends CustomCallback<ModCallbackCustom.POST_NEW_ROOM_EARLY> {
  private currentRoomTopLeftWallPtrHash: PtrHash | null = null;

  /** The wall entity directly to the right of the top-left wall. */
  private currentRoomTopLeftWallPtrHash2: PtrHash | null = null;

  constructor() {
    super();

    this.callbacksUsed = [
      // 19
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_NEW_ROOM, this.postNewRoom],

      // 24
      [ModCallback.PRE_ENTITY_SPAWN, this.preEntitySpawn],
    ];
  }

  protected override shouldFire = shouldFireRoom;

  // ModCallback.POST_NEW_ROOM (19)
  private readonly postNewRoom = (): void => {
    this.checkRoomChanged();
  };

  // ModCallback.PRE_ENTITY_SPAWN (24)
  private readonly preEntitySpawn = ():
    | [entityType: EntityType, variant: int, subType: int, initSeed: Seed]
    | undefined => {
    this.checkRoomChanged();
    return undefined;
  };

  private checkRoomChanged(): void {
    if (this.isNewRoom()) {
      const room = game.GetRoom();
      const roomType = room.GetType();

      this.fire(roomType);
    }
  }

  private isNewRoom(): boolean {
    const room = game.GetRoom();
    const topLeftWallGridIndex = getTopLeftWallGridIndex();
    const rightOfTopWallGridIndex = topLeftWallGridIndex + 1;

    let topLeftWall = room.GetGridEntity(topLeftWallGridIndex);
    let topLeftWall2 = room.GetGridEntity(rightOfTopWallGridIndex);

    // Sometimes, the `PRE_ENTITY_SPAWN` callback can fire before any grid entities in the room have
    // spawned, which means that the top-left wall will not exist. If ths is the case, then simply
    // spawn the top-left wall early.
    if (topLeftWall === undefined) {
      topLeftWall = spawnGridEntity(GridEntityType.WALL, topLeftWallGridIndex);
      if (topLeftWall === undefined) {
        logError(
          "Failed to spawn a new wall for the POST_NEW_ROOM_EARLY callback (on the first try).",
        );
        return false;
      }
    }

    // For some reason, the above check will rarely fail. We duplicate the check with another wall
    // segment to increase the reliability.
    if (topLeftWall2 === undefined) {
      topLeftWall2 = spawnGridEntity(
        GridEntityType.WALL,
        rightOfTopWallGridIndex,
      );
      if (topLeftWall2 === undefined) {
        logError(
          "Failed to spawn a new wall for the POST_NEW_ROOM_EARLY callback (on the second try).",
        );
        return false;
      }
    }

    const oldTopLeftWallPtrHash = this.currentRoomTopLeftWallPtrHash;
    const oldTopLeftWallPtrHash2 = this.currentRoomTopLeftWallPtrHash2;
    this.currentRoomTopLeftWallPtrHash = GetPtrHash(topLeftWall);
    this.currentRoomTopLeftWallPtrHash2 = GetPtrHash(topLeftWall2);

    return (
      oldTopLeftWallPtrHash !== this.currentRoomTopLeftWallPtrHash ||
      oldTopLeftWallPtrHash2 !== this.currentRoomTopLeftWallPtrHash2
    );
  }
}

----
classes\callbacks\PostNewRoomReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireRoom } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostNewRoomReordered extends CustomCallback<ModCallbackCustom.POST_NEW_ROOM_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.GAME_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFireRoom;
}

----
classes\callbacks\PostPEffectUpdateReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPEffectUpdateReordered extends CustomCallback<ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PLAYER_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFirePlayer;
}

----
classes\callbacks\PostPickupChanged.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPickupChanged extends CustomCallback<ModCallbackCustom.POST_PICKUP_CHANGED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PICKUP_CHANGE_DETECTION];
  }

  protected override shouldFire = shouldFirePickup;
}

----
classes\callbacks\PostPickupCollect.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getClosestPlayer } from "../../functions/players";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostPickupCollect extends CustomCallback<ModCallbackCustom.POST_PICKUP_COLLECT> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 36
      [ModCallback.POST_PICKUP_RENDER, this.postPickupRender],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_RENDER (36)
  private readonly postPickupRender = (pickup: EntityPickup) => {
    const sprite = pickup.GetSprite();
    const animation = sprite.GetAnimation();
    if (animation !== "Collect") {
      return;
    }

    const index = GetPtrHash(pickup);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);

      const player = getClosestPlayer(pickup.Position);
      this.fire(pickup, player);
    }
  };
}

----
classes\callbacks\PostPickupInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPickupInitFilter extends CustomCallback<ModCallbackCustom.POST_PICKUP_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 34
      [ModCallback.POST_PICKUP_INIT, this.postPickupInit],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_INIT (34)
  private readonly postPickupInit = (pickup: EntityPickup) => {
    this.fire(pickup);
  };
}

----
classes\callbacks\PostPickupInitFirst.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isAfterRoomFrame } from "../../functions/frames";
import { getRoomVisitedCount } from "../../functions/roomData";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPickupInitFirst extends CustomCallback<ModCallbackCustom.POST_PICKUP_INIT_FIRST> {
  public override v = {
    room: {
      firedSet: new Set<PtrHash>(),
    },
  };

  constructor() {
    super();

    this.callbacksUsed = [
      // 34
      [ModCallback.POST_PICKUP_INIT, this.postPickupInit],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_INIT (34)
  private readonly postPickupInit = (pickup: EntityPickup) => {
    const roomVisitedCount = getRoomVisitedCount();

    // The room visited count is not reset when re-entering a Treasure Room or Boss room in the
    // Ascent.
    if (isAfterRoomFrame(0) || roomVisitedCount === 0) {
      this.fire(pickup);
    }
  };
}

----
classes\callbacks\PostPickupInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostPickupInitLate extends CustomCallback<ModCallbackCustom.POST_PICKUP_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 35
      [ModCallback.POST_PICKUP_UPDATE, this.postPickupUpdate],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_UPDATE (35)
  private readonly postPickupUpdate = (pickup: EntityPickup) => {
    const index = GetPtrHash(pickup);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(pickup);
    }
  };
}

----
classes\callbacks\PostPickupRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPickupRenderFilter extends CustomCallback<ModCallbackCustom.POST_PICKUP_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 36
      [ModCallback.POST_PICKUP_RENDER, this.postPickupRender],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_RENDER (36)
  private readonly postPickupRender = (
    pickup: EntityPickup,
    renderOffset: Vector,
  ) => {
    this.fire(pickup, renderOffset);
  };
}

----
classes\callbacks\PostPickupSelectionFilter.ts
import type { PickupVariant } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_PICKUP_SELECTION_FILTER;

export class PostPickupSelectionFilter extends CustomCallback<T> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 37
      [ModCallback.POST_PICKUP_SELECTION, this.postPickupSelection],
    ];
  }

  /**
   * We cannot use the `shouldFirePickup` helper function because in the case of non-collectibles,
   * `EntityPickup.Type` and `EntityPickup.Variant` and `EntityPickup.SubType` will all be set to 0
   * in this callback.
   */
  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_pickup, pickupVariant, subType] = fireArgs;
    const [callbackPickupVariant, callbackPickupSubType] = optionalArgs;

    return (
      (callbackPickupVariant === undefined ||
        callbackPickupVariant === pickupVariant) &&
      (callbackPickupSubType === undefined || callbackPickupSubType === subType)
    );
  };

  // ModCallback.POST_PICKUP_SELECTION (37)
  private readonly postPickupSelection = (
    pickup: EntityPickup,
    variant: PickupVariant,
    subType: int,
  ): [PickupVariant, int] | undefined => this.fire(pickup, variant, subType);
}

----
classes\callbacks\PostPickupStateChanged.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    stateMap: new DefaultMap<PtrHash, int, [int]>((state) => state),
  },
};

export class PostPickupStateChanged extends CustomCallback<ModCallbackCustom.POST_PICKUP_STATE_CHANGED> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 35
      [ModCallback.POST_PICKUP_UPDATE, this.postPickupUpdate],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_UPDATE (35)
  private readonly postPickupUpdate = (pickup: EntityPickup) => {
    const ptrHash = GetPtrHash(pickup);
    const previousState = v.run.stateMap.getAndSetDefault(
      ptrHash,
      pickup.State,
    );
    const currentState = pickup.State;
    v.run.stateMap.set(ptrHash, currentState);

    if (previousState !== currentState) {
      this.fire(pickup, previousState, currentState);
    }
  };
}

----
classes\callbacks\PostPickupUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPickupUpdateFilter extends CustomCallback<ModCallbackCustom.POST_PICKUP_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 35
      [ModCallback.POST_PICKUP_UPDATE, this.postPickupUpdate],
    ];
  }

  protected override shouldFire = shouldFirePickup;

  // ModCallback.POST_PICKUP_UPDATE (35)
  private readonly postPickupUpdate = (pickup: EntityPickup) => {
    this.fire(pickup);
  };
}

----
classes\callbacks\PostPitRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPits } from "../../functions/gridEntitiesSpecific";
import { shouldFirePit } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPitRender extends CustomCallback<ModCallbackCustom.POST_PIT_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFirePit;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const pit of getPits()) {
      this.fire(pit);
    }
  };
}

----
classes\callbacks\PostPitUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPits } from "../../functions/gridEntitiesSpecific";
import { shouldFirePit } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPitUpdate extends CustomCallback<ModCallbackCustom.POST_PIT_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFirePit;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const pit of getPits()) {
      this.fire(pit);
    }
  };
}

----
classes\callbacks\PostPlayerChangeHealth.ts
import { HEALTH_TYPE_VALUES } from "../../cachedEnumValues";
import type { HealthType } from "../../enums/HealthType";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPlayerHealthType } from "../../functions/playerHealth";
import { getPlayerIndex } from "../../functions/playerIndex";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersHealthMap: new DefaultMap<PlayerIndex, Map<HealthType, int>>(
      () => new Map(),
    ),
  },
};

export class PostPlayerChangeHealth extends CustomCallback<ModCallbackCustom.POST_PLAYER_CHANGE_HEALTH> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectReordered = (player: EntityPlayer) => {
    // We call the "getPlayerIndex" function with the "differentiateForgottenAndSoul" argument. If
    // we don't differentiate between The Forgotten and The Soul, the callback will fire every time
    // the player switches between the two.
    const playerIndex = getPlayerIndex(player, true);
    const playerHealthMap =
      v.run.playersHealthMap.getAndSetDefault(playerIndex);

    for (const healthType of HEALTH_TYPE_VALUES) {
      const storedHealthValue = playerHealthMap.get(healthType);
      const currentHealthValue = getPlayerHealthType(player, healthType);
      playerHealthMap.set(healthType, currentHealthValue);

      if (
        storedHealthValue !== undefined &&
        storedHealthValue !== currentHealthValue
      ) {
        const difference = currentHealthValue - storedHealthValue;
        this.fire(
          player,
          healthType,
          difference,
          storedHealthValue,
          currentHealthValue,
        );
      }
    }
  };
}

----
classes\callbacks\PostPlayerChangeStat.ts
import { PLAYER_STAT_VALUES } from "../../cachedEnumValues";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { PlayerStat } from "../../enums/PlayerStat";
import { isBitSet128 } from "../../functions/bitSet128";
import { colorEquals, isColor } from "../../functions/color";
import { getPlayerIndex } from "../../functions/playerIndex";
import { getPlayerStat } from "../../functions/stats";
import { isBoolean, isNumber } from "../../functions/types";
import { isVector, vectorEquals } from "../../functions/vector";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import type { PossibleStatType } from "../../types/PossibleStatType";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersStatMap: new DefaultMap<
      PlayerIndex,
      Map<PlayerStat, PossibleStatType>
    >(() => new Map()),
  },
};

export class PostPlayerChangeStat extends CustomCallback<ModCallbackCustom.POST_PLAYER_CHANGE_STAT> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectReordered = (player: EntityPlayer) => {
    // We call the "getPlayerIndex" function with the "differentiateForgottenAndSoul" argument. If
    // we don't differentiate between The Forgotten and The Soul, the callback will fire every time
    // the player switches between the two.
    const playerIndex = getPlayerIndex(player, true);
    const playerStatMap = v.run.playersStatMap.getAndSetDefault(playerIndex);

    for (const statType of PLAYER_STAT_VALUES) {
      const storedStatValue = playerStatMap.get(statType);
      const currentStatValue = getPlayerStat(player, statType);
      playerStatMap.set(statType, currentStatValue);

      if (storedStatValue === undefined) {
        continue;
      }

      if (!statEquals(storedStatValue, currentStatValue)) {
        const isNumberStat =
          isNumber(storedStatValue) && isNumber(currentStatValue);
        const difference = isNumberStat
          ? currentStatValue - storedStatValue
          : 0;
        this.fire(
          player,
          statType,
          difference,
          storedStatValue,
          currentStatValue,
        );
      }
    }
  };
}

function statEquals(
  oldValue: PossibleStatType,
  newValue: PossibleStatType,
): boolean {
  const isNumberStat = isNumber(oldValue) && isNumber(newValue);
  if (isNumberStat) {
    return oldValue === newValue;
  }

  const isBooleanStat = isBoolean(oldValue) && isBoolean(newValue);
  if (isBooleanStat) {
    return oldValue === newValue;
  }

  const isBitSet128Stat = isBitSet128(oldValue) && isBitSet128(newValue);
  if (isBitSet128Stat) {
    return oldValue === newValue; // The class has the "__eq" meta-method.
  }

  const isColorStat = isColor(oldValue) && isColor(newValue);
  if (isColorStat) {
    return colorEquals(oldValue, newValue);
  }

  const isVectorStat = isVector(oldValue) && isVector(newValue);
  if (isVectorStat) {
    return vectorEquals(oldValue, newValue);
  }

  error(
    'Failed to determine the type of a stat in the "POST_PLAYER_CHANGE_STAT" callback.',
  );
}

----
classes\callbacks\PostPlayerChangeType.ts
import type { PlayerType } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import {
  defaultMapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersCharacterMap: new DefaultMap<
      PlayerIndex,
      PlayerType,
      [character: PlayerType]
    >((character: PlayerType) => character), // eslint-disable-line isaacscript/strict-enums
  },
};

export class PostPlayerChangeType extends CustomCallback<ModCallbackCustom.POST_PLAYER_CHANGE_TYPE> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectReordered = (player: EntityPlayer) => {
    const character = player.GetPlayerType();
    const storedCharacter = defaultMapGetPlayer(
      v.run.playersCharacterMap,
      player,
      character,
    );
    if (character !== storedCharacter) {
      mapSetPlayer(v.run.playersCharacterMap, player, character);
      this.fire(player, storedCharacter, character);
    }
  };
}

----
classes\callbacks\PostPlayerCollectibleAdded.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireCollectibleType } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPlayerCollectibleAdded extends CustomCallback<ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PLAYER_COLLECTIBLE_DETECTION];
  }

  protected override shouldFire = shouldFireCollectibleType;
}

----
classes\callbacks\PostPlayerCollectibleRemoved.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireCollectibleType } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPlayerCollectibleRemoved extends CustomCallback<ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PLAYER_COLLECTIBLE_DETECTION];
  }

  protected override shouldFire = shouldFireCollectibleType;
}

----
classes\callbacks\PostPlayerFatalDamage.ts
import type { ActiveSlot, UseFlag } from "isaac-typescript-definitions";
import {
  BossID,
  CollectibleType,
  DamageFlag,
  DamageFlagZero,
  ModCallback,
} from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { hasFlag } from "../../functions/flag";
import {
  mapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import { isChildPlayer } from "../../functions/playerIndex";
import {
  isDamageToPlayerFatal,
  willPlayerRevive,
} from "../../functions/revive";
import { inBossRoomOf } from "../../functions/rooms";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    /** Needed to detect if Glass Cannon will kill the player. */
    playersLastDamageGameFrame: new Map<PlayerIndex, int>(),
  },
};

export class PostPlayerFatalDamage extends CustomCallback<ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 23
      [ModCallback.PRE_USE_ITEM, this.preUseItemBible, [CollectibleType.BIBLE]],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  /**
   * Using The Bible on Satan is one of the few ways to die without taking damage, so we need to
   * handle this case.
   */
  // ModCallback.PRE_USE_ITEM (23)
  // CollectibleType.BIBLE (33)
  private readonly preUseItemBible = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: ActiveSlot,
    _customVarData: int,
  ): boolean | undefined => {
    if (!inBossRoomOf(BossID.SATAN)) {
      return undefined;
    }

    if (willPlayerRevive(player)) {
      return undefined;
    }

    const shouldSustainDeath = this.fire(
      player,
      0,
      DamageFlagZero,
      EntityRef(player),
      0,
    );
    if (shouldSustainDeath !== undefined) {
      // End-users will return false to stop the damage from being fatal. We have to return true to
      // prevent the Bible from firing.
      return !shouldSustainDeath;
    }

    return undefined;
  };

  // ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER
  private readonly entityTakeDmgPlayer = (
    player: EntityPlayer,
    amount: float,
    damageFlags: BitFlags<DamageFlag>,
    source: EntityRef,
    countdownFrames: int,
  ): boolean | undefined => {
    // This callback should not trigger for the Strawman Keeper and other players that are "child"
    // players.
    if (isChildPlayer(player)) {
      return undefined;
    }

    const gameFrameCount = game.GetFrameCount();
    const lastDamageGameFrame = mapGetPlayer(
      v.run.playersLastDamageGameFrame,
      player,
    );
    mapSetPlayer(v.run.playersLastDamageGameFrame, player, gameFrameCount);

    // If the damage has the damage flag of `DamageFlag.NO_KILL` (1 << 0), this will not be fatal
    // damage. (This is present on things like the Bad Trip pill.)
    if (hasFlag(damageFlags, DamageFlag.NO_KILL)) {
      return undefined;
    }

    // If the player has a revival item such as Dead Cat, this will not be fatal damage.
    if (willPlayerRevive(player)) {
      return undefined;
    }

    if (!isDamageToPlayerFatal(player, amount, source, lastDamageGameFrame)) {
      return undefined;
    }

    const shouldSustainDeath = this.fire(
      player,
      amount,
      damageFlags,
      source,
      countdownFrames,
    );
    if (shouldSustainDeath !== undefined) {
      return shouldSustainDeath;
    }

    return undefined;
  };
}

----
classes\callbacks\PostPlayerInitFirst.ts
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPlayers, isChildPlayer } from "../../functions/playerIndex";
import { inGenesisRoom } from "../../functions/rooms";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPlayerInitFirst extends CustomCallback<ModCallbackCustom.POST_PLAYER_INIT_FIRST> {
  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
      [ModCallbackCustom.POST_PLAYER_INIT_LATE, this.postPlayerInitLate],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    // When a player uses the Genesis collectible, they will lose all of their collectibles,
    // trinkets, pocket items, and stats, so they will need to be re-initialized like they would be
    // at the beginning of a run. However, in this case, the `POST_PLAYER_INIT_FIRST` callback will
    // not fire, because that only fires once per run. Thus, we explicitly handle this special case.
    // Note that whichever player uses Genesis, items will be removed from all players (at least in
    // the case of Jacob & Esau).
    if (inGenesisRoom()) {
      for (const player of getPlayers()) {
        this.fire(player);
      }
    }
  };

  // ModCallbackCustom.POST_PLAYER_INIT_LATE
  private readonly postPlayerInitLate = (player: EntityPlayer) => {
    // We want to exclude non-real players like the Strawman keeper.
    if (isChildPlayer(player)) {
      return;
    }

    this.fire(player);
  };
}

----
classes\callbacks\PostPlayerInitLate.ts
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import {
  setAddPlayer,
  setHasPlayer,
} from "../../functions/playerDataStructures";
import { shouldFirePlayer } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    playersFiredSet: new Set<PlayerIndex>(),
  },
};

export class PostPlayerInitLate extends CustomCallback<ModCallbackCustom.POST_PLAYER_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    if (!setHasPlayer(v.run.playersFiredSet, player)) {
      setAddPlayer(v.run.playersFiredSet, player);
      this.fire(player);
    }
  };
}

----
classes\callbacks\PostPlayerRenderReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPlayerRenderReordered extends CustomCallback<ModCallbackCustom.POST_PLAYER_RENDER_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PLAYER_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFirePlayer;
}

----
classes\callbacks\PostPlayerUpdateReordered.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPlayerUpdateReordered extends CustomCallback<ModCallbackCustom.POST_PLAYER_UPDATE_REORDERED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.PLAYER_REORDERED_CALLBACKS];
  }

  protected override shouldFire = shouldFirePlayer;
}

----
classes\callbacks\PostPoopRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPoops } from "../../functions/gridEntitiesSpecific";
import { shouldFirePoop } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPoopRender extends CustomCallback<ModCallbackCustom.POST_POOP_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFirePoop;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const poop of getPoops()) {
      this.fire(poop);
    }
  };
}

----
classes\callbacks\PostPoopUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPoops } from "../../functions/gridEntitiesSpecific";
import { shouldFirePoop } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPoopUpdate extends CustomCallback<ModCallbackCustom.POST_POOP_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFirePoop;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const poop of getPoops()) {
      this.fire(poop);
    }
  };
}

----
classes\callbacks\PostPressurePlateRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPressurePlates } from "../../functions/gridEntitiesSpecific";
import { shouldFirePressurePlate } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPressurePlateRender extends CustomCallback<ModCallbackCustom.POST_PRESSURE_PLATE_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFirePressurePlate;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const pressurePlate of getPressurePlates()) {
      this.fire(pressurePlate);
    }
  };
}

----
classes\callbacks\PostPressurePlateUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPressurePlates } from "../../functions/gridEntitiesSpecific";
import { shouldFirePressurePlate } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostPressurePlateUpdate extends CustomCallback<ModCallbackCustom.POST_PRESSURE_PLATE_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFirePressurePlate;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const pressurePlate of getPressurePlates()) {
      this.fire(pressurePlate);
    }
  };
}

----
classes\callbacks\PostProjectileInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostProjectileInitFilter extends CustomCallback<ModCallbackCustom.POST_PROJECTILE_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 43
      [ModCallback.POST_PROJECTILE_INIT, this.postProjectileInit],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.POST_PROJECTILE_INIT (43)
  private readonly postProjectileInit = (projectile: EntityProjectile) => {
    this.fire(projectile);
  };
}

----
classes\callbacks\PostProjectileInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostProjectileInitLate extends CustomCallback<ModCallbackCustom.POST_PROJECTILE_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 44
      [ModCallback.POST_PROJECTILE_UPDATE, this.postProjectileUpdate],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.POST_PROJECTILE_UPDATE (44)
  private readonly postProjectileUpdate = (
    projectile: EntityProjectile,
  ): void => {
    const ptrHash = GetPtrHash(projectile);
    if (!v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(projectile);
    }
  };
}

----
classes\callbacks\PostProjectileKill.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostProjectileKill extends CustomCallback<ModCallbackCustom.POST_PROJECTILE_KILL> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 44
      [ModCallback.POST_PROJECTILE_UPDATE, this.postProjectileUpdate],

      // 46
      [ModCallback.PRE_PROJECTILE_COLLISION, this.preProjectileCollision],

      // 67
      [ModCallback.POST_ENTITY_REMOVE, this.postEntityRemove],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.POST_PROJECTILE_UPDATE (44)
  private readonly postProjectileUpdate = (projectile: EntityProjectile) => {
    const ptrHash = GetPtrHash(projectile);

    if (projectile.CollidesWithGrid() || projectile.IsDead()) {
      v.room.firedSet.add(ptrHash);
    }
  };

  // ModCallback.PRE_PROJECTILE_COLLISION (46)
  private readonly preProjectileCollision = (
    projectile: EntityProjectile,
  ): boolean | undefined => {
    const ptrHash = GetPtrHash(projectile);
    v.room.firedSet.add(ptrHash);

    return undefined;
  };

  // ModCallback.POST_ENTITY_REMOVE (67)
  private readonly postEntityRemove = (entity: Entity): void => {
    const projectile = entity.ToProjectile();

    if (projectile === undefined) {
      return;
    }

    const ptrHash = GetPtrHash(projectile);

    if (v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(projectile);
    }
  };
}

----
classes\callbacks\PostProjectileRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostProjectileRenderFilter extends CustomCallback<ModCallbackCustom.POST_PROJECTILE_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 45
      [ModCallback.POST_PROJECTILE_RENDER, this.postProjectileRender],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.POST_PROJECTILE_RENDER (45)
  private readonly postProjectileRender = (
    projectile: EntityProjectile,
    renderOffset: Vector,
  ) => {
    this.fire(projectile, renderOffset);
  };
}

----
classes\callbacks\PostProjectileUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostProjectileUpdateFilter extends CustomCallback<ModCallbackCustom.POST_PROJECTILE_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 44
      [ModCallback.POST_PROJECTILE_UPDATE, this.postProjectileUpdate],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.POST_PROJECTILE_UPDATE (44)
  private readonly postProjectileUpdate = (projectile: EntityProjectile) => {
    this.fire(projectile);
  };
}

----
classes\callbacks\PostPurchase.ts
import type {
  CardType,
  CollectibleType,
  PillEffect,
} from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getPickups } from "../../functions/entitiesSpecific";
import {
  defaultMapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_PURCHASE;

const v = {
  room: {
    playersHoldingItemOnLastFrameMap: new DefaultMap<PlayerIndex, boolean>(
      false,
    ),
    playersUsedItemOnFrame: new DefaultMap<PlayerIndex, int>(0),
  },
};

export class PostPurchase extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 3
      [ModCallback.POST_USE_ITEM, this.postUseItem],

      // 5
      [ModCallback.POST_USE_CARD, this.postUseCard],

      // 10
      [ModCallback.POST_USE_PILL, this.postUsePill],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_player, pickup] = fireArgs;
    const [callbackPickupVariant, callbackPickupSubType] = optionalArgs;

    return (
      (callbackPickupVariant === undefined ||
        callbackPickupVariant === pickup.Variant) &&
      (callbackPickupSubType === undefined ||
        callbackPickupSubType === pickup.SubType)
    );
  };

  // ModCallback.POST_USE_ITEM (3)
  private readonly postUseItem = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
  ): boolean | undefined => {
    markUsedItemOnThisFrame(player);
    return undefined;
  };

  // ModCallback.POST_USE_CARD (5)
  private readonly postUseCard = (
    _cardType: CardType,
    player: EntityPlayer,
  ) => {
    markUsedItemOnThisFrame(player);
    return undefined;
  };

  // ModCallback.POST_USE_PILL (10)
  private readonly postUsePill = (
    _pillEffect: PillEffect,
    player: EntityPlayer,
  ) => {
    markUsedItemOnThisFrame(player);
    return undefined;
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const isHoldingItem = player.IsHoldingItem();
    const wasHoldingItemOnLastFrame = defaultMapGetPlayer(
      v.room.playersHoldingItemOnLastFrameMap,
      player,
    );
    mapSetPlayer(
      v.room.playersHoldingItemOnLastFrameMap,
      player,
      isHoldingItem,
    );

    // Assume that if the player did not use an active item, card, or pill recently, then they
    // purchased an item.
    if (
      !wasHoldingItemOnLastFrame &&
      isHoldingItem &&
      !this.playerUsedItemRecently(player)
    ) {
      this.playerPickedUpNewItem(player);
    }
  };

  private playerUsedItemRecently(player: EntityPlayer): boolean {
    const gameFrameCount = game.GetFrameCount();
    const usedCollectibleOnFrame = defaultMapGetPlayer(
      v.room.playersUsedItemOnFrame,
      player,
    );
    return (
      gameFrameCount === usedCollectibleOnFrame ||
      gameFrameCount === usedCollectibleOnFrame + 1
    );
  }

  private playerPickedUpNewItem(player: EntityPlayer) {
    const pickups = getPickups();
    const disappearingPickup = pickups.find(
      (pickup) => !pickup.Exists() && pickup.Price !== 0,
    );
    if (disappearingPickup !== undefined) {
      this.fire(player, disappearingPickup);
    }
  }
}

function markUsedItemOnThisFrame(player: EntityPlayer) {
  const gameFrameCount = game.GetFrameCount();
  mapSetPlayer(v.room.playersUsedItemOnFrame, player, gameFrameCount);
}

----
classes\callbacks\PostRockRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getRocks } from "../../functions/gridEntitiesSpecific";
import { shouldFireRock } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostRockRender extends CustomCallback<ModCallbackCustom.POST_ROCK_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFireRock;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const rock of getRocks()) {
      this.fire(rock);
    }
  };
}

----
classes\callbacks\PostRockUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getRocks } from "../../functions/gridEntitiesSpecific";
import { shouldFireRock } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostRockUpdate extends CustomCallback<ModCallbackCustom.POST_ROCK_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireRock;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const rock of getRocks()) {
      this.fire(rock);
    }
  };
}

----
classes\callbacks\PostRoomClearChanged.ts
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_ROOM_CLEAR_CHANGED;

const v = {
  room: {
    cleared: false,
  },
};

export class PostRoomClearChanged extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [roomClear] = fireArgs;
    const [callbackRoomClear] = optionalArgs;

    return callbackRoomClear === undefined || callbackRoomClear === roomClear;
  };

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    const room = game.GetRoom();
    const roomClear = room.IsClear();

    if (roomClear !== v.room.cleared) {
      v.room.cleared = roomClear;
      this.fire(roomClear);
    }
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = (): void => {
    const room = game.GetRoom();
    const roomClear = room.IsClear();

    v.room.cleared = roomClear;
  };
}

----
classes\callbacks\PostSacrifice.ts
import { DamageFlag, RoomType } from "isaac-typescript-definitions";
import { game } from "../../core/cachedClasses";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { hasFlag } from "../../functions/flag";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  level: {
    numSacrifices: 0,
  },
};

export class PostSacrifice extends CustomCallback<ModCallbackCustom.POST_SACRIFICE> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.ENTITY_TAKE_DMG
  private readonly entityTakeDmgPlayer = (
    player: EntityPlayer,
    _amount: float,
    damageFlags: BitFlags<DamageFlag>,
    _source: EntityRef,
    _countdownFrames: int,
  ): boolean | undefined => {
    const room = game.GetRoom();
    const roomType = room.GetType();
    const isSpikeDamage = hasFlag(damageFlags, DamageFlag.SPIKES);

    if (roomType === RoomType.SACRIFICE && isSpikeDamage) {
      v.level.numSacrifices++;
      this.fire(player, v.level.numSacrifices);
    }

    return undefined;
  };
}

----
classes\callbacks\PostSlotAnimationChanged.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotAnimationChanged extends CustomCallback<ModCallbackCustom.POST_SLOT_ANIMATION_CHANGED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.SLOT_RENDER_DETECTION];
  }

  protected override shouldFire = shouldFireSlot;
}

----
classes\callbacks\PostSlotCollision.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isSlot } from "../../functions/entityTypes";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotCollision extends CustomCallback<ModCallbackCustom.POST_SLOT_COLLISION> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 33
      [ModCallback.PRE_PLAYER_COLLISION, this.prePlayerCollision],
    ];
  }

  protected override shouldFire = shouldFireSlot;

  // ModCallback.PRE_PLAYER_COLLISION (33)
  private readonly prePlayerCollision = (
    player: EntityPlayer,
    collider: Entity,
  ): boolean | undefined => {
    if (isSlot(collider)) {
      this.fire(collider, player);
    }

    return undefined;
  };
}

----
classes\callbacks\PostSlotDestroyed.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotDestroyed extends CustomCallback<ModCallbackCustom.POST_SLOT_DESTROYED> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.SLOT_DESTROYED_DETECTION];
  }

  protected override shouldFire = shouldFireSlot;
}

----
classes\callbacks\PostSlotInit.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotInit extends CustomCallback<ModCallbackCustom.POST_SLOT_INIT> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.SLOT_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireSlot;
}

----
classes\callbacks\PostSlotRender.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotRender extends CustomCallback<ModCallbackCustom.POST_SLOT_RENDER> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.SLOT_RENDER_DETECTION];
  }

  protected override shouldFire = shouldFireSlot;
}

----
classes\callbacks\PostSlotUpdate.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireSlot } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSlotUpdate extends CustomCallback<ModCallbackCustom.POST_SLOT_UPDATE> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.SLOT_UPDATE_DETECTION];
  }

  protected override shouldFire = shouldFireSlot;
}

----
classes\callbacks\PostSpikesRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getSpikes } from "../../functions/gridEntitiesSpecific";
import { shouldFireSpikes } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSpikesRender extends CustomCallback<ModCallbackCustom.POST_SPIKES_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFireSpikes;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const spikes of getSpikes()) {
      this.fire(spikes);
    }
  };
}

----
classes\callbacks\PostSpikesUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getSpikes } from "../../functions/gridEntitiesSpecific";
import { shouldFireSpikes } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostSpikesUpdate extends CustomCallback<ModCallbackCustom.POST_SPIKES_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireSpikes;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const spikes of getSpikes()) {
      this.fire(spikes);
    }
  };
}

----
classes\callbacks\PostTNTRender.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getTNT } from "../../functions/gridEntitiesSpecific";
import { shouldFireTNT } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostTNTRender extends CustomCallback<ModCallbackCustom.POST_TNT_RENDER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  protected override shouldFire = shouldFireTNT;

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    for (const tnt of getTNT()) {
      this.fire(tnt);
    }
  };
}

----
classes\callbacks\PostTNTUpdate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getTNT } from "../../functions/gridEntitiesSpecific";
import { shouldFireTNT } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostTNTUpdate extends CustomCallback<ModCallbackCustom.POST_TNT_UPDATE> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];
  }

  protected override shouldFire = shouldFireTNT;

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    for (const tnt of getTNT()) {
      this.fire(tnt);
    }
  };
}

----
classes\callbacks\PostTearInitFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostTearInitFilter extends CustomCallback<ModCallbackCustom.POST_TEAR_INIT_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 39
      [ModCallback.POST_TEAR_INIT, this.postTearInit],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_TEAR_INIT (39)
  private readonly postTearInit = (tear: EntityTear) => {
    this.fire(tear);
  };
}

----
classes\callbacks\PostTearInitLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostTearInitLate extends CustomCallback<ModCallbackCustom.POST_TEAR_INIT_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 40
      [ModCallback.POST_TEAR_UPDATE, this.postTearUpdate],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_TEAR_UPDATE (40)
  private readonly postTearUpdate = (tear: EntityTear): void => {
    const ptrHash = GetPtrHash(tear);
    if (!v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(tear);
    }
  };
}

----
classes\callbacks\PostTearInitVeryLate.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostTearInitVeryLate extends CustomCallback<ModCallbackCustom.POST_TEAR_INIT_VERY_LATE> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 40
      [ModCallback.POST_TEAR_UPDATE, this.postTearUpdate],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_TEAR_UPDATE (40)
  private readonly postTearUpdate = (tear: EntityTear): void => {
    // This callback fires on frame 1.
    if (tear.FrameCount === 0) {
      return;
    }

    const index = GetPtrHash(tear);
    if (!v.room.firedSet.has(index)) {
      v.room.firedSet.add(index);
      this.fire(tear);
    }
  };
}

----
classes\callbacks\PostTearKill.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  room: {
    firedSet: new Set<PtrHash>(),
  },
};

export class PostTearKill extends CustomCallback<ModCallbackCustom.POST_TEAR_KILL> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 40
      [ModCallback.POST_TEAR_UPDATE, this.postTearUpdate],

      // 42
      [ModCallback.PRE_TEAR_COLLISION, this.preTearCollision],

      // 67
      [ModCallback.POST_ENTITY_REMOVE, this.postEntityRemove],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_PROJECTILE_UPDATE (40)
  private readonly postTearUpdate = (tear: EntityTear) => {
    const ptrHash = GetPtrHash(tear);

    if (tear.CollidesWithGrid() || tear.IsDead()) {
      v.room.firedSet.add(ptrHash);
    }
  };

  // ModCallback.PRE_TEAR_COLLISION (42)
  private readonly preTearCollision = (
    tear: EntityTear,
  ): boolean | undefined => {
    const ptrHash = GetPtrHash(tear);
    v.room.firedSet.add(ptrHash);

    return undefined;
  };

  // ModCallback.POST_ENTITY_REMOVE (67)
  private readonly postEntityRemove = (entity: Entity): void => {
    const tear = entity.ToTear();

    if (tear === undefined) {
      return;
    }

    const ptrHash = GetPtrHash(tear);

    if (v.room.firedSet.has(ptrHash)) {
      v.room.firedSet.add(ptrHash);
      this.fire(tear);
    }
  };
}

----
classes\callbacks\PostTearRenderFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostTearRenderFilter extends CustomCallback<ModCallbackCustom.POST_TEAR_RENDER_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 41
      [ModCallback.POST_TEAR_RENDER, this.postTearRender],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_TEAR_RENDER (41)
  private readonly postTearRender = (
    tear: EntityTear,
    renderOffset: Vector,
  ) => {
    this.fire(tear, renderOffset);
  };
}

----
classes\callbacks\PostTearUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PostTearUpdateFilter extends CustomCallback<ModCallbackCustom.POST_TEAR_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 40
      [ModCallback.POST_TEAR_UPDATE, this.postTearUpdate],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.POST_TEAR_UPDATE (40)
  private readonly postTearUpdate = (tear: EntityTear) => {
    this.fire(tear);
  };
}

----
classes\callbacks\PostTransformation.ts
import type { PlayerForm } from "isaac-typescript-definitions";
import { PLAYER_FORM_VALUES } from "../../cachedEnumValues";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { defaultMapGetPlayer } from "../../functions/playerDataStructures";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.POST_TRANSFORMATION;

const v = {
  run: {
    // We cannot use a nested `DefaultMap` here.
    playersTransformationsMap: new DefaultMap<
      PlayerIndex,
      Map<PlayerForm, boolean>
    >(() => new Map()),
  },
};

export class PostTransformation extends CustomCallback<T> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [_player, playerForm] = fireArgs;
    const [callbackPlayerForm] = optionalArgs;

    return (
      callbackPlayerForm === undefined || callbackPlayerForm === playerForm
    );
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const playerTransformationsMap = defaultMapGetPlayer(
      v.run.playersTransformationsMap,
      player,
    );

    for (const playerForm of PLAYER_FORM_VALUES) {
      const hasForm = player.HasPlayerForm(playerForm);
      let storedForm = playerTransformationsMap.get(playerForm);
      if (storedForm === undefined) {
        storedForm = false;
      }

      if (hasForm !== storedForm) {
        playerTransformationsMap.set(playerForm, hasForm);
        this.fire(player, playerForm, hasForm);
      }
    }
  };
}

----
classes\callbacks\PostTrinketBreak.ts
import type { DamageFlag } from "isaac-typescript-definitions";
import {
  EntityType,
  PickupVariant,
  TrinketType,
} from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { defaultMapGetPlayer } from "../../functions/playerDataStructures";
import { shouldFireTrinketType } from "../../shouldFire";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { DefaultMap } from "../DefaultMap";
import { CustomCallback } from "../private/CustomCallback";

const TRINKETS_THAT_CAN_BREAK = [
  TrinketType.WISH_BONE,
  TrinketType.WALNUT,
] as const;

const v = {
  run: {
    // We cannot use a nested `DefaultMap` here.
    playersTrinketMap: new DefaultMap<PlayerIndex, Map<TrinketType, int>>(
      () => new Map(),
    ),
  },
};

export class PostTrinketBreak extends CustomCallback<ModCallbackCustom.POST_TRINKET_BREAK> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFireTrinketType;

  // ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER
  private readonly entityTakeDmgPlayer = (
    player: EntityPlayer,
    _amount: float,
    _damageFlags: BitFlags<DamageFlag>,
    _source: EntityRef,
    _countdownFrames: int,
  ): boolean | undefined => {
    const trinketMap = defaultMapGetPlayer(v.run.playersTrinketMap, player);

    for (const trinketType of TRINKETS_THAT_CAN_BREAK) {
      const numTrinketsHeld = player.GetTrinketMultiplier(trinketType);
      let oldNumTrinketsHeld = trinketMap.get(trinketType);
      if (oldNumTrinketsHeld === undefined) {
        oldNumTrinketsHeld = 0;
      }

      if (numTrinketsHeld >= oldNumTrinketsHeld) {
        continue;
      }

      trinketMap.set(trinketType, numTrinketsHeld);

      // Ensure that the trinket was not dropped on the ground.
      const numTrinketsOnGround = Isaac.CountEntities(
        undefined,
        EntityType.PICKUP,
        PickupVariant.TRINKET,
        trinketType,
      );
      if (numTrinketsOnGround > 0) {
        continue;
      }

      this.fire(player, trinketType);
    }

    return undefined;
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    // On every frame, keep track of how many trinkets we have.
    const trinketMap = defaultMapGetPlayer(v.run.playersTrinketMap, player);

    for (const trinketType of TRINKETS_THAT_CAN_BREAK) {
      const numTrinkets = player.GetTrinketMultiplier(trinketType);
      if (numTrinkets === 0) {
        trinketMap.delete(trinketType);
      } else {
        trinketMap.set(trinketType, numTrinkets);
      }
    }
  };
}

----
classes\callbacks\PostUsePillFilter.ts
import type {
  PillColor,
  PillEffect,
  UseFlag,
} from "isaac-typescript-definitions";
import { ModCallback, PocketItemSlot } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { PocketItemType } from "../../enums/PocketItemType";
import { getPillColorFromEffect } from "../../functions/pills";
import {
  mapGetPlayer,
  mapSetPlayer,
} from "../../functions/playerDataStructures";
import { getPocketItems, pocketItemsEquals } from "../../functions/pocketItems";
import type { PocketItemDescription } from "../../interfaces/PocketItemDescription";
import type { PlayerIndex } from "../../types/PlayerIndex";
import { CustomCallback } from "../private/CustomCallback";

const v = {
  run: {
    pillColorToPillEffect: new Map<PillColor, PillEffect>(),
    playerPocketItems: new Map<PlayerIndex, PocketItemDescription[]>(),
  },
};

/**
 * The vanilla `POST_USE_PILL` callback does not pass the `PillColor` of the used pill. We can
 * resolve pill effect to pill color by using the `ItemPool.GetPillEffect` method. However, this
 * does not tell us whether the pill used was a horse pill. Thus, we must keep track of the pills
 * that the player is holding on every frame to account for this.
 *
 * In some cases, pills can be used without a corresponding pocket item slot, like in the case of
 * the reverse Temperance card. In this case, we fall back to looking up the color using the
 * `ItemPool.GetPillEffect` method.
 */
export class PostUsePillFilter extends CustomCallback<ModCallbackCustom.POST_USE_PILL_FILTER> {
  public override v = v;

  constructor() {
    super();

    this.callbacksUsed = [
      // 10
      [ModCallback.POST_USE_PILL, this.postUsePill],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  // ModCallback.POST_USE_PILL (10)
  private readonly postUsePill = (
    pillEffect: PillEffect,
    player: EntityPlayer,
    useFlags: BitFlags<UseFlag>,
  ) => {
    const pillColor = this.getPillColorOfCurrentlyUsedPill(player, pillEffect);
    this.fire(pillEffect, pillColor, player, useFlags);
  };

  private getPillColorOfCurrentlyUsedPill(
    player: EntityPlayer,
    pillEffect: PillEffect,
  ): PillColor {
    // First, check to see if the pocket items have changed in some way, which indicates that a real
    // pill was used.
    const oldPocketItems = mapGetPlayer(v.run.playerPocketItems, player);
    if (oldPocketItems !== undefined) {
      const pocketItems = getPocketItems(player);
      if (!pocketItemsEquals(oldPocketItems, pocketItems)) {
        const oldPocketItemSlot1 = oldPocketItems.find(
          (pocketItem) => pocketItem.slot === PocketItemSlot.SLOT_1,
        );
        if (
          oldPocketItemSlot1 !== undefined &&
          oldPocketItemSlot1.type === PocketItemType.PILL
        ) {
          return oldPocketItemSlot1.subType;
        }
      }
    }

    // At this point, either the pocket items have not changed, or we were not able to find a pill
    // in the old pocket items. The player might be using a reverse Temperance card, so we revert to
    // assuming that a non-horse pill was used and look up the color using the
    // `ItemPool.GetPillEffect` method.
    return getPillColorFromEffect(pillEffect);
  }

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    this.updateCurrentPocketItems(player);
  };

  private updateCurrentPocketItems(player: EntityPlayer) {
    const pocketItems = getPocketItems(player);
    mapSetPlayer(v.run.playerPocketItems, player, pocketItems);
  }
}

----
classes\callbacks\PreBerserkDeath.ts
import { CollectibleType } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { isChildPlayer } from "../../functions/playerIndex";
import { getPlayerNumHitsRemaining } from "../../functions/players";
import { willPlayerRevive } from "../../functions/revive";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreBerserkDeath extends CustomCallback<ModCallbackCustom.PRE_BERSERK_DEATH> {
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (
    player: EntityPlayer,
  ): void => {
    // This callback should not trigger for the Strawman Keeper and other players that are "child"
    // players.
    if (isChildPlayer(player)) {
      return;
    }

    const effects = player.GetEffects();
    const berserkEffect = effects.GetCollectibleEffect(CollectibleType.BERSERK);
    const numHitsRemaining = getPlayerNumHitsRemaining(player);

    // If the Berserk effect will end on the next frame and we have no hearts left.
    if (
      berserkEffect !== undefined &&
      berserkEffect.Cooldown === 1 &&
      numHitsRemaining === 0 &&
      !willPlayerRevive(player)
    ) {
      this.fire(player);
    }
  };
}

----
classes\callbacks\PreBombCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireBomb } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreBombCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_BOMB_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 60
      [ModCallback.PRE_BOMB_COLLISION, this.preBombCollision],
    ];
  }

  protected override shouldFire = shouldFireBomb;

  // ModCallback.PRE_BOMB_COLLISION (60)
  private readonly preBombCollision = (
    bomb: EntityBomb,
    collider: Entity,
    low: boolean,
  ): boolean | undefined => this.fire(bomb, collider, low);
}

----
classes\callbacks\PreCustomRevive.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreCustomRevive extends CustomCallback<ModCallbackCustom.PRE_CUSTOM_REVIVE> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.CUSTOM_REVIVE];
  }

  protected override shouldFire = shouldFirePlayer;
}

----
classes\callbacks\PreEntitySpawnFilter.ts
import type { EntityType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.PRE_ENTITY_SPAWN_FILTER;

export class PreEntitySpawnFilter extends CustomCallback<T> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 24
      [ModCallback.PRE_ENTITY_SPAWN, this.preEntitySpawn],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [entityType, variant, subType] = fireArgs;
    const [callbackEntityType, callbackVariant, callbackSubType] = optionalArgs;

    return (
      (callbackEntityType === undefined || callbackEntityType === entityType) &&
      (callbackVariant === undefined || callbackVariant === variant) &&
      (callbackSubType === undefined || callbackSubType === subType)
    );
  };

  // ModCallback.PRE_ENTITY_SPAWN (24)
  private readonly preEntitySpawn = (
    entityType: EntityType,
    variant: int,
    subType: int,
    position: Vector,
    velocity: Vector,
    spawner: Entity | undefined,
    initSeed: Seed,
  ) =>
    this.fire(
      entityType,
      variant,
      subType,
      position,
      velocity,
      spawner,
      initSeed,
    );
}

----
classes\callbacks\PreFamiliarCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireFamiliar } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreFamiliarCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_FAMILIAR_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 26
      [ModCallback.PRE_FAMILIAR_COLLISION, this.preFamiliarCollision],
    ];
  }

  protected override shouldFire = shouldFireFamiliar;

  // ModCallback.PRE_FAMILIAR_COLLISION (26)
  private readonly preFamiliarCollision = (
    familiar: EntityFamiliar,
    collider: Entity,
    low: boolean,
  ): boolean | undefined => this.fire(familiar, collider, low);
}

----
classes\callbacks\PreGetPedestal.ts
import {
  CollectibleType,
  ModCallback,
  PickupVariant,
} from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFirePlayer } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreGetPedestal extends CustomCallback<ModCallbackCustom.PRE_GET_PEDESTAL> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 38
      [
        ModCallback.PRE_PICKUP_COLLISION,
        this.prePickupCollision,
        [PickupVariant.COLLECTIBLE],
      ],
    ];
  }

  protected override shouldFire = shouldFirePlayer;

  // ModCallback.PRE_PICKUP_COLLISION (35)
  private readonly prePickupCollision = (
    pickup: EntityPickup,
    collider: Entity,
    _low: boolean,
  ): boolean | undefined => {
    const collectible = pickup as EntityPickupCollectible;

    if (collectible.SubType === CollectibleType.NULL) {
      return undefined;
    }

    const player = collider.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    const numCoins = player.GetNumCoins();
    if (collectible.Price > numCoins) {
      return undefined;
    }

    // Collectibles have a special variable to prevent them from being picked up for a certain time.
    // Players have special variable to prevent them from picking up a collectible for a certain
    // time.
    if (collectible.Wait > 0 || player.ItemHoldCooldown > 0) {
      return undefined;
    }

    if (player.IsHoldingItem()) {
      return undefined;
    }

    return this.fire(player, collectible);
  };
}

----
classes\callbacks\PreItemPickup.ts
import { ISCFeature } from "../../enums/ISCFeature";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireItemPickup } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreItemPickup extends CustomCallback<ModCallbackCustom.PRE_ITEM_PICKUP> {
  constructor() {
    super();

    this.featuresUsed = [ISCFeature.ITEM_PICKUP_DETECTION];
  }

  protected override shouldFire = shouldFireItemPickup;
}

----
classes\callbacks\PreKnifeCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireKnife } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreKnifeCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_KNIFE_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 53
      [ModCallback.PRE_KNIFE_COLLISION, this.preKnifeCollision],
    ];
  }

  protected override shouldFire = shouldFireKnife;

  // ModCallback.PRE_KNIFE_COLLISION (53)
  private readonly preKnifeCollision = (
    knife: EntityKnife,
    collider: Entity,
    low: boolean,
  ): boolean | undefined => this.fire(knife, collider, low);
}

----
classes\callbacks\PreNPCCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreNPCCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_NPC_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 30
      [ModCallback.PRE_NPC_COLLISION, this.preNPCCollision],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.PRE_NPC_COLLISION (30)
  private readonly preNPCCollision = (
    npc: EntityNPC,
    collider: Entity,
    low: boolean,
  ) => this.fire(npc, collider, low);
}

----
classes\callbacks\PreNPCUpdateFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireNPC } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreNPCUpdateFilter extends CustomCallback<ModCallbackCustom.PRE_NPC_UPDATE_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 69
      [ModCallback.PRE_NPC_UPDATE, this.preNPCUpdate],
    ];
  }

  protected override shouldFire = shouldFireNPC;

  // ModCallback.PRE_NPC_UPDATE (69)
  private readonly preNPCUpdate = (npc: EntityNPC) => this.fire(npc);
}

----
classes\callbacks\PreNewLevel.ts
import { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { getLastFrameOfAnimation } from "../../functions/sprites";
import { getEffectiveStage } from "../../functions/stage";
import { ReadonlySet } from "../../types/ReadonlySet";
import { CustomCallback } from "../private/CustomCallback";

const TRAVELING_TO_NEXT_FLOOR_ANIMATIONS = new ReadonlySet<string>([
  "Trapdoor",
  "LightTravel",
]);

const v = {
  run: {
    firedOnStage: null as int | null,
  },
};

export class PreNewLevel extends CustomCallback<ModCallbackCustom.PRE_NEW_LEVEL> {
  public override v = v;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PLAYER_RENDER_REORDERED,
        this.postPlayerRenderReordered,
      ],
    ];
  }

  // ModCallbackCustom.POST_PLAYER_RENDER_REORDERED
  private readonly postPlayerRenderReordered = (player: EntityPlayer) => {
    const effectiveStage = getEffectiveStage();
    if (effectiveStage === v.run.firedOnStage) {
      return;
    }

    const sprite = player.GetSprite();
    const animation = sprite.GetAnimation();
    if (!TRAVELING_TO_NEXT_FLOOR_ANIMATIONS.has(animation)) {
      return;
    }

    // We can't use the `Sprite.IsFinished` method to detect when we are at the end of the animation
    // because the player will stop rendering at that point. Thus, revert to checking for the final
    // frame manually.
    const frame = sprite.GetFrame();
    const finalFrame = getLastFrameOfAnimation(sprite);
    if (frame === finalFrame) {
      v.run.firedOnStage = effectiveStage;
      this.fire(player);
    }
  };
}

----
classes\callbacks\PreProjectileCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireProjectile } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreProjectileCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_PROJECTILE_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 46
      [ModCallback.PRE_PROJECTILE_COLLISION, this.preProjectileCollision],
    ];
  }

  protected override shouldFire = shouldFireProjectile;

  // ModCallback.PRE_PROJECTILE_COLLISION (46)
  private readonly preProjectileCollision = (
    projectile: EntityProjectile,
    collider: Entity,
    low: boolean,
  ): boolean | undefined => this.fire(projectile, collider, low);
}

----
classes\callbacks\PreRoomEntitySpawnFilter.ts
import type {
  EntityType,
  GridEntityXMLType,
} from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { FireArgs, OptionalArgs } from "../private/CustomCallback";
import { CustomCallback } from "../private/CustomCallback";

type T = ModCallbackCustom.PRE_ROOM_ENTITY_SPAWN_FILTER;

export class PreRoomEntitySpawnFilter extends CustomCallback<T> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 71
      [ModCallback.PRE_ROOM_ENTITY_SPAWN, this.preRoomEntitySpawn],
    ];
  }

  protected override shouldFire = (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ): boolean => {
    const [entityTypeOrGridEntityXMLType, variant, subType] = fireArgs;
    const [
      callbackEntityTypeOrGridEntityXMLType,
      callbackVariant,
      callbackSubType,
    ] = optionalArgs;

    return (
      (callbackEntityTypeOrGridEntityXMLType === undefined ||
        callbackEntityTypeOrGridEntityXMLType ===
          entityTypeOrGridEntityXMLType) &&
      (callbackVariant === undefined || callbackVariant === variant) &&
      (callbackSubType === undefined || callbackSubType === subType)
    );
  };

  // ModCallback.PRE_ROOM_ENTITY_SPAWN (71)
  private readonly preRoomEntitySpawn = (
    entityTypeOrGridEntityXMLType: EntityType | GridEntityXMLType,
    variant: int,
    subType: int,
    gridIndex: int,
    initSeed: Seed,
  ) =>
    this.fire(
      entityTypeOrGridEntityXMLType,
      variant,
      subType,
      gridIndex,
      initSeed,
    );
}

----
classes\callbacks\PreTearCollisionFilter.ts
import { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { shouldFireTear } from "../../shouldFire";
import { CustomCallback } from "../private/CustomCallback";

export class PreTearCollisionFilter extends CustomCallback<ModCallbackCustom.PRE_TEAR_COLLISION_FILTER> {
  constructor() {
    super();

    this.callbacksUsed = [
      // 42
      [ModCallback.PRE_TEAR_COLLISION, this.preTearCollision],
    ];
  }

  protected override shouldFire = shouldFireTear;

  // ModCallback.PRE_TEAR_COLLISION (42)
  private readonly preTearCollision = (
    tear: EntityTear,
    collider: Entity,
    low: boolean,
  ): boolean | undefined => this.fire(tear, collider, low);
}

----
classes\features\callbackLogic\CustomGridEntities.ts
import type { ActiveSlot, UseFlag } from "isaac-typescript-definitions";
import {
  CollectibleType,
  GridCollisionClass,
  GridEntityType,
  ModCallback,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import {
  removeGridEntity,
  spawnGridEntityWithVariant,
} from "../../../functions/gridEntities";
import { getPlayerFromPtr } from "../../../functions/players";
import { getRoomListIndex } from "../../../functions/roomData";
import { isInteger } from "../../../functions/types";
import { assertDefined } from "../../../functions/utils";
import { isVector } from "../../../functions/vector";
import type { GridEntityCustomData } from "../../../interfaces/GridEntityCustomData";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";
import type { RunInNFrames } from "../other/RunInNFrames";

const v = {
  level: {
    /** Indexed by room list index and grid index. */
    customGridEntities: new DefaultMap<int, Map<int, GridEntityCustomData>>(
      () => new Map(),
    ),
  },

  room: {
    genericPropPtrHashes: new Set<PtrHash>(),
    manuallyUsingShovel: false,
  },
};

export class CustomGridEntities extends Feature {
  /** @internal */
  public override v = v;

  private readonly runInNFrames: RunInNFrames;

  /** @internal */
  constructor(runInNFrames: RunInNFrames) {
    super();

    this.featuresUsed = [ISCFeature.RUN_IN_N_FRAMES];

    this.callbacksUsed = [
      // 23
      [
        ModCallback.PRE_USE_ITEM,
        this.preUseItemWeNeedToGoDeeper,
        [CollectibleType.WE_NEED_TO_GO_DEEPER],
      ],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.runInNFrames = runInNFrames;
  }

  // ModCallback.PRE_USE_ITEM (23)
  // CollectibleType.WE_NEED_TO_GO_DEEPER (84)
  private readonly preUseItemWeNeedToGoDeeper = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: ActiveSlot,
    _customVarData: int,
  ): boolean | undefined => {
    // If a player uses We Need to Go Deeper on top of a custom grid entity, then they will always
    // get a crawlspace, due to how custom grids are implemented with decorations. Thus, remove the
    // custom grid entity to prevent this from happening if needed.
    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();
    const roomCustomGridEntities =
      v.level.customGridEntities.get(roomListIndex);
    if (roomCustomGridEntities === undefined) {
      return undefined;
    }

    const gridIndex = room.GetGridIndex(player.Position);
    const customGridEntity = roomCustomGridEntities.get(gridIndex);
    if (customGridEntity === undefined) {
      return undefined;
    }

    // If the custom grid entity has collision, then the player should not be able to be standing on
    // top of it.
    if (customGridEntity.gridCollisionClass !== GridCollisionClass.NONE) {
      return undefined;
    }

    removeGridEntity(customGridEntity.gridIndex, false);

    const entityPtr = EntityPtr(player);
    this.runInNFrames.runNextGameFrame(() => {
      const futurePlayer = getPlayerFromPtr(entityPtr);
      if (futurePlayer === undefined) {
        return;
      }

      v.room.manuallyUsingShovel = true;
      futurePlayer.UseActiveItem(CollectibleType.WE_NEED_TO_GO_DEEPER);
      v.room.manuallyUsingShovel = false;
    });

    // Cancel the original effect.
    return true;
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = (): void => {
    // When we re-enter a room, the graphics for any custom entities will be reverted back to that
    // of a normal decoration. Thus, we must re-apply the anm2.
    const roomListIndex = getRoomListIndex();
    const roomCustomGridEntities =
      v.level.customGridEntities.get(roomListIndex);
    if (roomCustomGridEntities === undefined) {
      return;
    }

    const room = game.GetRoom();
    for (const [gridIndex, data] of roomCustomGridEntities) {
      const decoration = room.GetGridEntity(gridIndex);
      if (decoration === undefined) {
        roomCustomGridEntities.delete(gridIndex);
        continue;
      }

      if (data.anm2Path !== undefined) {
        const sprite = decoration.GetSprite();
        sprite.Load(data.anm2Path, true);
        const animationToPlay =
          data.defaultAnimation ?? sprite.GetDefaultAnimation();
        sprite.Play(animationToPlay, true);
      }
    }
  };

  /**
   * Helper function to spawn a custom grid entity. Custom grid entities are persistent in that they
   * will reappear if the player leaves and re-enters the room. (It will be manually respawned in
   * the `POST_NEW_ROOM` callback.)
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CUSTOM_GRID_ENTITIES`.
   *
   * Custom grid entities are built on top of real grid entities. You can use any existing grid
   * entity type as a base. For example, if you want to create a custom rock that would be breakable
   * like a normal rock, then you should specify `GridEntityType.ROCK` as the base grid entity type.
   *
   * Once a custom grid entity is spawned, you can take advantage of the custom grid callbacks such
   * as `POST_GRID_ENTITY_CUSTOM_UPDATE`. Note that the "normal" grid entities callbacks will not
   * fire for custom entities. For example, if you had a custom grid entity based on
   * `GridEntityType.ROCK`, and you also had a subscription to the `POST_GRID_ENTITY_UPDATE`
   * callback, the callback would only fire for normal rocks and not the custom entity.
   *
   * Custom grid entities are an IsaacScript feature because the vanilla game does not support any
   * custom grid entities.
   *
   * For example, this would be code to create a custom rock called a "Silver Rock" that produces a
   * dime when destroyed:
   *
   * ```ts
   * // This is local to the mod and can safely overlap with the values of `GridEntityType` (or
   * // values chosen by other mods).
   * const GridEntityTypeCustom = {
   *   SILVER_ROCK: 0 as GridEntityType,
   * } as const;
   *
   * // This is copied from "gfx/grid/grid_rock.anm2" with some tweaks to make it look special.
   * const SILVER_ROCK_ANM2_PATH = "gfx/grid/grid_rock_silver.anm2";
   *
   * export function silverRockInit(mod: ModUpgraded): void {
   *   mod.AddCallbackCustom(
   *     ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_BROKEN,
   *     postGridEntityCustomBrokenSilverRock,
   *     GridEntityTypeCustom.SILVER_ROCK,
   *   );
   * }
   *
   * function postGridEntityCustomBrokenSilverRock(gridEntity: GridEntity) {
   *   spawnCoin(CoinSubType.DIME, gridEntity.Position);
   * }
   *
   * export function spawnSilverRock(mod: ModUpgraded, gridIndex: int): GridEntity {
   *   return mod.spawnCustomGridEntity(
   *     GridEntityTypeCustom.SILVER_ROCK,
   *     gridIndex,
   *     undefined,
   *     SILVER_ROCK_ANM2_PATH,
   *     undefined,
   *     GridEntityType.ROCK,
   *   );
   * }
   * ```
   *
   * @param gridEntityTypeCustom An integer that identifies what kind of grid entity you are
   *                             creating. It should correspond to a local enum value created in
   *                             your mod. The integer can be any unique value and will not
   *                             correspond to the actual grid entity type used. (This integer is
   *                             used in the various custom grid entity callbacks.)
   * @param gridIndexOrPosition The grid index or position in the room that you want to spawn the
   *                            grid entity at. If a position is specified, the closest grid index
   *                            will be used.
   * @param gridCollisionClass Optional. The collision class that you want the custom grid entity to
   *                           have. If not specified, the grid collision class from the base grid
   *                           entity will be used.
   * @param anm2Path Optional. The path to the ANM2 file to use for the sprite. If not specified,
   *                 the normal sprite from the base grid entity will be used.
   * @param defaultAnimation Optional. The name of the animation to play after the sprite is
   *                         initialized and after the player re-enters a room with this grid entity
   *                         in it. If not specified, the default animation in the anm2 will be
   *                         used.
   * @param baseGridEntityType Optional. The type of the grid entity to use as a "base" for this
   *                           custom grid entity. Default is `GridEntityType.DECORATION`.
   * @param baseGridEntityVariant Optional. The variant of the grid entity to use as a "base" for
   *                              this custom grid entity. Default is 0.
   * @public
   */
  @Exported
  public spawnCustomGridEntity(
    gridEntityTypeCustom: GridEntityType,
    gridIndexOrPosition: int | Vector,
    gridCollisionClass?: GridCollisionClass,
    anm2Path?: string,
    defaultAnimation?: string,
    baseGridEntityType = GridEntityType.DECORATION,
    baseGridEntityVariant = 0,
  ): GridEntity {
    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();
    const gridIndex = isVector(gridIndexOrPosition)
      ? room.GetGridIndex(gridIndexOrPosition)
      : gridIndexOrPosition;

    const customGridEntity = spawnGridEntityWithVariant(
      baseGridEntityType,
      baseGridEntityVariant,
      gridIndexOrPosition,
    );
    assertDefined(customGridEntity, "Failed to spawn a custom grid entity.");

    if (gridCollisionClass !== undefined) {
      customGridEntity.CollisionClass = gridCollisionClass;
    }

    if (anm2Path !== undefined) {
      const sprite = customGridEntity.GetSprite();
      sprite.Load(anm2Path, true);
      const animationToPlay = defaultAnimation ?? sprite.GetDefaultAnimation();
      sprite.Play(animationToPlay, true);
    }

    const customGridEntityData: GridEntityCustomData = {
      gridEntityTypeCustom,
      roomListIndex,
      gridIndex,
      anm2Path,
      defaultAnimation,
      gridCollisionClass,
    };

    const roomCustomGridEntities =
      v.level.customGridEntities.getAndSetDefault(roomListIndex);
    roomCustomGridEntities.set(gridIndex, customGridEntityData);

    return customGridEntity;
  }

  /**
   * Helper function to remove a custom grid entity created by the `spawnCustomGrid` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CUSTOM_GRID_ENTITIES`.
   *
   * @param gridIndexOrPositionOrGridEntity You can specify the custom grid entity to remove by
   *                                providing the grid index, the room position, or the grid entity
   *                                itself.
   * @param updateRoom Optional. Whether to update the room after the grid entity is removed.
   *                   Default is true. This is generally a good idea because if the room is not
   *                   updated, you will be unable to spawn another grid entity on the same tile
   *                   until a frame has passed. However, doing this is expensive, since it involves
   *                   a call to `Isaac.GetRoomEntities`, so set it to false if you need to run this
   *                   function multiple times.
   * @returns The grid entity that was removed. Returns undefined if no grid entity was found at the
   *          given location or if the given grid entity was not a custom grid entity.
   * @public
   */
  @Exported
  public removeCustomGridEntity(
    gridIndexOrPositionOrGridEntity: int | Vector | GridEntity,
    updateRoom = true,
  ): GridEntity | undefined {
    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();

    let decoration: GridEntity;
    if (typeof gridIndexOrPositionOrGridEntity === "number") {
      const gridIndex = gridIndexOrPositionOrGridEntity;
      const gridEntity = room.GetGridEntity(gridIndex);
      if (gridEntity === undefined) {
        return undefined;
      }

      decoration = gridEntity;
    } else if (isVector(gridIndexOrPositionOrGridEntity)) {
      const position = gridIndexOrPositionOrGridEntity;
      const gridEntity = room.GetGridEntityFromPos(position);
      if (gridEntity === undefined) {
        return undefined;
      }

      decoration = gridEntity;
    } else {
      decoration = gridIndexOrPositionOrGridEntity;
    }

    const gridIndex = decoration.GetGridIndex();
    const roomCustomGridEntities =
      v.level.customGridEntities.getAndSetDefault(roomListIndex);
    const exists = roomCustomGridEntities.has(gridIndex);
    if (!exists) {
      return undefined;
    }

    roomCustomGridEntities.delete(gridIndex);
    removeGridEntity(decoration, updateRoom);

    return decoration;
  }

  /**
   * Helper function to get the custom grid entities in the current room. Returns an array of tuples
   * containing the raw decoration grid entity and the associated entity data.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CUSTOM_GRID_ENTITIES`.
   *
   * @public
   */
  @Exported
  public getCustomGridEntities(): Array<{
    gridEntity: GridEntity;
    data: GridEntityCustomData;
  }> {
    const roomListIndex = getRoomListIndex();
    const roomCustomGridEntities =
      v.level.customGridEntities.get(roomListIndex);
    if (roomCustomGridEntities === undefined) {
      return [];
    }

    const room = game.GetRoom();
    const customGridEntities: Array<{
      gridEntity: GridEntity;
      data: GridEntityCustomData;
    }> = [];
    for (const [gridIndex, data] of roomCustomGridEntities) {
      const gridEntity = room.GetGridEntity(gridIndex);
      if (gridEntity !== undefined) {
        customGridEntities.push({ gridEntity, data });
      }
    }

    return customGridEntities;
  }

  /**
   * Helper function to get the custom `GridEntityType` from a `GridEntity` or grid index. Returns
   * undefined if the provided `GridEntity` is not a custom grid entity, or if there was not a grid
   * entity on the provided grid index.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CUSTOM_GRID_ENTITIES`.
   *
   * @public
   */
  @Exported
  public getCustomGridEntityType(
    gridEntityOrGridIndex: GridEntity | int,
  ): GridEntityType | undefined {
    if (!this.initialized) {
      return undefined;
    }

    const gridIndex = isInteger(gridEntityOrGridIndex)
      ? gridEntityOrGridIndex
      : gridEntityOrGridIndex.GetGridIndex();

    const roomListIndex = getRoomListIndex();
    const roomCustomGridEntities =
      v.level.customGridEntities.get(roomListIndex);
    if (roomCustomGridEntities === undefined) {
      return undefined;
    }

    for (const [_gridIndex, data] of roomCustomGridEntities) {
      if (data.gridIndex === gridIndex) {
        return data.gridEntityTypeCustom;
      }
    }

    return undefined;
  }

  /**
   * Helper function to check if a `GridEntity` is a custom grid entity or if a grid index has a
   * custom grid entity.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CUSTOM_GRID_ENTITIES`.
   *
   * @public
   */
  @Exported
  public isCustomGridEntity(gridEntityOrGridIndex: GridEntity | int): boolean {
    const gridEntityTypeCustom = this.getCustomGridEntityType(
      gridEntityOrGridIndex,
    );
    return gridEntityTypeCustom !== undefined;
  }
}

----
classes\features\callbackLogic\CustomRevive.ts
import {
  CollectibleType,
  FamiliarVariant,
  ModCallback,
  PlayerType,
  SoundEffect,
} from "isaac-typescript-definitions";
import { sfxManager } from "../../../core/cachedClasses";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { rebirthItemTrackerRemoveCollectible } from "../../../functions/external";
import { log, logError } from "../../../functions/log";
import {
  getPlayerFromIndex,
  getPlayerIndex,
} from "../../../functions/playerIndex";
import { isCharacter } from "../../../functions/players";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import type { PostCustomRevive } from "../../callbacks/PostCustomRevive";
import type { PreCustomRevive } from "../../callbacks/PreCustomRevive";
import { Feature } from "../../private/Feature";
import type { RunInNFrames } from "../other/RunInNFrames";

const DEBUG = false as boolean;

enum CustomReviveState {
  DISABLED,

  /**
   * We can't immediately jump to waiting for an item animation because it is possible for a player
   * to be holding an item above their head as they are dying (e.g. with Razor Blade).
   */
  WAITING_FOR_ROOM_TRANSITION,

  WAITING_FOR_ITEM_ANIMATION,
}

const v = {
  run: {
    state: CustomReviveState.DISABLED,
    revivalType: null as int | null,
    dyingPlayerIndex: null as PlayerIndex | null,
  },
};

export class CustomRevive extends Feature {
  public override v = v;

  private readonly preCustomRevive: PreCustomRevive;
  private readonly postCustomRevive: PostCustomRevive;
  private readonly runInNFrames: RunInNFrames;

  constructor(
    preCustomRevive: PreCustomRevive,
    postCustomRevive: PostCustomRevive,
    runInNFrames: RunInNFrames,
  ) {
    super();

    this.featuresUsed = [ISCFeature.RUN_IN_N_FRAMES];

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],

      // 7
      [
        ModCallback.POST_FAMILIAR_INIT,
        this.postFamiliarInitOneUp,
        [FamiliarVariant.ONE_UP],
      ],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
      [ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE, this.postPlayerFatalDamage],
      [ModCallbackCustom.PRE_BERSERK_DEATH, this.preBerserkDeath],
    ];

    this.preCustomRevive = preCustomRevive;
    this.postCustomRevive = postCustomRevive;
    this.runInNFrames = runInNFrames;
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    if (v.run.state !== CustomReviveState.WAITING_FOR_ITEM_ANIMATION) {
      return;
    }

    // The 1-up sound will fire before the item holding animation begins, so we mute it on every
    // render frame.
    sfxManager.Stop(SoundEffect.ONE_UP);
  };

  // ModCallback.POST_FAMILIAR_INIT (7)
  // FamiliarVariant.ONE_UP (41)
  private readonly postFamiliarInitOneUp = (familiar: EntityFamiliar): void => {
    if (v.run.state !== CustomReviveState.WAITING_FOR_ROOM_TRANSITION) {
      return;
    }

    familiar.Remove();
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = (): void => {
    if (v.run.state !== CustomReviveState.WAITING_FOR_ROOM_TRANSITION) {
      return;
    }

    v.run.state = CustomReviveState.WAITING_FOR_ITEM_ANIMATION;
    this.logStateChanged();
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (
    player: EntityPlayer,
  ): void => {
    this.checkWaitingForItemAnimation(player);
  };

  private checkWaitingForItemAnimation(player: EntityPlayer): void {
    if (v.run.state !== CustomReviveState.WAITING_FOR_ITEM_ANIMATION) {
      return;
    }

    if (v.run.dyingPlayerIndex === null) {
      return;
    }

    const playerIndex = getPlayerIndex(player);
    if (playerIndex !== v.run.dyingPlayerIndex) {
      return;
    }

    let playerToCheckHoldingItem = player;
    if (isCharacter(player, PlayerType.SOUL_B)) {
      const forgottenBody = player.GetOtherTwin();
      if (forgottenBody !== undefined) {
        playerToCheckHoldingItem = forgottenBody;
      }
    }

    if (!playerToCheckHoldingItem.IsHoldingItem()) {
      return;
    }

    // The player is now playing the animation where they hold the 1-Up item overhead. The
    // `EntityPlayer.StopExtraAnimation` method will not work to stop this animation. End-users are
    // expected to play a new animation in the PostCustomRevive callback, which will overwrite the
    // 1-Up animation.

    if (v.run.revivalType !== null) {
      this.postCustomRevive.fire(playerToCheckHoldingItem, v.run.revivalType);
    }

    v.run.state = CustomReviveState.DISABLED;
    v.run.revivalType = null;
    v.run.dyingPlayerIndex = null;
    this.logStateChanged();
  }

  // ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE
  private readonly postPlayerFatalDamage = (
    player: EntityPlayer,
  ): boolean | undefined => {
    this.playerIsAboutToDie(player);
    return undefined;
  };

  // ModCallbackCustom.PRE_BERSERK_DEATH
  private readonly preBerserkDeath = (player: EntityPlayer): void => {
    this.playerIsAboutToDie(player);
  };

  /**
   * The player is about to die, which will immediately delete the save data for the run. To prevent
   * this from happening, we grant the 1-Up item.
   */
  private playerIsAboutToDie(player: EntityPlayer): void {
    const revivalType = this.preCustomRevive.fire(player);
    if (revivalType === undefined) {
      return;
    }

    v.run.state = CustomReviveState.WAITING_FOR_ROOM_TRANSITION;
    v.run.revivalType = revivalType;
    v.run.dyingPlayerIndex = getPlayerIndex(player);
    this.logStateChanged();

    player.AddCollectible(CollectibleType.ONE_UP, 0, false);
    rebirthItemTrackerRemoveCollectible(CollectibleType.ONE_UP);

    // The player should always be dead one frame from now. If they are not, then something has gone
    // wrong, probably with the `isDamageToPlayerFatal` function. Since end-user code is already
    // assuming that a custom revive is occurring, explicitly kill the player.
    const playerIndex = getPlayerIndex(player);
    this.runInNFrames.runNextGameFrame(() => {
      const futurePlayer = getPlayerFromIndex(playerIndex);
      if (futurePlayer === undefined) {
        return;
      }

      if (futurePlayer.IsDead()) {
        return;
      }

      logError(
        "The player is still alive after initializing a custom revive. Explicitly killing the player.",
      );
      futurePlayer.Kill();
    });
  }

  private logStateChanged(): void {
    if (DEBUG) {
      log(
        `Custom revive state changed: ${CustomReviveState[v.run.state]} (${
          v.run.state
        })`,
      );
    }
  }
}

----
classes\features\callbackLogic\EsauJrDetection.ts
import type { ControllerIndex, UseFlag } from "isaac-typescript-definitions";
import { CollectibleType, ModCallback } from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { getPlayersWithControllerIndex } from "../../../functions/players";
import type { PostEsauJr } from "../../callbacks/PostEsauJr";
import type { PostFirstEsauJr } from "../../callbacks/PostFirstEsauJr";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    usedEsauJrFrame: null as int | null,
    usedEsauJrControllerIndex: null as ControllerIndex | null,
    usedEsauJrAtLeastOnce: false,
  },
};

export class EsauJrDetection extends Feature {
  public override v = v;

  private readonly postEsauJr: PostEsauJr;
  private readonly postFirstEsauJr: PostFirstEsauJr;

  constructor(postEsauJr: PostEsauJr, postFirstEsauJr: PostFirstEsauJr) {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],

      // 3
      [
        ModCallback.POST_USE_ITEM,
        this.postUseItemEsauJr,
        [CollectibleType.ESAU_JR],
      ],
    ];

    this.postEsauJr = postEsauJr;
    this.postFirstEsauJr = postFirstEsauJr;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    const gameFrameCount = game.GetFrameCount();

    // Check to see if it is the frame after the player has used Esau Jr.
    if (
      v.run.usedEsauJrFrame === null ||
      gameFrameCount < v.run.usedEsauJrFrame + 1
    ) {
      return;
    }
    v.run.usedEsauJrFrame = null;

    // Find the player corresponding to the player who used Esau Jr. a frame ago (via matching the
    // ControllerIndex).
    if (v.run.usedEsauJrControllerIndex === null) {
      return;
    }
    const players = getPlayersWithControllerIndex(
      v.run.usedEsauJrControllerIndex,
    );
    v.run.usedEsauJrControllerIndex = null;

    const player = players[0];
    if (player === undefined) {
      return;
    }

    if (!v.run.usedEsauJrAtLeastOnce) {
      v.run.usedEsauJrAtLeastOnce = true;
      this.postFirstEsauJr.fire(player);
    }

    this.postEsauJr.fire(player);
  };

  // ModCallback.POST_USE_ITEM (3)
  // CollectibleType.ESAU_JR (703)
  private readonly postUseItemEsauJr = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: int,
    _customVarData: int,
  ): boolean | undefined => {
    const gameFrameCount = game.GetFrameCount();

    // The player only changes to Esau Jr. on the frame after the item is used.
    v.run.usedEsauJrFrame = gameFrameCount + 1;
    v.run.usedEsauJrControllerIndex = player.ControllerIndex;

    return undefined;
  };
}

----
classes\features\callbackLogic\FlipDetection.ts
import type { UseFlag } from "isaac-typescript-definitions";
import {
  CollectibleType,
  ModCallback,
  PlayerType,
} from "isaac-typescript-definitions";
import { getPlayersOfType, isTaintedLazarus } from "../../../functions/players";
import type { PostFirstFlip } from "../../callbacks/PostFirstFlip";
import type { PostFlip } from "../../callbacks/PostFlip";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    /** We don't consider the case of a multiplayer game with more than one Tainted Lazarus. */
    usedFlipAtLeastOnce: false,
  },
};

export class FlipDetection extends Feature {
  public override v = v;

  private readonly postFlip: PostFlip;
  private readonly postFirstFlip: PostFirstFlip;

  constructor(postFlip: PostFlip, postFirstFlip: PostFirstFlip) {
    super();

    this.callbacksUsed = [
      // 3
      [ModCallback.POST_USE_ITEM, this.postUseItemFlip, [CollectibleType.FLIP]],
    ];

    this.postFlip = postFlip;
    this.postFirstFlip = postFirstFlip;
  }

  // ModCallback.POST_USE_ITEM (3)
  // CollectibleType.FLIP (711)
  private readonly postUseItemFlip = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: int,
    _customVarData: int,
  ): boolean | undefined => {
    if (!isTaintedLazarus(player)) {
      return undefined;
    }

    // The player passed as part of the callback will be the old Lazarus that used the Flip item. We
    // pass the new Lazarus to the callback subscribers.
    const newLazarus = getNewLazarus(player);
    if (newLazarus === undefined) {
      return undefined;
    }

    if (!v.run.usedFlipAtLeastOnce) {
      v.run.usedFlipAtLeastOnce = true;
      this.postFirstFlip.fire(newLazarus, player);
    }

    this.postFlip.fire(newLazarus, player);

    return undefined;
  };
}

function getNewLazarus(oldLazarus: EntityPlayer): EntityPlayer | undefined {
  const oldCharacter = oldLazarus.GetPlayerType();

  let newCharacter: PlayerType;
  if (oldCharacter === PlayerType.LAZARUS_B) {
    newCharacter = PlayerType.LAZARUS_2_B;
  } else if (oldCharacter === PlayerType.LAZARUS_2_B) {
    newCharacter = PlayerType.LAZARUS_B;
  } else {
    return undefined;
  }

  const playersOfType = getPlayersOfType(newCharacter);
  return playersOfType.find(
    (player) => player.FrameCount === oldLazarus.FrameCount,
  );
}

----
classes\features\callbackLogic\GameReorderedCallbacks.ts
import type { LevelStage, StageType } from "isaac-typescript-definitions";
import { CollectibleType, ModCallback } from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { onGameFrame, onRenderFrame } from "../../../functions/frames";
import type { PostGameStartedReordered } from "../../callbacks/PostGameStartedReordered";
import type { PostGameStartedReorderedLast } from "../../callbacks/PostGameStartedReorderedLast";
import type { PostNewLevelReordered } from "../../callbacks/PostNewLevelReordered";
import type { PostNewRoomReordered } from "../../callbacks/PostNewRoomReordered";
import { Feature } from "../../private/Feature";

/**
 * By default, callbacks fire in the following order:
 * - `POST_NEW_ROOM` --> `POST_NEW_LEVEL` --> `POST_GAME_STARTED`
 *
 * It is easier to write mod code if the callbacks run in a more logical order:
 * - `POST_GAME_STARTED` --> `POST_NEW_LEVEL` --> `POST_NEW_ROOM`
 *
 * `isaacscript-common` provides three new callbacks that change the order to this:
 * - `POST_GAME_STARTED_REORDERED`
 * - `POST_NEW_LEVEL_REORDERED`
 * - `POST_NEW_ROOM_REORDERED`
 *
 * Additionally, there are some helper functions listed below that can deal with some edge cases
 * that you may run into with these callbacks.
 */
export class GameReorderedCallbacks extends Feature {
  /** Used to detect a player resuming a saved run. */
  private renderFrameRunStarted: int | null = null;

  private currentStage: int | null = null;
  private currentStageType: int | null = null;
  private usedGlowingHourGlass = false;
  private forceNewLevel = false;
  private forceNewRoom = false;

  private readonly postGameStartedReordered: PostGameStartedReordered;
  private readonly postNewLevelReordered: PostNewLevelReordered;
  private readonly postNewRoomReordered: PostNewRoomReordered;
  private readonly postGameStartedReorderedLast: PostGameStartedReorderedLast;

  /** @internal */
  constructor(
    postGameStartedReordered: PostGameStartedReordered,
    postNewLevelReordered: PostNewLevelReordered,
    postNewRoomReordered: PostNewRoomReordered,
    postGameStartedReorderedLast: PostGameStartedReorderedLast,
  ) {
    super();

    this.callbacksUsed = [
      // 3
      [
        ModCallback.POST_USE_ITEM,
        this.postUseItemGlowingHourGlass,
        [CollectibleType.GLOWING_HOUR_GLASS],
      ],

      // 9
      [ModCallback.POST_PLAYER_INIT, this.postPlayerInit],

      // 15
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_GAME_STARTED, this.postGameStarted],

      // 17
      [ModCallback.PRE_GAME_EXIT, this.preGameExit],

      // 18
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_NEW_LEVEL, this.postNewLevel],

      // 19
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_NEW_ROOM, this.postNewRoom],
    ];

    this.postGameStartedReordered = postGameStartedReordered;
    this.postNewLevelReordered = postNewLevelReordered;
    this.postNewRoomReordered = postNewRoomReordered;
    this.postGameStartedReorderedLast = postGameStartedReorderedLast;
  }

  // ModCallback.POST_USE_ITEM (3)
  // CollectibleType.GLOWING_HOUR_GLASS (422)
  private readonly postUseItemGlowingHourGlass = (): boolean | undefined => {
    // If Glowing Hourglass is used on the first room of a floor, it will send the player to the
    // previous floor without triggering the `POST_NEW_LEVEL` callback. Manually check for this.
    this.usedGlowingHourGlass = true;

    return undefined;
  };

  // ModCallback.POST_PLAYER_INIT (9)
  private readonly postPlayerInit = (_player: EntityPlayer): void => {
    if (this.renderFrameRunStarted === null) {
      this.renderFrameRunStarted = Isaac.GetFrameCount();
    }
  };

  // ModCallback.POST_GAME_STARTED (15)
  private readonly postGameStarted = (isContinued: boolean): void => {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();
    const room = game.GetRoom();
    const roomType = room.GetType();

    this.recordCurrentStage();
    this.postGameStartedReordered.fire(isContinued);
    this.postGameStartedReorderedLast.fire(isContinued);
    if (!isContinued) {
      // The vanilla `POST_NEW_LEVEL` callback only fires on non-continued runs, which makes sense,
      // because we do not want to blow away level variables in this case.
      this.postNewLevelReordered.fire(stage, stageType);
    }
    this.postNewRoomReordered.fire(roomType);
  };

  // ModCallback.PRE_GAME_EXIT (17)
  private readonly preGameExit = (): void => {
    this.renderFrameRunStarted = null;
  };

  // ModCallback.POST_NEW_LEVEL (18)
  private readonly postNewLevel = (): void => {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();
    const room = game.GetRoom();
    const roomType = room.GetType();

    if (onGameFrame(0) && !this.forceNewLevel) {
      // Wait for the `POST_GAME_STARTED` callback to fire.
      return;
    }
    this.forceNewLevel = false;

    this.recordCurrentStage();
    this.postNewLevelReordered.fire(stage, stageType);
    this.postNewRoomReordered.fire(roomType);
  };

  // ModCallback.POST_NEW_ROOM (19)
  private readonly postNewRoom = (): void => {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();
    const room = game.GetRoom();
    const roomType = room.GetType();

    if (this.usedGlowingHourGlass) {
      this.usedGlowingHourGlass = false;

      if (this.currentStage !== stage || this.currentStageType !== stageType) {
        // The player has used the Glowing Hourglass to take them to the previous floor (which does
        // not trigger the `POST_NEW_LEVEL` callback). Emulate what happens in the `POST_NEW_LEVEL`
        // callback.
        this.recordCurrentStage();
        this.postNewLevelReordered.fire(stage, stageType);
        this.postNewRoomReordered.fire(roomType);
        return;
      }
    }

    if (
      (onGameFrame(0) ||
        onRenderFrame(this.renderFrameRunStarted) ||
        this.currentStage !== stage ||
        this.currentStageType !== stageType) &&
      !this.forceNewRoom
    ) {
      return;
    }
    this.forceNewRoom = false;

    this.postNewRoomReordered.fire(roomType);
  };

  private recordCurrentStage(): void {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();

    this.currentStage = stage;
    this.currentStageType = stageType;
  }

  /**
   * Helper function to tell the `POST_NEW_LEVEL_REORDERED` callback that it should always fire on
   * the next `POST_NEW_LEVEL`.
   *
   * If some specific cases, mods can change the current level during run initialization on the 0th
   * frame. (For example, if you had a mod that made the player start the run in Caves instead of
   * Basement.) However, due to how the callback reordering works, the `POST_NEW_LEVEL_REORDERED`
   * callback will never fire on the 0th frame. To get around this, call this function before
   * changing levels to temporarily force the callback to fire.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.GAME_REORDERED_CALLBACKS`.
   *
   * @public
   */
  @Exported
  public forceNewLevelCallback(): void {
    this.forceNewLevel = true;
  }

  /**
   * Helper function to tell the `POST_NEW_ROOM_REORDERED` callback that it should always fire on
   * the next `POST_NEW_ROOM`.
   *
   * If some specific cases, mods can change the current room during run initialization on the 0th
   * frame. (For example, if you had a mod that made the player start the Treasure Room of Basement
   * 1 instead of the normal starting room.) However, due to how the callback reordering works, the
   * `POST_NEW_ROOM_REORDERED` callback will never fire on the 0th frame. To get around this, call
   * this function before changing rooms to temporarily force the callback to fire.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.GAME_REORDERED_CALLBACKS`.
   *
   * @public
   */
  @Exported
  public forceNewRoomCallback(): void {
    this.forceNewRoom = true;
  }

  /**
   * Helper function to manually set the variables that the reordered callback logic uses to track
   * the current stage and stage type.
   *
   * This is useful because if the stage is changed with the `Game.SetStage` method (or the
   * `setStage` helper function), the reordered callbacks will stop working.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.GAME_REORDERED_CALLBACKS`.
   *
   * @public
   */
  @Exported
  public reorderedCallbacksSetStage(
    stage: LevelStage,
    stageType: StageType,
  ): void {
    this.currentStage = stage;
    this.currentStageType = stageType;
  }
}

----
classes\features\callbackLogic\GridEntityCollisionDetection.ts
import { GridCollisionClass, ModCallback } from "isaac-typescript-definitions";
import {
  getCollidingEntitiesWithGridEntity,
  getGridEntities,
} from "../../../functions/gridEntities";
import { DefaultMap } from "../../DefaultMap";
import type { PostGridEntityCollision } from "../../callbacks/PostGridEntityCollision";
import type { PostGridEntityCustomCollision } from "../../callbacks/PostGridEntityCustomCollision";
import { Feature } from "../../private/Feature";
import type { CustomGridEntities } from "./CustomGridEntities";

const v = {
  room: {
    /** Indexed by grid entity pointer hash. */
    collidingEntitiesMap: new DefaultMap<PtrHash, Set<PtrHash>>(
      () => new Set(),
    ),
  },
};

export class GridEntityCollisionDetection extends Feature {
  public override v = v;

  private readonly postGridEntityCollision: PostGridEntityCollision;
  private readonly postGridEntityCustomCollision: PostGridEntityCustomCollision;
  private readonly customGridEntities: CustomGridEntities;

  constructor(
    postGridEntityCollision: PostGridEntityCollision,
    postGridEntityCustomCollision: PostGridEntityCustomCollision,
    customGridEntities: CustomGridEntities,
  ) {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];

    this.postGridEntityCollision = postGridEntityCollision;
    this.postGridEntityCustomCollision = postGridEntityCustomCollision;
    this.customGridEntities = customGridEntities;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    const gridEntities = getGridEntities();
    const gridEntitiesWithCollision = gridEntities.filter(
      (gridEntity) => gridEntity.CollisionClass !== GridCollisionClass.NONE,
    );
    for (const gridEntity of gridEntitiesWithCollision) {
      const gridEntityPtrHash = GetPtrHash(gridEntity);
      const oldCollidingEntities =
        v.room.collidingEntitiesMap.getAndSetDefault(gridEntityPtrHash);

      // Check for new colliding entities.
      const collidingEntities = getCollidingEntitiesWithGridEntity(gridEntity);
      for (const entity of collidingEntities) {
        const entityPtrHash = GetPtrHash(entity);
        if (!oldCollidingEntities.has(entityPtrHash)) {
          oldCollidingEntities.add(entityPtrHash);

          const gridEntityTypeCustom =
            this.customGridEntities.getCustomGridEntityType(gridEntity);
          if (gridEntityTypeCustom === undefined) {
            this.postGridEntityCollision.fire(gridEntity, entity);
          } else {
            this.postGridEntityCustomCollision.fire(
              gridEntity,
              gridEntityTypeCustom,
              entity,
            );
          }
        }
      }

      // Remove old colliding entities.
      const collidingEntitiesPtrHashes = collidingEntities.map((entity) =>
        GetPtrHash(entity),
      );
      const collidingEntitiesPtrHashSet = new Set(collidingEntitiesPtrHashes);
      for (const oldCollidingEntityPtrHash of oldCollidingEntities) {
        if (!collidingEntitiesPtrHashSet.has(oldCollidingEntityPtrHash)) {
          oldCollidingEntities.delete(oldCollidingEntityPtrHash);
        }
      }
    }
  };
}

----
classes\features\callbackLogic\GridEntityRenderDetection.ts
import { ModCallback } from "isaac-typescript-definitions";
import { getGridEntities } from "../../../functions/gridEntities";
import type { PostGridEntityCustomRender } from "../../callbacks/PostGridEntityCustomRender";
import type { PostGridEntityRender } from "../../callbacks/PostGridEntityRender";
import { Feature } from "../../private/Feature";
import type { CustomGridEntities } from "./CustomGridEntities";

export class GridEntityRenderDetection extends Feature {
  private readonly postGridEntityRender: PostGridEntityRender;
  private readonly postGridEntityCustomRender: PostGridEntityCustomRender;
  private readonly customGridEntities: CustomGridEntities;

  constructor(
    postGridEntityRender: PostGridEntityRender,
    postGridEntityCustomRender: PostGridEntityCustomRender,
    customGridEntities: CustomGridEntities,
  ) {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];

    this.postGridEntityRender = postGridEntityRender;
    this.postGridEntityCustomRender = postGridEntityCustomRender;
    this.customGridEntities = customGridEntities;
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    for (const gridEntity of getGridEntities()) {
      const gridIndex = gridEntity.GetGridIndex();
      const gridEntityTypeCustom =
        this.customGridEntities.getCustomGridEntityType(gridIndex);
      if (gridEntityTypeCustom === undefined) {
        this.postGridEntityRender.fire(gridEntity);
      } else {
        this.postGridEntityCustomRender.fire(gridEntity, gridEntityTypeCustom);
      }
    }
  };
}

----
classes\features\callbackLogic\GridEntityUpdateDetection.ts
import type { GridEntityType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import {
  getGridEntitiesMap,
  isGridEntityBroken,
} from "../../../functions/gridEntities";
import type { PostGridEntityBroken } from "../../callbacks/PostGridEntityBroken";
import type { PostGridEntityCustomBroken } from "../../callbacks/PostGridEntityCustomBroken";
import type { PostGridEntityCustomInit } from "../../callbacks/PostGridEntityCustomInit";
import type { PostGridEntityCustomRemove } from "../../callbacks/PostGridEntityCustomRemove";
import type { PostGridEntityCustomStateChanged } from "../../callbacks/PostGridEntityCustomStateChanged";
import type { PostGridEntityCustomUpdate } from "../../callbacks/PostGridEntityCustomUpdate";
import type { PostGridEntityInit } from "../../callbacks/PostGridEntityInit";
import type { PostGridEntityRemove } from "../../callbacks/PostGridEntityRemove";
import type { PostGridEntityStateChanged } from "../../callbacks/PostGridEntityStateChanged";
import type { PostGridEntityUpdate } from "../../callbacks/PostGridEntityUpdate";
import { Feature } from "../../private/Feature";
import type { CustomGridEntities } from "./CustomGridEntities";

type GridEntityTuple = [
  gridEntityType: GridEntityType,
  variant: int,
  state: int,
];

const v = {
  room: {
    /** Indexed by grid index. */
    initializedGridEntities: new Map<int, GridEntityTuple>(),
  },
};

export class GridEntityUpdateDetection extends Feature {
  public override v = v;

  private readonly postGridEntityInit: PostGridEntityInit;
  private readonly postGridEntityCustomInit: PostGridEntityCustomInit;
  private readonly postGridEntityUpdate: PostGridEntityUpdate;
  private readonly postGridEntityCustomUpdate: PostGridEntityCustomUpdate;
  private readonly postGridEntityRemove: PostGridEntityRemove;
  private readonly postGridEntityCustomRemove: PostGridEntityCustomRemove;
  private readonly postGridEntityStateChanged: PostGridEntityStateChanged;
  private readonly postGridEntityCustomStateChanged: PostGridEntityCustomStateChanged;
  private readonly postGridEntityBroken: PostGridEntityBroken;
  private readonly postGridEntityCustomBroken: PostGridEntityCustomBroken;
  private readonly customGridEntities: CustomGridEntities;

  constructor(
    postGridEntityInit: PostGridEntityInit,
    postGridEntityCustomInit: PostGridEntityCustomInit,
    postGridEntityUpdate: PostGridEntityUpdate,
    postGridEntityCustomUpdate: PostGridEntityCustomUpdate,
    postGridEntityRemove: PostGridEntityRemove,
    postGridEntityCustomRemove: PostGridEntityCustomRemove,
    postGridEntityStateChanged: PostGridEntityStateChanged,
    postGridEntityCustomStateChanged: PostGridEntityCustomStateChanged,
    postGridEntityBroken: PostGridEntityBroken,
    postGridEntityCustomBroken: PostGridEntityCustomBroken,
    customGridEntities: CustomGridEntities,
  ) {
    super();

    this.featuresUsed = [ISCFeature.RUN_IN_N_FRAMES];

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.postGridEntityInit = postGridEntityInit;
    this.postGridEntityCustomInit = postGridEntityCustomInit;
    this.postGridEntityUpdate = postGridEntityUpdate;
    this.postGridEntityCustomUpdate = postGridEntityCustomUpdate;
    this.postGridEntityRemove = postGridEntityRemove;
    this.postGridEntityCustomRemove = postGridEntityCustomRemove;
    this.postGridEntityStateChanged = postGridEntityStateChanged;
    this.postGridEntityCustomStateChanged = postGridEntityCustomStateChanged;
    this.postGridEntityBroken = postGridEntityBroken;
    this.postGridEntityCustomBroken = postGridEntityCustomBroken;
    this.customGridEntities = customGridEntities;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    const gridEntitiesMap = getGridEntitiesMap();

    // We check for removed grid entities first so that grid entities that change type will count as
    // being removed and fire the PostGridEntityRemoved callback.
    this.checkGridEntitiesRemoved(gridEntitiesMap);

    for (const [gridIndex, gridEntity] of gridEntitiesMap) {
      this.checkGridEntityStateChanged(gridIndex, gridEntity);
      this.checkNewGridEntity(gridIndex, gridEntity);

      const gridEntityTypeCustom =
        this.customGridEntities.getCustomGridEntityType(gridIndex);
      if (gridEntityTypeCustom === undefined) {
        this.postGridEntityUpdate.fire(gridEntity);
      } else {
        this.postGridEntityCustomUpdate.fire(gridEntity, gridEntityTypeCustom);
      }
    }
  };

  private checkGridEntitiesRemoved(
    gridEntitiesMap: ReadonlyMap<int, GridEntity>,
  ): void {
    for (const [gridIndex, gridEntityTuple] of v.room.initializedGridEntities) {
      const [storedGridEntityType, storedGridEntityVariant] = gridEntityTuple;
      const gridEntity = gridEntitiesMap.get(gridIndex);
      if (
        gridEntity === undefined ||
        gridEntity.GetType() !== storedGridEntityType
      ) {
        v.room.initializedGridEntities.delete(gridIndex);

        const gridEntityTypeCustom =
          this.customGridEntities.getCustomGridEntityType(gridIndex);
        if (gridEntityTypeCustom === undefined) {
          this.postGridEntityRemove.fire(
            gridIndex,
            storedGridEntityType,
            storedGridEntityVariant,
          );
        } else {
          this.postGridEntityCustomRemove.fire(gridIndex, gridEntityTypeCustom);
        }
      }
    }
  }

  private checkGridEntityStateChanged(
    gridIndex: int,
    gridEntity: GridEntity,
  ): void {
    const gridEntityTuple = v.room.initializedGridEntities.get(gridIndex);
    if (gridEntityTuple === undefined) {
      // This grid entity did not exist a frame ago; we don't want to fire the state changed
      // callback on the first frame that it exists.
      return;
    }

    const [_gridEntityType, _gridEntityVariant, oldState] = gridEntityTuple;
    const newState = gridEntity.State;
    if (oldState !== newState) {
      this.updateTupleInMap(gridEntity);

      const gridEntityTypeCustom =
        this.customGridEntities.getCustomGridEntityType(gridEntity);
      if (gridEntityTypeCustom === undefined) {
        this.postGridEntityStateChanged.fire(gridEntity, oldState, newState);
      } else {
        this.postGridEntityCustomStateChanged.fire(
          gridEntity,
          gridEntityTypeCustom,
          oldState,
          newState,
        );
      }

      if (isGridEntityBroken(gridEntity)) {
        if (gridEntityTypeCustom === undefined) {
          this.postGridEntityBroken.fire(gridEntity);
        } else {
          this.postGridEntityCustomBroken.fire(
            gridEntity,
            gridEntityTypeCustom,
          );
        }
      }
    }
  }

  private checkNewGridEntity(gridIndex: int, gridEntity: GridEntity): void {
    const gridEntityType = gridEntity.GetType();
    const gridEntityTuple = v.room.initializedGridEntities.get(gridIndex);

    if (
      gridEntityTuple === undefined ||
      gridEntityTuple[0] !== gridEntityType
    ) {
      this.updateTupleInMap(gridEntity);

      const gridEntityTypeCustom =
        this.customGridEntities.getCustomGridEntityType(gridEntity);
      if (gridEntityTypeCustom === undefined) {
        this.postGridEntityInit.fire(gridEntity);
      } else {
        this.postGridEntityCustomInit.fire(gridEntity, gridEntityTypeCustom);
      }
    }
  }

  private updateTupleInMap(gridEntity: GridEntity): void {
    const gridEntityType = gridEntity.GetType();
    const variant = gridEntity.GetVariant();
    const gridIndex = gridEntity.GetGridIndex();
    const newTuple: GridEntityTuple = [
      gridEntityType,
      variant,
      gridEntity.State,
    ];
    v.room.initializedGridEntities.set(gridIndex, newTuple);
  }

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = (): void => {
    const gridEntitiesMap = getGridEntitiesMap();

    for (const [gridIndex, gridEntity] of gridEntitiesMap) {
      this.checkNewGridEntity(gridIndex, gridEntity);
    }
  };
}

----
classes\features\callbackLogic\ItemPickupDetection.ts
import type {
  CollectibleType,
  TrinketType,
} from "isaac-typescript-definitions";
import { ItemType } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { defaultMapGetPlayer } from "../../../functions/playerDataStructures";
import { asNumber } from "../../../functions/types";
import type { PickingUpItem } from "../../../types/PickingUpItem";
import {
  newPickingUpItem,
  resetPickingUpItem,
} from "../../../types/PickingUpItem";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { DefaultMap } from "../../DefaultMap";
import type { PostItemPickup } from "../../callbacks/PostItemPickup";
import type { PreItemPickup } from "../../callbacks/PreItemPickup";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    playersPickingUpItemMap: new DefaultMap<PlayerIndex, PickingUpItem>(() =>
      newPickingUpItem(),
    ),
  },
};

export class ItemPickupDetection extends Feature {
  public override v = v;

  private readonly postItemPickup: PostItemPickup;
  private readonly preItemPickup: PreItemPickup;

  constructor(postItemPickup: PostItemPickup, preItemPickup: PreItemPickup) {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];

    this.postItemPickup = postItemPickup;
    this.preItemPickup = preItemPickup;
  }

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const pickingUpItem = defaultMapGetPlayer(
      v.run.playersPickingUpItemMap,
      player,
    );

    if (player.IsItemQueueEmpty()) {
      this.queueEmpty(player, pickingUpItem);
      // If a player enters a room with a trinket next to the entrance, the player will pick up the
      // trinket, but it will not become queued (it will be deposited into their inventory
      // immediately). Since we don't know what type of item the player is holding, don't account
      // for this bug.
    } else {
      this.queueNotEmpty(player, pickingUpItem);
    }
  };

  private queueEmpty(player: EntityPlayer, pickingUpItem: PickingUpItem) {
    if (
      pickingUpItem.itemType === ItemType.NULL ||
      asNumber(pickingUpItem.subType) === 0
    ) {
      return;
    }

    this.postItemPickup.fire(player, pickingUpItem);
    resetPickingUpItem(pickingUpItem);
  }

  private queueNotEmpty(player: EntityPlayer, pickingUpItem: PickingUpItem) {
    const queuedItem = player.QueuedItem.Item;
    if (queuedItem === undefined || queuedItem.Type === ItemType.NULL) {
      // This should never happen, since the `EntityPlayer.IsItemQueueEmpty` method returned true.
      return;
    }

    if (
      queuedItem.Type !== pickingUpItem.itemType ||
      queuedItem.ID !== pickingUpItem.subType
    ) {
      // Record which item we are picking up.
      pickingUpItem.itemType = queuedItem.Type;
      pickingUpItem.subType = queuedItem.ID as CollectibleType | TrinketType;

      this.preItemPickup.fire(player, pickingUpItem);
    }
  }
}

----
classes\features\callbackLogic\PickupChangeDetection.ts
import type { PickupVariant } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { ISCFeature } from "../../../enums/ISCFeature";
import type { PickupIndex } from "../../../types/PickupIndex";
import type { PostPickupChanged } from "../../callbacks/PostPickupChanged";
import { Feature } from "../../private/Feature";
import type { PickupIndexCreation } from "../other/PickupIndexCreation";

const v = {
  room: {
    pickupVariants: new Map<PickupIndex, PickupVariant>(),
    pickupSubTypes: new Map<PickupIndex, int>(),
  },
};

export class PickupChangeDetection extends Feature {
  public override v = v;

  private readonly postPickupChanged: PostPickupChanged;
  private readonly pickupIndexCreation: PickupIndexCreation;

  constructor(
    postPickupChanged: PostPickupChanged,
    pickupIndexCreation: PickupIndexCreation,
  ) {
    super();

    this.featuresUsed = [ISCFeature.PICKUP_INDEX_CREATION];

    this.callbacksUsed = [
      // 35
      [ModCallback.POST_PICKUP_UPDATE, this.postPickupUpdate],
    ];

    this.postPickupChanged = postPickupChanged;
    this.pickupIndexCreation = pickupIndexCreation;
  }

  // ModCallback.POST_PICKUP_UPDATE (35)
  private readonly postPickupUpdate = (pickup: EntityPickup) => {
    const pickupIndex = this.pickupIndexCreation.getPickupIndex(pickup);

    const oldVariant = v.room.pickupVariants.get(pickupIndex);
    v.room.pickupVariants.set(pickupIndex, pickup.Variant);

    const oldSubType = v.room.pickupSubTypes.get(pickupIndex);
    v.room.pickupSubTypes.set(pickupIndex, pickup.SubType);

    // If this is the first update frame for the pickup, it cannot have changed.
    if (oldVariant === undefined || oldSubType === undefined) {
      return;
    }

    if (oldVariant !== pickup.Variant || oldSubType !== pickup.SubType) {
      this.postPickupChanged.fire(
        pickup,
        oldVariant,
        oldSubType,
        pickup.Variant,
        pickup.SubType,
      );
    }
  };
}

----
classes\features\callbackLogic\PlayerCollectibleDetection.ts
import type { ActiveSlot } from "isaac-typescript-definitions";
import {
  CollectibleType,
  DamageFlag,
  ItemType,
  ModCallback,
  PlayerType,
} from "isaac-typescript-definitions";
import { ACTIVE_SLOT_VALUES } from "../../../cachedEnumValues";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { arrayEquals } from "../../../functions/array";
import { hasFlag } from "../../../functions/flag";
import {
  defaultMapGetPlayer,
  mapSetPlayer,
} from "../../../functions/playerDataStructures";
import { getPlayerFromPtr } from "../../../functions/players";
import { sortNormal } from "../../../functions/sort";
import { repeat } from "../../../functions/utils";
import type { PickingUpItem } from "../../../types/PickingUpItem";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { DefaultMap } from "../../DefaultMap";
import type { PostPlayerCollectibleAdded } from "../../callbacks/PostPlayerCollectibleAdded";
import type { PostPlayerCollectibleRemoved } from "../../callbacks/PostPlayerCollectibleRemoved";
import { Feature } from "../../private/Feature";
import type { ModdedElementSets } from "../other/ModdedElementSets";
import type { RunInNFrames } from "../other/RunInNFrames";

const v = {
  run: {
    playersCollectibleCount: new DefaultMap<PlayerIndex, int>(0),
    playersCollectibleMap: new DefaultMap<
      PlayerIndex,
      Map<CollectibleType, int>
    >(() => new Map()),
    playersActiveItemMap: new DefaultMap<
      PlayerIndex,
      Map<ActiveSlot, CollectibleType>
    >(() => new Map()),
  },
};

export class PlayerCollectibleDetection extends Feature {
  public override v = v;

  private readonly postPlayerCollectibleAdded: PostPlayerCollectibleAdded;
  private readonly postPlayerCollectibleRemoved: PostPlayerCollectibleRemoved;
  private readonly moddedElementSets: ModdedElementSets;
  private readonly runInNFrames: RunInNFrames;

  constructor(
    postPlayerCollectibleAdded: PostPlayerCollectibleAdded,
    postPlayerCollectibleRemoved: PostPlayerCollectibleRemoved,
    moddedElementSets: ModdedElementSets,
    runInNFrames: RunInNFrames,
  ) {
    super();

    this.featuresUsed = [
      ISCFeature.MODDED_ELEMENT_SETS,
      ISCFeature.RUN_IN_N_FRAMES,
    ];

    this.callbacksUsed = [
      // 3
      [ModCallback.POST_USE_ITEM, this.postUseItemD4, [CollectibleType.D4]],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
      [ModCallbackCustom.POST_ITEM_PICKUP, this.postItemPickup],
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];

    this.postPlayerCollectibleAdded = postPlayerCollectibleAdded;
    this.postPlayerCollectibleRemoved = postPlayerCollectibleRemoved;
    this.moddedElementSets = moddedElementSets;
    this.runInNFrames = runInNFrames;
  }

  /**
   * This is called when the collectible count changes and in situations where the entire build is
   * rerolled.
   *
   * Since getting a new player collectible map is expensive, we want to only run this function when
   * necessary, and not on e.g. every frame. Unfortunately, this has the side effect of missing out
   * on collectible changes from mods that add and remove a collectible on the same frame.
   *
   * @param player The player to update.
   * @param numCollectiblesChanged Pass undefined for situations where the entire build was
   *                               rerolled.
   */
  private updateCollectibleMapAndFire(
    player: EntityPlayer,
    numCollectiblesChanged: int | undefined,
  ) {
    const oldCollectibleMap = defaultMapGetPlayer(
      v.run.playersCollectibleMap,
      player,
    );
    const newCollectibleMap =
      this.moddedElementSets.getPlayerCollectibleMap(player);
    mapSetPlayer(v.run.playersCollectibleMap, player, newCollectibleMap);

    const collectibleTypesSet = new Set<CollectibleType>([
      ...oldCollectibleMap.keys(),
      ...newCollectibleMap.keys(),
    ]);

    let numFired = 0;
    for (const collectibleType of collectibleTypesSet) {
      const oldNum = oldCollectibleMap.get(collectibleType) ?? 0;
      const newNum = newCollectibleMap.get(collectibleType) ?? 0;
      const difference = newNum - oldNum;
      const increased = difference > 0;
      const absoluteDifference = Math.abs(difference);

      repeat(absoluteDifference, () => {
        if (increased) {
          this.postPlayerCollectibleAdded.fire(player, collectibleType);
        } else {
          this.postPlayerCollectibleRemoved.fire(player, collectibleType);
        }
        numFired++;
      });

      if (numFired === numCollectiblesChanged) {
        return;
      }
    }
  }

  // ModCallback.POST_USE_ITEM (3)
  // CollectibleType.D4 (284)
  private readonly postUseItemD4 = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
  ): boolean | undefined => {
    // This function is also triggered for:
    // - D100
    // - D Infinity copying D4 or D100
    // - 1-pip dice room
    // - 6-pip dice room
    // - Reverse Wheel of Fortune copying 1-pip or 6-pip dice room
    // - First getting Missing No.
    // - Arriving on a new floor with Missing No.

    // This function is not triggered for:
    // - Tainted Eden getting hit (this is explicitly handled elsewhere)
    // - Genesis (which is automatically handled by the collectibles being removed in the normal
    //   `POST_PLAYER_COLLECTIBLE_REMOVED` callback)
    this.updateCollectibleMapAndFire(player, undefined);

    return undefined;
  };

  /** We need to handle the case of Tainted Eden taking damage. */
  // ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER
  private readonly entityTakeDmgPlayer = (
    player: EntityPlayer,
    _amount: float,
    damageFlags: BitFlags<DamageFlag>,
    _source: EntityRef,
    _countdownFrames: int,
  ): boolean | undefined => {
    // Tainted Eden's mechanic does not apply if she e.g. uses Dull Razor.
    if (hasFlag(damageFlags, DamageFlag.FAKE)) {
      return undefined;
    }

    const character = player.GetPlayerType();
    if (character !== PlayerType.EDEN_B) {
      return undefined;
    }

    // The items will only be rerolled after the damage is successfully applied.
    const entityPtr = EntityPtr(player);
    this.runInNFrames.runNextGameFrame(() => {
      const futurePlayer = getPlayerFromPtr(entityPtr);
      if (futurePlayer !== undefined) {
        this.updateCollectibleMapAndFire(player, undefined);
      }
    });

    return undefined;
  };

  /**
   * We need to handle TMTRAINER collectibles, since they do not cause the player's collectible
   * count to change.
   */
  // ModCallbackCustom.POST_ITEM_PICKUP
  private readonly postItemPickup = (
    player: EntityPlayer,
    pickingUpItem: PickingUpItem,
  ) => {
    if (
      pickingUpItem.itemType === ItemType.TRINKET ||
      pickingUpItem.itemType === ItemType.NULL
    ) {
      return;
    }

    const newCollectibleCount = player.GetCollectibleCount();
    mapSetPlayer(v.run.playersCollectibleCount, player, newCollectibleCount);

    this.updateCollectibleMapAndFire(player, 1);
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const oldCollectibleCount = defaultMapGetPlayer(
      v.run.playersCollectibleCount,
      player,
    );
    const newCollectibleCount = player.GetCollectibleCount();
    mapSetPlayer(v.run.playersCollectibleCount, player, newCollectibleCount);

    const difference = newCollectibleCount - oldCollectibleCount;

    if (difference > 0) {
      this.updateCollectibleMapAndFire(player, difference);
    } else if (difference < 0) {
      this.updateCollectibleMapAndFire(player, difference * -1);
    } else if (difference === 0) {
      this.checkActiveItemsChanged(player);
    }
  };

  /**
   * Checking for collectible count will work to detect when a player swaps their active item for
   * another active item. This is because the collectible count will decrement by 1 when the item is
   * swapped onto the pedestal and the hold animation begins, and increment by 1 when the item is
   * dequeued and the hold animation ends.
   *
   * However, we also want to explicitly check for the case where a mod swaps in a custom active
   * collectible on the same frame, since doing so is cheap.
   */
  private checkActiveItemsChanged(player: EntityPlayer) {
    const activeItemMap = defaultMapGetPlayer(
      v.run.playersActiveItemMap,
      player,
    );

    const oldCollectibleTypes: CollectibleType[] = [];
    const newCollectibleTypes: CollectibleType[] = [];

    for (const activeSlot of ACTIVE_SLOT_VALUES) {
      const oldCollectibleType =
        activeItemMap.get(activeSlot) ?? CollectibleType.NULL;
      const newCollectibleType = player.GetActiveItem(activeSlot);
      activeItemMap.set(activeSlot, newCollectibleType);

      oldCollectibleTypes.push(oldCollectibleType);
      newCollectibleTypes.push(newCollectibleType);
    }

    // For example, it is possible for the player to switch Schoolbag items, which will cause the
    // collectibles in the array to be the same, but in a different order. Thus, we sort both arrays
    // before comparing them.
    oldCollectibleTypes.sort(sortNormal);
    newCollectibleTypes.sort(sortNormal);

    if (!arrayEquals(oldCollectibleTypes, newCollectibleTypes)) {
      // One or more active items have changed (with the player's total collectible count remaining
      // the same).
      this.updateCollectibleMapAndFire(player, undefined);
    }
  }
}

----
classes\features\callbackLogic\PlayerReorderedCallbacks.ts
// This handles logic for the following callbacks:
// - POST_PEFFECT_UPDATE_REORDERED
// - POST_PLAYER_RENDER_REORDERED
// - POST_PLAYER_UPDATE_REORDERED

import { ModCallback } from "isaac-typescript-definitions";
import { VectorZero } from "../../../core/constants";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { emptyArray } from "../../../functions/array";
import {
  getPlayerFromIndex,
  getPlayerIndex,
} from "../../../functions/playerIndex";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import type { PostPEffectUpdateReordered } from "../../callbacks/PostPEffectUpdateReordered";
import type { PostPlayerRenderReordered } from "../../callbacks/PostPlayerRenderReordered";
import type { PostPlayerUpdateReordered } from "../../callbacks/PostPlayerUpdateReordered";
import { Feature } from "../../private/Feature";

interface QueueElement {
  playerIndex: PlayerIndex;
  renderOffset: Vector;
}

const v = {
  run: {
    postGameStartedFiredOnThisRun: false,

    postPEffectUpdateQueue: [] as QueueElement[],
    postPlayerUpdateQueue: [] as QueueElement[],
    postPlayerRenderQueue: [] as QueueElement[],
  },
};

export class PlayerReorderedCallbacks extends Feature {
  public override v = v;

  private readonly postPEffectUpdateReordered: PostPEffectUpdateReordered;
  private readonly postPlayerRenderReordered: PostPlayerRenderReordered;
  private readonly postPlayerUpdateReordered: PostPlayerUpdateReordered;

  constructor(
    postPEffectUpdateReordered: PostPEffectUpdateReordered,
    postPlayerRenderReordered: PostPlayerRenderReordered,
    postPlayerUpdateReordered: PostPlayerUpdateReordered,
  ) {
    super();

    this.callbacksUsed = [
      // 4
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_PEFFECT_UPDATE, this.postPEffectUpdate],

      // 31
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_PLAYER_UPDATE, this.postPlayerUpdate],

      // 32
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_PLAYER_RENDER, this.postPlayerRender],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED_LAST,
        this.postGameStartedReorderedLast,
      ],
    ];

    this.postPEffectUpdateReordered = postPEffectUpdateReordered;
    this.postPlayerRenderReordered = postPlayerRenderReordered;
    this.postPlayerUpdateReordered = postPlayerUpdateReordered;
  }

  // ModCallback.POST_PEFFECT_UPDATE (4)
  private readonly postPEffectUpdate = (player: EntityPlayer): void => {
    if (v.run.postGameStartedFiredOnThisRun) {
      this.postPEffectUpdateReordered.fire(player);
    } else {
      // Defer callback execution until the `POST_GAME_STARTED` callback fires.
      const playerIndex = getPlayerIndex(player);
      v.run.postPEffectUpdateQueue.push({
        playerIndex,
        renderOffset: VectorZero,
      });
    }
  };

  // ModCallback.POST_PLAYER_UPDATE (31)
  private readonly postPlayerUpdate = (player: EntityPlayer): void => {
    if (v.run.postGameStartedFiredOnThisRun) {
      this.postPlayerUpdateReordered.fire(player);
    } else {
      // Defer callback execution until the `POST_GAME_STARTED` callback fires.
      const playerIndex = getPlayerIndex(player);
      v.run.postPlayerUpdateQueue.push({
        playerIndex,
        renderOffset: VectorZero,
      });
    }
  };

  // ModCallback.POST_PLAYER_RENDER (32)
  private readonly postPlayerRender = (
    player: EntityPlayer,
    renderOffset: Vector,
  ): void => {
    if (v.run.postGameStartedFiredOnThisRun) {
      this.postPlayerRenderReordered.fire(player, renderOffset);
    } else {
      // Defer callback execution until the `POST_GAME_STARTED` callback fires.
      const playerIndex = getPlayerIndex(player);
      v.run.postPlayerRenderQueue.push({ playerIndex, renderOffset });
    }
  };

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED_LAST
  private readonly postGameStartedReorderedLast = (): void => {
    v.run.postGameStartedFiredOnThisRun = true;

    dequeue(v.run.postPEffectUpdateQueue, this.postPEffectUpdateReordered.fire);
    dequeue(v.run.postPlayerUpdateQueue, this.postPlayerUpdateReordered.fire);
    dequeue(v.run.postPlayerRenderQueue, this.postPlayerRenderReordered.fire);
  };
}

function dequeue(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  queue: QueueElement[],
  fireFunc: (player: EntityPlayer, renderOffset: Vector) => void,
) {
  for (const element of queue) {
    const { playerIndex, renderOffset } = element;
    const player = getPlayerFromIndex(playerIndex);
    if (player !== undefined) {
      fireFunc(player, renderOffset);
    }
  }

  emptyArray(queue);
}

----
classes\features\callbackLogic\SlotDestroyedDetection.ts
// For machines, destruction is detected in two ways:

// 1) The main way is via a change in grid entity class. This happens when the machine is destroyed
//    with a bomb, for example. For this case, the slot will remain until the player leaves the
//    room.

// 2) In the specific case of a machine spawning a collectible, the machine will be immediately
//    removed. Thus, we assume that any despawning slot machine is destroyed in this way.

// For beggars, destruction is detected by monitoring for when a beggar despawns mid-room. Beggars
// that are paying out with a collectible will always be playing the "Teleport" animation.
// Otherwise, the beggar won't be playing any animation in particular.

import {
  EntityGridCollisionClass,
  EntityType,
  ModCallback,
} from "isaac-typescript-definitions";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { SlotDestructionType } from "../../../enums/SlotDestructionType";
import { isSlotMachine } from "../../../functions/slots";
import type { PostSlotDestroyed } from "../../callbacks/PostSlotDestroyed";
import { Feature } from "../../private/Feature";
import type { RoomHistory } from "../other/RoomHistory";

const v = {
  room: {
    destroyedSlotSet: new Set<PtrHash>(),
  },
};

export class SlotDestroyedDetection extends Feature {
  public override v = v;

  private readonly postSlotDestroyed: PostSlotDestroyed;
  private readonly roomHistory: RoomHistory;

  constructor(postSlotDestroyed: PostSlotDestroyed, roomHistory: RoomHistory) {
    super();

    this.featuresUsed = [ISCFeature.ROOM_HISTORY];

    this.callbacksUsed = [
      // 67
      [
        ModCallback.POST_ENTITY_REMOVE,
        this.postEntityRemoveSlot,
        [EntityType.SLOT],
      ],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_SLOT_UPDATE, this.postSlotUpdate],
    ];

    this.postSlotDestroyed = postSlotDestroyed;
    this.roomHistory = roomHistory;
  }

  // ModCallback.POST_ENTITY_REMOVE (67)
  // EntityType.SLOT (6)
  private readonly postEntityRemoveSlot = (entity: Entity) => {
    const slot = entity as EntitySlot;

    // The `POST_ENTITY_REMOVE` callback will fire for slots that are naturally despawning as a
    // player leaves a room. We want to ignore all slots that despawn for this reason.
    if (this.roomHistory.isLeavingRoom()) {
      return;
    }

    if (isSlotMachine(slot)) {
      this.postEntityRemoveSlotMachine(slot);
    } else {
      this.postEntityRemoveBeggar(slot);
    }
  };

  private postEntityRemoveSlotMachine(slot: EntitySlot) {
    this.postSlotDestroyed.fire(slot, SlotDestructionType.COLLECTIBLE_PAYOUT);
  }

  private postEntityRemoveBeggar(slot: EntitySlot) {
    const sprite = slot.GetSprite();
    const animation = sprite.GetAnimation();
    const slotDestructionType =
      animation === "Teleport"
        ? SlotDestructionType.COLLECTIBLE_PAYOUT
        : SlotDestructionType.NORMAL;
    this.postSlotDestroyed.fire(slot, slotDestructionType);
  }

  // ModCallbackCustom.POST_SLOT_UPDATE
  private readonly postSlotUpdate = (slot: EntitySlot) => {
    const ptrHash = GetPtrHash(slot);

    const alreadyDestroyed = v.room.destroyedSlotSet.has(ptrHash);
    if (alreadyDestroyed) {
      return;
    }

    this.checkDestroyedFromCollisionClass(slot);
  };

  /**
   * Slots normally have an entity collision class of `EntityCollisionClass.ALL` (4) and a grid
   * collision class of `EntityGridCollisionClass.NONE` (0). When they are destroyed with a bomb,
   * the entity collision class stays the same, but the grid collision class switches to
   * `EntityGridCollisionClass.GROUND` (5).
   */
  private checkDestroyedFromCollisionClass(slot: EntitySlot) {
    if (slot.GridCollisionClass === EntityGridCollisionClass.GROUND) {
      const ptrHash = GetPtrHash(slot);
      v.room.destroyedSlotSet.add(ptrHash);
      this.postSlotDestroyed.fire(slot, SlotDestructionType.NORMAL);
    }
  }
}

----
classes\features\callbackLogic\SlotRenderDetection.ts
import { ModCallback } from "isaac-typescript-definitions";
import { getSlots } from "../../../functions/entitiesSpecific";
import { DefaultMap } from "../../DefaultMap";
import type { PostSlotAnimationChanged } from "../../callbacks/PostSlotAnimationChanged";
import type { PostSlotRender } from "../../callbacks/PostSlotRender";
import { Feature } from "../../private/Feature";

const v = {
  room: {
    slotAnimations: new DefaultMap<PtrHash, string, [slot: Entity]>(
      (slot: Entity) => {
        const sprite = slot.GetSprite();
        return sprite.GetAnimation();
      },
    ),
    brokenSlots: new Set<PtrHash>(),
  },
};

export class SlotRenderDetection extends Feature {
  public override v = v;

  private readonly postSlotRender: PostSlotRender;
  private readonly postSlotAnimationChanged: PostSlotAnimationChanged;

  constructor(
    postSlotRender: PostSlotRender,
    postSlotAnimationChanged: PostSlotAnimationChanged,
  ) {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];

    this.postSlotRender = postSlotRender;
    this.postSlotAnimationChanged = postSlotAnimationChanged;
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    for (const slot of getSlots()) {
      this.postSlotRender.fire(slot);
      this.checkSlotAnimationChanged(slot);
    }
  };

  private checkSlotAnimationChanged(slot: EntitySlot) {
    const sprite = slot.GetSprite();
    const currentAnimation = sprite.GetAnimation();
    const ptrHash = GetPtrHash(slot);
    const previousAnimation = v.room.slotAnimations.getAndSetDefault(
      ptrHash,
      slot,
    );
    v.room.slotAnimations.set(ptrHash, currentAnimation);

    if (currentAnimation !== previousAnimation) {
      this.postSlotAnimationChanged.fire(
        slot,
        previousAnimation,
        currentAnimation,
      );
    }
  }
}

----
classes\features\callbackLogic\SlotUpdateDetection.ts
import { ModCallback } from "isaac-typescript-definitions";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { getSlots } from "../../../functions/entitiesSpecific";
import type { PostSlotInit } from "../../callbacks/PostSlotInit";
import type { PostSlotUpdate } from "../../callbacks/PostSlotUpdate";
import { Feature } from "../../private/Feature";

const v = {
  room: {
    initializedSlots: new Set<PtrHash>(),
  },
};

export class SlotUpdateDetection extends Feature {
  public override v = v;

  private readonly postSlotInit: PostSlotInit;
  private readonly postSlotUpdate: PostSlotUpdate;

  constructor(postSlotInit: PostSlotInit, postSlotUpdate: PostSlotUpdate) {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],
    ];

    this.customCallbacksUsed = [
      // This has to be the reordered callback because we don't want the `POST_SLOT_INIT` callback
      // firing on the first room of a floor before the `POST_NEW_LEVEL` callback.
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.postSlotInit = postSlotInit;
    this.postSlotUpdate = postSlotUpdate;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = () => {
    for (const slot of getSlots()) {
      this.checkNewEntity(slot);
      this.postSlotUpdate.fire(slot);
    }
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    for (const slot of getSlots()) {
      this.checkNewEntity(slot);
    }
  };

  private checkNewEntity(slot: EntitySlot) {
    const ptrHash = GetPtrHash(slot);
    if (!v.room.initializedSlots.has(ptrHash)) {
      v.room.initializedSlots.add(ptrHash);
      this.postSlotInit.fire(slot);
    }
  }
}

----
classes\features\other\CharacterHealthConversion.ts
import type { PlayerType } from "isaac-typescript-definitions";
import {
  HeartSubType,
  ModCallback,
  PickupVariant,
} from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { isRedHeart } from "../../../functions/pickups";
import type { ConversionHeartSubType } from "../../../types/ConversionHeartSubType";
import { Feature } from "../../private/Feature";

export class CharacterHealthConversion extends Feature {
  private readonly characterHealthReplacementMap = new Map<
    PlayerType,
    ConversionHeartSubType
  >();

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 38
      [
        ModCallback.PRE_PICKUP_COLLISION,
        this.prePickupCollisionHeart,
        [PickupVariant.HEART],
      ],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  // ModCallback.PRE_PICKUP_COLLISION (38)
  // PickupVariant.HEART (10)
  private readonly prePickupCollisionHeart = (
    pickup: EntityPickup,
    collider: Entity,
  ) => {
    if (!isRedHeart(pickup)) {
      return undefined;
    }

    const player = collider.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    const character = player.GetPlayerType();
    const conversionHeartSubType =
      this.characterHealthReplacementMap.get(character);
    if (conversionHeartSubType === undefined) {
      return undefined;
    }

    // Prevent internal code from running, which will prevent the player from picking up the heart,
    // but will still allow the heart to bounce off of the player.
    return false;
  };

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const character = player.GetPlayerType();
    const conversionHeartSubType =
      this.characterHealthReplacementMap.get(character);
    if (conversionHeartSubType === undefined) {
      return undefined;
    }

    convertRedHeartContainers(player, conversionHeartSubType);
    removeRedHearts(player);
  };

  /**
   * Helper function to make a character that has the same health mechanic as Blue Baby (red heart
   * containers --> soul hearts) or Dark Judas (red heart containers --> black hearts).
   *
   * Call this function once at the beginning of your mod to declare the health conversion type.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CHARACTER_HEALTH_CONVERSION`.
   *
   * @public
   */
  @Exported
  public registerCharacterHealthConversion(
    playerType: PlayerType,
    conversionHeartSubType: ConversionHeartSubType,
  ): void {
    if (this.characterHealthReplacementMap.has(playerType)) {
      error(
        `Failed to register a character of type ${playerType} because there is already an existing registered character with that type.`,
      );
    }

    this.characterHealthReplacementMap.set(playerType, conversionHeartSubType);
  }
}

function convertRedHeartContainers(
  player: EntityPlayer,
  heartSubType: ConversionHeartSubType,
) {
  const maxHearts = player.GetMaxHearts();
  if (maxHearts === 0) {
    return;
  }

  player.AddMaxHearts(maxHearts * -1, false);

  switch (heartSubType) {
    case HeartSubType.SOUL: {
      player.AddSoulHearts(maxHearts);
      break;
    }

    case HeartSubType.BLACK: {
      player.AddBlackHearts(maxHearts);
      break;
    }
  }
}

/**
 * We also have to check for normal red hearts, so that the player is not able to fill bone hearts
 * (by e.g. picking up a healing item like Breakfast).
 */
function removeRedHearts(player: EntityPlayer) {
  const hearts = player.GetHearts();
  if (hearts > 0) {
    player.AddHearts(hearts * -1);
  }
}

----
classes\features\other\CharacterStats.ts
import type { CacheFlag, PlayerType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { addPlayerStat, getDefaultPlayerStat } from "../../../functions/stats";
import { Feature } from "../../private/Feature";

type StatMap = ReadonlyMap<CacheFlag, number>;

/** Easily create custom characters that have base stats different from that of Isaac. */
export class CharacterStats extends Feature {
  private readonly charactersStatMap = new Map<PlayerType, StatMap>();

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 8
      [ModCallback.EVALUATE_CACHE, this.evaluateCache],
    ];
  }

  // ModCallback.EVALUATE_CACHE (8)
  private readonly evaluateCache = (
    player: EntityPlayer,
    cacheFlag: CacheFlag,
  ) => {
    const character = player.GetPlayerType();
    const statMap = this.charactersStatMap.get(character);
    if (statMap === undefined) {
      return;
    }

    const stat = statMap.get(cacheFlag);
    const defaultStat = getDefaultPlayerStat(cacheFlag);
    if (stat === undefined || defaultStat === undefined) {
      return;
    }
    const delta = stat - defaultStat;

    addPlayerStat(player, cacheFlag, delta);
  };

  /**
   * Helper function to manage the stats for a vanilla or custom character. Call this function once
   * at the beginning of your mod to declare the starting stats.
   *
   * You must provide this function with a map of CacheFlag to the default stat amount. For example,
   * the default amount of damage is 3.5. To make a custom character start with 4.5 damage:
   *
   * ```ts
   * const fooDefaultStats = new Map<CacheFlag, number>([
   *   [CacheFlag.DAMAGE, 4.5],
   * ])
   * registerCharacterStats(PlayerTypeCustom.FOO, fooDefaultStats);
   * ```
   *
   * Note that the format for the `CacheFlag.FIRE_DELAY` value should be in the tears stat format,
   * not the `MaxFireDelay` format.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CHARACTER_STATS`.
   *
   * @public
   */
  @Exported
  public registerCharacterStats(
    playerType: PlayerType,
    statMap: ReadonlyMap<CacheFlag, number>,
  ): void {
    this.charactersStatMap.set(playerType, statMap);
  }
}

----
classes\features\other\CollectibleItemPoolType.ts
import type { ItemPoolType } from "isaac-typescript-definitions";
import { ModCallback, PickupVariant } from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { getEntityID } from "../../../functions/entities";
import { isCollectible } from "../../../functions/pickupVariants";
import { getRoomItemPoolType } from "../../../functions/rooms";
import type { PickupIndex } from "../../../types/PickupIndex";
import { Feature } from "../../private/Feature";
import type { PickupIndexCreation } from "./PickupIndexCreation";

const v = {
  run: {
    collectibleItemPoolTypeMap: new Map<PickupIndex, ItemPoolType>(),
  },
};

export class CollectibleItemPoolType extends Feature {
  /** @internal */
  public override v = v;

  private readonly pickupIndexCreation: PickupIndexCreation;

  /** @internal */
  constructor(pickupIndexCreation: PickupIndexCreation) {
    super();

    this.featuresUsed = [ISCFeature.PICKUP_INDEX_CREATION];

    this.callbacksUsed = [
      // 34
      [
        ModCallback.POST_PICKUP_INIT,
        this.postPickupInitCollectible,
        [PickupVariant.COLLECTIBLE],
      ],
    ];

    this.pickupIndexCreation = pickupIndexCreation;
  }

  // ModCallback.POST_PICKUP_INIT (34)
  // PickupVariant.COLLECTIBLE (100)
  private readonly postPickupInitCollectible = (collectible: EntityPickup) => {
    const pickupIndex = this.pickupIndexCreation.getPickupIndex(collectible);

    if (!v.run.collectibleItemPoolTypeMap.has(pickupIndex)) {
      const itemPool = game.GetItemPool();
      const lastItemPoolType = itemPool.GetLastPool();

      v.run.collectibleItemPoolTypeMap.set(pickupIndex, lastItemPoolType);
    }
  };

  /**
   * Helper function to get the item pool type that a given collectible came from. Since there is no
   * native method in the API to get this, we listen in the `POST_PICKUP_INIT` callback for
   * collectibles, use the `ItemPool.GetLastPool` method, and then assume that the collectible
   * matches.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.COLLECTIBLE_ITEM_POOL_TYPE`.
   *
   * @public
   */
  @Exported
  public getCollectibleItemPoolType(collectible: EntityPickup): ItemPoolType {
    if (!isCollectible(collectible)) {
      const entityID = getEntityID(collectible);
      error(
        `The "getCollectibleItemPoolType" function was given a non-collectible: ${entityID}`,
      );
    }

    const pickupIndex = this.pickupIndexCreation.getPickupIndex(collectible);
    const itemPoolType = v.run.collectibleItemPoolTypeMap.get(pickupIndex);
    return itemPoolType ?? getRoomItemPoolType();
  }
}

----
classes\features\other\CustomHotkeys.ts
import { Keyboard, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { isKeyboardPressed } from "../../../functions/input";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";

export class CustomHotkeys extends Feature {
  /**
   * The keys are the keyboard keys that trigger the hotkey. The values are the functions that
   * contain the arbitrary code to run.
   */
  private readonly staticHotkeyFunctionMap = new Map<Keyboard, () => void>();

  /**
   * The keys are the functions that determine what the hotkey key is. The values are the functions
   * that contain the arbitrary code to run.
   */
  private readonly dynamicHotkeyFunctionMap = new Map<
    () => Keyboard | undefined,
    () => void
  >();

  private readonly keyPressedMap = new DefaultMap<Keyboard, boolean>(false);

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    for (const [keyboard, triggerFunc] of this.staticHotkeyFunctionMap) {
      this.checkIfTriggered(keyboard, triggerFunc);
    }

    for (const [keyboardFunc, triggerFunc] of this.dynamicHotkeyFunctionMap) {
      const keyboard = keyboardFunc();
      if (keyboard !== undefined) {
        this.checkIfTriggered(keyboard, triggerFunc);
      }
    }
  };

  private checkIfTriggered(keyboard: Keyboard, triggerFunc: () => void) {
    const isPressed = isKeyboardPressed(keyboard);
    const wasPreviouslyPressed = this.keyPressedMap.getAndSetDefault(keyboard);
    this.keyPressedMap.set(keyboard, isPressed);

    if (isPressed && !wasPreviouslyPressed) {
      triggerFunc();
    }
  }

  /**
   * Helper function to run arbitrary code when you press and release a specific keyboard key.
   *
   * This can be used to easily set up custom hotkeys to facilitate custom game features or to
   * assist in debugging.
   *
   * Inputs are checked for in the `POST_RENDER` callback.
   *
   * This is different from the `setHotkey` function in that the keyboard activation key is not
   * hardcoded and is instead the return value of a provided function. This is useful for situations
   * where the key can change (like if end-users can specify a custom hotkey using Mod Config Menu).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_HOTKEYS`.
   *
   * @param getKeyFunc The function that returns the key that will trigger the hotkey.
   * @param triggerFunc A function containing the arbitrary code that you want to execute when the
   *                    hotkey is triggered.
   * @public
   */
  @Exported
  public setConditionalHotkey(
    getKeyFunc: () => Keyboard | undefined,
    triggerFunc: () => void,
  ): void {
    if (this.dynamicHotkeyFunctionMap.has(getKeyFunc)) {
      error(
        "Failed to register a hotkey due to a custom hotkey already being defined for the submitted function.",
      );
    }

    this.dynamicHotkeyFunctionMap.set(getKeyFunc, triggerFunc);
  }

  /**
   * Helper function to run arbitrary code when you press and release a specific keyboard key.
   *
   * This can be used to easily set up custom hotkeys to facilitate custom game features or to
   * assist in debugging.
   *
   * Inputs are checked for in the `POST_RENDER` callback.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_HOTKEYS`.
   *
   * @param keyboard The key that you want to trigger the hotkey.
   * @param triggerFunc A function containing the arbitrary code that you want to execute when the
   *                    hotkey is triggered.
   * @public
   */
  @Exported
  public setHotkey(keyboard: Keyboard, triggerFunc: () => void): void {
    if (this.staticHotkeyFunctionMap.has(keyboard)) {
      error(
        `Failed to register a hotkey due to a hotkey already being defined for: Keyboard.${Keyboard[keyboard]} (${keyboard})`,
      );
    }

    this.staticHotkeyFunctionMap.set(keyboard, triggerFunc);
  }

  /**
   * Helper function to remove a hotkey created with the `setConditionalHotkey` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_HOTKEYS`.
   *
   * @param getKeyFunc Equal to the `getKeyFunc` that you passed when initially registering the
   *                   hotkey.
   * @public
   */
  @Exported
  public unsetConditionalHotkey(getKeyFunc: () => Keyboard | undefined): void {
    if (!this.dynamicHotkeyFunctionMap.has(getKeyFunc)) {
      error(
        "Failed to unregister a hotkey since there is no existing hotkey defined for the submitted function.",
      );
    }

    this.dynamicHotkeyFunctionMap.delete(getKeyFunc);
  }

  /**
   * Helper function to remove a hotkey created with the `setHotkey` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_HOTKEYS`.
   *
   * @param keyboard Equal to the keyboard value that you passed when initially registering the
   *                 hotkey.
   * @public
   */
  @Exported
  public unsetHotkey(keyboard: Keyboard): void {
    if (!this.staticHotkeyFunctionMap.has(keyboard)) {
      error(
        `Failed to unregister a hotkey since there is no existing hotkey defined for: Keyboard.${Keyboard[keyboard]} (${keyboard})`,
      );
    }

    this.staticHotkeyFunctionMap.delete(keyboard);
  }
}

----
classes\features\other\CustomItemPools.ts
import type { ItemPoolType } from "isaac-typescript-definitions";
import { CollectibleType } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { arrayRemoveIndexInPlace } from "../../../functions/array";
import { copyMap } from "../../../functions/map";
import { assertDefined } from "../../../functions/utils";
import { getRandomIndexFromWeightedArray } from "../../../functions/weighted";
import { ReadonlyMap } from "../../../types/ReadonlyMap";
import type { WeightedArray } from "../../../types/WeightedArray";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    customItemPools: new ReadonlyMap<
      ItemPoolType,
      WeightedArray<CollectibleType>
    >(),
  },
};

const customItemPoolMap = new Map<
  ItemPoolType,
  WeightedArray<CollectibleType>
>();

export class CustomItemPools extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED,
        this.postGameStartedReorderedFalse,
        [false],
      ],
    ];
  }

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED
  // false
  private readonly postGameStartedReorderedFalse = () => {
    v.run.customItemPools = copyMap(customItemPoolMap);
  };

  /**
   * Helper function to register a custom item pool. Use this function once when your mod first
   * loads to declare the items that you want to be in the item pools. Then, in the middle of a run,
   * you can use `getCustomItemPoolCollectible`.
   *
   * For example:
   *
   * ```ts
   * const ItemPoolTypeCustom = {
   *   FOO = 0 as ItemPoolType,
   * } as const;
   *
   * const FOO_ITEM_POOL = [
   *   [CollectibleType.SAD_ONION, 1],
   *   [CollectibleType.INNER_EYE, 0.5],
   * ];
   *
   * registerCustomItemPool(ItemPoolTypeCustom.FOO, FOO_ITEM_POOL);
   * ```
   *
   * Note that custom item pools do not currently support partial weight decrementation on sight.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_ITEM_POOLS`.
   *
   * @param itemPoolTypeCustom An integer that identifies what kind of item pool you are creating.
   *                           It should correspond to a local `ItemPoolTypeCustom` enum in your
   *                           mod. The integer can be any unique value and can safely overlap with
   *                           the vanilla item pool type values (or values chosen by other mods).
   * @param collectibles An array of weighted collectible tuples that represent the item pool that
   *                     you are creating. The first element in he tuple is the `CollectibleType`,
   *                     and the second element in the tuple is the float that represents the weight
   *                     of the collectible.
   * @public
   */
  @Exported
  public registerCustomItemPool(
    itemPoolTypeCustom: ItemPoolType,
    collectibles: Readonly<WeightedArray<CollectibleType>>,
  ): void {
    if (customItemPoolMap.has(itemPoolTypeCustom)) {
      error(
        `Failed to register a custom item pool since the provided type of ${itemPoolTypeCustom} was already registered.`,
      );
    }

    customItemPoolMap.set(
      itemPoolTypeCustom,
      collectibles as WeightedArray<CollectibleType>,
    );
  }

  /**
   * Helper function to get a new collectible from a custom item pool created with the
   * `registerCustomItemPool` function. This function has the same format as the
   * `ItemPool.GetCollectible` method.
   *
   * By default, a collectible will not be removed from the pool once it is selected, unless the
   * `decrease` argument is set to true (similar to how a vanilla item pool works).
   *
   * If you want to get an unseeded collectible type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_ITEM_POOLS`.
   *
   * @param itemPoolTypeCustom An integer representing the custom item pool to use.
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param decrease Optional. Whether to remove the selected collectible from the item pool.
   *                 Default is true.
   * @param defaultItem Optional. The collectible to return if the item pool is depleted. Default is
   *                    `CollectibleType.NULL`.
   * @public
   */
  @Exported
  public getCustomItemPoolCollectible(
    itemPoolTypeCustom: ItemPoolType,
    seedOrRNG: Seed | RNG | undefined,
    decrease = false,
    defaultItem = CollectibleType.NULL,
  ): CollectibleType {
    const customItemPool = v.run.customItemPools.get(itemPoolTypeCustom);
    assertDefined(
      customItemPool,
      `Failed to find the custom item pool of: ${itemPoolTypeCustom}`,
    );

    if (customItemPool.length === 0) {
      return defaultItem;
    }

    const randomIndex = getRandomIndexFromWeightedArray(
      customItemPool,
      seedOrRNG,
    );
    const tuple = customItemPool[randomIndex];
    assertDefined(
      tuple,
      `Failed to get an element from a custom item pool using a random index of: ${randomIndex}`,
    );

    if (decrease) {
      arrayRemoveIndexInPlace(customItemPool, randomIndex);
    }

    return tuple[0];
  }
}

----
classes\features\other\CustomPickups.ts
import type { PickupVariant } from "isaac-typescript-definitions";
import {
  EffectVariant,
  EntityType,
  ModCallback,
} from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { LadderSubTypeCustom } from "../../../enums/LadderSubTypeCustom";
import {
  getEntityID,
  getEntityIDFromConstituents,
} from "../../../functions/entities";
import { spawnEffect } from "../../../functions/entitiesSpecific";
import { Feature } from "../../private/Feature";

interface CustomPickupFunctions {
  collectFunc: (this: void, player: EntityPlayer) => void;
  collisionFunc: (this: void, player: EntityPlayer) => boolean;
}

/**
 * Normally, we would make a custom entity to represent a fading-away pickup, but we don't want to
 * interfere with the "entities2.xml" file in end-user mods. Thus, we must select a vanilla effect
 * to masquerade as a backdrop effect.
 *
 * We arbitrarily choose a ladder for this purpose because it will not automatically despawn after
 * time passes, like most other effects.
 */
const PICKUP_EFFECT_VARIANT = EffectVariant.LADDER;
const PICKUP_EFFECT_SUB_TYPE = LadderSubTypeCustom.CUSTOM_PICKUP;

export class CustomPickups extends Feature {
  /** Indexed by entity ID. */
  private readonly customPickupFunctionsMap = new Map<
    string,
    CustomPickupFunctions
  >();

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 38
      [ModCallback.PRE_PICKUP_COLLISION, this.prePickupCollision],

      // 56
      [
        ModCallback.POST_EFFECT_RENDER,
        this.postEffectRenderPickupEffect,
        [PICKUP_EFFECT_VARIANT],
      ],
    ];
  }

  // ModCallback.PRE_PICKUP_COLLISION (38)
  private readonly prePickupCollision = (
    pickup: EntityPickup,
    collider: Entity,
  ): boolean | undefined => {
    const entityID = getEntityID(pickup);
    const customPickupFunctions = this.customPickupFunctionsMap.get(entityID);
    if (customPickupFunctions === undefined) {
      return undefined;
    }

    const player = collider.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    const shouldPickup = customPickupFunctions.collisionFunc(player);
    if (!shouldPickup) {
      return undefined;
    }

    pickup.Remove();

    const pickupSprite = pickup.GetSprite();
    const fileName = pickupSprite.GetFilename();

    const effect = spawnEffect(
      PICKUP_EFFECT_VARIANT,
      PICKUP_EFFECT_SUB_TYPE,
      pickup.Position,
    );
    const effectSprite = effect.GetSprite();
    effectSprite.Load(fileName, true);
    effectSprite.Play("Collect", true);

    customPickupFunctions.collectFunc(player);

    return undefined;
  };

  // ModCallback.POST_EFFECT_RENDER (56)
  // PICKUP_EFFECT_VARIANT
  private readonly postEffectRenderPickupEffect = (effect: EntityEffect) => {
    if (effect.SubType !== PICKUP_EFFECT_SUB_TYPE) {
      return;
    }

    const sprite = effect.GetSprite();
    if (sprite.IsFinished("Collect")) {
      effect.Remove();
    }
  };

  /**
   * Helper function to register a custom pickup with the IsaacScript standard library. Use this
   * feature for custom pickups that are intended to be picked up by the player, like bombs and
   * keys.
   *
   * When IsaacScript detects that a player should be collecting the custom pickup, then the pickup
   * will be immediately removed, and an effect showing the pickup's respective `Collect` animation
   * will be spawned. (This emulates how a normal vanilla pickup would work.) After that, the
   * provided `collectFunc` will be fired. In this function, you will probably want to play a sound
   * corresponding to what kind of pickup it is (e.g. `SoundEffect.KEY_PICKUP_GAUNTLET`), as well as
   * do things like adding something to the player's inventory.
   *
   * Note that when you specify your custom pickup in the "entities2.xml" file, it should have a
   * type of "5" and be associated with an anm2 file that has a "Collect" animation.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_PICKUPS`.
   *
   * @param pickupVariantCustom The variant for the corresponding custom pickup.
   * @param subType The sub-type for the corresponding custom pickup.
   * @param collectFunc The function to run when the player collects this pickup.
   * @param collisionFunc Optional. The function to run when a player collides with the pickup.
   *                      Default is a function that always returns true, meaning that the player
   *                      will always immediately collect the pickup when they collide with it.
   *                      Specify this function if your pickup should only be able to be collected
   *                      under certain conditions.
   * @public
   */
  @Exported
  public registerCustomPickup(
    pickupVariantCustom: PickupVariant,
    subType: int,
    collectFunc: (this: void, player: EntityPlayer) => void,
    collisionFunc: (this: void, player: EntityPlayer) => boolean = () => true,
  ): void {
    const entityID = getEntityIDFromConstituents(
      EntityType.PICKUP,
      pickupVariantCustom,
      subType,
    );
    const customPickupFunctions: CustomPickupFunctions = {
      collectFunc,
      collisionFunc,
    };
    this.customPickupFunctionsMap.set(entityID, customPickupFunctions);
  }
}

----
classes\features\other\CustomStages.ts
import type { DoorSlotFlag, Music } from "isaac-typescript-definitions";
import {
  CollectibleType,
  GridEntityType,
  LevelCurse,
  LevelStage,
  ModCallback,
  RoomShape,
  RoomType,
  StageType,
} from "isaac-typescript-definitions";
import { game, musicManager } from "../../../core/cachedClasses";
import * as metadataJSON from "../../../customStageMetadata.json"; // This will correspond to "customStageMetadata.lua" at run-time.
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { isArray } from "../../../functions/array";
import {
  doorSlotsToDoorSlotFlags,
  getDoorSlotsForRoomShape,
} from "../../../functions/doors";
import { hasFlag, removeFlag } from "../../../functions/flag";
import { logError } from "../../../functions/log";
import { newRNG } from "../../../functions/rng";
import { removeUrnRewards } from "../../../functions/rockAlt";
import {
  getRoomDataForTypeVariant,
  getRoomsInsideGrid,
  inRoomType,
} from "../../../functions/rooms";
import { getMusicForStage } from "../../../functions/sound";
import { setStage } from "../../../functions/stage";
import { assertDefined } from "../../../functions/utils";
import type {
  CustomStageLua,
  CustomStageRoomMetadata,
} from "../../../interfaces/CustomStageTSConfig";
import type {
  CustomStage,
  RoomTypeMap,
} from "../../../interfaces/private/CustomStage";
import { Feature } from "../../private/Feature";
import type { CustomGridEntities } from "../callbackLogic/CustomGridEntities";
import type { GameReorderedCallbacks } from "../callbackLogic/GameReorderedCallbacks";
import type { CustomTrapdoors } from "./CustomTrapdoors";
import type { DisableAllSound } from "./DisableAllSound";
import type { Pause } from "./Pause";
import type { RunInNFrames } from "./RunInNFrames";
import { setCustomStageBackdrop } from "./customStages/backdrop";
import {
  CUSTOM_FLOOR_STAGE,
  CUSTOM_FLOOR_STAGE_TYPE,
  DEFAULT_BASE_STAGE,
  DEFAULT_BASE_STAGE_TYPE,
} from "./customStages/constants";
import {
  convertVanillaTrapdoors,
  setCustomDecorationGraphics,
  setCustomDoorGraphics,
  setCustomPitGraphics,
  setCustomRockGraphics,
} from "./customStages/gridEntities";
import { setShadows } from "./customStages/shadows";
import {
  streakTextGetShaderParams,
  streakTextPostRender,
  topStreakTextStart,
} from "./customStages/streakText";
import {
  getRandomBossRoomFromPool,
  getRandomCustomStageRoom,
} from "./customStages/utils";
import { v } from "./customStages/v";
import {
  playVersusScreenAnimation,
  versusScreenPostRender,
} from "./customStages/versusScreen";

/**
 * 60 does not work correctly (the music kicking in from stage -1 will mute it), so we use 70 to be
 * safe.
 */
const MUSIC_DELAY_RENDER_FRAMES = 70;

export class CustomStages extends Feature {
  /** @internal */
  public override v = v;

  /** Indexed by custom stage name. */
  private readonly customStagesMap = new Map<string, CustomStage>();

  /** Indexed by room variant. */
  private readonly customStageCachedRoomData = new Map<int, RoomConfig>();

  private usingRedKey = false;

  private readonly customGridEntities: CustomGridEntities;
  private readonly customTrapdoors: CustomTrapdoors;
  private readonly disableAllSound: DisableAllSound;
  private readonly gameReorderedCallbacks: GameReorderedCallbacks;
  private readonly pause: Pause;
  private readonly runInNFrames: RunInNFrames;

  /** @internal */
  constructor(
    customGridEntities: CustomGridEntities,
    customTrapdoors: CustomTrapdoors,
    disableAllSound: DisableAllSound,
    gameReorderedCallbacks: GameReorderedCallbacks,
    pause: Pause,
    runInNFrames: RunInNFrames,
  ) {
    super();

    this.featuresUsed = [
      ISCFeature.CUSTOM_GRID_ENTITIES,
      ISCFeature.CUSTOM_TRAPDOORS,
      ISCFeature.DISABLE_ALL_SOUND,
      ISCFeature.GAME_REORDERED_CALLBACKS,
      ISCFeature.PAUSE,
      ISCFeature.RUN_IN_N_FRAMES,
    ];

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],

      // 3
      [
        ModCallback.POST_USE_ITEM,
        this.postUseItemRedKey,
        [CollectibleType.RED_KEY],
      ],

      // 12
      [ModCallback.POST_CURSE_EVAL, this.postCurseEval],

      // 21
      [ModCallback.GET_SHADER_PARAMS, this.getShaderParams],

      // 23
      [
        ModCallback.PRE_USE_ITEM,
        this.preUseItemRedKey,
        [CollectibleType.RED_KEY],
      ],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GRID_ENTITY_BROKEN,
        this.postGridEntityBrokenRockAlt,
        [GridEntityType.ROCK_ALT],
      ],
      [ModCallbackCustom.POST_GRID_ENTITY_INIT, this.postGridEntityInit],
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.customGridEntities = customGridEntities;
    this.customTrapdoors = customTrapdoors;
    this.disableAllSound = disableAllSound;
    this.gameReorderedCallbacks = gameReorderedCallbacks;
    this.pause = pause;
    this.runInNFrames = runInNFrames;

    this.initCustomStageMetadata();
  }

  private initCustomStageMetadata() {
    if (!isArray(metadataJSON)) {
      error(
        'The IsaacScript standard library attempted to read the custom stage metadata from the "customStageMetadata.lua" file, but it was not an array.',
      );
    }
    const customStagesLua = metadataJSON as CustomStageLua[];

    for (const customStageLua of customStagesLua) {
      this.initRoomTypeMap(customStageLua);
      this.initCustomTrapdoorDestination(customStageLua);
    }
  }

  private initRoomTypeMap(customStageLua: CustomStageLua) {
    const roomTypeMap = getRoomTypeMap(customStageLua);
    const customStage: CustomStage = {
      ...customStageLua,
      roomTypeMap,
    };
    this.customStagesMap.set(customStage.name, customStage);
  }

  private initCustomTrapdoorDestination(customStageLua: CustomStageLua) {
    this.customTrapdoors.registerCustomTrapdoorDestination(
      customStageLua.name,
      this.goToCustomStage,
    );
  }

  private readonly goToCustomStage = (
    destinationName: string | undefined,
    destinationStage: LevelStage,
    _destinationStageType: StageType,
  ) => {
    assertDefined(
      destinationName,
      "Failed to go to a custom stage since the custom trapdoors feature did not pass a destination name to the logic function.",
    );

    const firstFloor = destinationStage === LevelStage.BASEMENT_1;
    this.setCustomStage(destinationName, firstFloor);
  };

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return;
    }

    streakTextPostRender();
    versusScreenPostRender(this.pause, this.disableAllSound);

    // Fix the bug where the music will stop after loading a new room. (This does not work if placed
    // in the `POST_NEW_ROOM_REORDERED` callback or the `POST_UPDATE` callback.)
    if (customStage.music !== undefined) {
      const currentMusic = musicManager.GetCurrentMusicID();
      const music = Isaac.GetMusicIdByName(customStage.music);
      if (currentMusic === music) {
        musicManager.Resume();
        musicManager.UpdateVolume();
      }
    }
  };

  /**
   * Fix the bug where Red Key will not work on custom floors (due to the stage being a bugged
   * value).
   */
  // ModCallback.POST_USE_ITEM (3)
  private readonly postUseItemRedKey = (): boolean | undefined => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return undefined;
    }

    if (!this.usingRedKey) {
      return undefined;
    }
    this.usingRedKey = false;

    const level = game.GetLevel();
    level.SetStage(CUSTOM_FLOOR_STAGE, CUSTOM_FLOOR_STAGE_TYPE);

    return undefined;
  };

  // ModCallback.POST_CURSE_EVAL (12)
  private readonly postCurseEval = (
    curses: BitFlags<LevelCurse>,
  ): BitFlags<LevelCurse> | LevelCurse | undefined => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return undefined;
    }

    // Prevent XL floors on custom stages, since the streak text will not work properly.
    if (hasFlag(curses, LevelCurse.LABYRINTH)) {
      return removeFlag(curses, LevelCurse.LABYRINTH);
    }

    return undefined;
  };

  // ModCallback.GET_SHADER_PARAMS (22)
  private readonly getShaderParams = (
    shaderName: string,
  ): Record<string, unknown> | undefined => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return undefined;
    }

    streakTextGetShaderParams(customStage, shaderName);
    return undefined;
  };

  /**
   * Fix the bug where Red Key will not work on custom floors (due to the stage being a bugged
   * value).
   */
  // ModCallback.PRE_USE_ITEM (23)
  private readonly preUseItemRedKey = (): boolean | undefined => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return undefined;
    }

    this.usingRedKey = true;

    const level = game.GetLevel();
    const stage = customStage.baseStage ?? DEFAULT_BASE_STAGE;
    const stageType = customStage.baseStageType ?? DEFAULT_BASE_STAGE_TYPE;
    level.SetStage(stage, stageType); // eslint-disable-line isaacscript/strict-enums

    return undefined;
  };

  // ModCallbackCustom.POST_GRID_ENTITY_BROKEN
  // GridEntityType.ROCK_ALT
  private readonly postGridEntityBrokenRockAlt = (gridEntity: GridEntity) => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return;
    }

    // Assume that if the end-user does not have custom rock graphics specified, they want to keep
    // the vanilla urn reward functionality.
    if (customStage.rocksPNGPath === undefined) {
      return;
    }

    // On the bugged stage of -1, only urns will spawn, so we do not have to handle the case of
    // mushroom rewards, skull rewards, and so on.
    removeUrnRewards(gridEntity);
  };

  // ModCallbackCustom.POST_GRID_ENTITY_INIT
  private readonly postGridEntityInit = (gridEntity: GridEntity) => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return;
    }

    // We only want to modify vanilla grid entities.
    if (this.customGridEntities.isCustomGridEntity(gridEntity)) {
      return;
    }

    setCustomDecorationGraphics(customStage, gridEntity);
    setCustomRockGraphics(customStage, gridEntity);
    setCustomPitGraphics(customStage, gridEntity);
    setCustomDoorGraphics(customStage, gridEntity);
    convertVanillaTrapdoors(
      customStage,
      gridEntity,
      v.run.firstFloor,
      this.customTrapdoors,
    );
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    const customStage = v.run.currentCustomStage;
    if (customStage === null) {
      return;
    }

    setCustomStageBackdrop(customStage);
    setShadows(customStage);
    playVersusScreenAnimation(
      customStage,
      this.disableAllSound,
      this.pause,
      this.runInNFrames,
    );

    // Fix the bug where music from special rooms (like the "Boss Over" music) will persist for the
    // rest of the floor.
    if (customStage.music !== undefined && inRoomType(RoomType.DEFAULT)) {
      const music = Isaac.GetMusicIdByName(customStage.music);
      const currentMusic = musicManager.GetCurrentMusicID();
      if (currentMusic !== music) {
        musicManager.Fadein(music);
      }
    }
  };

  /** Pick a custom room for each vanilla room. */
  private setStageRoomsData(
    customStage: CustomStage,
    rng: RNG,
    verbose: boolean,
  ) {
    const level = game.GetLevel();
    const startingRoomGridIndex = level.GetStartingRoomIndex();

    for (const room of getRoomsInsideGrid()) {
      // The starting floor of each room should stay empty.
      if (room.SafeGridIndex === startingRoomGridIndex) {
        continue;
      }

      if (room.Data === undefined) {
        continue;
      }

      const roomType = room.Data.Type;
      const roomShapeMap = customStage.roomTypeMap.get(roomType);
      if (roomShapeMap === undefined) {
        // Only show errors for non-default room types. (We do not require that end-users provide
        // custom rooms for shops and other special rooms inside of their XML file.)
        if (roomType === RoomType.DEFAULT) {
          logError(
            `Failed to find any custom rooms for RoomType.${RoomType[roomType]} (${roomType}) for custom stage: ${customStage.name}`,
          );
        }
        continue;
      }

      const roomShape = room.Data.Shape;
      const roomDoorSlotFlagMap = roomShapeMap.get(roomShape);
      if (roomDoorSlotFlagMap === undefined) {
        logError(
          `Failed to find any custom rooms for RoomType.${RoomType[roomType]} (${roomType}) + RoomShape.${RoomShape[roomShape]} (${roomShape}) for custom stage: ${customStage.name}`,
        );
        continue;
      }

      const doorSlotFlags = room.Data.Doors;
      let roomsMetadata = roomDoorSlotFlagMap.get(doorSlotFlags);
      if (roomsMetadata === undefined) {
        // The custom stage does not have any rooms for the specific room type + room shape + door
        // slot combination. As a fallback, check to see if the custom stage has one or more rooms
        // for this specific room type + room shape + all doors.
        const allDoorSlots = getDoorSlotsForRoomShape(roomShape);
        const allDoorSlotFlags = doorSlotsToDoorSlotFlags(allDoorSlots);
        roomsMetadata = roomDoorSlotFlagMap.get(allDoorSlotFlags);
        if (roomsMetadata === undefined) {
          logError(
            `Failed to find any custom rooms for RoomType.${RoomType[roomType]} (${roomType}) + RoomShape.${RoomShape[roomShape]} (${roomShape}) + all doors enabled for custom stage: ${customStage.name}`,
          );
          continue;
        }
      }

      let randomRoom: CustomStageRoomMetadata;
      if (roomType === RoomType.BOSS) {
        if (customStage.bossPool === undefined) {
          continue;
        }

        randomRoom = getRandomBossRoomFromPool(
          roomsMetadata,
          customStage.bossPool,
          rng,
          verbose,
        );
      } else {
        randomRoom = getRandomCustomStageRoom(roomsMetadata, rng, verbose);
      }

      let newRoomData = this.customStageCachedRoomData.get(randomRoom.variant);
      if (newRoomData === undefined) {
        // We do not already have the room data for this room cached.
        newRoomData = getRoomDataForTypeVariant(
          roomType,
          randomRoom.variant,
          false, // Since we are going to multiple rooms, we cancel the transition.
          true, // The custom stage rooms are loaded inside of the "00.special rooms.stb" file.
        );
        if (newRoomData === undefined) {
          logError(
            `Failed to get the room data for room variant ${randomRoom.variant} for custom stage: ${customStage.name}`,
          );
          continue;
        }

        this.customStageCachedRoomData.set(randomRoom.variant, newRoomData);
      }

      room.Data = newRoomData;
    }
  }

  /**
   * Helper function to warp to a custom stage/level.
   *
   * Custom stages/levels must first be defined in the "tsconfig.json" file. See the documentation
   * for more details: https://isaacscript.github.io/main/custom-stages/
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_STAGES`.
   *
   * @param name The name of the custom stage, corresponding to what is in the "tsconfig.json" file.
   * @param firstFloor Optional. Whether to go to the first floor or the second floor. For example,
   *                   if you have a custom stage emulating Caves, then the first floor would be
   *                   Caves 1, and the second floor would be Caves 2. Default is true.
   * @param streakText Optional. Whether to show the streak text at the top of the screen that
   *                   announces the name of the level. Default is true.
   * @param verbose Optional. Whether to log additional information about the rooms that are chosen.
   *                Default is false.
   * @public
   */
  @Exported
  public setCustomStage(
    name: string,
    firstFloor = true,
    streakText = true,
    verbose = false,
  ): void {
    const customStage = this.customStagesMap.get(name);
    assertDefined(
      customStage,
      `Failed to set the custom stage of "${name}" because it was not found in the custom stages map. (Try restarting IsaacScript / recompiling the mod / restarting the game, and try again. If that does not work, you probably forgot to define it in your "tsconfig.json" file.) See the website for more details on how to set up custom stages.`,
    );

    const level = game.GetLevel();
    const stage = level.GetStage();
    const seeds = game.GetSeeds();
    const startSeed = seeds.GetStartSeed();
    const rng = newRNG(startSeed);

    v.run.currentCustomStage = customStage;
    v.run.firstFloor = firstFloor;

    // Before changing the stage, we have to revert the bugged stage, if necessary. This prevents
    // the bug where the backdrop will not spawn.
    if (stage === CUSTOM_FLOOR_STAGE) {
      level.SetStage(LevelStage.BASEMENT_1, StageType.ORIGINAL);
    }

    let baseStage: LevelStage =
      customStage.baseStage === undefined
        ? DEFAULT_BASE_STAGE
        : (customStage.baseStage as LevelStage);
    if (!firstFloor) {
      baseStage++; // eslint-disable-line isaacscript/strict-enums
    }

    const baseStageType: StageType =
      customStage.baseStageType === undefined
        ? DEFAULT_BASE_STAGE_TYPE
        : (customStage.baseStageType as StageType);

    const reseed = stage >= baseStage;
    setStage(baseStage, baseStageType, reseed);

    // As soon as we warp to the base stage, the base stage music will begin to play. Thus, we
    // temporarily mute all music.
    musicManager.Disable();

    this.setStageRoomsData(customStage, rng, verbose);

    // Set the stage to an invalid value, which will prevent the walls and floors from loading.
    const targetStage = CUSTOM_FLOOR_STAGE;
    const targetStageType = CUSTOM_FLOOR_STAGE_TYPE;
    level.SetStage(targetStage, targetStageType);
    this.gameReorderedCallbacks.reorderedCallbacksSetStage(
      targetStage,
      targetStageType,
    );

    // In vanilla, the streak text appears about when the pixelation has faded and while Isaac is
    // still laying on the ground. Unfortunately, we cannot exactly replicate the vanilla timing,
    // because the level text will bug out and smear the background if we play it from a
    // `POST_RENDER` callback. Thus, we run it on the next game frame as a workaround.
    if (streakText) {
      this.runInNFrames.runNextGameFrame(() => {
        topStreakTextStart();
      });
    }

    // The bugged stage will not have any music associated with it, so we must manually start to
    // play a track. First, prefer the music that is explicitly assigned to this custom floor.
    let customStageMusic: Music | -1 | undefined;
    if (customStage.music !== undefined) {
      customStageMusic = Isaac.GetMusicIdByName(customStage.music) as
        | Music
        | -1;
      if (customStageMusic === -1) {
        logError(
          `Failed to get the music ID associated with the name of: ${customStage.music}`,
        );
      }
    }

    const music =
      customStageMusic === undefined || customStageMusic === -1
        ? getMusicForStage(baseStage, baseStageType)
        : customStageMusic;

    this.runInNFrames.runInNRenderFrames(() => {
      musicManager.Enable();
      musicManager.Play(music);
      musicManager.UpdateVolume();
    }, MUSIC_DELAY_RENDER_FRAMES);

    // We must reload the current room in order for the `Level.SetStage` method to take effect.
    // Furthermore, we need to cancel the queued warp to the `GridRoom.DEBUG` room. We can
    // accomplish both of these things by initiating a room transition to an arbitrary room.
    // However, we rely on the parent function to do this, since for normal purposes, we need to
    // initiate a room transition for the pixelation effect.
  }

  /**
   * Helper function to disable the custom stage. This is typically called before taking the player
   * to a vanilla floor.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_STAGES`.
   *
   * @public
   */
  @Exported
  public disableCustomStage(): void {
    v.run.currentCustomStage = null;
  }
}

function getRoomTypeMap(customStageLua: CustomStageLua): RoomTypeMap {
  const roomTypeMap = new Map<
    RoomType,
    Map<RoomShape, Map<DoorSlotFlag, CustomStageRoomMetadata[]>>
  >();

  for (const roomMetadata of customStageLua.roomsMetadata) {
    const roomType = roomMetadata.type as RoomType;

    let roomShapeMap = roomTypeMap.get(roomType);
    if (roomShapeMap === undefined) {
      roomShapeMap = new Map<
        RoomShape,
        Map<DoorSlotFlag, CustomStageRoomMetadata[]>
      >();
      roomTypeMap.set(roomType, roomShapeMap);
    }

    const roomShape = roomMetadata.shape as RoomShape;

    let roomDoorSlotFlagMap = roomShapeMap.get(roomShape);
    if (roomDoorSlotFlagMap === undefined) {
      roomDoorSlotFlagMap = new Map<
        BitFlags<DoorSlotFlag>,
        CustomStageRoomMetadata[]
      >();
      roomShapeMap.set(roomShape, roomDoorSlotFlagMap);
    }

    const doorSlotFlags = roomMetadata.doorSlotFlags as BitFlags<DoorSlotFlag>;
    let rooms = roomDoorSlotFlagMap.get(doorSlotFlags);
    if (rooms === undefined) {
      rooms = [];
      roomDoorSlotFlagMap.set(doorSlotFlags, rooms);
    }

    rooms.push(roomMetadata);
  }

  return roomTypeMap;
}

----
classes\features\other\CustomTrapdoors.ts
import {
  ButtonAction,
  Direction,
  EntityCollisionClass,
  EntityGridCollisionClass,
  EntityPartition,
  GridCollisionClass,
  LevelStage,
  ModCallback,
  PlayerType,
  RoomTransitionAnim,
  RoomType,
  StageType,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { VectorZero } from "../../../core/constants";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { GridEntityTypeCustom } from "../../../enums/private/GridEntityTypeCustom";
import { StageTravelState } from "../../../enums/private/StageTravelState";
import { TrapdoorAnimation } from "../../../enums/private/TrapdoorAnimation";
import { easeOutSine } from "../../../functions/easing";
import {
  isAfterRoomFrame,
  isBeforeRenderFrame,
  onOrAfterRenderFrame,
} from "../../../functions/frames";
import { log } from "../../../functions/log";
import { movePlayersToCenter } from "../../../functions/playerCenter";
import {
  getAllPlayers,
  getOtherPlayers,
  isChildPlayer,
} from "../../../functions/playerIndex";
import { isCharacter } from "../../../functions/players";
import { anyPlayerCloserThan } from "../../../functions/positionVelocity";
import {
  getRoomGridIndex,
  getRoomListIndex,
} from "../../../functions/roomData";
import { teleport } from "../../../functions/roomTransition";
import { setStage } from "../../../functions/stage";
import { getTSTLClassName } from "../../../functions/tstlClass";
import { assertDefined } from "../../../functions/utils";
import { isVector } from "../../../functions/vector";
import type { CustomTrapdoorDescription } from "../../../interfaces/private/CustomTrapdoorDescription";
import { ReadonlySet } from "../../../types/ReadonlySet";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";
import type { CustomGridEntities } from "../callbackLogic/CustomGridEntities";
import type { DisableInputs } from "./DisableInputs";
import type { PonyDetection } from "./PonyDetection";
import type { RoomClearFrame } from "./RoomClearFrame";
import type { RunInNFrames } from "./RunInNFrames";
import type { RunNextRoom } from "./RunNextRoom";
import type { StageHistory } from "./StageHistory";
import { CUSTOM_FLOOR_STAGE } from "./customStages/constants";

const DEBUG = false as boolean;

/** This also applies to crawl spaces. The value was determined through trial and error. */
const TRAPDOOR_OPEN_DISTANCE = 60;

const TRAPDOOR_OPEN_DISTANCE_AFTER_BOSS = TRAPDOOR_OPEN_DISTANCE * 2.5;
const TRAPDOOR_BOSS_REACTION_FRAMES = 30;

const TRAPDOOR_TOUCH_DISTANCE = 16.5;

const ANIMATIONS_THAT_PREVENT_STAGE_TRAVEL = new ReadonlySet<string>([
  "Death",
  "Happy",
  "Sad",
  "Jump",
]);

const PIXELATION_TO_BLACK_FRAMES = 60;

const OTHER_PLAYER_TRAPDOOR_JUMP_DELAY_GAME_FRAMES = 6;
const OTHER_PLAYER_TRAPDOOR_JUMP_DURATION_GAME_FRAMES = 5;

const v = {
  run: {
    state: StageTravelState.NONE,

    /** The render frame that this state was reached. */
    stateRenderFrame: null as int | null,

    customTrapdoorActivated: null as CustomTrapdoorDescription | null,
  },

  level: {
    /** Indexed by room list index and grid index. */
    trapdoors: new DefaultMap<int, Map<int, CustomTrapdoorDescription>>(
      () => new Map(),
    ),
  },
};

export class CustomTrapdoors extends Feature {
  /** Indexed by custom trapdoor ID. */
  private readonly destinationFuncMap = new Map<
    string,
    (
      destinationName: string | undefined,
      destinationStage: LevelStage,
      destinationStageType: StageType,
    ) => void
  >();

  /** @internal */
  public override v = v;

  /**
   * In order to represent a black sprite, we just use the first frame of the boss versus screen
   * animation. However, we must lazy load the sprite in order to prevent issues with mods that
   * replace the vanilla files. (For some reason, loading the sprites will cause the overwrite to no
   * longer apply on the second and subsequent runs.)
   */
  private readonly blackSprite = Sprite();

  private readonly customGridEntities: CustomGridEntities;
  private readonly disableInputs: DisableInputs;
  private readonly ponyDetection: PonyDetection;
  private readonly roomClearFrame: RoomClearFrame;
  private readonly runInNFrames: RunInNFrames;
  private readonly runNextRoom: RunNextRoom;
  private readonly stageHistory: StageHistory;

  /** @internal */
  constructor(
    customGridEntities: CustomGridEntities,
    disableInputs: DisableInputs,
    ponyDetection: PonyDetection,
    roomClearFrame: RoomClearFrame,
    runInNFrames: RunInNFrames,
    runNextRoom: RunNextRoom,
    stageHistory: StageHistory,
  ) {
    super();

    this.featuresUsed = [
      ISCFeature.CUSTOM_GRID_ENTITIES,
      ISCFeature.DISABLE_INPUTS,
      ISCFeature.PONY_DETECTION,
      ISCFeature.ROOM_CLEAR_FRAME,
      ISCFeature.RUN_IN_N_FRAMES,
      ISCFeature.RUN_NEXT_ROOM,
      ISCFeature.STAGE_HISTORY,
    ];

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE,
        this.postGridEntityCustomUpdateTrapdoor,
        [GridEntityTypeCustom.TRAPDOOR_CUSTOM],
      ],
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];

    this.customGridEntities = customGridEntities;
    this.disableInputs = disableInputs;
    this.ponyDetection = ponyDetection;
    this.roomClearFrame = roomClearFrame;
    this.runInNFrames = runInNFrames;
    this.runNextRoom = runNextRoom;
    this.stageHistory = stageHistory;
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    this.checkAllPlayersJumpComplete();
    this.checkPixelationToBlackComplete();
    this.checkSecondPixelationHalfWay();
    this.checkAllPlayersLayingDownComplete();
    this.drawBlackSprite();
  };

  private checkAllPlayersJumpComplete() {
    if (v.run.state !== StageTravelState.PLAYERS_JUMPING_DOWN) {
      return;
    }

    if (anyPlayerPlayingExtraAnimation()) {
      return;
    }

    const renderFrameCount = Isaac.GetFrameCount();
    const roomGridIndex = getRoomGridIndex();

    v.run.state = StageTravelState.PIXELATION_TO_BLACK;
    v.run.stateRenderFrame = renderFrameCount;
    this.logStateChanged();

    // In order to display the pixelation effect that should happen when we go to a new floor, we
    // need to start a room transition. We arbitrarily pick the current room for this purpose. (We
    // do not have to worry about Curse of the Maze here, because even if we are taken to a
    // different room, it will not matter, since we will be traveling to a new floor after the
    // screen fades to black.)
    teleport(
      roomGridIndex,
      Direction.NO_DIRECTION,
      RoomTransitionAnim.PIXELATION,
    );

    // Next, we wait a certain amount of render frames for the pixelation to fade the screen to
    // black.
  }

  private checkPixelationToBlackComplete() {
    if (
      v.run.state !== StageTravelState.PIXELATION_TO_BLACK ||
      v.run.stateRenderFrame === null
    ) {
      return;
    }

    const renderFrameScreenBlack =
      v.run.stateRenderFrame + PIXELATION_TO_BLACK_FRAMES;
    if (isBeforeRenderFrame(renderFrameScreenBlack)) {
      return;
    }

    v.run.state = StageTravelState.WAITING_FOR_FIRST_PIXELATION_TO_END;
    this.logStateChanged();

    // Now, we display a black sprite on top of the pixelation effect, to prevent showing the rest
    // of the animation.
    const hud = game.GetHUD();
    hud.SetVisible(false);

    // If the pixelation effect is not fully allowed to complete, the game's internal buffer will
    // not be flushed. The consequence of this is that after 11 custom stage transitions, the
    // "log.txt" starts to become become spammed with: [ASSERT] - PushRenderTarget: stack overflow!

    // In order to work around this, we fully let the animation complete by only continuing the
    // stage transition on the next game frame.
    this.runInNFrames.runNextGameFrame(() => {
      const level = game.GetLevel();
      const startingRoomIndex = level.GetStartingRoomIndex();
      const futureRenderFrameCount = Isaac.GetFrameCount();

      v.run.state =
        StageTravelState.WAITING_FOR_SECOND_PIXELATION_TO_GET_HALF_WAY;
      v.run.stateRenderFrame = futureRenderFrameCount;

      this.goToCustomTrapdoorDestination();

      // Start another pixelation effect. This time, we will keep the screen black with the sprite,
      // and then remove the black sprite once the pixelation effect is halfway complete.
      teleport(
        startingRoomIndex,
        Direction.NO_DIRECTION,
        RoomTransitionAnim.PIXELATION,
      );
    });
  }

  private goToCustomTrapdoorDestination() {
    if (v.run.customTrapdoorActivated === null) {
      // This should never happen; provide some sane default values.
      v.run.customTrapdoorActivated = {
        destinationName: undefined,
        destinationStage: LevelStage.BASEMENT_1,
        destinationStageType: StageType.ORIGINAL,
        open: true,
        firstSpawn: true,
      };
    }

    const destinationFunc = this.getDestinationFunc(
      v.run.customTrapdoorActivated,
    );
    destinationFunc(
      v.run.customTrapdoorActivated.destinationName,
      v.run.customTrapdoorActivated.destinationStage,
      v.run.customTrapdoorActivated.destinationStageType,
    );
  }

  private getDestinationFunc(
    customTrapdoorDescription: CustomTrapdoorDescription,
  ): (
    destinationName: string | undefined,
    destinationStage: LevelStage,
    destinationStageType: StageType,
  ) => void {
    if (customTrapdoorDescription.destinationName === undefined) {
      return goToVanillaStage;
    }

    const destinationFunc = this.destinationFuncMap.get(
      customTrapdoorDescription.destinationName,
    );
    if (destinationFunc === undefined) {
      return goToVanillaStage;
    }

    return destinationFunc;
  }

  private checkSecondPixelationHalfWay() {
    if (
      v.run.state !==
        StageTravelState.WAITING_FOR_SECOND_PIXELATION_TO_GET_HALF_WAY ||
      v.run.stateRenderFrame === null
    ) {
      return;
    }

    const renderFrameScreenBlack =
      v.run.stateRenderFrame + PIXELATION_TO_BLACK_FRAMES;
    if (isBeforeRenderFrame(renderFrameScreenBlack)) {
      return;
    }

    v.run.state = StageTravelState.PIXELATION_TO_ROOM;
    this.logStateChanged();

    const hud = game.GetHUD();
    hud.SetVisible(true);

    this.runNextRoom.runNextRoom(() => {
      v.run.state = StageTravelState.PLAYERS_LAYING_DOWN;
      this.logStateChanged();

      // After the room transition, the players will be placed next to a door, but they should be in
      // the center of the room to emulate what happens on a vanilla stage.
      movePlayersToCenter();

      for (const player of getAllPlayers()) {
        player.AnimateAppear();

        // We need to restore the original collision classes.
        player.EntityCollisionClass = EntityCollisionClass.ALL;
        player.GridCollisionClass = EntityGridCollisionClass.GROUND;
      }

      const level = game.GetLevel();
      const stage = level.GetStage();
      if (stage !== CUSTOM_FLOOR_STAGE) {
        // The vanilla streak text shows just before the player stands up, which is a few frames
        // from now. We arbitrarily play it now instead of waiting to avoid the extra complexity.
        level.ShowName(false);
      }
    });
  }

  private checkAllPlayersLayingDownComplete() {
    if (v.run.state !== StageTravelState.PLAYERS_LAYING_DOWN) {
      return;
    }

    if (anyPlayerPlayingExtraAnimation()) {
      return;
    }

    v.run.state = StageTravelState.NONE;
    this.logStateChanged();

    const tstlClassName = getTSTLClassName(this);
    assertDefined(
      tstlClassName,
      "Failed to find get the class name for the custom trapdoor feature.",
    );

    this.disableInputs.enableAllInputs(tstlClassName);
  }

  private drawBlackSprite(): void {
    if (
      v.run.state !== StageTravelState.WAITING_FOR_FIRST_PIXELATION_TO_END &&
      v.run.state !==
        StageTravelState.WAITING_FOR_SECOND_PIXELATION_TO_GET_HALF_WAY
    ) {
      return;
    }

    if (!this.blackSprite.IsLoaded()) {
      this.blackSprite.Load("gfx/ui/boss/versusscreen.anm2", true);
      this.blackSprite.SetFrame("Scene", 0);
      this.blackSprite.Scale = Vector(100, 100);
    }

    this.blackSprite.RenderLayer(0, VectorZero);
  }

  // ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE
  // GridEntityTypeCustom.TRAPDOOR_CUSTOM
  private readonly postGridEntityCustomUpdateTrapdoor = (
    gridEntity: GridEntity,
  ) => {
    const roomListIndex = getRoomListIndex();
    const gridIndex = gridEntity.GetGridIndex();

    const roomTrapdoorMap = v.level.trapdoors.getAndSetDefault(roomListIndex);
    const trapdoorDescription = roomTrapdoorMap.get(gridIndex);
    if (trapdoorDescription === undefined) {
      return;
    }

    this.checkCustomTrapdoorOpenClose(gridEntity, trapdoorDescription);
    this.checkCustomTrapdoorPlayerTouched(gridEntity, trapdoorDescription);
  };

  private checkCustomTrapdoorOpenClose(
    gridEntity: GridEntity,
    trapdoorDescription: CustomTrapdoorDescription,
  ): void {
    /** By default, trapdoors will never close if they are already open. */
    if (trapdoorDescription.open) {
      return;
    }

    if (this.shouldTrapdoorOpen(gridEntity, trapdoorDescription.firstSpawn)) {
      openCustomTrapdoor(gridEntity, trapdoorDescription);
    }
  }

  private shouldTrapdoorOpen(
    gridEntity: GridEntity,
    firstSpawn: boolean,
  ): boolean {
    const room = game.GetRoom();
    const roomClear = room.IsClear();

    return (
      !anyPlayerCloserThan(gridEntity.Position, TRAPDOOR_OPEN_DISTANCE) &&
      !this.isPlayerCloseAfterBoss(gridEntity.Position) &&
      !shouldBeClosedFromStartingInRoomWithEnemies(firstSpawn, roomClear)
    );
  }

  private isPlayerCloseAfterBoss(position: Vector) {
    const room = game.GetRoom();
    const roomType = room.GetType();
    const roomClearGameFrame = this.roomClearFrame.getRoomClearGameFrame();

    // In order to prevent a player from accidentally entering a freshly-spawned trapdoor after
    // killing the boss of the floor, we use a wider open distance for a short amount of frames.
    if (
      roomType !== RoomType.BOSS ||
      roomClearGameFrame === undefined ||
      onOrAfterRenderFrame(roomClearGameFrame + TRAPDOOR_BOSS_REACTION_FRAMES)
    ) {
      return false;
    }

    return anyPlayerCloserThan(position, TRAPDOOR_OPEN_DISTANCE_AFTER_BOSS);
  }

  private checkCustomTrapdoorPlayerTouched(
    gridEntity: GridEntity,
    trapdoorDescription: CustomTrapdoorDescription,
  ): void {
    if (v.run.state !== StageTravelState.NONE) {
      return;
    }

    if (!trapdoorDescription.open) {
      return;
    }

    const playersTouching = Isaac.FindInRadius(
      gridEntity.Position,
      TRAPDOOR_TOUCH_DISTANCE,
      EntityPartition.PLAYER,
    );
    for (const playerEntity of playersTouching) {
      const player = playerEntity.ToPlayer();
      if (player === undefined) {
        continue;
      }

      if (
        // We don't want a Pony dash to transition to a new floor or a crawl space.
        !this.ponyDetection.isPlayerUsingPony(player) &&
        !isChildPlayer(player) &&
        canPlayerInteractWithTrapdoor(player)
      ) {
        this.playerTouchedCustomTrapdoor(
          gridEntity,
          trapdoorDescription,
          player,
        );
        return; // Prevent two players from touching the same entity.
      }
    }
  }

  private playerTouchedCustomTrapdoor(
    gridEntity: GridEntity,
    trapdoorDescription: CustomTrapdoorDescription,
    player: EntityPlayer,
  ) {
    v.run.state = StageTravelState.PLAYERS_JUMPING_DOWN;
    v.run.customTrapdoorActivated = trapdoorDescription;
    this.logStateChanged();

    const tstlClassName = getTSTLClassName(this);
    assertDefined(
      tstlClassName,
      "Failed to find get the class name for the custom trapdoor feature.",
    );

    // We don't want to allow pausing, since that will allow render frames to pass without advancing
    // the stage traveling logic. (We track how many render frames have passed to know when to move
    // to the next step.)
    const whitelist = new ReadonlySet([ButtonAction.CONSOLE]);
    this.disableInputs.disableAllInputsExceptFor(tstlClassName, whitelist);
    setPlayerAttributes(player, gridEntity.Position);
    dropTaintedForgotten(player);

    player.PlayExtraAnimation("Trapdoor");

    const otherPlayers = getOtherPlayers(player);
    for (const [i, otherPlayer] of otherPlayers.entries()) {
      const gameFramesToWaitBeforeJumping =
        OTHER_PLAYER_TRAPDOOR_JUMP_DELAY_GAME_FRAMES * (i + 1);
      const otherPlayerPtr = EntityPtr(otherPlayer);
      this.runInNFrames.runInNGameFrames(() => {
        this.startDelayedJump(otherPlayerPtr, gridEntity.Position);
      }, gameFramesToWaitBeforeJumping);
    }
  }

  private startDelayedJump(entityPtr: EntityPtr, trapdoorPosition: Vector) {
    const entity = entityPtr.Ref;
    if (entity === undefined) {
      return;
    }

    const player = entity.ToPlayer();
    if (player === undefined) {
      return;
    }

    player.PlayExtraAnimation("Trapdoor");

    this.adjustPlayerPositionToTrapdoor(
      entityPtr,
      player.Position,
      trapdoorPosition,
    );
  }

  private adjustPlayerPositionToTrapdoor(
    entityPtr: EntityPtr,
    startPos: Vector,
    endPos: Vector,
  ) {
    if (v.run.state !== StageTravelState.PLAYERS_JUMPING_DOWN) {
      return;
    }

    const entity = entityPtr.Ref;
    if (entity === undefined) {
      return;
    }

    const player = entity.ToPlayer();
    if (player === undefined) {
      return;
    }

    this.runInNFrames.runNextRenderFrame(() => {
      this.adjustPlayerPositionToTrapdoor(entityPtr, startPos, endPos);
    });

    const sprite = player.GetSprite();
    if (sprite.IsFinished("Trapdoor")) {
      player.Position = endPos;
      player.Velocity = VectorZero;
      return;
    }

    const frame = sprite.GetFrame();
    if (frame >= OTHER_PLAYER_TRAPDOOR_JUMP_DURATION_GAME_FRAMES) {
      // We have already arrived at the trapdoor.
      player.Position = endPos;
      player.Velocity = VectorZero;
      return;
    }

    // Make the player jump towards the trapdoor. We use an easing function so that the distance
    // traveled is not linear, emulating what the game does.
    const totalDifference = endPos.sub(startPos);
    const progress = frame / OTHER_PLAYER_TRAPDOOR_JUMP_DURATION_GAME_FRAMES;
    const easeProgress = easeOutSine(progress);
    const differenceForThisFrame = totalDifference.mul(easeProgress);
    const targetPosition = startPos.add(differenceForThisFrame);

    player.Position = targetPosition;
    player.Velocity = VectorZero;
  }

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    this.checkJumpComplete(player);
  };

  private checkJumpComplete(player: EntityPlayer) {
    if (v.run.state !== StageTravelState.PLAYERS_JUMPING_DOWN) {
      return;
    }

    // In this state, the players are jumping down the hole (i.e. playing the "Trapdoor" animation).
    // When it completes, they will return to normal (i.e. just standing on top of the trapdoor).
    // Thus, make them invisible at the end of the animation. (They will automatically be set to
    // visible again once we travel to the next floor.)
    const sprite = player.GetSprite();
    if (sprite.IsFinished("Trapdoor")) {
      player.Visible = false;
    }
  }

  private shouldTrapdoorSpawnOpen(
    gridEntity: GridEntity,
    firstSpawn: boolean,
  ): boolean {
    const room = game.GetRoom();
    const roomClear = room.IsClear();

    // Trapdoors created after a room has already initialized should spawn closed by default:
    // - Trapdoors created after bosses should spawn closed so that players do not accidentally jump
    //   into them.
    // - Trapdoors created by We Need to Go Deeper should spawn closed because the player will be
    //   standing on top of them.
    if (isAfterRoomFrame(0)) {
      return false;
    }

    // If we just entered a new room with enemies in it, spawn the trapdoor closed so that the
    // player has to defeat the enemies first before using the trapdoor.
    if (!roomClear) {
      return false;
    }

    // If we just entered a new room that is already cleared, spawn the trapdoor closed if we are
    // standing close to it, and open otherwise.
    return this.shouldTrapdoorOpen(gridEntity, firstSpawn);
  }

  private logStateChanged(): void {
    if (DEBUG) {
      log(
        `Custom trapdoors state changed: ${StageTravelState[v.run.state]} (${
          v.run.state
        })`,
      );
    }
  }

  /**
   * Helper function to specify where your custom trapdoor should take the player. Call this once at
   * the beginning of your mod for each kind of custom trapdoor that you want to have. The provided
   * `destinationFunc` will be executed when the player jumps into the trapdoor and the pixelation
   * effect fades to black.
   *
   * Registration is needed so that custom trapdoors can be serializable when the player saves and
   * quits.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_TRAPDOORS`.
   *
   * @param destinationName The name that identifies the type of custom trapdoor. It should
   *                        correspond to a local `CustomTrapdoorType` enum in your mod. It can be
   *                        any unique value and can safely overlap with values chosen by other
   *                        mods.
   * @param destinationFunc A function that takes the player to the destination that you want.
   *                        Inside this function, use the `setStage` or `setCustomStage` helper
   *                        functions, or do something completely custom.
   */
  @Exported
  public registerCustomTrapdoorDestination(
    destinationName: string,
    destinationFunc: (
      destinationName: string | undefined,
      destinationStage: LevelStage,
      destinationStageType: StageType,
    ) => void,
  ): void {
    if (this.destinationFuncMap.has(destinationName)) {
      error(
        `Failed to register a custom trapdoor type of ${destinationName} since this custom trapdoor type has already been registered.`,
      );
    }

    this.destinationFuncMap.set(destinationName, destinationFunc);
  }

  /**
   * Helper function to spawn a trapdoor grid entity that will take a player to a vanilla stage or
   * custom location.
   *
   * - If you want to create a custom trapdoor that goes to a vanilla stage, pass `undefined` for
   *   the `destinationName` parameter.
   * - If you want to create a custom trapdoor that takes the player to a custom location, you must
   *   have registered the corresponding `destinationName` at the beginning of your mod with the
   *   `registerCustomTrapdoorDestination` function. (This is necessary so that custom trapdoors can
   *   be serializable when the player saves and quits.)
   *
   * Under the hood, the custom trapdoor is represented by a decoration grid entity and is manually
   * respawned every time the player re-enters the room.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.CUSTOM_TRAPDOORS`.
   *
   * @param gridIndexOrPosition The location in the room to spawn the trapdoor.
   * @param destinationName Optional. A string representing the name of the of destination that the
   *                        custom trapdoor will take the player to. Default is undefined, which
   *                        will take the player to a vanilla stage.
   * @param destinationStage Optional. The first argument that will be passed to the
   *                         `destinationFunc` corresponding to this custom trapdoor. This is
   *                         essentially metadata for the custom trapdoor. Leave this undefined if
   *                         your corresponding custom trapdoor function does not care what the
   *                         destination stage should be. Default is the "normal" next vanilla
   *                         stage.
   * @param destinationStageType Optional. The second argument that will be passed to the
   *                             `destinationFunc` corresponding to this custom trapdoor. This is
   *                             essentially metadata for the custom trapdoor. Leave this undefined
   *                             if your corresponding custom trapdoor function does not care what
   *                             the destination stage type should be. Default is the "normal" next
   *                             vanilla stage type.
   * @param anm2Path Optional. The path to the anm2 file to use. By default, the vanilla trapdoor
   *                 anm2 of "gfx/grid/door_11_trapdoor.anm2" will be used. The specified anm2 file
   *                 must have animations called "Opened", "Closed", and "Open Animation".
   * @param spawnOpen Optional. Whether to spawn the trapdoor in an open state. By default, behavior
   *                  will be used that emulates a vanilla trapdoor.
   */
  @Exported
  public spawnCustomTrapdoor(
    gridIndexOrPosition: int | Vector,
    destinationName?: string,
    destinationStage?: LevelStage,
    destinationStageType?: StageType,
    anm2Path = "gfx/grid/door_11_trapdoor.anm2",
    spawnOpen?: boolean,
  ): GridEntity {
    if (
      destinationName !== undefined &&
      !this.destinationFuncMap.has(destinationName)
    ) {
      error(
        `Failed to spawn a custom trapdoor with a destination of "${destinationName}" since a destination with that name has not been registered with the "registerCustomTrapdoorDestination" function. (If you are trying to go to a custom stage, the custom stage library should automatically do this for you when your mod first boots.)`,
      );
    }

    if (destinationStage === undefined) {
      destinationStage = this.stageHistory.getNextStageWithHistory();
    }

    if (destinationStageType === undefined) {
      destinationStageType = this.stageHistory.getNextStageTypeWithHistory();
    }

    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();
    const gridIndex = isVector(gridIndexOrPosition)
      ? room.GetGridIndex(gridIndexOrPosition)
      : gridIndexOrPosition;

    const gridEntity = this.customGridEntities.spawnCustomGridEntity(
      GridEntityTypeCustom.TRAPDOOR_CUSTOM,
      gridIndexOrPosition,
      GridCollisionClass.NONE,
      anm2Path,
      TrapdoorAnimation.OPENED,
    );

    const firstSpawn = isAfterRoomFrame(0);
    const open =
      spawnOpen ?? this.shouldTrapdoorSpawnOpen(gridEntity, firstSpawn);

    const roomTrapdoorMap = v.level.trapdoors.getAndSetDefault(roomListIndex);
    const customTrapdoorDescription: CustomTrapdoorDescription = {
      destinationName,
      destinationStage,
      destinationStageType,
      open,
      firstSpawn,
    };
    roomTrapdoorMap.set(gridIndex, customTrapdoorDescription);

    const sprite = gridEntity.GetSprite();
    const animation = open
      ? TrapdoorAnimation.OPENED
      : TrapdoorAnimation.CLOSED;
    sprite.Play(animation, true);

    return gridEntity;
  }
}

function anyPlayerPlayingExtraAnimation() {
  const players = getAllPlayers();
  return players.some((player) => !player.IsExtraAnimationFinished());
}

function shouldBeClosedFromStartingInRoomWithEnemies(
  firstSpawn: boolean,
  roomClear: boolean,
) {
  return firstSpawn && !roomClear;
}

function openCustomTrapdoor(
  gridEntity: GridEntity,
  trapdoorDescription: CustomTrapdoorDescription,
) {
  trapdoorDescription.open = true;

  const sprite = gridEntity.GetSprite();
  sprite.Play(TrapdoorAnimation.OPEN_ANIMATION, true);
}

function canPlayerInteractWithTrapdoor(player: EntityPlayer) {
  // Players cannot interact with stage travel entities when items are queued or while playing
  // certain animations.
  const sprite = player.GetSprite();
  const animation = sprite.GetAnimation();
  return (
    !player.IsHoldingItem() &&
    !ANIMATIONS_THAT_PREVENT_STAGE_TRAVEL.has(animation)
  );
}

function setPlayerAttributes(trapdoorPlayer: EntityPlayer, position: Vector) {
  // Snap the player to the exact position of the trapdoor so that they cleanly jump down the hole.
  trapdoorPlayer.Position = position;

  for (const player of getAllPlayers()) {
    // Disable the controls to prevent the player from moving, shooting, and so on. (We also disable
    // the inputs in the `INPUT_ACTION` callback, but that does not prevent mouse inputs.)
    player.ControlsEnabled = false;

    // Freeze all players.
    player.Velocity = VectorZero;

    // We don't want enemy attacks to move the players.
    player.EntityCollisionClass = EntityCollisionClass.NONE;
    player.GridCollisionClass = EntityGridCollisionClass.NONE;

    player.StopExtraAnimation();
  }
}

function dropTaintedForgotten(player: EntityPlayer) {
  if (isCharacter(player, PlayerType.FORGOTTEN_B)) {
    const taintedSoul = player.GetOtherTwin();
    if (taintedSoul !== undefined) {
      taintedSoul.ThrowHeldEntity(VectorZero);
    }
  }
}

/** The default `destinationFunc` for a custom trapdoor. */
function goToVanillaStage(
  _destinationName: string | undefined,
  destinationStage: LevelStage,
  destinationStageType: StageType,
) {
  setStage(destinationStage, destinationStageType);
}

----
classes\features\other\DebugDisplay.ts
import { Exported } from "../../../decorators";
import { printEnabled } from "../../../functions/console";
import type { ModUpgradedInterface } from "../../../interfaces/private/ModUpgradedInterface";
import { Feature } from "../../private/Feature";
import { DebugDisplayBomb } from "./debugDisplay/DebugDisplayBomb";
import { DebugDisplayDoor } from "./debugDisplay/DebugDisplayDoor";
import { DebugDisplayEffect } from "./debugDisplay/DebugDisplayEffect";
import { DebugDisplayFamiliar } from "./debugDisplay/DebugDisplayFamiliar";
import { DebugDisplayKnife } from "./debugDisplay/DebugDisplayKnife";
import { DebugDisplayLaser } from "./debugDisplay/DebugDisplayLaser";
import { DebugDisplayNPC } from "./debugDisplay/DebugDisplayNPC";
import { DebugDisplayPickup } from "./debugDisplay/DebugDisplayPickup";
import { DebugDisplayPit } from "./debugDisplay/DebugDisplayPit";
import { DebugDisplayPlayer } from "./debugDisplay/DebugDisplayPlayer";
import { DebugDisplayPoop } from "./debugDisplay/DebugDisplayPoop";
import { DebugDisplayPressurePlate } from "./debugDisplay/DebugDisplayPressurePlate";
import { DebugDisplayProjectile } from "./debugDisplay/DebugDisplayProjectile";
import { DebugDisplayRock } from "./debugDisplay/DebugDisplayRock";
import { DebugDisplaySlot } from "./debugDisplay/DebugDisplaySlot";
import { DebugDisplaySpikes } from "./debugDisplay/DebugDisplaySpikes";
import { DebugDisplayTear } from "./debugDisplay/DebugDisplayTear";
import { DebugDisplayTNT } from "./debugDisplay/DebugDisplayTNT";

export class DebugDisplay extends Feature {
  private readonly mod: ModUpgradedInterface;

  private readonly player = new DebugDisplayPlayer(); // 1
  private readonly tear = new DebugDisplayTear(); // 2
  private readonly familiar = new DebugDisplayFamiliar(); // 3
  private readonly bomb = new DebugDisplayBomb(); // 4
  private readonly pickup = new DebugDisplayPickup(); // 5
  private readonly slot = new DebugDisplaySlot(); // 6
  private readonly laser = new DebugDisplayLaser(); // 7
  private readonly knife = new DebugDisplayKnife(); // 8
  private readonly projectile = new DebugDisplayProjectile(); // 9
  private readonly effect = new DebugDisplayEffect(); // 1000
  private readonly npc = new DebugDisplayNPC();

  private readonly rock = new DebugDisplayRock(); // 2, 3, 4, 5, 6, 22, 24, 25, 26, 27
  private readonly pit = new DebugDisplayPit(); // 7
  private readonly spikes = new DebugDisplaySpikes(); // 8, 9
  private readonly tnt = new DebugDisplayTNT(); // 12
  private readonly poop = new DebugDisplayPoop(); // 14
  private readonly door = new DebugDisplayDoor(); // 16
  private readonly pressurePlate = new DebugDisplayPressurePlate(); // 20

  /** @internal */
  constructor(mod: ModUpgradedInterface) {
    super();

    this.mod = mod;
  }

  // -------------
  // Set Functions
  // -------------

  /**
   * If the "togglePlayerDisplay" function is called, text will be drawn on the screen next to each
   * player. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * For example, this would draw the number of the player's collectibles next to their head:
   *
   * ```ts
   * setPlayerDisplay((player) => {
   *   return `collectible count: ${player.GetCollectibleCount()}`;
   * });
   * ```
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setPlayerDisplay(
    textCallback: (player: EntityPlayer) => string,
  ): void {
    this.player.textCallback = textCallback;
  }

  /**
   * If the "toggleTearDisplay" function is called, text will be drawn on the screen next to each
   * tear. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setTearDisplay(textCallback: (tear: EntityTear) => string): void {
    this.tear.textCallback = textCallback;
  }

  /**
   * If the "toggleFamiliarDisplay" function is called, text will be drawn on the screen next to
   * each familiar. Use this function to specify a callback function that returns the string that
   * should be drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setFamiliarDisplay(
    textCallback: (familiar: EntityFamiliar) => string,
  ): void {
    this.familiar.textCallback = textCallback;
  }

  /**
   * If the "toggleBombDisplay" function is called, text will be drawn on the screen next to each
   * bomb. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setBombDisplay(textCallback: (bomb: EntityBomb) => string): void {
    this.bomb.textCallback = textCallback;
  }

  /**
   * If the "togglePickupDisplay" function is called, text will be drawn on the screen next to each
   * pickup. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setPickupDisplay(
    textCallback: (pickup: EntityPickup) => string,
  ): void {
    this.pickup.textCallback = textCallback;
  }

  /**
   * If the "toggleSlotDisplay" function is called, text will be drawn on the screen next to each
   * slot. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setSlotDisplay(textCallback: (slot: Entity) => string): void {
    this.slot.textCallback = textCallback;
  }

  /**
   * If the "toggleLaserDisplay" function is called, text will be drawn on the screen next to each
   * laser. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setLaserDisplay(textCallback: (laser: EntityLaser) => string): void {
    this.laser.textCallback = textCallback;
  }

  /**
   * If the "toggleKnifeDisplay" function is called, text will be drawn on the screen next to each
   * knife. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setKnifeDisplay(textCallback: (knife: EntityKnife) => string): void {
    this.knife.textCallback = textCallback;
  }

  /**
   * If the "toggleProjectileDisplay" function is called, text will be drawn on the screen next to
   * each projectile. Use this function to specify a callback function that returns the string that
   * should be drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setProjectileDisplay(
    textCallback: (projectile: EntityProjectile) => string,
  ): void {
    this.projectile.textCallback = textCallback;
  }

  /**
   * If the "extra console commands" feature is specified, the "effectDisplay" console command will
   * draw text on the screen next to each effect. Use this function to specify a callback function
   * that returns the string that should be drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setEffectDisplay(
    textCallback: (effect: EntityEffect) => string,
  ): void {
    this.effect.textCallback = textCallback;
  }

  /**
   * If the "toggleNPCDisplay" function is called, text will be drawn on the screen next to each
   * NPC. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setNPCDisplay(textCallback: (npc: EntityNPC) => string): void {
    this.npc.textCallback = textCallback;
  }

  /**
   * If the "toggleRockDisplay" function is called, text will be drawn on the screen next to each
   * rock. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setRockDisplay(textCallback: (rock: GridEntityRock) => string): void {
    this.rock.textCallback = textCallback;
  }

  /**
   * If the "togglePitDisplay" function is called, text will be drawn on the screen next to each
   * pit. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setPitDisplay(textCallback: (pit: GridEntityPit) => string): void {
    this.pit.textCallback = textCallback;
  }

  /**
   * If the "toggleSpikesDisplay" function is called, text will be drawn on the screen next to each
   * spikes. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setSpikesDisplay(
    textCallback: (spikes: GridEntitySpikes) => string,
  ): void {
    this.spikes.textCallback = textCallback;
  }

  /**
   * If the "toggleTNTDisplay" function is called, text will be drawn on the screen next to each
   * TNT. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setTNTDisplay(textCallback: (tnt: GridEntityTNT) => string): void {
    this.tnt.textCallback = textCallback;
  }

  /**
   * If the "togglePoopDisplay" function is called, text will be drawn on the screen next to each
   * poop. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setPoopDisplay(textCallback: (poop: GridEntityPoop) => string): void {
    this.poop.textCallback = textCallback;
  }

  /**
   * If the "toggleDoorDisplay" function is called, text will be drawn on the screen next to each
   * door. Use this function to specify a callback function that returns the string that should be
   * drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setDoorDisplay(textCallback: (door: GridEntityDoor) => string): void {
    this.door.textCallback = textCallback;
  }

  /**
   * If the "togglePressurePlateDisplay" function is called, text will be drawn on the screen next
   * to each pressure plate. Use this function to specify a callback function that returns the
   * string that should be drawn.
   *
   * Once the function is set, the library will call it automatically on every frame. For this
   * reason, you typically only need to set the function once at the beginning of your mod.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @public
   */
  @Exported
  public setPressurePlateDisplay(
    textCallback: (pressurePlate: GridEntityPressurePlate) => string,
  ): void {
    this.pressurePlate.textCallback = textCallback;
  }

  // ----------------
  // Toggle Functions
  // ----------------

  private toggleFeature(
    feature: Feature,
    featureName: string,
    force: boolean | undefined,
  ) {
    let shouldInit = !feature.initialized;
    if (force !== undefined) {
      shouldInit = force;
    }

    if (shouldInit) {
      this.mod.initFeature(feature);
    } else {
      this.mod.uninitFeature(feature);
    }

    printEnabled(feature.initialized, `${featureName} display`);
  }

  /**
   * Toggles the debug display for players, which will draw text on the screen next to each player.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public togglePlayerDisplay(force?: boolean): void {
    this.toggleFeature(this.player, "player", force);
  }

  /**
   * Toggles the debug display for tears, which will draw text on the screen next to each tear.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`. *
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleTearDisplay(force?: boolean): void {
    this.toggleFeature(this.tear, "tear", force);
  }

  /**
   * Toggles the debug display for familiars, which will draw text on the screen next to each
   * familiar.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleFamiliarDisplay(force?: boolean): void {
    this.toggleFeature(this.familiar, "familiar", force);
  }

  /**
   * Toggles the debug display for bombs, which will draw text on the screen next to each bomb.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleBombDisplay(force?: boolean): void {
    this.toggleFeature(this.bomb, "bomb", force);
  }

  /**
   * Toggles the debug display for pickups, which will draw text on the screen next to each pickup.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public togglePickupDisplay(force?: boolean): void {
    this.toggleFeature(this.pickup, "pickup", force);
  }

  /**
   * Toggles the debug display for slots, which will draw text on the screen next to each slot.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleSlotDisplay(force?: boolean): void {
    this.toggleFeature(this.slot, "slot", force);
  }

  /**
   * Toggles the debug display for lasers, which will draw text on the screen next to each laser.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleLaserDisplay(force?: boolean): void {
    this.toggleFeature(this.laser, "laser", force);
  }

  /**
   * Toggles the debug display for knives, which will draw text on the screen next to each knife.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleKnifeDisplay(force?: boolean): void {
    this.toggleFeature(this.knife, "knife", force);
  }

  /**
   * Toggles the debug display for projectiles, which will draw text on the screen next to each
   * projectile.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleProjectileDisplay(force?: boolean): void {
    this.toggleFeature(this.projectile, "projectile", force);
  }

  /**
   * Toggles the debug display for effects, which will draw text on the screen next to each effect.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleEffectDisplay(force?: boolean): void {
    this.toggleFeature(this.effect, "effect", force);
  }

  /**
   * Toggles the debug display for NPCs, which will draw text on the screen next to each NPC.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleNPCDisplay(force?: boolean): void {
    this.toggleFeature(this.npc, "NPC", force);
  }

  /**
   * Toggles the debug display for rocks, which will draw text on the screen next to each rock.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleRockDisplay(force?: boolean): void {
    this.toggleFeature(this.rock, "rock", force);
  }

  /**
   * Toggles the debug display for pits, which will draw text on the screen next to each pit.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public togglePitDisplay(force?: boolean): void {
    this.toggleFeature(this.pit, "pit", force);
  }

  /**
   * Toggles the debug display for spikes, which will draw text on the screen next to each spike.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleSpikesDisplay(force?: boolean): void {
    this.toggleFeature(this.spikes, "spikes", force);
  }

  /**
   * Toggles the debug display for TNT, which will draw text on the screen next to each TNT.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleTNTDisplay(force?: boolean): void {
    this.toggleFeature(this.tnt, "tnt", force);
  }

  /**
   * Toggles the debug display for poops, which will draw text on the screen next to each poop.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public togglePoopDisplay(force?: boolean): void {
    this.toggleFeature(this.poop, "poop", force);
  }

  /**
   * Toggles the debug display for doors, which will draw text on the screen next to each door.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public toggleDoorDisplay(force?: boolean): void {
    this.toggleFeature(this.door, "door", force);
  }

  /**
   * Toggles the debug display for pressure plates, which will draw text on the screen next to each
   * pressure plate.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEBUG_DISPLAY`.
   *
   * @param force Optional. A boolean that represents the value to force the display to. For
   *              example, you can specify true to always make the display turn on, regardless of
   *              whether it is already on.
   * @public
   */
  @Exported
  public togglePressurePlateDisplay(force?: boolean): void {
    this.toggleFeature(this.pressurePlate, "pressure plate", force);
  }
}

----
classes\features\other\DeployJSONRoom.ts
import type { GridEntityXMLType } from "isaac-typescript-definitions";
import {
  EntityCollisionClass,
  EntityGridCollisionClass,
  EntityType,
  GridEntityType,
  PickupVariant,
  PitfallVariant,
  RoomType,
} from "isaac-typescript-definitions";
import { GRID_ENTITY_XML_TYPE_VALUES } from "../../../cachedEnumValues";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { emptyRoom } from "../../../functions/emptyRoom";
import {
  getEntityIDFromConstituents,
  spawnWithSeed,
} from "../../../functions/entities";
import {
  convertXMLGridEntityType,
  getGridEntities,
  spawnGridEntityWithVariant,
} from "../../../functions/gridEntities";
import { getRandomJSONEntity } from "../../../functions/jsonRoom";
import { log } from "../../../functions/log";
import { isRNG, newRNG } from "../../../functions/rng";
import { gridCoordinatesToWorldPosition } from "../../../functions/roomGrid";
import { setRoomCleared, setRoomUncleared } from "../../../functions/rooms";
import { spawnCollectible } from "../../../functions/spawnCollectible";
import { asCollectibleType, parseIntSafe } from "../../../functions/types";
import { assertDefined } from "../../../functions/utils";
import type { JSONRoom } from "../../../interfaces/JSONRoomsFile";
import { ReadonlySet } from "../../../types/ReadonlySet";
import { Feature } from "../../private/Feature";
import type { PreventGridEntityRespawn } from "./PreventGridEntityRespawn";

const GRID_ENTITY_XML_TYPE_SET = new ReadonlySet<GridEntityXMLType>(
  GRID_ENTITY_XML_TYPE_VALUES,
);

export class DeployJSONRoom extends Feature {
  private readonly preventGridEntityRespawn: PreventGridEntityRespawn;

  /** @internal */
  constructor(preventGridEntityRespawn: PreventGridEntityRespawn) {
    super();

    this.featuresUsed = [ISCFeature.PREVENT_GRID_ENTITY_RESPAWN];

    this.preventGridEntityRespawn = preventGridEntityRespawn;
  }

  private spawnAllEntities(
    jsonRoom: Readonly<JSONRoom>,
    rng: RNG,
    verbose = false,
  ) {
    let shouldUnclearRoom = false;

    for (const jsonSpawn of jsonRoom.spawn) {
      const xString = jsonSpawn.$.x;
      const x = parseIntSafe(xString);
      assertDefined(
        x,
        `Failed to convert the following x coordinate to an integer (for a spawn): ${xString}`,
      );

      const yString = jsonSpawn.$.y;
      const y = parseIntSafe(yString);
      assertDefined(
        y,
        `Failed to convert the following y coordinate to an integer (for a spawn): ${yString}`,
      );

      const jsonEntity = getRandomJSONEntity(jsonSpawn.entity, rng);

      const entityTypeString = jsonEntity.$.type;
      const entityTypeNumber = parseIntSafe(entityTypeString);
      assertDefined(
        entityTypeNumber,
        `Failed to convert the entity type to an integer: ${entityTypeString}`,
      );

      const variantString = jsonEntity.$.variant;
      const variant = parseIntSafe(variantString);
      assertDefined(
        variant,
        `Failed to convert the entity variant to an integer: ${variant}`,
      );

      const subTypeString = jsonEntity.$.subtype;
      const subType = parseIntSafe(subTypeString);
      assertDefined(
        subType,
        `Failed to convert the entity sub-type to an integer: ${subType}`,
      );

      const isGridEntity = GRID_ENTITY_XML_TYPE_SET.has(
        entityTypeNumber as GridEntityXMLType,
      );
      if (isGridEntity) {
        const gridEntityXMLType = entityTypeNumber as GridEntityXMLType;
        if (verbose) {
          log(
            `Spawning grid entity ${gridEntityXMLType}.${variant} at: (${x}, ${y})`,
          );
        }
        spawnGridEntityForJSONRoom(gridEntityXMLType, variant, x, y);
      } else {
        const entityType = entityTypeNumber as EntityType;
        if (verbose) {
          const entityID = getEntityIDFromConstituents(
            entityType,
            variant,
            subType,
          );
          log(`Spawning normal entity ${entityID} at: (${x}, ${y})`);
        }
        const entity = this.spawnNormalEntityForJSONRoom(
          entityType,
          variant,
          subType,
          x,
          y,
          rng,
        );
        const npc = entity.ToNPC();
        if (npc !== undefined && npc.CanShutDoors) {
          shouldUnclearRoom = true;
        }
      }
    }

    // After emptying the room, we manually cleared the room. However, if the room layout contains
    // an battle NPC, then we need to reset the clear state and close the doors again.
    if (shouldUnclearRoom) {
      if (verbose) {
        log(
          "Setting the room to be uncleared since there were one or more battle NPCs spawned.",
        );
      }
      setRoomUncleared();
    } else if (verbose) {
      log("Leaving the room cleared since there were no battle NPCs spawned.");
    }
  }

  private spawnNormalEntityForJSONRoom(
    entityType: EntityType,
    variant: int,
    subType: int,
    x: int,
    y: int,
    rng: RNG,
  ) {
    const room = game.GetRoom();
    const roomType = room.GetType();
    const position = gridCoordinatesToWorldPosition(x, y);
    const seed = rng.Next();

    let entity: Entity;
    if (
      entityType === EntityType.PICKUP &&
      variant === PickupVariant.COLLECTIBLE
    ) {
      const collectibleType = asCollectibleType(subType);
      const options = roomType === RoomType.ANGEL;
      entity = spawnCollectible(collectibleType, position, seed, options);
    } else {
      entity = spawnWithSeed(entityType, variant, subType, position, seed);
    }

    // For some reason, Pitfalls do not spawn with the correct collision classes.
    if (
      entityType === EntityType.PITFALL &&
      variant === PitfallVariant.PITFALL
    ) {
      entity.EntityCollisionClass = EntityCollisionClass.ENEMIES;
      entity.GridCollisionClass = EntityGridCollisionClass.WALLS;
    }

    return entity;
  }

  /**
   * Helper function to deconstruct a vanilla room and set up a custom room in its place.
   * Specifically, this will clear the current room of all entities and grid entities, and then
   * spawn all of the entries and grid entities in the provided JSON room. For this reason, you must
   * be in the actual room in order to use this function.
   *
   * A JSON room is simply an XML file converted to JSON. You can create JSON rooms by using the
   * Basement Renovator room editor to create an XML file, and then convert it to JSON using the
   * `convert-xml-to-json` tool (e.g. `npx convert-xml-to-json my-rooms.xml`).
   *
   * This function is meant to be used in the `POST_NEW_ROOM` callback.
   *
   * For example:
   *
   * ```ts
   *
   * import customRooms from "./customRooms.json";
   *
   * export function postNewRoom(): void {
   *   const firstJSONRoom = customRooms.rooms.room[0];
   *   deployJSONRoom(firstJSONRoom);
   * }
   * ```
   *
   * If you want to deploy an unseeded room, you must explicitly pass `undefined` to the `seedOrRNG`
   * parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DEPLOY_JSON_ROOM`.
   *
   * @param jsonRoom The JSON room to deploy.
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param verbose Optional. If specified, will write entries to the "log.txt" file that describe
   *                what the function is doing. Default is false.
   * @public
   */
  @Exported
  public deployJSONRoom(
    jsonRoom: Readonly<JSONRoom>,
    seedOrRNG: Seed | RNG | undefined,
    verbose = false,
  ): void {
    const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

    if (verbose) {
      log("Starting to empty the room of entities and grid entities.");
    }
    emptyRoom();
    if (verbose) {
      log("Finished emptying the room of entities and grid entities.");
    }

    setRoomCleared();

    if (verbose) {
      log("Starting to spawn all of the new entities and grid entities.");
    }
    this.spawnAllEntities(jsonRoom, rng, verbose);
    if (verbose) {
      log("Finished spawning all of the new entities and grid entities.");
    }

    fixPitGraphics();
    this.preventGridEntityRespawn.preventGridEntityRespawn();
  }
}

function spawnGridEntityForJSONRoom(
  gridEntityXMLType: GridEntityXMLType,
  gridEntityXMLVariant: int,
  x: int,
  y: int,
) {
  const room = game.GetRoom();

  const gridEntityTuple = convertXMLGridEntityType(
    gridEntityXMLType,
    gridEntityXMLVariant,
  );
  if (gridEntityTuple === undefined) {
    return undefined;
  }
  const [gridEntityType, variant] = gridEntityTuple;
  const position = gridCoordinatesToWorldPosition(x, y);
  const gridIndex = room.GetGridIndex(position);

  const gridEntity = spawnGridEntityWithVariant(
    gridEntityType,
    variant,
    gridIndex,
  );
  if (gridEntity === undefined) {
    return gridEntity;
  }

  // Prevent poops from playing an appear animation, since that is not supposed to normally happen
  // when entering a new room.
  if (gridEntityType === GridEntityType.POOP) {
    const sprite = gridEntity.GetSprite();
    sprite.Play("State1", true);
    sprite.SetLastFrame();
  }

  return gridEntity;
}

/**
 * By default, when spawning multiple pits next to each other, the graphics will not "meld"
 * together. Thus, now that all of the entities in the room are spawned, we must iterate over the
 * pits in the room and manually fix their sprites, if necessary.
 */
function fixPitGraphics() {
  const room = game.GetRoom();
  const gridWidth = room.GetGridWidth();
  const pitMap = getPitMap();

  for (const [gridIndex, gridEntity] of pitMap) {
    const gridIndexLeft = gridIndex - 1;
    const L = pitMap.has(gridIndexLeft);
    const gridIndexRight = gridIndex + 1;
    const R = pitMap.has(gridIndexRight);
    const gridIndexUp = gridIndex - gridWidth;
    const U = pitMap.has(gridIndexUp);
    const gridIndexDown = gridIndex + gridWidth;
    const D = pitMap.has(gridIndexDown);
    const gridIndexUpLeft = gridIndex - gridWidth - 1;
    const UL = pitMap.has(gridIndexUpLeft);
    const gridIndexUpRight = gridIndex - gridWidth + 1;
    const UR = pitMap.has(gridIndexUpRight);
    const gridIndexDownLeft = gridIndex + gridWidth - 1;
    const DL = pitMap.has(gridIndexDownLeft);
    const gridIndexDownRight = gridIndex + gridWidth + 1;
    const DR = pitMap.has(gridIndexDownRight);

    const pitFrame = getPitFrame(L, R, U, D, UL, UR, DL, DR);
    const sprite = gridEntity.GetSprite();
    sprite.SetFrame(pitFrame);
  }
}

function getPitMap(): ReadonlyMap<int, GridEntity> {
  const pitMap = new Map<int, GridEntity>();
  for (const gridEntity of getGridEntities(GridEntityType.PIT)) {
    const gridIndex = gridEntity.GetGridIndex();
    pitMap.set(gridIndex, gridEntity);
  }

  return pitMap;
}

/** The logic in this function is copied from Basement Renovator. */
function getPitFrame(
  L: boolean,
  R: boolean,
  U: boolean,
  D: boolean,
  UL: boolean,
  UR: boolean,
  DL: boolean,
  DR: boolean,
) {
  let F = 0;

  // First, check for bitwise frames. (It works for all combinations of just left/up/right/down.)
  if (L) {
    F |= 1;
  }
  if (U) {
    F |= 2;
  }
  if (R) {
    F |= 4;
  }
  if (D) {
    F |= 8;
  }

  // Then, check for other combinations.
  if (U && L && !UL && !R && !D) {
    F = 17;
  }
  if (U && R && !UR && !L && !D) {
    F = 18;
  }
  if (L && D && !DL && !U && !R) {
    F = 19;
  }
  if (R && D && !DR && !L && !U) {
    F = 20;
  }
  if (L && U && R && D && !UL) {
    F = 21;
  }
  if (L && U && R && D && !UR) {
    F = 22;
  }
  if (U && R && D && !L && !UR) {
    F = 25;
  }
  if (L && U && D && !R && !UL) {
    F = 26;
  }

  if (L && U && R && D && !DL && !DR) {
    F = 24;
  }
  if (L && U && R && D && !UR && !UL) {
    F = 23;
  }
  if (L && U && R && UL && !UR && !D) {
    F = 27;
  }
  if (L && U && R && UR && !UL && !D) {
    F = 28;
  }
  if (L && U && R && !D && !UR && !UL) {
    F = 29;
  }
  if (L && R && D && DL && !U && !DR) {
    F = 30;
  }
  if (L && R && D && DR && !U && !DL) {
    F = 31;
  }
  if (L && R && D && !U && !DL && !DR) {
    F = 32;
  }

  return F;
}

----
classes\features\other\DisableAllSound.ts
import { ModCallback } from "isaac-typescript-definitions";
import { musicManager } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { stopAllSoundEffects } from "../../../functions/sound";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    disableSoundSet: new Set<string>(),
  },
};

export class DisableAllSound extends Feature {
  /** @internal */
  public override v = v;

  private musicWasEnabled = false;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    if (v.run.disableSoundSet.size === 0) {
      return;
    }

    stopAllSoundEffects();
  };

  /**
   * Helper function to stop muting all sound effects and music.
   *
   * Use this function to set things back to normal after having used `disableAllSounds`.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_ALL_SOUND`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   */
  @Exported
  public enableAllSound(key: string): void {
    if (!v.run.disableSoundSet.has(key)) {
      return;
    }
    v.run.disableSoundSet.delete(key);

    if (v.run.disableSoundSet.size === 0 && this.musicWasEnabled) {
      musicManager.Enable();
    }

    // Stop all sound effects that were initialized prior to enabling sounds (in case there was a
    // sound played played previously on this render frame).
    stopAllSoundEffects();
  }

  /**
   * Helper function to disable all sound effects and music (by constantly musting them).
   *
   * Use the `enableAllSounds` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_ALL_SOUND`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   */
  @Exported
  public disableAllSound(key: string): void {
    if (v.run.disableSoundSet.size === 0) {
      this.musicWasEnabled = musicManager.IsEnabled();
    }

    v.run.disableSoundSet.add(key);

    // Stop all sound effects that were initialized prior to disabling sounds.
    stopAllSoundEffects();
  }
}

----
classes\features\other\DisableInputs.ts
import type { ButtonAction } from "isaac-typescript-definitions";
import { InputHook, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import {
  MOVEMENT_BUTTON_ACTIONS_SET,
  SHOOTING_BUTTON_ACTIONS_SET,
} from "../../../functions/input";
import { ReadonlySet } from "../../../types/ReadonlySet";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    /**
     * Glowing Hour Glass support is disabled by default since it can cause bugs with extra-gameplay
     * features. (For example, whether the player should be able to move is not something that
     * should be reset by the Glowing Hour Glass.)
     */
    __ignoreGlowingHourGlass: true,

    /** Indexed by the requesting feature key. */
    disableInputs: new Map<string, ReadonlySet<ButtonAction>>(),

    /** Indexed by the requesting feature key. */
    enableAllInputsWithBlacklistMap: new Map<
      string,
      ReadonlySet<ButtonAction>
    >(),

    /** Indexed by the requesting feature key. */
    disableAllInputsWithWhitelistMap: new Map<
      string,
      ReadonlySet<ButtonAction>
    >(),
  },
};

export class DisableInputs extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 13
      [
        ModCallback.INPUT_ACTION,
        this.isActionPressed,
        [InputHook.IS_ACTION_PRESSED], // 0
      ],

      // 13
      [
        ModCallback.INPUT_ACTION,
        this.isActionTriggered,
        [InputHook.IS_ACTION_TRIGGERED], // 1
      ],

      // 13
      [
        ModCallback.INPUT_ACTION,
        this.getActionValue,
        [InputHook.GET_ACTION_VALUE], // 2
      ],
    ];
  }

  // InputHook.IS_ACTION_PRESSED (0)
  private readonly isActionPressed = (
    _entity: Entity | undefined,
    _inputHook: InputHook,
    buttonAction: ButtonAction,
  ) => this.getReturnValue(buttonAction, true);

  // InputHook.IS_ACTION_TRIGGERED (1)
  private readonly isActionTriggered = (
    _entity: Entity | undefined,
    _inputHook: InputHook,
    buttonAction: ButtonAction,
  ) => this.getReturnValue(buttonAction, true);

  // InputHook.GET_ACTION_VALUE (2)
  private readonly getActionValue = (
    _entity: Entity | undefined,
    _inputHook: InputHook,
    buttonAction: ButtonAction,
  ) => this.getReturnValue(buttonAction, false);

  private getReturnValue(buttonAction: ButtonAction, booleanCallback: boolean) {
    const disableValue = booleanCallback ? false : 0;

    for (const blacklist of v.run.disableInputs.values()) {
      if (blacklist.has(buttonAction)) {
        return disableValue;
      }
    }

    for (const whitelist of v.run.disableAllInputsWithWhitelistMap.values()) {
      if (!whitelist.has(buttonAction)) {
        return disableValue;
      }
    }

    for (const blacklist of v.run.enableAllInputsWithBlacklistMap.values()) {
      if (blacklist.has(buttonAction)) {
        return disableValue;
      }
    }

    return undefined;
  }

  /**
   * Helper function to check if the `ISCFeature.DISABLE_INPUTS` feature is turned on in some
   * capacity.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @public
   */
  @Exported
  public areInputsEnabled(): boolean {
    return (
      v.run.disableInputs.size === 0 &&
      v.run.enableAllInputsWithBlacklistMap.size === 0 &&
      v.run.disableAllInputsWithWhitelistMap.size === 0
    );
  }

  /**
   * Helper function to enable all inputs. Use this function to set things back to normal after
   * having used one of the other helper functions to disable inputs.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @public
   */
  @Exported
  public enableAllInputs(key: string): void {
    v.run.disableAllInputsWithWhitelistMap.delete(key);
    v.run.enableAllInputsWithBlacklistMap.delete(key);
  }

  /**
   * Helper function to disable specific inputs, like opening the console.
   *
   * This function is variadic, meaning that you can specify as many inputs as you want to disable.
   * (To disable all inputs, see the `disableAllInputs` function.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @param buttonActions An array of the actions to action.
   * @public
   */
  @Exported
  public disableInputs(
    key: string,
    ...buttonActions: readonly ButtonAction[]
  ): void {
    const buttonActionsSet = new ReadonlySet(buttonActions);
    v.run.disableInputs.set(key, buttonActionsSet);
  }

  /**
   * Helper function to disable all inputs. This is useful because `EntityPlayer.ControlsEnabled`
   * can be changed by the game under certain conditions.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @public
   */
  @Exported
  public disableAllInputs(key: string): void {
    v.run.disableAllInputsWithWhitelistMap.set(key, new ReadonlySet());
    v.run.enableAllInputsWithBlacklistMap.delete(key);
  }

  /**
   * Helper function to enable all inputs besides the ones provided. This is useful because
   * `EntityPlayer.ControlsEnabled` can be changed by the game under certain conditions.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @param blacklist A set of ButtonActions to disallow.
   * @public
   */
  @Exported
  public enableAllInputsExceptFor(
    key: string,
    blacklist: ReadonlySet<ButtonAction>,
  ): void {
    v.run.disableAllInputsWithWhitelistMap.delete(key);
    v.run.enableAllInputsWithBlacklistMap.set(key, blacklist);
  }

  /**
   * Helper function to disable all inputs besides the ones provided. This is useful because
   * `EntityPlayer.ControlsEnabled` can be changed by the game under certain conditions.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @param whitelist A set of ButtonActions to allow.
   * @public
   */
  @Exported
  public disableAllInputsExceptFor(
    key: string,
    whitelist: ReadonlySet<ButtonAction>,
  ): void {
    v.run.disableAllInputsWithWhitelistMap.set(key, whitelist);
    v.run.enableAllInputsWithBlacklistMap.delete(key);
  }

  /**
   * Helper function to disable only the inputs used for moving the character (or moving the cursor
   * in the UI). This is useful because `EntityPlayer.ControlsEnabled` can be changed by the game
   * under certain conditions.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @public
   */
  @Exported
  public disableMovementInputs(key: string): void {
    this.enableAllInputsExceptFor(key, MOVEMENT_BUTTON_ACTIONS_SET);
  }

  /**
   * Helper function to disable only the inputs used for shooting tears. This is useful because
   * `EntityPlayer.ControlsEnabled` can be changed by the game under certain conditions.
   *
   * Use the `enableAllInputs` helper function to set things back to normal.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.DISABLE_INPUTS`.
   *
   * @param key The name of the mod feature that is requesting the enable/disable. For example, if
   *            this was part of the code for a custom enemy called "Super Gaper", then you could
   *            use a key of "SuperGaper". The name is necessary so that multiple mod features can
   *            work in tandem.
   * @public
   */
  @Exported
  public disableShootingInputs(key: string): void {
    this.enableAllInputsExceptFor(key, SHOOTING_BUTTON_ACTIONS_SET);
  }
}

----
classes\features\other\EdenStartingStatsHealth.ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import type { PlayerStat } from "../../../enums/PlayerStat";
import { isActiveCollectible } from "../../../functions/collectibles";
import {
  mapGetPlayer,
  mapHasPlayer,
  mapSetPlayer,
} from "../../../functions/playerDataStructures";
import { getPlayerHealth } from "../../../functions/playerHealth";
import { isEden } from "../../../functions/players";
import { getPlayerStats } from "../../../functions/stats";
import type { PlayerHealth } from "../../../interfaces/PlayerHealth";
import type { PlayerStats } from "../../../interfaces/PlayerStats";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    edenActiveCollectibles: new Map<PlayerIndex, CollectibleType>(),
    edenPassiveCollectibles: new Map<PlayerIndex, CollectibleType>(),
    edenPlayerStats: new Map<PlayerIndex, PlayerStats>(),
    edenPlayerHealth: new Map<PlayerIndex, PlayerHealth>(),
  },
};

export class EdenStartingStatsHealth extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 9
      [ModCallback.POST_PLAYER_INIT, this.postPlayerInit],
    ];

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED,
        this.postPlayerCollectibleAdded,
      ],
    ];
  }

  /**
   * We must use the `POST_PLAYER_INIT` callback since the two random collectibles have not been
   * granted yet.
   */
  private readonly postPlayerInit = (player: EntityPlayer) => {
    if (!isEden(player)) {
      return;
    }

    this.getEdenStats(player);
    this.getEdenHealth(player);
  };

  private getEdenStats(player: EntityPlayer): void {
    const existingStatMap = mapGetPlayer(v.run.edenPlayerStats, player);
    if (existingStatMap !== undefined) {
      return;
    }

    const playerStats = getPlayerStats(player);
    mapSetPlayer(v.run.edenPlayerStats, player, playerStats);
  }

  private getEdenHealth(player: EntityPlayer): void {
    const existingHealthMap = mapGetPlayer(v.run.edenPlayerHealth, player);
    if (existingHealthMap !== undefined) {
      return;
    }

    const playerHealth = getPlayerHealth(player);
    mapSetPlayer(v.run.edenPlayerHealth, player, playerHealth);
  }

  /**
   * We must use the `POST_PLAYER_COLLECTIBLE_ADDED` callback since the collectibles are not yet
   * granted in the `POST_PLAYER_INIT` callback.
   */
  private readonly postPlayerCollectibleAdded = (
    player: EntityPlayer,
    collectibleType: CollectibleType,
  ): void => {
    if (!isEden(player)) {
      return;
    }

    const map = isActiveCollectible(collectibleType)
      ? v.run.edenActiveCollectibles
      : v.run.edenPassiveCollectibles;

    if (!mapHasPlayer(map, player)) {
      mapSetPlayer(map, player, collectibleType);
    }
  };

  /**
   * Helper function to get the active collectible that Eden started with at the beginning of the
   * run.
   *
   * Returns undefined if passed a player that is not Eden or if the starting collectibles are not
   * yet added. (Eden's starting collectibles are added after the `POST_PLAYER_INIT` callback has
   * fired.)
   *
   * @public
   */
  @Exported
  public getEdenStartingActiveCollectible(
    player: EntityPlayer,
  ): CollectibleType | undefined {
    return mapGetPlayer(v.run.edenActiveCollectibles, player);
  }

  /**
   * Helper function to get an array containing the active collectible and the passive collectible
   * that Eden started with at the beginning of the run. The active collectible will be the first
   * element and the passive collectible will be the second element.
   *
   * Returns an empty array if passed a player that is not Eden or if the starting collectibles are
   * not yet added. (Eden's starting collectibles are added after the `POST_PLAYER_INIT` callback
   * has fired.)
   *
   * @public
   */
  @Exported
  public getEdenStartingCollectibles(player: EntityPlayer): CollectibleType[] {
    const collectibleTypes: CollectibleType[] = [];

    const activeCollectibleType = mapGetPlayer(
      v.run.edenActiveCollectibles,
      player,
    );

    if (activeCollectibleType !== undefined) {
      collectibleTypes.push(activeCollectibleType);
    }

    const passiveCollectibleType = mapGetPlayer(
      v.run.edenPassiveCollectibles,
      player,
    );

    if (passiveCollectibleType !== undefined) {
      collectibleTypes.push(passiveCollectibleType);
    }

    return collectibleTypes;
  }

  /**
   * Helper function to get the health that Eden started with at the beginning of the run before any
   * of the random collectibles were added.
   *
   * Returns undefined if passed a player that is not Eden.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.EDEN_STARTING_STATS`.
   *
   * @public
   */
  @Exported
  public getEdenStartingHealth(
    player: EntityPlayer,
  ): Readonly<PlayerHealth> | undefined {
    return mapGetPlayer(v.run.edenPlayerHealth, player);
  }

  /**
   * Helper function to get the passive collectible that Eden started with at the beginning of the
   * run.
   *
   * Returns undefined if passed a player that is not Eden or if the starting collectibles are not
   * yet added. (Eden's starting collectibles are added after the `POST_PLAYER_INIT` callback has
   * fired.)
   *
   * @public
   */
  @Exported
  public getEdenStartingPassiveCollectible(
    player: EntityPlayer,
  ): CollectibleType | undefined {
    return mapGetPlayer(v.run.edenPassiveCollectibles, player);
  }

  /**
   * Helper function to get the value of the randomized starting stat for Eden that was assigned at
   * the beginning of the run before any of the random collectibles were added.
   *
   * Returns undefined if passed a player that is not Eden.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.EDEN_STARTING_STATS`.
   *
   * @public
   */
  @Exported
  public getEdenStartingStat<T extends PlayerStat>(
    player: EntityPlayer,
    playerStat: T,
  ): PlayerStats[T] | undefined {
    const playerStats = mapGetPlayer(v.run.edenPlayerStats, player);
    if (playerStats === undefined) {
      return undefined;
    }

    return playerStats[playerStat];
  }

  /**
   * Helper function to get all of the stat values that Eden started with at the beginning of the
   * run before any of the random collectibles were added.
   *
   * Returns undefined if passed a player that is not Eden.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.EDEN_STARTING_STATS`.
   *
   * @public
   */
  @Exported
  public getEdenStartingStats(
    player: EntityPlayer,
  ): Readonly<PlayerStats> | undefined {
    return mapGetPlayer(v.run.edenPlayerStats, player);
  }
}

----
classes\features\other\ExtraConsoleCommands.ts
import type { DamageFlag } from "isaac-typescript-definitions";
import {
  CacheFlag,
  CollectibleType,
  LevelCurse,
  ModCallback,
  TearVariant,
} from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { isVanillaConsoleCommand } from "../../../functions/console";
import { addFlag, bitFlags } from "../../../functions/flag";
import { logError } from "../../../functions/log";
import { getMapPartialMatch } from "../../../functions/string";
import { assertDefined } from "../../../functions/utils";
import { Feature } from "../../private/Feature";
import * as commands from "./extraConsoleCommands/commands";
import { v } from "./extraConsoleCommands/v";

// eslint-disable-next-line @typescript-eslint/naming-convention
declare let __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE:
  | ExtraConsoleCommands
  | undefined;

/**
 * When you enable this feature, many custom commands will be added to the in-game console. See the
 * [dedicated command list](ExtraConsoleCommandsList) for more information about them.
 *
 * Note that in order to avoid conflicts, if two or more mods enable this feature, then the first
 * loaded one will control all of the command logic. When this occurs, a global variable of
 * `__ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE` will be created and will automatically be
 * used by the non-main instances. For this reason, if you use multiple mods with
 * `isaacscript-common` and a custom command from the standard library is not working properly, then
 * you might need to get another mod author to update their version of `isaacscript-common`.
 */
export class ExtraConsoleCommands extends Feature {
  /** @internal */
  public override v = v;

  private readonly isMainFeature: boolean;

  private readonly commandFunctionMap = new Map<
    string,
    (params: string) => void
  >();

  /** @internal */
  constructor() {
    super();

    // Only one instance of this feature can be instantiated across all mods.
    this.isMainFeature =
      __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE === undefined;
    if (!this.isMainFeature) {
      return;
    }

    // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
    __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE = this;

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],

      // 8
      [
        ModCallback.EVALUATE_CACHE,
        this.evaluateCacheDamage,
        [CacheFlag.DAMAGE], // 1 << 0
      ],

      // 8
      [
        ModCallback.EVALUATE_CACHE,
        this.evaluateCacheFireDelay,
        [CacheFlag.FIRE_DELAY], // 1 << 1
      ],

      // 8
      [
        ModCallback.EVALUATE_CACHE,
        this.evaluateCacheSpeed,
        [CacheFlag.SPEED], // 1 << 4
      ],

      // 8
      [
        ModCallback.EVALUATE_CACHE,
        this.evaluateCacheFlying,
        [CacheFlag.FLYING], // 1 << 7
      ],

      // 12
      [ModCallback.POST_CURSE_EVAL, this.postCurseEval],

      // 22
      [ModCallback.EXECUTE_CMD, this.executeCmd],

      // 61
      [ModCallback.POST_FIRE_TEAR, this.postFireTear],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER, this.entityTakeDmgPlayer],
    ];

    for (const [funcName, func] of Object.entries(commands)) {
      this.commandFunctionMap.set(funcName, func);
    }
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = () => {
    if (v.persistent.spamBloodRights) {
      const player = Isaac.GetPlayer();
      player.UseActiveItem(CollectibleType.BLOOD_RIGHTS);
    }
  };

  // ModCallback.EVALUATE_CACHE (8)
  // CacheFlag.DAMAGE (1 << 0)
  private readonly evaluateCacheDamage = (player: EntityPlayer) => {
    if (v.persistent.damage) {
      player.Damage = v.persistent.damageAmount;
    }
  };

  // ModCallback.EVALUATE_CACHE (8)
  // CacheFlag.FIRE_DELAY (1 << 1)
  private readonly evaluateCacheFireDelay = (player: EntityPlayer) => {
    if (v.persistent.tears) {
      player.FireDelay = v.persistent.tearsAmount;
    }
  };

  // ModCallback.EVALUATE_CACHE (8)
  // CacheFlag.SPEED (1 << 4)
  private readonly evaluateCacheSpeed = (player: EntityPlayer) => {
    if (v.persistent.speed) {
      player.MoveSpeed = v.persistent.speedAmount;
    }
  };

  // ModCallback.EVALUATE_CACHE (8)
  // CacheFlag.FLYING (1 << 7)
  private readonly evaluateCacheFlying = (player: EntityPlayer) => {
    if (v.persistent.flight) {
      player.CanFly = true;
    }
  };

  // ModCallback.POST_CURSE_EVAL (12)
  private readonly postCurseEval = (
    curses: BitFlags<LevelCurse>,
  ): BitFlags<LevelCurse> | LevelCurse | undefined => {
    if (v.persistent.disableCurses) {
      return bitFlags(LevelCurse.NONE);
    }

    let newCurses = curses;

    // 1
    if (v.persistent.darkness) {
      newCurses = addFlag(newCurses, LevelCurse.DARKNESS);
    }

    // 2
    if (v.persistent.labyrinth) {
      newCurses = addFlag(newCurses, LevelCurse.LABYRINTH);
    }

    // 3
    if (v.persistent.lost) {
      newCurses = addFlag(newCurses, LevelCurse.LOST);
    }

    // 4
    if (v.persistent.unknown) {
      newCurses = addFlag(newCurses, LevelCurse.UNKNOWN);
    }

    // 5
    if (v.persistent.cursed) {
      newCurses = addFlag(newCurses, LevelCurse.CURSED);
    }

    // 6
    if (v.persistent.maze) {
      newCurses = addFlag(newCurses, LevelCurse.MAZE);
    }

    // 7
    if (v.persistent.blind) {
      newCurses = addFlag(newCurses, LevelCurse.BLIND);
    }

    // 8
    if (v.persistent.giant) {
      newCurses = addFlag(newCurses, LevelCurse.GIANT);
    }

    return curses === newCurses ? undefined : newCurses;
  };

  // ModCallback.EXECUTE_CMD (22)
  private readonly executeCmd = (command: string, params: string) => {
    const resultTuple = getMapPartialMatch(command, this.commandFunctionMap);
    if (resultTuple === undefined) {
      // We opt to not print an error message because a non-IsaacScript mod may have configured a
      // custom console command.
      return;
    }

    const [commandName, commandFunction] = resultTuple;
    print(`Command: ${commandName}`);
    commandFunction(params);
  };

  // ModCallback.POST_FIRE_TEAR (61)
  private readonly postFireTear = (tear: EntityTear) => {
    if (v.persistent.chaosCardTears) {
      tear.ChangeVariant(TearVariant.CHAOS_CARD);
    }
  };

  // ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER
  private readonly entityTakeDmgPlayer = (
    _player: EntityPlayer,
    _damageAmount: float,
    _damageFlags: BitFlags<DamageFlag>,
    _damageSource: EntityRef,
    _damageCountdownFrames: int,
  ) => {
    if (v.persistent.spamBloodRights) {
      return false;
    }

    return undefined;
  };

  /**
   * Helper function to add a custom console command.
   *
   * The standard library comes with [many existing console commands](ExtraConsoleCommandsList) that
   * are useful for debugging, but you can also add your own commands that are useful for your
   * particular mod. It's easier to add commands to the existing command system than to add your own
   * logic manually to the `EXECUTE_CMD` callback.
   *
   * This function is intended to be called when your mod is first loading.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.EXTRA_CONSOLE_COMMANDS`.
   *
   * @public
   */
  @Exported
  public addConsoleCommand(
    commandName: string,
    commandFunction: (params: string) => void,
  ): void {
    if (!this.isMainFeature) {
      assertDefined(
        __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE,
        "Failed to find the non-main isaacscript-common extra console commands feature in the global variable.",
      );
      __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE.addConsoleCommand(
        commandName,
        commandFunction,
      );
      return;
    }

    if (isVanillaConsoleCommand(commandName)) {
      logError(
        `Failed to add a new console command of "${commandName}" because that name already belongs to a vanilla command. You must pick a non-colliding name.`,
      );
      return;
    }

    if (this.commandFunctionMap.has(commandName)) {
      logError(
        `Failed to add a new console command of "${commandName}" because there is already an existing custom command by that name. If you want to overwrite a command from the standard library, you can use the "removeExtraConsoleCommand" function.`,
      );
      return;
    }

    this.commandFunctionMap.set(commandName, commandFunction);
  }

  /**
   * Helper function to remove a custom console command.
   *
   * The standard library comes with [many existing console commands](ExtraConsoleCommandsList) that
   * are useful for debugging. If you want to disable one of them, use this function.
   *
   * This function is intended to be called when your mod is first loading.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.EXTRA_CONSOLE_COMMANDS`.
   *
   * @public
   */
  @Exported
  public removeConsoleCommand(commandName: string): void {
    if (!this.isMainFeature) {
      assertDefined(
        __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE,
        "Failed to find the non-main isaacscript-common extra console commands feature in the global variable.",
      );
      __ISAACSCRIPT_COMMON_EXTRA_CONSOLE_COMMANDS_FEATURE.removeConsoleCommand(
        commandName,
      );
      return;
    }

    if (!this.commandFunctionMap.has(commandName)) {
      error(
        `Failed to remove the console command of "${commandName}", since it does not already exist in the command map.`,
      );
    }

    this.commandFunctionMap.delete(commandName);
  }

  /**
   * Helper function to remove all custom console commands.
   *
   * The standard library comes with [many existing console commands](ExtraConsoleCommandsList) that
   * are useful for debugging. If you want to disable all of them after this feature has already
   * been initialized, use this function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.EXTRA_CONSOLE_COMMANDS`.
   *
   * @public
   */
  @Exported
  public removeAllConsoleCommands(): void {
    this.commandFunctionMap.clear();
  }
}

----
classes\features\other\FadeInRemover.ts
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { Feature } from "../../private/Feature";

const INSTANT_FADE_IN_SPEED = 1;

export class FadeInRemover extends Feature {
  private enabled = false;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED,
        this.postGameStartedReordered,
        [undefined],
      ],
    ];
  }

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED
  private readonly postGameStartedReordered = () => {
    if (this.enabled) {
      game.Fadein(INSTANT_FADE_IN_SPEED);
    }
  };

  /**
   * Removes the fade-in that occurs at the beginning of a run. If this behavior is desired, call
   * this function once at the beginning of your mod.
   *
   * This is useful for debugging, when you are resetting the game often.
   *
   * You can restore the vanilla behavior with the `restoreFadeIn` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FADE_IN_REMOVER`.
   *
   * @public
   */
  @Exported
  public removeFadeIn(): void {
    this.enabled = true;
  }

  /**
   * Disables the fade-in remover. Only useful if you have previously called the `removeFadeIn`
   * function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FADE_IN_REMOVER`.
   *
   * @public
   */
  @Exported
  public restoreFadeIn(): void {
    this.enabled = false;
  }
}

----
classes\features\other\FastReset.ts
import { ButtonAction, ModCallback } from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import {
  isActionTriggeredOnAnyInput,
  isModifierKeyPressed,
} from "../../../functions/input";
import { restart } from "../../../functions/run";
import { Feature } from "../../private/Feature";

/** A global variable set by custom consoles. */
declare let AwaitingTextInput: boolean;

export class FastReset extends Feature {
  private enabled = false;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];
  }

  // ModCallback.POST_RENDER (2)
  private readonly postRender = () => {
    if (!this.enabled) {
      return;
    }

    checkResetInput();
  };

  /**
   * Enables the fast-reset feature, which allows you to restart the game instantaneously. If this
   * behavior is desired, call this function once at the beginning of your mod.
   *
   * This is useful for debugging, when you are resetting the game often.
   *
   * You can disable the fast-reset feature with the `disableFastReset` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FAST_RESET`.
   *
   * @public
   */
  @Exported
  public enableFastReset(): void {
    this.enabled = true;
  }

  /**
   * Disables the fast-reset feature. Only useful if you have previously called the
   * `enableFastReset` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FAST_RESET`.
   *
   * @public
   */
  @Exported
  public disableFastReset(): void {
    this.enabled = false;
  }
}

/** Check for fast-reset inputs. */
function checkResetInput() {
  const isPaused = game.IsPaused();

  // Disable the fast-reset feature if the console is open. (This will also disable the feature when
  // the game is paused, but that's okay as well.)
  if (isPaused) {
    return;
  }

  // Disable the fast-reset feature if any custom consoles are open.
  if (AwaitingTextInput) {
    return;
  }

  // Don't fast-reset if any modifiers are pressed.
  if (isModifierKeyPressed()) {
    return;
  }

  // Check to see if the player has pressed the restart input. (We check all inputs instead of
  // `player.ControllerIndex` because a controller player might be using the keyboard to reset.)
  if (isActionTriggeredOnAnyInput(ButtonAction.RESTART)) {
    restart();
  }
}

----
classes\features\other\FlyingDetection.ts
import { NullItemID } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { Feature } from "../../private/Feature";
import type { ModdedElementSets } from "./ModdedElementSets";

const FLYING_NULL_ITEMS = [
  NullItemID.REVERSE_SUN, // 66
  NullItemID.SPIRIT_SHACKLES_SOUL, // 10
  NullItemID.LOST_CURSE, // 112
] as const;

export class FlyingDetection extends Feature {
  private readonly moddedElementSets: ModdedElementSets;

  /** @internal */
  constructor(moddedElementSets: ModdedElementSets) {
    super();

    this.featuresUsed = [ISCFeature.MODDED_ELEMENT_SETS];

    this.moddedElementSets = moddedElementSets;
  }

  /**
   * Helper function to see if the player currently has flying from a temporary effect such as
   * Hanged Man, Bat Wing, and so on.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FLYING_DETECTION`.
   *
   * @public
   */
  @Exported
  public hasFlyingTemporaryEffect(player: EntityPlayer): boolean {
    const effects = player.GetEffects();

    // - We specify true to the `getFlyingCollectibles` function since conditional flying
    //   collectibles will only grant a temporary effect if their condition is activated.
    // - The Hanged Man card gives a Transcendence temporary effect.
    // - Pinking Shears gives a Transcendence temporary effect.
    const flyingCollectibles =
      this.moddedElementSets.getFlyingCollectibleTypes(true);
    for (const collectibleType of flyingCollectibles) {
      if (effects.HasCollectibleEffect(collectibleType)) {
        return true;
      }
    }

    const flyingTrinkets = this.moddedElementSets.getFlyingTrinketTypes();
    for (const trinketType of flyingTrinkets) {
      if (effects.HasTrinketEffect(trinketType)) {
        return true;
      }
    }

    for (const nullItemID of FLYING_NULL_ITEMS) {
      if (effects.HasNullEffect(nullItemID)) {
        return true;
      }
    }

    return false;
  }
}

----
classes\features\other\ForgottenSwitch.ts
import { ButtonAction } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { Feature } from "../../private/Feature";
import type { PressInput } from "./PressInput";

export class ForgottenSwitch extends Feature {
  /** @internal */
  public override v = {
    run: {
      shouldSwitch: false,
    },
  };

  private readonly pressInput: PressInput;

  /** @internal */
  constructor(pressInput: PressInput) {
    super();

    this.featuresUsed = [ISCFeature.PRESS_INPUT];

    this.pressInput = pressInput;
  }

  /**
   * When used on The Forgotten, switches to The Soul. When used on The Soul, switches to The
   * Forgotten. This takes 1 game frame to take effect.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.FORGOTTEN_SWITCH`.
   *
   * @public
   */
  @Exported
  public forgottenSwitch(player: EntityPlayer): void {
    this.pressInput.pressInput(player, ButtonAction.DROP);
  }
}

----
classes\features\other\ItemPoolDetection.ts
import type { ItemPoolType } from "isaac-typescript-definitions";
import {
  CollectibleType,
  ItemConfigTag,
  PlayerType,
  TrinketType,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { collectibleHasTag } from "../../../functions/collectibleTag";
import { anyPlayerHasCollectible } from "../../../functions/playerCollectibles";
import {
  mapGetPlayer,
  mapSetPlayer,
} from "../../../functions/playerDataStructures";
import { getAllPlayers } from "../../../functions/playerIndex";
import { getPlayersOfType } from "../../../functions/players";
import { repeat } from "../../../functions/utils";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { Feature } from "../../private/Feature";
import type { ModdedElementSets } from "./ModdedElementSets";

const COLLECTIBLE_TYPE_THAT_IS_NOT_IN_ANY_POOLS = CollectibleType.KEY_PIECE_1;

const COLLECTIBLES_THAT_AFFECT_ITEM_POOLS = [
  CollectibleType.CHAOS, // 402
  CollectibleType.SACRED_ORB, // 691
  CollectibleType.TMTRAINER, // 721
] as const;

const TRINKETS_THAT_AFFECT_ITEM_POOLS = [TrinketType.NO] as const;

export class ItemPoolDetection extends Feature {
  private readonly moddedElementSets: ModdedElementSets;

  /** @internal */
  constructor(moddedElementSets: ModdedElementSets) {
    super();

    this.featuresUsed = [ISCFeature.MODDED_ELEMENT_SETS];

    this.moddedElementSets = moddedElementSets;
  }

  /**
   * Helper function to get the remaining collectibles in a given item pool. This function is
   * expensive, so only use it in situations where the lag is acceptable.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ITEM_POOL_DETECTION`.
   *
   * @public
   */
  @Exported
  public getCollectiblesInItemPool(
    itemPoolType: ItemPoolType,
  ): readonly CollectibleType[] {
    const collectibleArray = this.moddedElementSets.getCollectibleTypes();
    return collectibleArray.filter((collectibleType) =>
      this.isCollectibleInItemPool(collectibleType, itemPoolType),
    );
  }

  /**
   * Helper function to see if the given collectible is still present in the given item pool.
   *
   * If the collectible is non-offensive, any Tainted Losts will be temporarily changed to Isaac and
   * then changed back. (This is because Tainted Lost is not able to retrieve non-offensive
   * collectibles from item pools).
   *
   * Under the hood, this function works by using the `ItemPool.AddRoomBlacklist` method to
   * blacklist every collectible except for the one provided.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ITEM_POOL_DETECTION`.
   *
   * @public
   */
  @Exported
  public isCollectibleInItemPool(
    collectibleType: CollectibleType,
    itemPoolType: ItemPoolType,
  ): boolean {
    // We use a specific collectible which is known to not be in any pools as a default value. Thus,
    // we must explicitly handle this case.
    if (collectibleType === COLLECTIBLE_TYPE_THAT_IS_NOT_IN_ANY_POOLS) {
      return false;
    }

    // On Tainted Lost, it is impossible to retrieve non-offensive collectibles from pools, so we
    // temporarily change the character to Isaac.
    const taintedLosts = getPlayersOfType(PlayerType.LOST_B);
    const isOffensive = collectibleHasTag(
      collectibleType,
      ItemConfigTag.OFFENSIVE,
    );
    let changedPlayerTypes = false;
    if (!isOffensive) {
      changedPlayerTypes = true;
      for (const player of taintedLosts) {
        player.ChangePlayerType(PlayerType.ISAAC);
      }
    }

    const { removedItemsMap, removedTrinketsMap } =
      removeItemsAndTrinketsThatAffectItemPools();

    // Blacklist every collectible in the game except for the provided collectible.
    const itemPool = game.GetItemPool();
    itemPool.ResetRoomBlacklist();
    for (const collectibleTypeInSet of this.moddedElementSets.getCollectibleTypes()) {
      if (collectibleTypeInSet !== collectibleType) {
        itemPool.AddRoomBlacklist(collectibleTypeInSet);
      }
    }

    // Get a collectible from the pool and see if it is the intended collectible. (We can use any
    // arbitrary value as the seed since it should not influence the result.)
    const seed = 1 as Seed;
    const retrievedCollectibleType = itemPool.GetCollectible(
      itemPoolType,
      false,
      seed,
      COLLECTIBLE_TYPE_THAT_IS_NOT_IN_ANY_POOLS,
    );
    const collectibleUnlocked = retrievedCollectibleType === collectibleType;

    // Reset the blacklist
    itemPool.ResetRoomBlacklist();

    restoreItemsAndTrinketsThatAffectItemPools(
      removedItemsMap,
      removedTrinketsMap,
    );

    // Change any players back to Tainted Lost, if necessary.
    if (changedPlayerTypes) {
      for (const player of taintedLosts) {
        player.ChangePlayerType(PlayerType.LOST_B);
      }
    }

    return collectibleUnlocked;
  }

  /**
   * Helper function to see if the given collectible is unlocked on the current save file. This
   * requires providing the corresponding item pool that the collectible is normally located in.
   *
   * - If any player currently has the collectible, then it is assumed to be unlocked. (This is
   *   because in almost all cases, when a collectible is added to a player's inventory, it is
   *   subsequently removed from all pools.)
   * - If the collectible is located in more than one item pool, then any item pool can be provided.
   * - If the collectible is not located in any item pools, then this function will always return
   *   false.
   * - If the collectible is non-offensive, any Tainted Losts will be temporarily changed to Isaac
   *   and then changed back. (This is because Tainted Lost is not able to retrieve non-offensive
   *   collectibles from item pools).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ITEM_POOL_DETECTION`.
   *
   * @public
   */
  @Exported
  public isCollectibleUnlocked(
    collectibleType: CollectibleType,
    itemPoolType: ItemPoolType,
  ): boolean {
    if (anyPlayerHasCollectible(collectibleType)) {
      return true;
    }

    return this.isCollectibleInItemPool(collectibleType, itemPoolType);
  }
}

/**
 * Before checking the item pools, remove any collectibles or trinkets that would affect the
 * retrieved collectible types.
 */
function removeItemsAndTrinketsThatAffectItemPools(): {
  removedItemsMap: Map<PlayerIndex, CollectibleType[]>;
  removedTrinketsMap: Map<PlayerIndex, TrinketType[]>;
} {
  const removedItemsMap = new Map<PlayerIndex, CollectibleType[]>();
  const removedTrinketsMap = new Map<PlayerIndex, TrinketType[]>();
  for (const player of getAllPlayers()) {
    const removedItems: CollectibleType[] = [];
    for (const itemToRemove of COLLECTIBLES_THAT_AFFECT_ITEM_POOLS) {
      // We need to include non-real collectibles (like Lilith's Incubus), so we omit the second
      // argument.
      const numCollectibles = player.GetCollectibleNum(itemToRemove);
      repeat(numCollectibles, () => {
        player.RemoveCollectible(itemToRemove);
        removedItems.push(itemToRemove);
      });
    }

    mapSetPlayer(removedItemsMap, player, removedItems);

    const removedTrinkets: TrinketType[] = [];
    for (const trinketToRemove of TRINKETS_THAT_AFFECT_ITEM_POOLS) {
      if (player.HasTrinket(trinketToRemove)) {
        const numTrinkets = player.GetTrinketMultiplier(trinketToRemove);
        repeat(numTrinkets, () => {
          player.TryRemoveTrinket(trinketToRemove);
          removedTrinkets.push(trinketToRemove);
        });
      }
    }

    mapSetPlayer(removedTrinketsMap, player, removedTrinkets);
  }

  return { removedItemsMap, removedTrinketsMap };
}

function restoreItemsAndTrinketsThatAffectItemPools(
  removedItemsMap: ReadonlyMap<PlayerIndex, CollectibleType[]>,
  removedTrinketsMap: ReadonlyMap<PlayerIndex, TrinketType[]>,
) {
  for (const player of getAllPlayers()) {
    const removedItems = mapGetPlayer(removedItemsMap, player);
    if (removedItems !== undefined) {
      for (const collectibleType of removedItems) {
        player.AddCollectible(collectibleType, 0, false); // Prevent Chaos from spawning pickups
      }
    }

    const removedTrinkets = mapGetPlayer(removedTrinketsMap, player);
    if (removedTrinkets !== undefined) {
      for (const trinketType of removedTrinkets) {
        player.AddTrinket(trinketType, false);
      }
    }
  }
}

----
classes\features\other\ModdedElementDetection.ts
import type {
  CardType,
  CollectibleType,
  PillEffect,
  TrinketType,
} from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { itemConfig } from "../../../core/cachedClasses";
import {
  LAST_VANILLA_CARD_TYPE,
  LAST_VANILLA_COLLECTIBLE_TYPE,
  LAST_VANILLA_PILL_EFFECT,
  LAST_VANILLA_TRINKET_TYPE,
  NUM_VANILLA_CARD_TYPES,
  NUM_VANILLA_COLLECTIBLE_TYPES,
  NUM_VANILLA_PILL_EFFECTS,
  NUM_VANILLA_TRINKET_TYPES,
} from "../../../core/constantsFirstLast";
import { Exported } from "../../../decorators";
import { Feature } from "../../private/Feature";

// eslint-disable-next-line isaacscript/strict-enums
const FIRST_MODDED_COLLECTIBLE_TYPE: CollectibleType =
  LAST_VANILLA_COLLECTIBLE_TYPE + 1;

// eslint-disable-next-line isaacscript/strict-enums
const FIRST_MODDED_TRINKET_TYPE: TrinketType = LAST_VANILLA_TRINKET_TYPE + 1;

// eslint-disable-next-line isaacscript/strict-enums
const FIRST_MODDED_CARD_TYPE: CardType = LAST_VANILLA_CARD_TYPE + 1;

// eslint-disable-next-line isaacscript/strict-enums
const FIRST_MODDED_PILL_EFFECT: PillEffect = LAST_VANILLA_PILL_EFFECT + 1;

/**
 * Mods can add extra things to the game (e.g. collectibles, trinkets, and so on). Since mods load
 * in alphabetical order, the total number of things can't be properly be known until at least one
 * callback fires (which indicates that all mods have been loaded).
 *
 * This feature gates all such functions behind a callback check. Subsequently, these functions will
 * throw a runtime error if they are called in the menu, before any callbacks have occurred. This
 * ensures that the proper values are always returned and allows you to get immediate feedback if
 * you accidentally access them from the menu.
 */
export class ModdedElementDetection extends Feature {
  private atLeastOneCallbackFired = false;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 9
      [ModCallback.POST_PLAYER_INIT, this.postPlayerInit],
    ];
  }

  // ModCallback.POST_PLAYER_INIT (9)
  private readonly postPlayerInit = () => {
    this.atLeastOneCallbackFired = true;
  };

  private errorIfNoCallbacksFired(constantType: string) {
    if (!this.atLeastOneCallbackFired) {
      error(
        `Failed to retrieve a ${constantType} constant. Since not all mods have been loaded yet, any constants of this type will be inaccurate. Thus, you must wait until at least one callback fires before retrieving these types of constants.`,
      );
    }
  }

  // ------------
  // Collectibles
  // ------------

  /**
   * Returns the first modded collectible type, or undefined if there are no modded collectibles.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectibles will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getFirstModdedCollectibleType(): CollectibleType | undefined {
    this.errorIfNoCallbacksFired("collectible");

    const itemConfigItem = itemConfig.GetCollectible(
      FIRST_MODDED_COLLECTIBLE_TYPE,
    );

    return itemConfigItem === undefined
      ? undefined
      : FIRST_MODDED_COLLECTIBLE_TYPE;
  }

  /**
   * Will change depending on how many modded collectibles there are.
   *
   * Equal to `itemConfig.GetCollectibles().Size - 1`. (`Size` includes invalid collectibles, like
   * 666. We subtract one to account for `CollectibleType.NULL`.)
   *
   * If there are no mods present that add any custom collectibles, this function will return
   * `CollectibleType.MOMS_RING` (732).
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectibles will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getLastCollectibleType(): CollectibleType {
    this.errorIfNoCallbacksFired("collectible");
    return itemConfig.GetCollectibles().Size - 1;
  }

  /**
   * Returns the total number of collectibles in the item config, including both vanilla and modded
   * collectibles. If you just need the number of vanilla collectible types, use the
   * `NUM_VANILLA_COLLECTIBLE_TYPES` constant.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectibles will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumCollectibleTypes(): int {
    this.errorIfNoCallbacksFired("collectible");
    return NUM_VANILLA_COLLECTIBLE_TYPES + this.getNumModdedCollectibleTypes();
  }

  /**
   * Unlike vanilla collectible types, modded collectible types are always contiguous.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectibles will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumModdedCollectibleTypes(): int {
    this.errorIfNoCallbacksFired("collectible");
    return this.getLastCollectibleType() - LAST_VANILLA_COLLECTIBLE_TYPE;
  }

  // --------
  // Trinkets
  // --------

  /**
   * Returns the first modded trinket type, or undefined if there are no modded trinkets.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinkets will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getFirstModdedTrinketType(): TrinketType | undefined {
    this.errorIfNoCallbacksFired("trinket");

    const itemConfigItem = itemConfig.GetTrinket(FIRST_MODDED_TRINKET_TYPE);
    return itemConfigItem === undefined ? undefined : FIRST_MODDED_TRINKET_TYPE;
  }

  /**
   * Will change depending on how many modded trinkets there are.
   *
   * Equal to `itemConfig.GetTrinkets().Size - 1`. (`Size` includes invalid trinkets, like 47. We
   * subtract one to account for `TrinketType.NULL`.)
   *
   * If there are no mods present that add any custom trinkets, this function will return
   * `TrinketType.SIGIL_OF_BAPHOMET` (189).
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinkets will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getLastTrinketType(): TrinketType {
    this.errorIfNoCallbacksFired("trinket");
    return itemConfig.GetTrinkets().Size - 1;
  }

  /**
   * Returns the total number of trinkets in the item config, including both vanilla and modded
   * trinkets. If you just need the number of vanilla trinket types, use the
   * `NUM_VANILLA_TRINKET_TYPES` constant.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinkets will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumTrinketTypes(): int {
    this.errorIfNoCallbacksFired("trinket");
    return NUM_VANILLA_TRINKET_TYPES + this.getNumModdedTrinketTypes();
  }

  /**
   * Unlike vanilla trinket types, modded trinket types are always contiguous.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinkets will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumModdedTrinketTypes(): int {
    this.errorIfNoCallbacksFired("trinket");
    return this.getLastTrinketType() - LAST_VANILLA_TRINKET_TYPE;
  }

  // -----
  // Cards
  // -----

  /**
   * Returns the first modded card sub-type, or undefined if there are no modded cards.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all cards will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getFirstModdedCardType(): CardType | undefined {
    this.errorIfNoCallbacksFired("card");

    const itemConfigCard = itemConfig.GetCard(FIRST_MODDED_CARD_TYPE);
    return itemConfigCard === undefined ? undefined : FIRST_MODDED_CARD_TYPE;
  }

  /**
   * Will change depending on how many modded cards there are.
   *
   * Equal to `itemConfig.GetCards().Size - 1`. (`Size` includes invalid cards, but since cards are
   * contiguous, there are no invalid cards. We subtract one to account for `CardType.NULL`.)
   *
   * If there are no mods present that add any custom cards, this function will return
   * `CardType.SOUL_OF_JACOB_AND_ESAU` (97).
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinkets will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getLastCardType(): CardType {
    this.errorIfNoCallbacksFired("card");
    return itemConfig.GetCards().Size - 1;
  }

  /**
   * Returns the total number of cards in the item config, including both vanilla and modded cards.
   * If you just need the number of vanilla card types, use the `NUM_VANILLA_CARD_TYPES` constant.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all cards will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumCardTypes(): int {
    this.errorIfNoCallbacksFired("card");
    return NUM_VANILLA_CARD_TYPES + this.getNumModdedCardTypes();
  }

  /**
   * Like vanilla card types, modded card types are always contiguous.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all cards will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumModdedCardTypes(): int {
    this.errorIfNoCallbacksFired("card");
    return this.getLastCardType() - LAST_VANILLA_CARD_TYPE;
  }

  // ------------
  // Pill Effects
  // ------------

  /**
   * Returns the first modded pill effect, or undefined if there are no modded pill effects.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getFirstModdedPillEffect(): PillEffect | undefined {
    this.errorIfNoCallbacksFired("pill");

    const itemConfigPillEffect = itemConfig.GetPillEffect(
      FIRST_MODDED_PILL_EFFECT,
    );

    return itemConfigPillEffect === undefined
      ? undefined
      : FIRST_MODDED_PILL_EFFECT;
  }

  /**
   * Will change depending on how many modded pill effects there are.
   *
   * Equal to `itemConfig.GetPillEffects().Size - 1`. (`Size` includes invalid pill effects, but
   * since pill effects are contiguous, there are no invalid pill effects. We subtract one to
   * account for the enum starting at 0 instead of 1.)
   *
   * If there are no mods present that add any custom pill effects, this function will return
   * `PillEffect.EXPERIMENTAL` (49).
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getLastPillEffect(): PillEffect {
    this.errorIfNoCallbacksFired("pill");
    return itemConfig.GetPillEffects().Size - 1;
  }

  /**
   * Returns the total number of pill effects in the item config, including both vanilla and modded
   * pill effects. If you just need the number of vanilla pill effects, use the
   * `NUM_VANILLA_PILL_EFFECTS` constant.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all cards will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumPillEffects(): int {
    this.errorIfNoCallbacksFired("pill");
    return NUM_VANILLA_PILL_EFFECTS + this.getNumModdedPillEffects();
  }

  /**
   * Like vanilla pill effects, modded pill effects are always contiguous.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all cards will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.MODDED_ELEMENT_DETECTION`.
   *
   * @public
   */
  @Exported
  public getNumModdedPillEffects(): int {
    this.errorIfNoCallbacksFired("card");
    return this.getLastPillEffect() - LAST_VANILLA_PILL_EFFECT;
  }
}

----
classes\features\other\ModdedElementSets.ts
import type { PillEffect } from "isaac-typescript-definitions";
import {
  CacheFlag,
  CardType,
  CollectibleType,
  ItemConfigCardType,
  ItemConfigTag,
  PlayerForm,
  TrinketType,
} from "isaac-typescript-definitions";
import {
  CACHE_FLAG_VALUES,
  ITEM_CONFIG_CARD_TYPE_VALUES,
  ITEM_CONFIG_TAG_VALUES,
} from "../../../cachedEnumValues";
import { itemConfig } from "../../../core/cachedClasses";
import {
  FIRST_GLITCHED_COLLECTIBLE_TYPE,
  QUALITIES,
} from "../../../core/constants";
import {
  VANILLA_CARD_TYPES,
  VANILLA_COLLECTIBLE_TYPES,
  VANILLA_PILL_EFFECTS,
  VANILLA_TRINKET_TYPES,
} from "../../../core/constantsVanilla";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { arrayRemove, getRandomArrayElement } from "../../../functions/array";
import { getItemConfigCardType } from "../../../functions/cards";
import { collectibleHasTag } from "../../../functions/collectibleTag";
import {
  collectibleHasCacheFlag,
  getCollectibleQuality,
  isActiveCollectible,
  isHiddenCollectible,
  isPassiveOrFamiliarCollectible,
} from "../../../functions/collectibles";
import { getFlagName } from "../../../functions/flag";
import { getRandomSetElement } from "../../../functions/set";
import { trinketHasCacheFlag } from "../../../functions/trinkets";
import {
  asCardType,
  asCollectibleType,
  asPillEffect,
  asTrinketType,
} from "../../../functions/types";
import { assertDefined, iRange, repeat } from "../../../functions/utils";
import { ITEM_CONFIG_CARD_TYPES_FOR_CARDS } from "../../../sets/itemConfigCardTypesForCards";
import { ReadonlyMap } from "../../../types/ReadonlyMap";
import type { ReadonlySet } from "../../../types/ReadonlySet";
import { Feature } from "../../private/Feature";
import type { ModdedElementDetection } from "./ModdedElementDetection";

const CONDITIONAL_FLYING_COLLECTIBLE_TYPES = [
  CollectibleType.BIBLE,
  CollectibleType.EMPTY_VESSEL,
  CollectibleType.ASTRAL_PROJECTION,
  CollectibleType.RECALL,
] as const;

const TRANSFORMATION_TO_TAG_MAP = new ReadonlyMap<PlayerForm, ItemConfigTag>([
  [PlayerForm.GUPPY, ItemConfigTag.GUPPY], // 0
  [PlayerForm.BEELZEBUB, ItemConfigTag.FLY], // 1
  [PlayerForm.FUN_GUY, ItemConfigTag.MUSHROOM], // 2
  [PlayerForm.SERAPHIM, ItemConfigTag.ANGEL], // 3
  [PlayerForm.BOB, ItemConfigTag.BOB], // 4
  [PlayerForm.SPUN, ItemConfigTag.SYRINGE], // 5
  [PlayerForm.YES_MOTHER, ItemConfigTag.MOM], // 6
  [PlayerForm.CONJOINED, ItemConfigTag.BABY], // 7
  [PlayerForm.LEVIATHAN, ItemConfigTag.DEVIL], // 8
  [PlayerForm.OH_CRAP, ItemConfigTag.POOP], // 9
  [PlayerForm.BOOKWORM, ItemConfigTag.BOOK], // 10
  // PlayerForm.ADULTHOOD (11) is based on pill usage.
  [PlayerForm.SPIDER_BABY, ItemConfigTag.SPIDER], // 12
  // PlayerForm.STOMPY (13) is based on size.
]);

/**
 * A feature that lazy-inits and caches various arrays and sets that include both vanilla and modded
 * elements. This is useful for performance purposes (so that we do not have to reconstruct the
 * arrays/sets multiple times).
 *
 * The modded arrays/sets are created using the functions from
 * `ISCFeature.MODDED_ELEMENT_DETECTION`.
 */
export class ModdedElementSets extends Feature {
  private arraysInitialized = false;

  // ----------------
  // Main collections
  // ----------------

  private readonly allCollectibleTypesArray: CollectibleType[] = [];
  private readonly allCollectibleTypesSet = new Set<CollectibleType>();

  private readonly moddedCollectibleTypesArray: CollectibleType[] = [];
  private readonly moddedCollectibleTypesSet = new Set<CollectibleType>();

  private readonly allTrinketTypesArray: TrinketType[] = [];
  private readonly allTrinketTypesSet = new Set<TrinketType>();

  private readonly moddedTrinketTypesArray: TrinketType[] = [];
  private readonly moddedTrinketTypesSet = new Set<TrinketType>();

  private readonly allCardTypesArray: CardType[] = [];
  private readonly allCardTypesSet = new Set<CardType>();

  private readonly moddedCardTypesArray: CardType[] = [];
  private readonly moddedCardTypesSet = new Set<CardType>();

  private readonly allPillEffectsArray: PillEffect[] = [];
  private readonly allPillEffectsSet = new Set<PillEffect>();

  private readonly moddedPillEffectsArray: PillEffect[] = [];
  private readonly moddedPillEffectsSet = new Set<PillEffect>();

  // -----------------
  // Other collections
  // -----------------

  private readonly cacheFlagToCollectibleTypesMap = new Map<
    CacheFlag,
    readonly CollectibleType[]
  >();

  private readonly cacheFlagToTrinketTypesMap = new Map<
    CacheFlag,
    readonly TrinketType[]
  >();

  private flyingCollectibleTypes: CollectibleType[] = [];
  private permanentFlyingCollectibleTypes: CollectibleType[] = [];

  private flyingTrinketTypes: TrinketType[] = [];

  private readonly tagToCollectibleTypesMap = new Map<
    ItemConfigTag,
    CollectibleType[]
  >();

  private readonly edenActiveCollectibleTypesSet = new Set<CollectibleType>();
  private readonly edenPassiveCollectibleTypesSet = new Set<CollectibleType>();

  private readonly qualityToCollectibleTypesMap = new Map<
    Quality,
    readonly CollectibleType[]
  >();

  private readonly itemConfigCardTypeToCardTypeMap = new Map<
    ItemConfigCardType,
    CardType[]
  >();

  /**
   * The array of card types that are not:
   *
   * - ItemConfigCardType.RUNE
   * - ItemConfigCardType.SPECIAL_OBJECT
   */
  private readonly cardTypeCardArray: CardType[] = [];

  private readonly moddedElementDetection: ModdedElementDetection;

  /** @internal */
  constructor(moddedElementDetection: ModdedElementDetection) {
    super();

    this.featuresUsed = [ISCFeature.MODDED_ELEMENT_DETECTION];

    this.moddedElementDetection = moddedElementDetection;
  }

  private lazyInit() {
    if (this.arraysInitialized) {
      return;
    }
    this.arraysInitialized = true;

    this.lazyInitModdedCollectibleTypes();
    this.lazyInitModdedTrinketTypes();
    this.lazyInitModdedCardTypes();
    this.lazyInitModdedPillEffects();
    this.lazyInitTagToCollectibleTypesMap();
    this.lazyInitCacheFlagToCollectibleTypesMap();
    this.lazyInitCacheFlagToTrinketTypesMap();
    this.lazyInitFlyingCollectibleTypesSet();
    this.lazyInitFlyingTrinketTypesSet();
    this.lazyInitEdenCollectibleTypesSet();
    this.lazyInitQualityToCollectibleTypesMap();
    this.lazyInitCardTypes();
  }

  private lazyInitModdedCollectibleTypes() {
    for (const collectibleType of VANILLA_COLLECTIBLE_TYPES) {
      this.allCollectibleTypesArray.push(collectibleType);
      this.allCollectibleTypesSet.add(collectibleType);
    }

    const firstModdedCollectibleType =
      this.moddedElementDetection.getFirstModdedCollectibleType();
    if (firstModdedCollectibleType === undefined) {
      return;
    }

    const lastCollectibleType =
      this.moddedElementDetection.getLastCollectibleType();
    const moddedCollectibleTypes = iRange(
      firstModdedCollectibleType,
      lastCollectibleType,
    );

    for (const collectibleTypeInt of moddedCollectibleTypes) {
      // Modded collectible types are contiguous, but we check every value just in case.
      const collectibleType = asCollectibleType(collectibleTypeInt);
      const itemConfigItem = itemConfig.GetCollectible(collectibleType);
      if (itemConfigItem !== undefined) {
        this.moddedCollectibleTypesArray.push(collectibleType);
        this.moddedCollectibleTypesSet.add(collectibleType);

        this.allCollectibleTypesArray.push(collectibleType);
        this.allCollectibleTypesSet.add(collectibleType);
      }
    }
  }

  private lazyInitModdedTrinketTypes() {
    for (const trinketType of VANILLA_TRINKET_TYPES) {
      this.allTrinketTypesArray.push(trinketType);
      this.allTrinketTypesSet.add(trinketType);
    }

    const firstModdedTrinketType =
      this.moddedElementDetection.getFirstModdedTrinketType();
    if (firstModdedTrinketType === undefined) {
      return;
    }

    const lastTrinketType = this.moddedElementDetection.getLastTrinketType();
    const moddedTrinketTypes = iRange(firstModdedTrinketType, lastTrinketType);

    for (const trinketTypeInt of moddedTrinketTypes) {
      // Modded trinket types are contiguous, but we check every value just in case.
      const trinketType = asTrinketType(trinketTypeInt);
      const itemConfigItem = itemConfig.GetTrinket(trinketType);
      if (itemConfigItem !== undefined) {
        this.moddedTrinketTypesArray.push(trinketType);
        this.moddedTrinketTypesSet.add(trinketType);

        this.allTrinketTypesArray.push(trinketType);
        this.allTrinketTypesSet.add(trinketType);
      }
    }
  }

  private lazyInitModdedCardTypes() {
    for (const cardType of VANILLA_CARD_TYPES) {
      this.allCardTypesArray.push(cardType);
      this.allCardTypesSet.add(cardType);
    }

    const firstModdedCardType =
      this.moddedElementDetection.getFirstModdedCardType();
    if (firstModdedCardType === undefined) {
      return;
    }

    const lastCardType = this.moddedElementDetection.getLastCardType();
    const moddedCardTypes = iRange(firstModdedCardType, lastCardType);

    for (const cardTypeInt of moddedCardTypes) {
      // Modded card types are contiguous, but we check every value just in case.
      const cardType = asCardType(cardTypeInt);
      const itemConfigCard = itemConfig.GetCard(cardType);
      if (itemConfigCard !== undefined) {
        this.moddedCardTypesArray.push(cardType);
        this.moddedCardTypesSet.add(cardType);

        this.allCardTypesArray.push(cardType);
        this.allCardTypesSet.add(cardType);
      }
    }
  }

  private lazyInitModdedPillEffects() {
    for (const pillEffect of VANILLA_PILL_EFFECTS) {
      this.allPillEffectsArray.push(pillEffect);
      this.allPillEffectsSet.add(pillEffect);
    }

    const firstModdedPillEffect =
      this.moddedElementDetection.getFirstModdedPillEffect();
    if (firstModdedPillEffect === undefined) {
      return;
    }

    const lastPillEffect = this.moddedElementDetection.getLastPillEffect();
    const moddedPillEffects = iRange(firstModdedPillEffect, lastPillEffect);

    for (const pillEffectInt of moddedPillEffects) {
      // Modded pill effects are contiguous, but we check every value just in case.
      const pillEffect = asPillEffect(pillEffectInt);
      const itemConfigPillEffect = itemConfig.GetPillEffect(pillEffect);
      if (itemConfigPillEffect !== undefined) {
        this.moddedPillEffectsArray.push(pillEffect);
        this.moddedPillEffectsSet.add(pillEffect);

        this.allPillEffectsArray.push(pillEffect);
        this.allPillEffectsSet.add(pillEffect);
      }
    }
  }

  private lazyInitTagToCollectibleTypesMap() {
    // The tag to collectible types map should be valid for every tag, so we initialize it with
    // empty arrays.
    for (const itemConfigTag of ITEM_CONFIG_TAG_VALUES) {
      this.tagToCollectibleTypesMap.set(itemConfigTag, [] as CollectibleType[]);
    }

    for (const collectibleType of this.getCollectibleTypes()) {
      for (const itemConfigTag of ITEM_CONFIG_TAG_VALUES) {
        if (!collectibleHasTag(collectibleType, itemConfigTag)) {
          continue;
        }

        const collectibleTypes =
          this.tagToCollectibleTypesMap.get(itemConfigTag);
        if (collectibleTypes === undefined) {
          const flagName = getFlagName(itemConfigTag, ItemConfigTag);
          error(
            `Failed to get the collectible types for item tag: ${flagName}`,
          );
        }
        collectibleTypes.push(collectibleType);
      }
    }
  }

  private lazyInitCacheFlagToCollectibleTypesMap() {
    for (const cacheFlag of CACHE_FLAG_VALUES) {
      const collectibleTypes: CollectibleType[] = [];

      for (const collectibleType of this.getCollectibleTypes()) {
        if (collectibleHasCacheFlag(collectibleType, cacheFlag)) {
          collectibleTypes.push(collectibleType);
        }
      }

      this.cacheFlagToCollectibleTypesMap.set(cacheFlag, collectibleTypes);
    }
  }

  private lazyInitCacheFlagToTrinketTypesMap() {
    for (const cacheFlag of CACHE_FLAG_VALUES) {
      const trinketTypes: TrinketType[] = [];

      for (const trinketType of this.getTrinketTypes()) {
        if (trinketHasCacheFlag(trinketType, cacheFlag)) {
          trinketTypes.push(trinketType);
        }
      }

      this.cacheFlagToTrinketTypesMap.set(cacheFlag, trinketTypes);
    }
  }

  private lazyInitFlyingCollectibleTypesSet() {
    // Instead of manually compiling a list of collectibles that grant flying, we can instead
    // dynamically look for collectibles that have `CacheFlag.FLYING`. But none of the collectibles
    // with a cache of "all" grant flying (including all of the 3 Dollar Bill collectibles and all
    // of the Birthright effects), so we can safely remove them from the list.
    const collectibleTypesWithFlyingCacheFlag =
      this.getCollectibleTypesWithCacheFlag(CacheFlag.FLYING);
    const collectibleTypesWithAllCacheFlag =
      this.getCollectibleTypesWithCacheFlag(CacheFlag.ALL);
    this.flyingCollectibleTypes = arrayRemove(
      collectibleTypesWithFlyingCacheFlag,
      ...collectibleTypesWithAllCacheFlag,
    );

    // Additionally, create a second set that represents the collectible types that grant flying
    // non-conditionally.
    this.permanentFlyingCollectibleTypes = arrayRemove(
      this.flyingCollectibleTypes,
      ...CONDITIONAL_FLYING_COLLECTIBLE_TYPES,
    );
  }

  private lazyInitFlyingTrinketTypesSet() {
    // Instead of manually compiling a list of trinkets that grant flying, we can instead
    // dynamically look for collectibles that have `CacheFlag.FLYING`. But none of the trinkets with
    // `CacheFlag.ALL` grant flying except for Azazel's Stump, so we can safely remove them from the
    // list.
    const trinketTypesWithFlyingCacheFlag = this.getTrinketsTypesWithCacheFlag(
      CacheFlag.FLYING,
    );
    const trinketTypesWithAllCacheFlag = this.getTrinketsTypesWithCacheFlag(
      CacheFlag.ALL,
    );
    const trinketTypesWithAllCacheFlagThatDontGrantFlying = arrayRemove(
      trinketTypesWithAllCacheFlag,
      TrinketType.AZAZELS_STUMP,
    );
    this.flyingTrinketTypes = arrayRemove(
      trinketTypesWithFlyingCacheFlag,
      ...trinketTypesWithAllCacheFlagThatDontGrantFlying,
    );
  }

  private lazyInitEdenCollectibleTypesSet() {
    for (const collectibleType of this.getCollectibleTypes()) {
      if (
        isHiddenCollectible(collectibleType) ||
        collectibleHasTag(collectibleType, ItemConfigTag.NO_EDEN)
      ) {
        continue;
      }

      if (isActiveCollectible(collectibleType)) {
        this.edenActiveCollectibleTypesSet.add(collectibleType);
      }

      if (isPassiveOrFamiliarCollectible(collectibleType)) {
        this.edenPassiveCollectibleTypesSet.add(collectibleType);
      }
    }
  }

  private lazyInitQualityToCollectibleTypesMap() {
    for (const quality of QUALITIES) {
      const collectibleTypes: CollectibleType[] = [];

      for (const collectibleType of this.getCollectibleTypes()) {
        const collectibleTypeQuality = getCollectibleQuality(collectibleType);
        if (collectibleTypeQuality === quality) {
          collectibleTypes.push(collectibleType);
        }
      }

      this.qualityToCollectibleTypesMap.set(quality, collectibleTypes);
    }
  }

  private lazyInitCardTypes() {
    // The card type to cards map should be valid for every card type, so we initialize it with
    // empty arrays.
    for (const itemConfigCardType of ITEM_CONFIG_CARD_TYPE_VALUES) {
      this.itemConfigCardTypeToCardTypeMap.set(
        itemConfigCardType,
        [] as CardType[],
      );
    }

    for (const cardType of this.getCardTypes()) {
      const itemConfigCardType = getItemConfigCardType(cardType);
      if (itemConfigCardType !== undefined) {
        const cardTypes =
          this.itemConfigCardTypeToCardTypeMap.get(itemConfigCardType);
        assertDefined(
          cardTypes,
          `Failed to get the card types for item config card type: ${itemConfigCardType}`,
        );

        cardTypes.push(cardType);

        if (ITEM_CONFIG_CARD_TYPES_FOR_CARDS.has(itemConfigCardType)) {
          this.cardTypeCardArray.push(cardType);
        }
      }
    }
  }

  // ------------
  // Collectibles
  // ------------

  /**
   * Returns an array containing every valid collectible type in the game, including modded
   * collectibles.
   *
   * Use this if you need to iterate over the collectibles in order. If you need to do O(1) lookups,
   * then use the `getCollectibleTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypes(): readonly CollectibleType[] {
    this.lazyInit();
    return this.allCollectibleTypesArray;
  }

  /**
   * Returns a set containing every valid collectible type in the game, including modded
   * collectibles.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the collectibles in order,
   * then use the `getCollectibleTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypeSet(): ReadonlySet<CollectibleType> {
    this.lazyInit();
    return this.allCollectibleTypesSet;
  }

  /**
   * Returns an array containing every modded collectible type in the game.
   *
   * Use this if you need to iterate over the collectibles in order. If you need to do O(1) lookups,
   * then use the `getModdedCollectibleTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedCollectibleTypes(): readonly CollectibleType[] {
    this.lazyInit();
    return this.moddedCollectibleTypesArray;
  }

  /**
   * Returns a set containing every modded collectible type in the game.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the collectibles in order,
   * then use the `getModdedCollectibleTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedCollectibleTypesSet(): ReadonlySet<CollectibleType> {
    this.lazyInit();
    return this.moddedCollectibleTypesSet;
  }

  /**
   * Iterates over every collectible in the game and returns a map containing the number of each
   * item that the player has.
   *
   * Note that this will filter out non-real collectibles like Lilith's Incubus.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerCollectibleMap(
    player: EntityPlayer,
  ): Map<CollectibleType, int> {
    const collectibleArray = this.getCollectibleTypes();

    const collectibleMap = new Map<CollectibleType, int>();
    for (const collectibleType of collectibleArray) {
      // We specify "true" as the second argument to filter out things like Lilith's Incubus.
      const numCollectibles = player.GetCollectibleNum(collectibleType, true);
      if (numCollectibles > 0) {
        collectibleMap.set(collectibleType, numCollectibles);
      }
    }

    // If the player has TMTRAINER, they might also have glitched items.
    if (player.HasCollectible(CollectibleType.TMTRAINER)) {
      let collectibleType = FIRST_GLITCHED_COLLECTIBLE_TYPE;
      let itemConfigItem: Readonly<ItemConfigItem> | undefined;
      do {
        itemConfigItem = itemConfig.GetCollectible(collectibleType);

        if (itemConfigItem !== undefined) {
          // The `EntityPlayer.GetCollectibleNum` method is bugged with TMTrainer items and will
          // always return 0. To work around this, we simply assume that if the player has the
          // collectible, then they have one copy of the item.
          const hasCollectibles = player.HasCollectible(collectibleType, true);
          if (hasCollectibles) {
            collectibleMap.set(collectibleType, 1);
          }
        }

        collectibleType--; // eslint-disable-line isaacscript/strict-enums
      } while (itemConfigItem !== undefined);
    }

    return collectibleMap;
  }

  // --------
  // Trinkets
  // --------

  /**
   * Returns an array containing every modded trinket type in the game.
   *
   * Use this if you need to iterate over the trinkets in order. If you need to do O(1) lookups,
   * then use the `getModdedTrinketTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getTrinketTypes(): readonly TrinketType[] {
    this.lazyInit();
    return this.allTrinketTypesArray;
  }

  /**
   * Returns a set containing every modded trinket type in the game.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the trinkets in order,
   * then use the `getModdedTrinketTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getTrinketTypesSet(): ReadonlySet<TrinketType> {
    this.lazyInit();
    return this.allTrinketTypesSet;
  }

  /**
   * Returns an array containing every modded trinket type in the game.
   *
   * Use this if you need to iterate over the trinkets in order. If you need to do O(1) lookups,
   * then use the `getModdedTrinketTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedTrinketTypes(): readonly TrinketType[] {
    this.lazyInit();
    return this.moddedTrinketTypesArray;
  }

  /**
   * Returns a set containing every modded trinket type in the game.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the trinkets in order,
   * then use the `getModdedTrinketTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedTrinketTypesSet(): ReadonlySet<TrinketType> {
    this.lazyInit();
    return this.moddedTrinketTypesSet;
  }

  // -----
  // Cards
  // -----

  /**
   * Returns an array containing every valid card type in the game, including modded cards.
   *
   * Use this if you need to iterate over the cards in order. If you need to do O(1) lookups, then
   * use the `getCardTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCardTypes(): readonly CardType[] {
    this.lazyInit();
    return this.allCardTypesArray;
  }

  /**
   * Returns a set containing every valid card type in the game, including modded cards.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the cards in order, then
   * use the `getCardTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCardTypesSet(): ReadonlySet<CardType> {
    this.lazyInit();
    return this.allCardTypesSet;
  }

  /**
   * Returns an array containing every modded card type in the game.
   *
   * Use this if you need to iterate over the cards in order. If you need to do O(1) lookups, then
   * use the `getModdedCardTypesSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedCardTypes(): readonly CardType[] {
    this.lazyInit();
    return this.moddedCardTypesArray;
  }

  /**
   * Returns a set containing every modded card type in the game.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the cards in order, then
   * use the `getModdedCardTypes` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedCardTypesSet(): ReadonlySet<CardType> {
    this.lazyInit();
    return this.moddedCardTypesSet;
  }

  // ------------
  // Pill Effects
  // ------------

  /**
   * Returns an array containing every valid pill effect in the game, including modded pill effects.
   *
   * Use this if you need to iterate over the pill effects in order. If you need to do O(1) lookups,
   * then use the `getPillEffectSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPillEffects(): readonly PillEffect[] {
    this.lazyInit();
    return this.allPillEffectsArray;
  }

  /**
   * Returns a set containing every valid pill effect in the game, including modded pill effects.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the pill effects in order,
   * then use the `getPillEffects` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPillEffectsSet(): ReadonlySet<PillEffect> {
    this.lazyInit();
    return this.allPillEffectsSet;
  }

  /**
   * Returns an array containing every modded pill effect in the game.
   *
   * Use this if you need to iterate over the pill effects in order. If you need to do O(1) lookups,
   * then use the `getModdedPillEffectsSet` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedPillEffects(): readonly PillEffect[] {
    this.lazyInit();
    return this.moddedPillEffectsArray;
  }

  /**
   * Returns a set containing every modded pill effect in the game.
   *
   * Use this if you need to do O(1) lookups. If you need to iterate over the pill effects in order,
   * then use the `getModdedPillEffects` helper function instead.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all pill effects will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getModdedPillEffectsSet(): ReadonlySet<PillEffect> {
    this.lazyInit();
    return this.moddedPillEffectsSet;
  }

  // -----------
  // Cache Flags
  // -----------

  /**
   * Returns a set containing every collectible type with the given cache flag, including modded
   * collectibles.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypesWithCacheFlag(
    cacheFlag: CacheFlag,
  ): readonly CollectibleType[] {
    this.lazyInit();

    const collectiblesSet = this.cacheFlagToCollectibleTypesMap.get(cacheFlag);
    if (collectiblesSet === undefined) {
      return [];
    }

    return collectiblesSet;
  }

  /**
   * Returns a set containing every trinket type with the given cache flag, including modded
   * trinkets.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getTrinketsTypesWithCacheFlag(
    cacheFlag: CacheFlag,
  ): readonly TrinketType[] {
    this.lazyInit();

    const trinketTypes = this.cacheFlagToTrinketTypesMap.get(cacheFlag);
    if (trinketTypes === undefined) {
      return [];
    }

    return trinketTypes;
  }

  /**
   * Returns an array containing every collectible type that the player has that matches the
   * provided `CacheFlag`.
   *
   * For example, if the cache flag is `CacheFlag.FLYING`, and the player has one Lord of the Pit
   * and two Dead Doves, then this function would return:
   *
   * ```ts
   * [
   *   CollectibleType.LORD_OF_THE_PIT,
   *   CollectibleType.DEAD_DOVE,
   *   CollectibleType.DEAD_DOVE,
   * ]
   * ```
   *
   * Note that this array will not include collectibles that the player does not really have, like
   * Lilith's Incubus.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerCollectiblesWithCacheFlag(
    player: EntityPlayer,
    cacheFlag: CacheFlag,
  ): readonly CollectibleType[] {
    const collectiblesWithCacheFlag =
      this.getCollectibleTypesWithCacheFlag(cacheFlag);

    const playerCollectibles: CollectibleType[] = [];
    for (const collectibleType of collectiblesWithCacheFlag) {
      // We specify "true" as the second argument to filter out things like Lilith's Incubus.
      const numCollectibles = player.GetCollectibleNum(collectibleType, true);
      repeat(numCollectibles, () => {
        playerCollectibles.push(collectibleType);
      });
    }

    return playerCollectibles;
  }

  /**
   * Returns a map containing every trinket type that the player has that matches the provided
   * `CacheFlag`. The values of the map correspond to the multiplier for that trinket.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerTrinketsWithCacheFlag(
    player: EntityPlayer,
    cacheFlag: CacheFlag,
  ): Map<TrinketType, int> {
    const trinketTypesWithCacheFlag =
      this.getTrinketsTypesWithCacheFlag(cacheFlag);

    const playerTrinkets = new Map<TrinketType, int>();
    for (const trinketType of trinketTypesWithCacheFlag) {
      const trinketMultiplier = player.GetTrinketMultiplier(trinketType);
      if (trinketMultiplier > 0) {
        playerTrinkets.set(trinketType, trinketMultiplier);
      }
    }

    return playerTrinkets;
  }

  /**
   * Returns a set of all of the collectibles that grant flight. This is derived from collectibles
   * that have `CacheFlag.FLYING` set in the "items.xml" file.
   *
   * Vanilla collectibles that only grant flight conditionally are manually pruned. Collectibles
   * such as Empty Vessel should be checked for via the `hasFlyingTemporaryEffect` function.
   *
   * Under the hood, this is determined by looking at the collectibles that have `CacheFlag.FLYING`
   * and excluding the ones that have `CacheFlag.ALL`. (None of the collectibles with
   * `CacheFlag.ALL` grant flying, including all of the 3 Dollar Bill collectibles and all of the
   * Birthright effects.)
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param includeConditionalItems Whether collectibles that only grant flight conditionally should
   *                                be included in the set (like Empty Vessel).
   * @public
   */
  @Exported
  public getFlyingCollectibleTypes(
    includeConditionalItems: boolean,
  ): readonly CollectibleType[] {
    this.lazyInit();

    return includeConditionalItems
      ? this.flyingCollectibleTypes
      : this.permanentFlyingCollectibleTypes;
  }

  /**
   * Returns a set of all of the trinkets that grant flight. (All vanilla trinkets that grant flight
   * do so conditionally, like Bat Wing and Azazel's Stump.)
   *
   * Under the hood, this is determined by looking at the trinkets that have `CacheFlag.FLYING` and
   * excluding the ones that have `CacheFlag.ALL`. (None of the trinket with `CacheFlag.ALL` grant
   * flying except for Azazel's Stump.)
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all trinket types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getFlyingTrinketTypes(): readonly TrinketType[] {
    this.lazyInit();
    return this.flyingTrinketTypes;
  }

  // ----------------
  // Collectible Tags
  // ----------------

  /**
   * Returns a set containing every collectible type with the given tag.
   *
   * For example, to get all of the collectible types that count as offensive for the purposes of
   * Tainted Lost:
   *
   * ```ts
   * const offensiveCollectibleTypes = getCollectibleTypesWithTag(ItemConfigTag.OFFENSIVE);
   * ```
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypesWithTag(
    itemConfigTag: ItemConfigTag,
  ): readonly CollectibleType[] {
    this.lazyInit();

    const collectibleTypes = this.tagToCollectibleTypesMap.get(itemConfigTag);
    assertDefined(
      collectibleTypes,
      `The item config tag of ${itemConfigTag} is not a valid value of the "ItemConfigTag" enum.`,
    );

    return collectibleTypes;
  }

  /**
   * Returns an array of collectible types that a player has with a particular tag.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerCollectiblesWithTag(
    player: EntityPlayer,
    itemConfigTag: ItemConfigTag,
  ): readonly CollectibleType[] {
    const collectibleTypesWithTag =
      this.getCollectibleTypesWithTag(itemConfigTag);

    const playerCollectibles: CollectibleType[] = [];
    for (const collectibleType of collectibleTypesWithTag) {
      // We specify "true" as the second argument to filter out things like Lilith's Incubus.
      const numCollectibles = player.GetCollectibleNum(collectibleType, true);
      repeat(numCollectibles, () => {
        playerCollectibles.push(collectibleType);
      });
    }

    return playerCollectibles;
  }

  /**
   * Helper function to get all of the collectible types in the game that count towards a particular
   * transformation.
   *
   * For example, to get all of the collectible types that count towards Guppy:
   *
   * ```ts
   * const guppyCollectibleTypes = getCollectiblesForTransformation(PlayerForm.GUPPY);
   * ```
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypesForTransformation(
    playerForm: PlayerForm,
  ): readonly CollectibleType[] {
    const itemConfigTag = TRANSFORMATION_TO_TAG_MAP.get(playerForm);
    assertDefined(
      itemConfigTag,
      `Failed to get the collectible types for the transformation of ${playerForm} because that transformation is not based on collectibles.`,
    );

    return this.getCollectibleTypesWithTag(itemConfigTag);
  }

  /**
   * Returns an array of collectible types that a player has that count towards a particular
   * transformation.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerCollectiblesForTransformation(
    player: EntityPlayer,
    playerForm: PlayerForm,
  ): readonly CollectibleType[] {
    const collectibleForTransformation =
      this.getCollectibleTypesForTransformation(playerForm);

    const playerCollectibles: CollectibleType[] = [];
    for (const collectibleType of collectibleForTransformation) {
      // We specify "true" as the second argument to filter out things like Lilith's Incubus.
      const numCollectibles = player.GetCollectibleNum(collectibleType, true);
      repeat(numCollectibles, () => {
        playerCollectibles.push(collectibleType);
      });
    }

    return playerCollectibles;
  }

  /**
   * Returns a set containing every valid passive item that can be randomly granted to Eden as a
   * starting item.
   *
   * Under the hood, this is determined by looking at the "noeden" tag in "items_metadata.xml".
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getEdenActiveCollectibleTypes(): ReadonlySet<CollectibleType> {
    this.lazyInit();
    return this.edenActiveCollectibleTypesSet;
  }

  /**
   * Returns a set containing every valid passive item that can be randomly granted to Eden as a
   * starting item.
   *
   * Under the hood, this is determined by looking at the "noeden" tag in "items_metadata.xml".
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getEdenPassiveCollectibleTypes(): ReadonlySet<CollectibleType> {
    this.lazyInit();
    return this.edenPassiveCollectibleTypesSet;
  }

  /**
   * Returns a random active collectible type that that is a valid starting item for Eden.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * If you want to get an unseeded collectible type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param exceptions Optional. An array of runes to not select.
   * @public
   */
  @Exported
  public getRandomEdenActiveCollectibleType(
    seedOrRNG: Seed | RNG | undefined,
    exceptions: readonly CollectibleType[] = [],
  ): CollectibleType {
    this.lazyInit();

    return getRandomSetElement(
      this.edenPassiveCollectibleTypesSet,
      seedOrRNG,
      exceptions,
    );
  }

  /**
   * Returns a random passive collectible type that that is a valid starting item for Eden
   * (including familiars).
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * If you want to get an unseeded collectible type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param exceptions Optional. An array of runes to not select.
   * @public
   */
  @Exported
  public getRandomEdenPassiveCollectibleType(
    seedOrRNG: Seed | RNG | undefined,
    exceptions: readonly CollectibleType[] = [],
  ): CollectibleType {
    this.lazyInit();

    return getRandomSetElement(
      this.edenPassiveCollectibleTypesSet,
      seedOrRNG,
      exceptions,
    );
  }

  // -------------------
  // Collectible Quality
  // -------------------

  /**
   * Returns an array containing every collectible type with the given quality.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCollectibleTypesOfQuality(
    quality: Quality,
  ): readonly CollectibleType[] {
    this.lazyInit();

    const collectibleTypes = this.qualityToCollectibleTypesMap.get(quality);
    assertDefined(
      collectibleTypes,
      `The quality of ${quality} is not a valid quality.`,
    );

    return collectibleTypes;
  }

  /**
   * Returns an array of collectible types that a player has that are of a particular quality.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all collectible types will necessarily be present when a mod first loads (due to mod load
   * order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getPlayerCollectiblesOfQuality(
    player: EntityPlayer,
    quality: Quality,
  ): readonly CollectibleType[] {
    const collectibleTypesOfQuality =
      this.getCollectibleTypesOfQuality(quality);

    const playerCollectibleTypes: CollectibleType[] = [];
    for (const collectibleType of collectibleTypesOfQuality) {
      // We specify "true" as the second argument to filter out things like Lilith's Incubus.
      const numCollectibles = player.GetCollectibleNum(collectibleType, true);
      repeat(numCollectibles, () => {
        playerCollectibleTypes.push(collectibleType);
      });
    }

    return playerCollectibleTypes;
  }

  // ----------------------
  // Item Config Card Types
  // ----------------------

  /**
   * Helper function to get an array of card types matching the `ItemConfigCardType`.
   *
   * This function is variadic, meaning that you can you can specify N card types to get an array
   * containing cards that match any of the specified types.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @public
   */
  @Exported
  public getCardTypesOfType(
    ...itemConfigCardTypes: readonly ItemConfigCardType[]
  ): readonly CardType[] {
    this.lazyInit();

    const matchingCardTypes: CardType[] = [];
    for (const itemConfigCardType of itemConfigCardTypes) {
      const cardTypes =
        this.itemConfigCardTypeToCardTypeMap.get(itemConfigCardType);
      assertDefined(
        cardTypes,
        `Failed to get the card types for item config type: ${itemConfigCardType}`,
      );

      for (const cardType of cardTypes) {
        matchingCardTypes.push(cardType);
      }
    }

    return matchingCardTypes;
  }

  /**
   * Helper function to get a random card type that matches the provided `ItemConfigCardType`.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * If you want to get an unseeded card type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param itemConfigCardType The item config card type that represents the pool of cards to select
   *                           from.
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param exceptions Optional. An array of cards to not select.
   * @public
   */
  @Exported
  public getRandomCardTypeOfType(
    itemConfigCardType: ItemConfigCardType,
    seedOrRNG: Seed | RNG | undefined,
    exceptions: readonly CardType[] = [],
  ): CardType {
    const cardTypes = this.getCardTypesOfType(itemConfigCardType);
    return getRandomArrayElement(cardTypes, seedOrRNG, exceptions);
  }

  /**
   * Has an equal chance of returning any card (e.g. Fool, Reverse Fool, Wild Card, etc.).
   *
   * This will not return:
   * - any runes
   * - any objects like Dice Shard
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * If you want to get an unseeded card type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param exceptions Optional. An array of cards to not select.
   * @public
   */
  @Exported
  public getRandomCard(
    seedOrRNG: Seed | RNG | undefined,
    exceptions: readonly CardType[] = [],
  ): CardType {
    this.lazyInit();
    return getRandomArrayElement(this.cardTypeCardArray, seedOrRNG, exceptions);
  }

  /**
   * Has an equal chance of returning any rune (e.g. Rune of Hagalaz, Blank Rune, Black Rune, Soul
   * of Isaac, etc.). This will never return a Rune Shard.
   *
   * This function can only be called if at least one callback has been executed. This is because
   * not all card types will necessarily be present when a mod first loads (due to mod load order).
   *
   * If you want to get an unseeded card type, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.MODDED_ELEMENT_SETS`.
   *
   * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @param exceptions Optional. An array of runes to not select.
   * @public
   */
  @Exported
  public getRandomRune(
    seedOrRNG: Seed | RNG | undefined,
    exceptions: readonly CardType[] = [],
  ): CardType {
    const runeCardTypes = this.getCardTypesOfType(ItemConfigCardType.RUNE);
    const runeExceptions = [...exceptions, CardType.RUNE_SHARD];
    return getRandomArrayElement(runeCardTypes, seedOrRNG, runeExceptions);
  }
}

----
classes\features\other\NoSirenSteal.ts
import type { FamiliarVariant } from "isaac-typescript-definitions";
import { EntityType, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    familiarBlacklist: [] as Array<
      [variant: FamiliarVariant, subType: int | undefined]
    >,
  },
};

export class NoSirenSteal extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 27
      [
        ModCallback.POST_NPC_INIT,
        this.postNPCInitSirenHelper,
        [EntityType.SIREN_HELPER],
      ],
    ];
  }

  // ModCallback.POST_NPC_INIT (27)
  // EntityType.SIREN_HELPER (966)
  private readonly postNPCInitSirenHelper = (npc: EntityNPC) => {
    this.checkReturnFamiliarToPlayer(npc);
  };

  private checkReturnFamiliarToPlayer(npc: EntityNPC) {
    if (npc.Target === undefined) {
      return;
    }

    const familiar = npc.Target.ToFamiliar();
    if (familiar === undefined) {
      return;
    }

    if (this.blacklistEntryExists(familiar.Variant, familiar.SubType)) {
      npc.Remove();
      familiar.AddToFollowers();
    }
  }

  private blacklistEntryExists(
    incomingFamiliarVariant: FamiliarVariant,
    incomingFamiliarSubType: int | undefined,
  ): boolean {
    for (const familiarTuple of v.run.familiarBlacklist) {
      const [familiarVariant, familiarSubType] = familiarTuple;

      if (
        familiarVariant === incomingFamiliarVariant &&
        familiarSubType === incomingFamiliarSubType
      ) {
        // There is an entry that matches the variant and sub-type exactly.
        return true;
      }

      if (
        familiarVariant === incomingFamiliarVariant &&
        familiarSubType === undefined
      ) {
        // There is an entry that matches all sub-types for this variant.
        return true;
      }
    }

    return false;
  }

  /**
   * Blacklists a familiar from being stolen by The Siren boss. This should be called once at the
   * beginning of every run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.NO_SIREN_STEAL`.
   *
   * @param familiarVariant The familiar variant to blacklist.
   * @param familiarSubType The sub-type to blacklist. Optional. The default is to blacklist all
   *                        sub-types of the given variant.
   * @public
   */
  @Exported
  public setFamiliarNoSirenSteal(
    familiarVariant: FamiliarVariant,
    familiarSubType?: int,
  ): void {
    if (this.blacklistEntryExists(familiarVariant, familiarSubType)) {
      return;
    }

    v.run.familiarBlacklist.push([familiarVariant, familiarSubType]);
  }
}

----
classes\features\other\Pause.ts
import {
  ButtonAction,
  CollectibleType,
  InputHook,
  ModCallback,
} from "isaac-typescript-definitions";
import { VectorZero } from "../../../core/constants";
import { Exported } from "../../../decorators";
import {
  getProjectiles,
  getTears,
  removeAllProjectiles,
  removeAllTears,
} from "../../../functions/entitiesSpecific";
import { isTear } from "../../../functions/isaacAPIClass";
import { logError } from "../../../functions/log";
import { useActiveItemTemp } from "../../../functions/playerCollectibles";
import { getAllPlayers } from "../../../functions/playerIndex";
import { getTSTLClassName } from "../../../functions/tstlClass";
import { assertDefined } from "../../../functions/utils";
import { ReadonlySet } from "../../../types/ReadonlySet";
import { Feature } from "../../private/Feature";
import type { DisableInputs } from "./DisableInputs";

interface InitialDescription {
  position: Vector;
  positionOffset: Vector;
  velocity: Vector;
  height: float;
  fallingSpeed: float;
  fallingAcceleration: float;
}

const v = {
  run: {
    isPseudoPaused: false,
    shouldUnpause: false,
    initialDescriptions: new Map<PtrHash, InitialDescription>(),
  },
};

export class Pause extends Feature {
  /** @internal */
  public override v = v;

  private readonly disableInputs: DisableInputs;

  /** @internal */
  constructor(disableInputs: DisableInputs) {
    super();

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],

      // 13
      [
        ModCallback.INPUT_ACTION,
        this.inputActionGetActionValue,
        [InputHook.GET_ACTION_VALUE],
      ],
    ];

    this.disableInputs = disableInputs;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = () => {
    if (!v.run.isPseudoPaused) {
      return;
    }

    const firstPlayer = Isaac.GetPlayer();
    useActiveItemTemp(firstPlayer, CollectibleType.PAUSE);

    this.stopTearsAndProjectilesFromMoving();
  };

  private stopTearsAndProjectilesFromMoving() {
    const tearsAndProjectiles = [...getTears(), ...getProjectiles()];

    for (const tearOrProjectile of tearsAndProjectiles) {
      const ptrHash = GetPtrHash(tearOrProjectile);
      const initialDescription = v.run.initialDescriptions.get(ptrHash);
      if (initialDescription === undefined) {
        continue;
      }

      tearOrProjectile.Position = initialDescription.position;
      tearOrProjectile.PositionOffset = initialDescription.positionOffset;
      tearOrProjectile.Velocity = VectorZero;
      tearOrProjectile.Height = initialDescription.height;
      tearOrProjectile.FallingSpeed = 0;
      if (isTear(tearOrProjectile)) {
        tearOrProjectile.FallingAcceleration =
          initialDescription.fallingAcceleration;
      } else {
        tearOrProjectile.FallingAccel = initialDescription.fallingAcceleration;
      }
    }
  }

  // ModCallback.INPUT_ACTION (13)
  // InputHook.GET_ACTION_VALUE (2)
  private readonly inputActionGetActionValue = (
    _entity: Entity | undefined,
    _inputHook: InputHook,
    buttonAction: ButtonAction,
  ): boolean | float | undefined => {
    if (buttonAction !== ButtonAction.SHOOT_RIGHT) {
      return undefined;
    }

    if (!v.run.shouldUnpause) {
      return undefined;
    }
    v.run.shouldUnpause = false;

    // Returning a value of 1 for a single sub-frame will be enough for the game to register an
    // unpause but not enough for a tear to actually be fired.
    return 1;
  };

  /**
   * Helper function to check if the pause feature from `isaacscript-common` is currently
   * pseudo-pausing the game.
   *
   * @public
   */
  @Exported
  public isPaused(): boolean {
    return v.run.isPseudoPaused;
  }

  /**
   * Helper function to emulate what happens when the player pauses the game. Use the `unpause`
   * function to return things back to normal.
   *
   * Under the hood, this function:
   * - uses the Pause collectible on every game frame
   * - disables any player inputs (except for `ButtonAction.MENU_CONFIRM` and
   *   `ButtonAction.CONSOLE`)
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PAUSE`.
   *
   * @public
   */
  @Exported
  public pause(): void {
    if (v.run.isPseudoPaused) {
      logError(
        "Failed to pseudo-pause the game, since it was already pseudo-paused.",
      );
      return;
    }
    v.run.isPseudoPaused = true;

    // Tears/projectiles in the room will move slightly on every frame, even when the Pause
    // collectible is active. Thus, we manually reset the initial positions and heights on every
    // frame.
    v.run.initialDescriptions.clear();
    const tearsAndProjectiles = [...getTears(), ...getProjectiles()];
    for (const tearOrProjectile of tearsAndProjectiles) {
      const ptrHash = GetPtrHash(tearOrProjectile);
      const initialDescription: InitialDescription = {
        position: tearOrProjectile.Position,
        positionOffset: tearOrProjectile.PositionOffset,
        velocity: tearOrProjectile.Velocity,
        height: tearOrProjectile.Height,
        fallingSpeed: tearOrProjectile.FallingSpeed,
        fallingAcceleration: isTear(tearOrProjectile)
          ? tearOrProjectile.FallingAcceleration
          : tearOrProjectile.FallingAccel,
      };
      v.run.initialDescriptions.set(ptrHash, initialDescription);
    }

    const firstPlayer = Isaac.GetPlayer();
    useActiveItemTemp(firstPlayer, CollectibleType.PAUSE);

    const tstlClassName = getTSTLClassName(this);
    assertDefined(
      tstlClassName,
      "Failed to get the class name for the pause feature.",
    );

    const whitelist = new ReadonlySet([
      ButtonAction.MENU_CONFIRM,
      ButtonAction.CONSOLE,
    ]);
    this.disableInputs.disableAllInputsExceptFor(tstlClassName, whitelist);

    for (const player of getAllPlayers()) {
      // Disable the controls to prevent the players from moving, shooting, and so on. (We also
      // disable the inputs in the `INPUT_ACTION` callback, but that does not prevent mouse inputs.)
      player.ControlsEnabled = false;

      // Prevent the players from leaving the room. (If we don't reset the velocity, they can
      // continue to move towards a door.)
      player.Velocity = VectorZero;
    }

    this.stopTearsAndProjectilesFromMoving();
  }

  /**
   * Helper function to put things back to normal after the `pause` function was used.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PAUSE`.
   *
   * @public
   */
  @Exported
  public unpause(): void {
    if (!v.run.isPseudoPaused) {
      logError(
        "Failed to pseudo-unpause the game, since it was not already pseudo-paused.",
      );
      return;
    }
    v.run.isPseudoPaused = false;
    v.run.shouldUnpause = true;

    const tstlClassName = getTSTLClassName(this);
    assertDefined(
      tstlClassName,
      "Failed to find get the class name for the pause feature.",
    );

    this.disableInputs.enableAllInputs(tstlClassName);
    for (const player of getAllPlayers()) {
      player.ControlsEnabled = true;
    }

    // After a vanilla pause, the tears will not resume their normal velocity and will "stick" to
    // the air. Even if we try to help the tears along by explicitly resetting all of the
    // velocity-related variables to their initial values, this will not make a difference. Thus,
    // revert to removing all of the tears and projectiles in the room. (If a Ludovico tear is
    // removed, it will automatically be respawned on the next frame.)
    removeAllTears();
    removeAllProjectiles();
  }
}

----
classes\features\other\PersistentEntities.ts
import type { Dimension, EntityType } from "isaac-typescript-definitions";
import { EntityFlag, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { spawn } from "../../../functions/entities";
import { getRoomListIndex } from "../../../functions/roomData";
import { Feature } from "../../private/Feature";
import type { RoomHistory } from "./RoomHistory";

interface PersistentEntityDescription {
  entityType: EntityType;
  variant: int;
  subType: int;
  dimension: Dimension;
  roomListIndex: int;
  position: Readonly<Vector>;
}

type PersistentEntityTuple = [index: int, entityPtr: EntityPtr];

const v = {
  run: {
    /** Iterates upward as new persistent entities are created. */
    persistentEntityIndexCounter: 0,
  },

  level: {
    /**
     * Indexed by persistent entity index.
     *
     * When the entity is spawned in the currently room, its corresponding entry in this map will be
     * temporarily deleted (until the entity itself is despawned).
     */
    persistentEntities: new Map<int, PersistentEntityDescription>(),
  },

  room: {
    spawnedPersistentEntities: new Map<PtrHash, PersistentEntityTuple>(),
  },
};

export class PersistentEntities extends Feature {
  /** @internal */
  public override v = v;

  private readonly roomHistory: RoomHistory;

  /** @internal */
  constructor(roomHistory: RoomHistory) {
    super();

    this.featuresUsed = [ISCFeature.ROOM_HISTORY];

    this.callbacksUsed = [
      // 67
      [ModCallback.POST_ENTITY_REMOVE, this.postEntityRemove],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.roomHistory = roomHistory;
  }

  // ModCallback.POST_ENTITY_REMOVE (67)
  private readonly postEntityRemove = (entity: Entity) => {
    const ptrHash = GetPtrHash(entity);
    const tuple = v.room.spawnedPersistentEntities.get(ptrHash);
    if (tuple === undefined) {
      return;
    }

    // A persistent entity is being removed, either because it was killed / manually despawned, or
    // the player left the room.
    const index = tuple[0];

    if (this.roomHistory.isLeavingRoom()) {
      this.trackDespawningPickupPosition(entity, index);
    } else {
      this.removePersistentEntity(index, false);
    }
  };

  /**
   * The persistent entity is despawning because the player is in the process of leaving the room.
   * Keep track of the position for later.
   */
  private trackDespawningPickupPosition(entity: Entity, index: int) {
    // (The "latest" room description is really the previous room, because the `POST_NEW_ROOM`
    // callback was not fired yet.)
    const previousRoomDescription = this.roomHistory.getLatestRoomDescription();
    if (previousRoomDescription === undefined) {
      return;
    }

    const persistentEntityDescription: PersistentEntityDescription = {
      entityType: entity.Type,
      variant: entity.Variant,
      subType: entity.SubType,
      dimension: previousRoomDescription.dimension,
      roomListIndex: previousRoomDescription.roomListIndex,
      position: entity.Position,
    };
    v.level.persistentEntities.set(index, persistentEntityDescription);
  }

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    const roomListIndex = getRoomListIndex();
    const persistentEntities = [...v.level.persistentEntities.entries()];
    const persistentEntitiesInThisRoom = persistentEntities.filter(
      ([_index, description]) => roomListIndex === description.roomListIndex,
    );

    for (const [index, description] of persistentEntitiesInThisRoom) {
      v.level.persistentEntities.delete(index);
      this.spawnAndTrack(
        description.entityType,
        description.variant,
        description.subType,
        description.position,
        index,
        true,
      );
    }
  };

  private spawnAndTrack(
    entityType: EntityType,
    variant: int,
    subType: int,
    position: Vector,
    index: int,
    respawning = false,
  ): Entity {
    const entity = spawn(entityType, variant, subType, position);
    if (respawning) {
      entity.ClearEntityFlags(EntityFlag.APPEAR);
    }

    const ptrHash = GetPtrHash(entity);

    // Keep track that we spawned it so that we can respawn it if the player re-enters the room.
    const tuple: [int, EntityPtr] = [index, EntityPtr(entity)];
    v.room.spawnedPersistentEntities.set(ptrHash, tuple);

    return entity;
  }

  /**
   * Helper function to stop an entity spawned with the `spawnPersistentEntity` helper function from
   * respawning.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PERSISTENT_ENTITIES`.
   *
   * @param persistentEntityIndex The index that was returned by the `spawnPersistentEntity`
   *                              function.
   * @param removeEntity Optional. True by default. Set to false if you want to stop an entity from
   *                     being persistent but you don't want to actually remove the
   *                     currently-spawned entity from the room.
   * @public
   */
  @Exported
  public removePersistentEntity(
    persistentEntityIndex: int,
    removeEntity = true,
  ): void {
    v.level.persistentEntities.delete(persistentEntityIndex);

    for (const [ptrHash, tuple] of v.room.spawnedPersistentEntities) {
      const [index, entityPtr] = tuple;
      if (index !== persistentEntityIndex) {
        continue;
      }

      v.room.spawnedPersistentEntities.delete(ptrHash);

      if (removeEntity && entityPtr.Ref !== undefined) {
        entityPtr.Ref.Remove();
      }
    }
  }

  /**
   * Helper function to spawn an entity that will have persistence similar to a pickup.
   *
   * By default, as soon as you leave a room, any spawned entities will be despawned and will not
   * return if the player revisits the room. This means that if you want to have an entity like a
   * pickup, you have to manually respawn it when the player re-enters the room. Use this helper
   * function to avoid having to do any tracking on your own.
   *
   * Conventionally, the word "persistent" refers to `EntityFlag.FLAG_PERSISTENT`, which is used on
   * e.g. familiars to make them appear in every room. On the other hand, pickups are also
   * persistent, but they are not present in every room, only one specific room. This function
   * spawns entities like pickups, not familiars.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PERSISTENT_ENTITIES`.
   *
   * @returns An object containing the entity and the persistent entity index. You can use the index
   *          with the `removePersistentEntity` function.
   * @public
   */
  @Exported
  public spawnPersistentEntity(
    entityType: EntityType,
    variant: int,
    subType: int,
    position: Vector,
  ): { entity: Entity; persistentIndex: int } {
    v.run.persistentEntityIndexCounter++;

    const entity = this.spawnAndTrack(
      entityType,
      variant,
      subType,
      position,
      v.run.persistentEntityIndexCounter,
    );

    return { entity, persistentIndex: v.run.persistentEntityIndexCounter };
  }
}

----
classes\features\other\PickupIndexCreation.ts
import {
  EntityType,
  ModCallback,
  RoomType,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { getEntityID } from "../../../functions/entities";
import { onOrBeforeRoomFrame } from "../../../functions/frames";
import { getRoomListIndex } from "../../../functions/roomData";
import { onAscent } from "../../../functions/stage";
import { vectorEquals } from "../../../functions/vector";
import type { PickupIndex } from "../../../types/PickupIndex";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";
import type { RoomHistory } from "./RoomHistory";
import type { SaveDataManager } from "./SaveDataManager";

interface PickupDescription {
  position: Vector;
  initSeed: Seed;
}

const v = {
  run: {
    /** Is incremented before assignment. Thus, the first pickup will have an index of 1. */
    pickupCounter: 0 as PickupIndex,

    pickupDataTreasureRooms: new Map<PickupIndex, PickupDescription>(),
    pickupDataBossRooms: new Map<PickupIndex, PickupDescription>(),
  },

  level: {
    /** Indexed by room list index. */
    pickupData: new DefaultMap<int, Map<PickupIndex, PickupDescription>>(
      () => new Map(),
    ),
  },

  room: {
    pickupIndexes: new Map<PtrHash, PickupIndex>(),
  },
};

export class PickupIndexCreation extends Feature {
  /** @internal */
  public override v = v;

  private readonly roomHistory: RoomHistory;
  private readonly saveDataManager: SaveDataManager;

  /** @internal */
  constructor(roomHistory: RoomHistory, saveDataManager: SaveDataManager) {
    super();

    this.featuresUsed = [ISCFeature.ROOM_HISTORY, ISCFeature.SAVE_DATA_MANAGER];

    this.callbacksUsed = [
      // 34
      [ModCallback.POST_PICKUP_INIT, this.postPickupInit],

      // 67
      [
        ModCallback.POST_ENTITY_REMOVE,
        this.postEntityRemovePickup,
        [EntityType.PICKUP],
      ],
    ];

    this.roomHistory = roomHistory;
    this.saveDataManager = saveDataManager;
  }

  // ModCallback.POST_PICKUP_INIT (34)
  private readonly postPickupInit = (pickup: EntityPickup) => {
    this.setPickupIndex(pickup);
  };

  private setPickupIndex(pickup: EntityPickup): void {
    const ptrHash = GetPtrHash(pickup);

    // In certain situations, pickups can be morphed, which will trigger the `POST_PICKUP_INIT`
    // callback but should not incur a new pickup counter. (For example, the collectible rotation
    // with Tainted Isaac.) For these situations, we will already be tracking an index for this
    // pointer hash.
    if (v.room.pickupIndexes.has(ptrHash)) {
      return;
    }

    // First, handle the special case of re-entering a room with a previously tracked pickup. If we
    // find a match in the level pickup data, we will use the pickup index from the match.
    const pickupIndexFromLevelData =
      this.getPickupIndexFromPreviousData(pickup);
    const room = game.GetRoom();
    const isFirstVisit = room.IsFirstVisit();
    if (
      pickupIndexFromLevelData !== undefined &&
      !isFirstVisit &&
      onOrBeforeRoomFrame(0)
    ) {
      v.room.pickupIndexes.set(ptrHash, pickupIndexFromLevelData);
      return;
    }

    // This is a brand new pickup that we have not previously seen on this run.
    v.run.pickupCounter++;
    v.room.pickupIndexes.set(ptrHash, v.run.pickupCounter);
  }

  private getPickupIndexFromPreviousData(
    pickup: EntityPickup,
  ): PickupIndex | undefined {
    const roomListIndex = getRoomListIndex();
    const pickupDescriptions =
      v.level.pickupData.getAndSetDefault(roomListIndex);

    let pickupIndex = getStoredPickupIndex(pickup, pickupDescriptions);
    if (pickupIndex === undefined) {
      pickupIndex = this.getPostAscentPickupIndex(pickup);
    }

    return pickupIndex;
  }

  // ModCallback.POST_ENTITY_REMOVE (67)
  // EntityType.PICKUP (5)
  private readonly postEntityRemovePickup = (entity: Entity) => {
    this.checkDespawningFromPlayerLeavingRoom(entity);
  };

  private checkDespawningFromPlayerLeavingRoom(entity: Entity) {
    const ptrHash = GetPtrHash(entity);
    const pickupIndex = v.room.pickupIndexes.get(ptrHash);
    if (pickupIndex === undefined) {
      return;
    }

    if (!this.roomHistory.isLeavingRoom()) {
      return;
    }

    this.trackDespawningPickupMetadata(entity, pickupIndex);
  }

  /**
   * This is a pickup that is despawning because the player is in the process of leaving the room.
   * Keep track of the metadata for later.
   */
  private trackDespawningPickupMetadata(
    entity: Entity,
    pickupIndex: PickupIndex,
  ) {
    // The "latest" room description is really the previous room, because the `POST_NEW_ROOM`
    // callback has not fired yet.
    const previousRoomDescription = this.roomHistory.getLatestRoomDescription();
    if (previousRoomDescription === undefined) {
      return;
    }

    const previousRoomListIndex = previousRoomDescription.roomListIndex;
    const pickupDescriptions = v.level.pickupData.getAndSetDefault(
      previousRoomListIndex,
    );

    const pickupDescription: PickupDescription = {
      position: entity.Position,
      initSeed: entity.InitSeed,
    };
    pickupDescriptions.set(pickupIndex, pickupDescription);

    const pickupDataMapForCurrentRoom = this.getPickupDataMapForCurrentRoom();
    if (pickupDataMapForCurrentRoom !== undefined) {
      pickupDataMapForCurrentRoom.set(pickupIndex, pickupDescription);
    }

    // Since the `POST_ENTITY_REMOVE` callback fires after the `PRE_GAME_EXIT` callback, we need to
    // explicitly save data again if the player is in the process of saving and quitting the run.
    if (this.saveDataManager.saveDataManagerInMenu()) {
      this.saveDataManager.saveDataManagerSave();
    }
  }

  /**
   * If the despawning pickup was in a Treasure Room or Boss Room, then it is possible that the
   * pickup could re-appear during The Ascent. If this is the case, we store the metadata on a
   * separate map to reference later.
   */
  private getPickupDataMapForCurrentRoom():
    | Map<PickupIndex, PickupDescription>
    | undefined {
    if (onAscent()) {
      return undefined;
    }

    const room = game.GetRoom();
    const roomType = room.GetType();

    switch (roomType) {
      case RoomType.TREASURE: {
        return v.run.pickupDataTreasureRooms;
      }

      case RoomType.BOSS: {
        return v.run.pickupDataBossRooms;
      }

      default: {
        return undefined;
      }
    }
  }

  private getPostAscentPickupIndex(
    pickup: EntityPickup,
  ): PickupIndex | undefined {
    // If we have not found the pickup index yet, we might be re-entering a post-Ascent Treasure
    // Room or Boss Room.
    if (!onAscent()) {
      return undefined;
    }

    const room = game.GetRoom();
    const roomType = room.GetType();

    switch (roomType) {
      case RoomType.TREASURE: {
        return getStoredPickupIndex(pickup, v.run.pickupDataTreasureRooms);
      }

      case RoomType.BOSS: {
        return getStoredPickupIndex(pickup, v.run.pickupDataBossRooms);
      }

      default: {
        return undefined;
      }
    }
  }

  /**
   * Mods often have to track variables relating to a pickups. Finding an index for these kinds of
   * data structures is difficult, since pickups are respawned every time a player re-enters a room,
   * so the `PtrHash` will change.
   *
   * Use this function to get a unique index for a pickup to use in these data structures.
   *
   * Specifically, `PickupIndex` is a number that represents the spawn order of the pickup on the
   * current run. For example, the first pickup spawned will have an index of 1, the second one will
   * have an index of 2, and so on.
   *
   * Tracking pickups requires stateful tracking, so using pickup indexes requires an upgraded mod.
   *
   * Note that the pickup index will not change:
   * - When a pickup is rolled with e.g. D6 or D20.
   * - When an item is "rotated" via e.g. Tainted Isaac's mechanic.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.PICKUP_INDEX_CREATION`.
   */
  @Exported
  public getPickupIndex(pickup: EntityPickup): PickupIndex {
    const ptrHash = GetPtrHash(pickup);
    const pickupIndexInitial = v.room.pickupIndexes.get(ptrHash);
    if (pickupIndexInitial !== undefined) {
      return pickupIndexInitial;
    }

    this.setPickupIndex(pickup);
    const pickupIndex = v.room.pickupIndexes.get(ptrHash);
    if (pickupIndex !== undefined) {
      return pickupIndex;
    }

    const entityID = getEntityID(pickup);
    error(`Failed to generate a new pickup index for pickup: ${entityID}`);
  }
}

function getStoredPickupIndex(
  pickup: Entity,
  pickupDescriptions: ReadonlyMap<PickupIndex, PickupDescription>,
): PickupIndex | undefined {
  for (const [pickupIndex, pickupDescription] of pickupDescriptions) {
    if (
      vectorEquals(pickupDescription.position, pickup.Position) &&
      pickupDescription.initSeed === pickup.InitSeed
    ) {
      return pickupIndex;
    }
  }

  return undefined;
}

----
classes\features\other\PlayerCollectibleTracking.ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { arrayRemoveInPlace } from "../../../functions/array";
import { isActiveCollectible } from "../../../functions/collectibles";
import { defaultMapGetPlayer } from "../../../functions/playerDataStructures";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    playersCollectibleTypes: new DefaultMap<
      PlayerIndex,
      CollectibleType[],
      [player: EntityPlayer]
    >(() => []),
  },
};

export class PlayerCollectibleTracking extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED,
        this.postPlayerCollectibleAdded,
      ],
      [
        ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED,
        this.postPlayerCollectibleRemoved,
      ],
    ];
  }

  // ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED
  private readonly postPlayerCollectibleAdded = (
    player: EntityPlayer,
    collectibleType: CollectibleType,
  ) => {
    const collectibleTypes = defaultMapGetPlayer(
      v.run.playersCollectibleTypes,
      player,
      player,
    );
    collectibleTypes.push(collectibleType);
  };

  // ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED
  private readonly postPlayerCollectibleRemoved = (
    player: EntityPlayer,
    collectibleType: CollectibleType,
  ) => {
    const collectibleTypes = defaultMapGetPlayer(
      v.run.playersCollectibleTypes,
      player,
      player,
    );
    arrayRemoveInPlace(collectibleTypes, collectibleType);
  };

  /**
   * Helper function to get all of the collectible types that the player has gotten so far on this
   * run, in order.
   *
   * In the case of items given on the first frame of the run or the case where the player rerolls
   * their build in the middle of the run (e.g. with D4), the order of the collectible types will
   * not correspond to the order that the items were actually given to the player. In this case, the
   * order will be from the lowest `CollectibleType` to the highest.
   *
   * Under the hood, this feature works by tracking the number of collectibles that a player has on
   * every frame. Thus, in a situation where a collectible was both added and removed to the player
   * on the same frame, the amount of total collectibles would stay the same, and the collectible
   * types would not be updated. In vanilla, this situation would never happen, but another mod
   * might do this for some reason. (With that said, the next time that a collectible is normally
   * added or removed, it would trigger a re-scan, and the previous changes would be picked up.)
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.PLAYER_COLLECTIBLE_TRACKING`.
   *
   * @param player The player to get the collectible types for.
   * @param includeActiveCollectibles Optional. If true, will include all active collectibles.
   *                                Default is true.
   * @public
   */
  @Exported
  public getPlayerCollectibleTypes(
    player: EntityPlayer,
    includeActiveCollectibles = true,
  ): readonly CollectibleType[] {
    const collectibleTypes = defaultMapGetPlayer(
      v.run.playersCollectibleTypes,
      player,
      player,
    );

    if (includeActiveCollectibles) {
      return collectibleTypes;
    }

    return collectibleTypes.filter(
      (collectibleType) => !isActiveCollectible(collectibleType),
    );
  }

  /**
   * Helper function to get the last passive collectible type that the player picked up. In most
   * cases, this will be the passive that would be removed if the player used Clicker.
   *
   * Returns undefined if the player does not have any passive collectibles.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.PLAYER_COLLECTIBLE_TRACKING`.
   *
   * @public
   */
  @Exported
  public getPlayerLastPassiveCollectibleType(
    player: EntityPlayer,
  ): CollectibleType | undefined {
    const collectibleTypes = this.getPlayerCollectibleTypes(player, false);
    return collectibleTypes.at(-1);
  }
}

----
classes\features\other\PonyDetection.ts
import { CollectibleType, EntityFlag } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { hasFlag } from "../../../functions/flag";
import {
  setAddPlayer,
  setDeletePlayer,
  setHasPlayer,
} from "../../../functions/playerDataStructures";
import { getPlayers } from "../../../functions/playerIndex";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { Feature } from "../../private/Feature";

const FLAGS_WHEN_PONY_IS_ACTIVE = [
  EntityFlag.NO_KNOCKBACK, // 1 << 26
  EntityFlag.NO_PHYSICS_KNOCKBACK, // 1 << 30
  EntityFlag.NO_DAMAGE_BLINK, // 1 << 36
] as const;

const v = {
  run: {
    playersIsPonyActive: new Set<PlayerIndex>(),
  },
};

export class PonyDetection extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED,
        this.postPEffectUpdateReordered,
      ],
    ];
  }

  // ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED
  private readonly postPEffectUpdateReordered = (player: EntityPlayer) => {
    const effects = player.GetEffects();
    const entityFlags = player.GetEntityFlags();
    const hasPonyCollectibleEffect =
      effects.HasCollectibleEffect(CollectibleType.PONY) ||
      effects.HasCollectibleEffect(CollectibleType.WHITE_PONY);
    const isPonyActiveOnPreviousFrame = setHasPlayer(
      v.run.playersIsPonyActive,
      player,
    );
    const hasPonyFlags = hasFlag(entityFlags, ...FLAGS_WHEN_PONY_IS_ACTIVE);

    const isPonyActiveNow =
      hasPonyCollectibleEffect || (isPonyActiveOnPreviousFrame && hasPonyFlags);
    if (isPonyActiveNow) {
      setAddPlayer(v.run.playersIsPonyActive, player);
    } else {
      setDeletePlayer(v.run.playersIsPonyActive, player);
    }
  };

  /**
   * Helper function to see if the player is under the effects of A Pony or White Pony charge.
   * Detecting this is difficult, as the temporary effect will disappear upon entering a new room.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PONY_DETECTION`.
   *
   * @public
   */
  @Exported
  public isPlayerUsingPony(player: EntityPlayer): boolean {
    return setHasPlayer(v.run.playersIsPonyActive, player);
  }

  /**
   * Helper function to see if any player is under the effects of A Pony or White Pony charge.
   * Detecting this is difficult, as the temporary effect will disappear upon entering a new room.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PONY_DETECTION`.
   *
   * @public
   */
  @Exported
  public anyPlayerUsingPony(): boolean {
    const players = getPlayers();
    return players.some((player) => this.isPlayerUsingPony(player));
  }
}

----
classes\features\other\PressInput.ts
import type { ButtonAction } from "isaac-typescript-definitions";
import { InputHook, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { getPlayerIndex } from "../../../functions/playerIndex";
import type { PlayerIndex } from "../../../types/PlayerIndex";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    buttonActionPairs: [] as Array<{
      playerIndex: PlayerIndex;
      buttonAction: ButtonAction;
    }>,
  },
};

export class PressInput extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 13
      [
        ModCallback.INPUT_ACTION,
        this.isActionTriggered,
        [InputHook.IS_ACTION_TRIGGERED],
      ],
    ];
  }

  // ModCallback.INPUT_ACTION (13)
  // InputHook.IS_ACTION_TRIGGERED (1)
  private readonly isActionTriggered = (
    entity: Entity | undefined,
    _inputHook: InputHook,
    buttonAction: ButtonAction,
  ) => {
    if (entity === undefined) {
      return undefined;
    }

    const player = entity.ToPlayer();
    if (player === undefined) {
      return undefined;
    }

    const playerIndex = getPlayerIndex(player);

    for (let i = v.run.buttonActionPairs.length - 1; i >= 0; i--) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const pair = v.run.buttonActionPairs[i]!;

      if (
        pair.playerIndex === playerIndex &&
        pair.buttonAction === buttonAction
      ) {
        v.run.buttonActionPairs.splice(i);
        return true;
      }
    }

    return undefined;
  };

  /**
   * Helper function to press an arbitrary `ButtonAction` on the next possible input poll. In most
   * cases, this will be equivalent to if the first player pressed the corresponding input. It
   * usually takes 1 frame for the input to take effect.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.PRESS_INPUT`.
   */
  @Exported
  public pressInput(player: EntityPlayer, buttonAction: ButtonAction): void {
    const playerIndex = getPlayerIndex(player);
    v.run.buttonActionPairs.push({ playerIndex, buttonAction });
  }
}

----
classes\features\other\PreventChildEntities.ts
import { ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { Feature } from "../../private/Feature";

const v = {
  room: {
    preventingEntities: new Set<PtrHash>(),
  },
};

export class PreventChildEntities extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 27
      [ModCallback.POST_NPC_INIT, this.postNPCInit],
    ];
  }

  // ModCallback.POST_NPC_INIT (27)
  private readonly postNPCInit = (npc: EntityNPC) => {
    const spawnerEntityMatch =
      npc.SpawnerEntity !== undefined &&
      v.room.preventingEntities.has(GetPtrHash(npc.SpawnerEntity));

    const parentMatch =
      npc.Parent !== undefined &&
      v.room.preventingEntities.has(GetPtrHash(npc.Parent));

    if (spawnerEntityMatch || parentMatch) {
      npc.Remove();
    }
  };

  /**
   * Helper function to prevent an entity from spawning any other entities. Meant to be used on NPCs
   * like Squirts. This behavior will only last for the current room.
   *
   * Under the hood, this function will remove any new NPCs spawned that have a
   * `Entity.SpawnerEntity` or `Entity.Parent` value that matches the provided entity. (They are
   * removed during the `POST_NPC_INIT` callback specifically.)
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.PREVENT_CHILD_ENTITIES`.
   *
   * @public
   */
  @Exported
  public preventChildEntities(entity: Entity): void {
    const ptrHash = GetPtrHash(entity);
    v.room.preventingEntities.add(ptrHash);
  }
}

----
classes\features\other\PreventGridEntityRespawn.ts
import type { ActiveSlot, UseFlag } from "isaac-typescript-definitions";
import {
  CollectibleType,
  GridEntityType,
  ModCallback,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { emptyArray } from "../../../functions/array";
import {
  getAllGridIndexes,
  getGridEntities,
  removeGridEntity,
  setGridEntityInvisible,
  spawnGridEntity,
} from "../../../functions/gridEntities";
import { getPlayerFromPtr } from "../../../functions/players";
import { getRoomListIndex } from "../../../functions/roomData";
import { DefaultMap } from "../../DefaultMap";
import { Feature } from "../../private/Feature";
import type { RunInNFrames } from "./RunInNFrames";

const v = {
  level: {
    roomListIndexToDecorationGridIndexes: new DefaultMap<int, int[]>(() => []),
  },

  room: {
    manuallyUsingShovel: false,
  },
};

export class PreventGridEntityRespawn extends Feature {
  /** @internal */
  public override v = v;

  private readonly runInNFrames: RunInNFrames;

  /** @internal */
  constructor(runInNFrames: RunInNFrames) {
    super();

    this.featuresUsed = [ISCFeature.RUN_IN_N_FRAMES];

    this.callbacksUsed = [
      // 23
      [
        ModCallback.PRE_USE_ITEM,
        this.preUseItemWeNeedToGoDeeper,
        [CollectibleType.WE_NEED_TO_GO_DEEPER],
      ],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];

    this.runInNFrames = runInNFrames;
  }

  // ModCallback.PRE_USE_ITEM (23)
  // CollectibleType.WE_NEED_TO_GO_DEEPER (84)
  private readonly preUseItemWeNeedToGoDeeper = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: ActiveSlot,
    _customVarData: int,
  ): boolean | undefined => {
    if (v.room.manuallyUsingShovel) {
      return undefined;
    }

    const roomListIndex = getRoomListIndex();
    if (!v.level.roomListIndexToDecorationGridIndexes.has(roomListIndex)) {
      return undefined;
    }

    // Since the room was filled with decorations to prevent any grid entities from respawning, if
    // the player uses a shovel, it will always reveal a crawl space. In order to restore the normal
    // shovel functionality, we cancel the shovel use, remove all the decorations, wait a frame,
    // manually use the shovel again, and then respawn the decorations. (We can't do it all on this
    // frame because updating the room causes two invocations of the shovel to happen.)
    const decorations = getGridEntities(GridEntityType.DECORATION);
    for (const decoration of decorations) {
      removeGridEntity(decoration, false);
    }

    const entityPtr = EntityPtr(player);
    this.runInNFrames.runNextGameFrame(() => {
      const futurePlayer = getPlayerFromPtr(entityPtr);
      if (futurePlayer === undefined) {
        return;
      }

      const futureRoomListIndex = getRoomListIndex();
      if (futureRoomListIndex !== roomListIndex) {
        return;
      }

      v.room.manuallyUsingShovel = true;
      futurePlayer.UseActiveItem(CollectibleType.WE_NEED_TO_GO_DEEPER);
      v.room.manuallyUsingShovel = false;

      const decorationGridIndexes =
        v.level.roomListIndexToDecorationGridIndexes.getAndSetDefault(
          roomListIndex,
        );
      emptyArray(decorationGridIndexes);
      this.preventGridEntityRespawn();
    });

    // Cancel the original effect.
    return true;
  };

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    this.setDecorationsInvisible();
  };

  /**
   * Every time we re-enter the room, the sprites for all of the decorations will come back, so we
   * have to remove them again.
   */
  private setDecorationsInvisible() {
    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();
    const decorationGridIndexes =
      v.level.roomListIndexToDecorationGridIndexes.get(roomListIndex);
    if (decorationGridIndexes === undefined) {
      return;
    }

    for (const gridIndex of decorationGridIndexes) {
      const gridEntity = room.GetGridEntity(gridIndex);
      if (gridEntity !== undefined) {
        // Other grid entities may have spawned, like trapdoors or crawl spaces. Thus, only make
        // decorations invisible.
        const gridEntityType = gridEntity.GetType();
        if (gridEntityType === GridEntityType.DECORATION) {
          setGridEntityInvisible(gridEntity);
        }
      }
    }
  }

  /**
   * Helper function to prevent any removed grid entities from respawning if the player re-enters
   * the current room.
   *
   * This is accomplished by spawning a new grid entity on every tile that does not already have a
   * grid entity. This will force the game to spawn the new grid entity instead of the old one. The
   * natural grid entity to choose for this purpose is a decoration, since it is non-interacting.
   * Then, the decorations are made invisible and any shovel uses are intercepted to avoid creating
   * a crawl space (instead of a trapdoor).
   *
   * Another option besides decorations would be to use a pressure plates with a state of 1, which
   * is a state that is normally unused by the game and makes it invisible & persistent. However,
   * pickups will not be able to spawn on pressure plates, which lead to various bugs (e.g. pickups
   * spawning on top of pits). Thus, using a decoration is preferable.
   *
   * Yet another option to accomplish this would be to replace the room data with that of an empty
   * room. However, the room data must exactly match the room type, the room shape, and the doors,
   * so this is not possible to do in a robust way without adding empty rooms to the mod's `content`
   * folder to draw the data from.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.PREVENT_GRID_ENTITY_RESPAWN`.
   */
  @Exported
  public preventGridEntityRespawn(): void {
    const room = game.GetRoom();
    const roomListIndex = getRoomListIndex();

    const decorationGridIndexes =
      v.level.roomListIndexToDecorationGridIndexes.getAndSetDefault(
        roomListIndex,
      );

    for (const gridIndex of getAllGridIndexes()) {
      const existingGridEntity = room.GetGridEntity(gridIndex);
      if (existingGridEntity !== undefined) {
        continue;
      }

      const decoration = spawnGridEntity(GridEntityType.DECORATION, gridIndex);
      if (decoration !== undefined) {
        setGridEntityInvisible(decoration);
      }

      decorationGridIndexes.push(gridIndex);
    }
  }
}

----
classes\features\other\RerunDetection.ts
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { inStartingRoom } from "../../../functions/rooms";
import { onFirstFloor } from "../../../functions/stage";
import { Feature } from "../../private/Feature";

const v = {
  // We cannot use a "run" object since the variables would be reset when a rerun starts.
  persistent: {
    pastFirstFloor: false,
    onRerun: false,
  },
};

export class RerunDetection extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED,
        this.postGameStartedReordered,
      ],
      [ModCallbackCustom.POST_NEW_LEVEL_REORDERED, this.postNewLevelReordered],
    ];
  }

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED
  private readonly postGameStartedReordered = (isContinued: boolean) => {
    if (isContinued) {
      if (onFirstFloor() && inStartingRoom() && v.persistent.pastFirstFloor) {
        v.persistent.onRerun = true;
      }
    } else {
      v.persistent.onRerun = false;
    }
  };

  // ModCallbackCustom.POST_NEW_LEVEL_REORDERED
  private readonly postNewLevelReordered = () => {
    v.persistent.pastFirstFloor = !onFirstFloor();
  };

  /**
   * Helper function to detect if the current run was starting using the "Rerun" option from the
   * main menu.
   *
   * Under the hood, this assumes that any run that is past the first floor and continues in the
   * starting room of the run is a rerun.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RERUN_DETECTION`.
   *
   * @public
   */
  @Exported
  public onRerun(): boolean {
    return v.persistent.onRerun;
  }
}

----
classes\features\other\RoomClearFrame.ts
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { Feature } from "../../private/Feature";

const v = {
  room: {
    roomClearGameFrame: undefined as int | undefined,
    roomClearRenderFrame: undefined as int | undefined,
    roomClearRoomFrame: undefined as int | undefined,
  },
};

export class RoomClearFrame extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_ROOM_CLEAR_CHANGED,
        this.postRoomClearChangedTrue,
      ],
    ];
  }

  // ModCallbackCustom.POST_ROOM_CLEAR_CHANGED
  // true
  private readonly postRoomClearChangedTrue = () => {
    const gameFrameCount = game.GetFrameCount();
    const room = game.GetRoom();
    const roomFrameCount = room.GetFrameCount();
    const renderFrameCount = Isaac.GetFrameCount();

    v.room.roomClearGameFrame = gameFrameCount;
    v.room.roomClearRenderFrame = renderFrameCount;
    v.room.roomClearRoomFrame = roomFrameCount;
  };

  /**
   * Helper function to get the game frame (i.e. `Game.GetFrameCount`) of the last time that this
   * room was cleared. Returns undefined if the room has never been cleared.
   *
   * Note that if the room is left, all room clear tracking for it will be discarded.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_CLEAR_FRAME`.
   *
   * @public
   */
  @Exported
  public getRoomClearGameFrame(): int | undefined {
    return v.room.roomClearGameFrame;
  }

  /**
   * Helper function to get the render frame (i.e. `Isaac.GetFrameCount`) of the last time that this
   * room was cleared. Returns undefined if the room has never been cleared.
   *
   * Note that if the room is left, all room clear tracking for it will be discarded.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_CLEAR_FRAME`.
   *
   * @public
   */
  @Exported
  public getRoomClearRenderFrame(): int | undefined {
    return v.room.roomClearRenderFrame;
  }

  /**
   * Helper function to get the room frame (i.e. `Room.GetFrameCount`) of the last time that this
   * room was cleared. Returns undefined if the room has never been cleared.
   *
   * Note that if the room is left, all room clear tracking for it will be discarded.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_CLEAR_FRAME`.
   *
   * @public
   */
  @Exported
  public getRoomClearRoomFrame(): int | undefined {
    return v.room.roomClearRoomFrame;
  }
}

----
classes\features\other\RoomHistory.ts
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { getDimension } from "../../../functions/dimensions";
import {
  getRoomGridIndex,
  getRoomListIndex,
  getRoomName,
  getRoomStageID,
  getRoomSubType,
  getRoomVariant,
  getRoomVisitedCount,
} from "../../../functions/roomData";
import type { RoomDescription } from "../../../interfaces/RoomDescription";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    roomHistory: [] as Array<Readonly<RoomDescription>>,
  },
};

export class RoomHistory extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_EARLY, this.postNewRoomEarly],
    ];
  }

  // ModCallbackCustom.POST_NEW_ROOM_EARLY
  private readonly postNewRoomEarly = () => {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();
    const room = game.GetRoom();
    const roomType = room.GetType();
    const seeds = game.GetSeeds();
    const startSeedString = seeds.GetStartSeedString();
    const stageID = getRoomStageID();
    const dimension = getDimension();
    const roomVariant = getRoomVariant();
    const roomSubType = getRoomSubType();
    const roomName = getRoomName();
    const roomGridIndex = getRoomGridIndex();
    const roomListIndex = getRoomListIndex();
    const roomVisitedCount = getRoomVisitedCount();

    const roomDescription: RoomDescription = {
      startSeedString,
      stage,
      stageType,
      stageID,
      dimension,
      roomType,
      roomVariant,
      roomSubType,
      roomName,
      roomGridIndex,
      roomListIndex,
      roomVisitedCount,
    };
    v.run.roomHistory.push(roomDescription);
  };

  /**
   * Helper function to manually delete the last room description from the internal array. This is
   * useful if a mod needs to send the player to a room temporarily and the room should not count as
   * the player having traveled to that room.
   *
   * @public
   */
  @Exported
  public deleteLastRoomDescription(): void {
    v.run.roomHistory.pop();
  }

  /**
   * Helper function to get the total number of rooms that the player has entered thus far on the
   * run. (Re-entering the same room will increment the number returned.)
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_HISTORY`.
   *
   * @public
   */
  @Exported
  public getNumRoomsEntered(): int {
    return v.run.roomHistory.length;
  }

  /**
   * Helper function to get information about all of the rooms that a player has visited thus far on
   * this run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_HISTORY`.
   *
   * @public
   */
  @Exported
  public getRoomHistory(): ReadonlyArray<Readonly<RoomDescription>> {
    return v.run.roomHistory;
  }

  /**
   * Helper function to get information about the room that was previously visited.
   *
   * In the special case of only one room having been visited thus far (i.e. the starting room of
   * the run), the starting room will be returned.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_HISTORY`.
   *
   * @public
   */
  @Exported
  public getPreviousRoomDescription(): Readonly<RoomDescription> {
    const previousRoomDescription = v.run.roomHistory.at(-2);
    if (previousRoomDescription !== undefined) {
      return previousRoomDescription;
    }

    const startingRoomDescription = v.run.roomHistory[0];
    if (startingRoomDescription !== undefined) {
      return startingRoomDescription;
    }

    error(
      "Failed to find a room description for any rooms thus far on this run.",
    );
  }

  /**
   * Helper function to get information about the most recent room that is stored in the room
   * history array.
   *
   * This is useful in the `POST_ENTITY_REMOVE` callback; see the `isLeavingRoom` function.
   *
   * Note that this function can return undefined in the case where it is called on the first room
   * of the run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_HISTORY`.
   *
   * @public
   */
  @Exported
  public getLatestRoomDescription(): Readonly<RoomDescription> | undefined {
    return v.run.roomHistory.at(-1);
  }

  /**
   * Helper function to detect if the player is on the first room of the room.
   *
   * @public
   */
  @Exported
  public inFirstRoom(): boolean {
    return v.run.roomHistory.length === 1;
  }

  /**
   * Helper function to detect if the game is in the state where the room index has changed to a new
   * room, but the entities from the previous room are currently in the process of despawning. (At
   * this point, the `POST_NEW_ROOM` callback and the `POST_NEW_ROOM_EARLY` callback will not have
   * fired yet, and there will not be an entry in the room history array for the current room.)
   *
   * This function is intended to be used in the `POST_ENTITY_REMOVE` callback to detect when an
   * entity is despawning.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.ROOM_HISTORY`.
   *
   * @public
   */
  @Exported
  public isLeavingRoom(): boolean {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();
    const seeds = game.GetSeeds();
    const startSeedString = seeds.GetStartSeedString();
    const roomListIndex = getRoomListIndex();
    const roomVisitedCount = getRoomVisitedCount();
    const latestRoomDescription = this.getLatestRoomDescription();

    // Sometimes, this function can be called in situations where entities from the previous run are
    // being despawned. If this is the case, then the room history will currently be empty.
    if (latestRoomDescription === undefined) {
      return false;
    }

    return (
      startSeedString !== latestRoomDescription.startSeedString ||
      stage !== latestRoomDescription.stage ||
      stageType !== latestRoomDescription.stageType ||
      roomListIndex !== latestRoomDescription.roomListIndex ||
      roomVisitedCount !== latestRoomDescription.roomVisitedCount
    );
  }
}

----
classes\features\other\RunInNFrames.ts
import type { PlayerType } from "isaac-typescript-definitions";
import { ModCallback } from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { arrayRemoveInPlace } from "../../../functions/array";
import { restart } from "../../../functions/run";
import { Feature } from "../../private/Feature";
import type { RoomHistory } from "./RoomHistory";

/** Used for `runInNFrames` functions. */
interface QueuedFunction {
  func: () => void;
  frameCountToFire: int;
  numRoomsEntered: int;
  cancelIfRoomChanges: boolean;
}

/**
 * Used for `setInterval` functions.
 *
 * The return value is whether to continue the function from firing.
 */
interface IntervalFunction extends QueuedFunction {
  func: () => boolean;
  numIntervalFrames: int;
}

const v = {
  run: {
    queuedGameFunctions: [] as QueuedFunction[],
    queuedRenderFunctions: [] as QueuedFunction[],

    intervalGameFunctions: [] as IntervalFunction[],
    intervalRenderFunctions: [] as IntervalFunction[],
  },
};

export class RunInNFrames extends Feature {
  /** @internal */
  public override v = v;

  public override vConditionalFunc = (): boolean => false;

  private readonly roomHistory: RoomHistory;

  /** @internal */
  constructor(roomHistory: RoomHistory) {
    super();

    this.featuresUsed = [ISCFeature.ROOM_HISTORY];

    this.callbacksUsed = [
      // 1
      [ModCallback.POST_UPDATE, this.postUpdate],

      // 2
      [ModCallback.POST_RENDER, this.postRender],
    ];

    this.roomHistory = roomHistory;
  }

  // ModCallback.POST_UPDATE (1)
  private readonly postUpdate = (): void => {
    const gameFrameCount = game.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    checkExecuteQueuedFunctions(
      v.run.queuedGameFunctions,
      gameFrameCount,
      numRoomsEntered,
    );
    checkExecuteIntervalFunctions(
      v.run.intervalGameFunctions,
      gameFrameCount,
      numRoomsEntered,
    );
  };

  // ModCallback.POST_RENDER (2)
  private readonly postRender = (): void => {
    const renderFrameCount = Isaac.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    checkExecuteQueuedFunctions(
      v.run.queuedRenderFunctions,
      renderFrameCount,
      numRoomsEntered,
    );
    checkExecuteIntervalFunctions(
      v.run.intervalRenderFunctions,
      renderFrameCount,
      numRoomsEntered,
    );
  };

  /**
   * Helper function to restart on the next render frame. Useful because it is impossible to restart
   * the game inside of the `POST_NEW_ROOM`, `POST_NEW_LEVEL`, or `POST_GAME_STARTED` callbacks when
   * a run is first starting.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param character Optional. If specified, will restart the game as the specified character.
   * @public
   */
  @Exported
  public restartNextRenderFrame(character?: PlayerType): void {
    this.runNextRenderFrame(() => {
      restart(character);
    });
  }

  /**
   * Supply a function to run N game frames from now in the `POST_UPDATE` callback.
   *
   * For a usage example, see the documentation for the `runNextGameFrame`, which is used in a
   * similar way.
   *
   * Note that this function will not handle saving and quitting. If a player saving and quitting
   * before the deferred function fires would cause a bug in your mod, then you should handle
   * deferred functions manually using serializable data.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to run.
   * @param numGameFrames The amount of game frames to wait before running the function.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public runInNGameFrames(
    func: () => void,
    numGameFrames: int,
    cancelIfRoomChanges = false,
  ): void {
    const gameFrameCount = game.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    const frameCountToFire = gameFrameCount + numGameFrames;
    const queuedFunction: QueuedFunction = {
      func,
      frameCountToFire,
      numRoomsEntered,
      cancelIfRoomChanges,
    };
    v.run.queuedGameFunctions.push(queuedFunction);
  }

  /**
   * Supply a function to run N render frames from now in the `POST_RENDER` callback.
   *
   * For a usage example, see the documentation for the `runNextGameFrame`, which is used in a
   * similar way.
   *
   * Note that this function will not handle saving and quitting. If a player saving and quitting
   * before the deferred function fires would cause a bug in your mod, then you should handle
   * deferred functions manually using serializable data.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to run.
   * @param numRenderFrames The amount of render frames to wait before running the function.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public runInNRenderFrames(
    func: () => void,
    numRenderFrames: int,
    cancelIfRoomChanges = false,
  ): void {
    const renderFrameCount = Isaac.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    const frameCountToFire = renderFrameCount + numRenderFrames;
    const queuedFunction: QueuedFunction = {
      func,
      frameCountToFire,
      numRoomsEntered,
      cancelIfRoomChanges,
    };
    v.run.queuedRenderFunctions.push(queuedFunction);
  }

  /**
   * Supply a function to run on the next `POST_UPDATE` callback.
   *
   * For example:
   *
   * ```ts
   * const NUM_EXPLODER_EXPLOSIONS = 5;
   *
   * function useItemExploder(player: EntityPlayer) {
   *   playSound("exploderBegin");
   *   explode(player, NUM_EXPLODER_EXPLOSIONS);
   * }
   *
   * function explode(player: EntityPlayer, numFramesLeft: int) {
   *   Isaac.Explode(player, undefined, 1);
   *   numFramesLeft -= 1;
   *   if (numFramesLeft === 0) {
   *     runNextFrame(() => {
   *       explode(player, numFramesLeft);
   *     });
   *   }
   * }
   * ```
   *
   * Note that this function will not handle saving and quitting. If a player saving and quitting
   * before the deferred function fires would cause a bug in your mod, then you should handle
   * deferred functions manually using serializable data.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to run.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public runNextGameFrame(func: () => void, cancelIfRoomChanges = false): void {
    this.runInNGameFrames(func, 1, cancelIfRoomChanges);
  }

  /**
   * Supply a function to run on the next `POST_RENDER` callback.
   *
   * For a usage example, see the documentation for the `runNextGameFrame`, which is used in a
   * similar way.
   *
   * Note that this function will not handle saving and quitting.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to run.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public runNextRenderFrame(
    func: () => void,
    cancelIfRoomChanges = false,
  ): void {
    this.runInNRenderFrames(func, 1, cancelIfRoomChanges);
  }

  /**
   * Supply a function to be repeatedly run on an interval of N game frames in the `POST_UPDATE`
   * callback. The function will continue to be fired until `false` is returned from the function.
   *
   * This is similar to the `setInterval` vanilla JavaScript function, except there is no
   * corresponding `clearInterval` function. (Instead, the return value from the supplied function
   * is used to stop the interval.)
   *
   * Note that this function will not handle saving and quitting. You must manually restart any
   * intervals if the player saves and quits in the middle of a run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to repeatedly run on an interval.
   * @param numGameFrames The amount of game frames to wait between each run.
   * @param runImmediately Whether to execute the function right now before waiting for the
   *                       interval.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public setIntervalGameFrames(
    func: () => boolean,
    numGameFrames: int,
    runImmediately: boolean,
    cancelIfRoomChanges = false,
  ): void {
    if (runImmediately) {
      const returnValue = func();
      if (!returnValue) {
        return;
      }
    }

    const gameFrameCount = game.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    const intervalFunction: IntervalFunction = {
      func,
      frameCountToFire: gameFrameCount + numGameFrames,
      numRoomsEntered,
      cancelIfRoomChanges,
      numIntervalFrames: numGameFrames,
    };
    v.run.intervalGameFunctions.push(intervalFunction);
  }

  /**
   * Supply a function to be repeatedly run on an interval of N render frames in the `POST_RENDER`
   * callback. The function will continue to be fired until `false` is returned from the function.
   *
   * This is similar to the `setInterval` vanilla JavaScript function, except there is no
   * corresponding `clearInterval` function. (Instead, the return value from the supplied function
   * is used to stop the interval.)
   *
   * Note that this function will not handle saving and quitting. You must manually restart any
   * intervals if the player saves and quits in the middle of a run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_IN_N_FRAMES`.
   *
   * @param func The function to repeatedly run on an interval.
   * @param numRenderFrames The amount of game frames to wait between each run.
   * @param runImmediately Whether to execute the function right now before waiting for the
   *                       interval.
   * @param cancelIfRoomChanges Optional. Whether to cancel running the function if a new room is
   *                            loaded in the interim. Default is false.
   * @public
   */
  @Exported
  public setIntervalRenderFrames(
    func: () => boolean,
    numRenderFrames: int,
    runImmediately: boolean,
    cancelIfRoomChanges = false,
  ): void {
    if (runImmediately) {
      const returnValue = func();
      if (!returnValue) {
        return;
      }
    }

    const renderFrameCount = Isaac.GetFrameCount();
    const numRoomsEntered = this.roomHistory.getNumRoomsEntered();

    const intervalFunction: IntervalFunction = {
      func,
      frameCountToFire: renderFrameCount + numRenderFrames,
      numRoomsEntered,
      cancelIfRoomChanges,
      numIntervalFrames: numRenderFrames,
    };
    v.run.intervalRenderFunctions.push(intervalFunction);
  }
}

function checkExecuteQueuedFunctions(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  queuedFunctions: QueuedFunction[],
  frameCount: int,
  newNumRoomsEntered: int,
) {
  const firingFunctions = queuedFunctions.filter(
    ({ frameCountToFire }) => frameCount >= frameCountToFire,
  );

  for (const firingFunction of firingFunctions) {
    const { func, cancelIfRoomChanges, numRoomsEntered } = firingFunction;

    if (!cancelIfRoomChanges || numRoomsEntered === newNumRoomsEntered) {
      func();
    }

    arrayRemoveInPlace(queuedFunctions, firingFunction);
  }
}

function checkExecuteIntervalFunctions(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  intervalFunctions: IntervalFunction[],
  frameCount: int,
  newNumRoomsEntered: int,
) {
  const firingFunctions = intervalFunctions.filter(
    ({ frameCountToFire }) => frameCount >= frameCountToFire,
  );

  for (const firingFunction of firingFunctions) {
    const { func, cancelIfRoomChanges, numRoomsEntered, numIntervalFrames } =
      firingFunction;

    let returnValue = false;
    if (!cancelIfRoomChanges || numRoomsEntered === newNumRoomsEntered) {
      returnValue = func();
    }

    arrayRemoveInPlace(intervalFunctions, firingFunction);

    // Queue the next interval (as long as the function did not return false).
    if (returnValue) {
      const newIntervalFunction: IntervalFunction = {
        func,
        frameCountToFire: frameCount + numIntervalFrames,
        numRoomsEntered,
        cancelIfRoomChanges,
        numIntervalFrames,
      };
      intervalFunctions.push(newIntervalFunction);
    }
  }
}

----
classes\features\other\RunNextRoom.ts
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { emptyArray } from "../../../functions/array";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    queuedFunctions: [] as Array<() => void>,
  },
};

export class RunNextRoom extends Feature {
  /** @internal */
  public override v = v;

  public override vConditionalFunc = (): boolean => false;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_REORDERED, this.postNewRoomReordered],
    ];
  }

  // ModCallbackCustom.POST_NEW_ROOM_REORDERED
  private readonly postNewRoomReordered = () => {
    for (const func of v.run.queuedFunctions) {
      func();
    }

    emptyArray(v.run.queuedFunctions);
  };

  /**
   * Supply a function to run on the next `POST_NEW_ROOM` callback.
   *
   * Note that this function will not handle saving and quitting. If a player saving and quitting
   * before the deferred function fires would cause a bug in your mod, then you should handle
   * deferred functions manually using serializable data.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_NEXT_ROOM`.
   */
  @Exported
  public runNextRoom(func: () => void): void {
    v.run.queuedFunctions.push(func);
  }
}

----
classes\features\other\RunNextRun.ts
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { emptyArray } from "../../../functions/array";
import { Feature } from "../../private/Feature";

const v = {
  persistent: {
    queuedFunctions: [] as Array<() => void>,
  },
};

export class RunNextRun extends Feature {
  /** @internal */
  public override v = v;

  public override vConditionalFunc = (): boolean => false;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED,
        this.postGameStartedReorderedFalse,
        [false],
      ],
    ];
  }

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED
  // false
  private readonly postGameStartedReorderedFalse = () => {
    for (const func of v.persistent.queuedFunctions) {
      func();
    }

    emptyArray(v.persistent.queuedFunctions);
  };

  /**
   * Supply a function to run on the next `POST_GAME_STARTED` callback.
   *
   * Note that this function will not handle saving and quitting. If a player saving and quitting
   * before the deferred function fires would cause a bug in your mod, then you should handle
   * deferred functions manually using serializable data.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.RUN_NEXT_ROOM`.
   *
   * @public
   */
  @Exported
  public runNextRun(func: () => void): void {
    v.persistent.queuedFunctions.push(func);
  }
}

----
classes\features\other\SaveDataManager.ts
import type { ActiveSlot, UseFlag } from "isaac-typescript-definitions";
import { CollectibleType, ModCallback } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { SaveDataKey } from "../../../enums/SaveDataKey";
import { SerializationType } from "../../../enums/SerializationType";
import { deepCopy } from "../../../functions/deepCopy";
import { isAfterGameFrame } from "../../../functions/frames";
import { log } from "../../../functions/log";
import { onFirstFloor } from "../../../functions/stage";
import { getTSTLClassName, isTSTLClass } from "../../../functions/tstlClass";
import { isString, isTable } from "../../../functions/types";
import { assertDefined } from "../../../functions/utils";
import type { SaveData } from "../../../interfaces/SaveData";
import type { AnyClass } from "../../../types/AnyClass";
import { ReadonlySet } from "../../../types/ReadonlySet";
import { Feature } from "../../private/Feature";
import {
  makeGlowingHourGlassBackup,
  restoreGlowingHourGlassBackup,
} from "./saveDataManager/glowingHourGlass";
import { loadFromDisk } from "./saveDataManager/loadFromDisk";
import {
  restoreDefaultForFeatureKey,
  restoreDefaultsForAllFeaturesAndKeys,
  restoreDefaultsForAllFeaturesKey,
} from "./saveDataManager/restoreDefaults";
import { saveToDisk } from "./saveDataManager/saveToDisk";

/** "g" stands for "globals". */
declare let g: LuaMap<string, SaveData>; // eslint-disable-line @typescript-eslint/no-unused-vars

const NON_USER_DEFINED_CLASS_NAMES = new ReadonlySet<string>([
  "Map",
  "Set",
  "DefaultMap",
]);

export class SaveDataManager extends Feature {
  /**
   * We store a local reference to the mod object so that we can access the corresponding methods
   * that read and write to the "save#.dat" file.
   */
  private readonly mod: Mod;

  /**
   * The save data map is indexed by subscriber name. We use Lua tables instead of TypeScriptToLua
   * Maps for the master map so that we can access the variables via the in-game console when
   * debugging. (TSTL Maps don't expose the map keys as normal keys.)
   */
  private readonly saveDataMap = new LuaMap<string, SaveData>();

  /**
   * When mod feature data is initialized, we copy the initial values into a separate map so that we
   * can restore them later on.
   */
  private readonly saveDataDefaultsMap = new LuaMap<string, SaveData>();

  /**
   * Each mod feature can optionally provide a function that can control whether the save data is
   * written to disk.
   */
  private readonly saveDataConditionalFuncMap = new LuaMap<
    string,
    () => boolean
  >();

  /**
   * We backup some save data keys on every new room for the purposes of restoring it when Glowing
   * Hour Glass is used.
   *
   * Note that the save data is backed up in serialized form so that we can use the `merge` function
   * to restore it.
   */
  private readonly saveDataGlowingHourGlassMap = new LuaMap<string, SaveData>();

  /**
   * End-users can register their classes with the save data manager for proper serialization when
   * contained in nested maps, sets, and arrays.
   */
  private readonly classConstructors = new LuaMap<string, AnyClass>();

  // Other variables
  private inARun = false;
  private restoreGlowingHourGlassDataOnNextRoom = false;

  /** @internal */
  constructor(mod: Mod) {
    super();

    this.callbacksUsed = [
      // 3
      [
        ModCallback.POST_USE_ITEM,
        this.postUseItemGlowingHourGlass,
        [CollectibleType.GLOWING_HOUR_GLASS],
      ],

      // 9
      [ModCallback.POST_PLAYER_INIT, this.postPlayerInit],

      // 17
      [ModCallback.PRE_GAME_EXIT, this.preGameExit],

      // 18
      // We want to avoid a needless dependency on the `GameReorderedCallbacks` feature.
      // eslint-disable-next-line deprecation/deprecation
      [ModCallback.POST_NEW_LEVEL, this.postNewLevel],
    ];

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_ROOM_EARLY, this.postNewRoomEarly],
    ];

    this.mod = mod;
  }

  // ModCallback.POST_USE_ITEM (3)
  // CollectibleType.GLOWING_HOUR_GLASS (422)
  private readonly postUseItemGlowingHourGlass = (
    _collectibleType: CollectibleType,
    _rng: RNG,
    _player: EntityPlayer,
    _useFlags: BitFlags<UseFlag>,
    _activeSlot: ActiveSlot,
    _customVarData: int,
  ): boolean | undefined => {
    this.restoreGlowingHourGlassDataOnNextRoom = true;
    return undefined;
  };

  // ModCallback.POST_PLAYER_INIT (9)
  private readonly postPlayerInit = (_player: EntityPlayer): void => {
    // We want to only load data once per run to handle the case of a player using Genesis, a second
    // player joining the run, and so on.
    if (this.inARun) {
      return;
    }
    this.inARun = true;

    // Handle the race-condition of using the Glowing Hourglass and then resetting the run.
    this.restoreGlowingHourGlassDataOnNextRoom = false;

    // We want to unconditionally load save data on every new run since there might be persistent
    // data that is not tied to an individual run.
    loadFromDisk(this.mod, this.saveDataMap, this.classConstructors);

    const isContinued = isAfterGameFrame(0);
    if (!isContinued) {
      restoreDefaultsForAllFeaturesAndKeys(
        this.saveDataMap,
        this.saveDataDefaultsMap,
      );
    }

    // On continued runs, the `POST_NEW_LEVEL` callback will not fire, so we do not have to worry
    // about saved data based on level getting overwritten.
  };

  // ModCallback.PRE_GAME_EXIT (17)
  private readonly preGameExit = (): void => {
    // We unconditionally save variables to disk (because regardless of a save & quit or a death,
    // persistent variables should be recorded).
    saveToDisk(this.mod, this.saveDataMap, this.saveDataConditionalFuncMap);

    // Mark that we are going to the menu. (Technically, the `POST_ENTITY_REMOVE` callback may fire
    // before actually going to the menu, but that must be explicitly handled.)
    this.inARun = false;

    // At this point, we could blow away the existing save data or restore defaults, but it is not
    // necessary since we will have to do it again in the `POST_PLAYER_INIT` callback. Furthermore,
    // the `POST_ENTITY_REMOVE` callback may fire after the `PRE_GAME_EXIT` callback, so wiping data
    // now could result in bugs for features that depend on that (e.g. `PickupIndexCreation`).
  };

  // ModCallback.POST_NEW_LEVEL (18)
  private readonly postNewLevel = (): void => {
    restoreDefaultsForAllFeaturesKey(
      this.saveDataMap,
      this.saveDataDefaultsMap,
      SaveDataKey.LEVEL,
    );

    // We save data to disk at the beginning of every floor (for the 2nd floor and beyond) to
    // emulate what the game does internally. (This mitigates data loss in the event of a crash).
    if (!onFirstFloor()) {
      saveToDisk(this.mod, this.saveDataMap, this.saveDataConditionalFuncMap);
    }
  };

  // ModCallbackCustom.POST_NEW_ROOM_EARLY
  private readonly postNewRoomEarly = (): void => {
    restoreDefaultsForAllFeaturesKey(
      this.saveDataMap,
      this.saveDataDefaultsMap,
      SaveDataKey.ROOM,
    );

    // Handle the Glowing Hourglass.
    if (this.restoreGlowingHourGlassDataOnNextRoom) {
      this.restoreGlowingHourGlassDataOnNextRoom = false;
      restoreGlowingHourGlassBackup(
        this.saveDataMap,
        this.saveDataConditionalFuncMap,
        this.saveDataGlowingHourGlassMap,
        this.classConstructors,
      );
    } else {
      makeGlowingHourGlassBackup(
        this.saveDataMap,
        this.saveDataConditionalFuncMap,
        this.saveDataGlowingHourGlassMap,
      );
    }
  };

  /**
   * This is the entry point to the save data manager, a system which provides two major features:
   *
   * 1. Automatic resetting of variables on a new run, on a new level, or on a new room (as
   *    desired).
   * 2. Automatic saving and loading of all tracked data to the "save#.dat" file.
   *
   * You provide this function with an object containing your variables, and then it will
   * automatically manage them for you. (See below for an example.)
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   * (Upgrade your mod before registering any of your own callbacks so that the save data manager
   * will run before any of your code does.)
   *
   * The save data manager is meant to be called once for each feature of your mod. In other words,
   * you should not put all of the variables for your mod on the same object. Instead, scope your
   * variables locally to a single file that contains a mod feature, and then call this function to
   * register them. For example:
   *
   * ```ts
   * // In file: feature1.ts
   *
   * // Declare local variables for this file or feature.
   * const v = {
   *   // These variables are never reset; manage them yourself at will.
   *   persistent: {
   *     foo1: 0,
   *   },
   *
   *   // These variables are reset at the beginning of every run.
   *   run: {
   *     foo2: 0,
   *   },
   *
   *   // These variables are reset at the beginning of every level.
   *   level: {
   *     foo3: 0,
   *   },
   *
   *   // These variables are reset at the beginning of every room.
   *   room: {
   *     foo4: 0,
   *   },
   * };
   * // The child objects of "persistent", "run", "level", and "room are optional; only create the
   * // ones that you need.
   *
   * // Now, give `v` to the save data manager, and it will automatically manage the variables for
   * // you.
   * mod.saveDataManager("feature1", v);
   *
   * // Elsewhere in the file, use your variables.
   * function feature1Function() {
   *   if (v.run.foo1 > 0) {
   *     // Insert code here.
   *   }
   * }
   * ```
   *
   * - Save data is loaded from disk in the `POST_PLAYER_INIT` callback (i.e. the first callback
   *   that can possibly run).
   * - Save data is recorded to disk in the `PRE_GAME_EXIT` callback.
   *
   * You can use many different variable types on your variable object, but not everything is
   * supported. For the specific things that are supported, see the documentation for the `deepCopy`
   * helper function.
   *
   * If you want the save data manager to load data before the `POST_PLAYER_INIT` callback (i.e. in
   * the main menu), then you should explicitly call the `saveDataManagerLoad` function. (The save
   * data manager cannot do this on its own because it cannot know when your mod features are
   * finished initializing.)
   *
   * Some features may have variables that need to be automatically reset per run/level, but not
   * saved to disk on game exit. (For example, if they contain functions or other non-serializable
   * data.) For these cases, set the second argument of this function to `false`.
   *
   * Note that when the player uses Glowing Hourglass, the save data manager will automatically
   * restore any variables on a "run" or "level" object with a backup that was created when the room
   * was entered. Thus, you should not have to explicitly program support for Glowing Hourglass into
   * your mod features that use the save data manager. If this is undesired for your specific
   * use-case, then add a key of `__ignoreGlowingHourGlass: true` to your "run" or "level" object.
   *
   * By default, the Glowing Hour Glass functionality will not apply to "persistent" objects. If
   * this is undesired, you can add a key of `__rewindWithGlowingHourGlass: true` to the object.
   *
   * @param key The name of the file or feature that is submitting data to be managed by the save
   *            data manager. The save data manager will throw an error if the key is already
   *            registered. Note that you can also pass a TSTL class instead of a string and the
   *            save data manager will use the name of the class as the key.
   * @param v An object that corresponds to the `SaveData` interface. The object is conventionally
   *          called "v" for brevity. ("v" is short for "local variables").
   * @param conditionalFunc Optional. A function to run to check if this save data should be written
   *                        to disk. Default is `() => true`, meaning that this save data will
   *                        always be written to disk. Use a conditional function for the situations
   *                        when the local variables are for a feature that the end-user can
   *                        disable. (If the feature is disabled, then there would be no point in
   *                        writing any of the variables to the "save#.dat" file.) You can also
   *                        specify `false` to this argument in order to completely disable saving
   *                        data. (Specifying `false` will allow you to use non-serializable objects
   *                        in your save data, such as `EntityPtr`.
   * @public
   */
  // This is the overload for the standard case with serializable data.
  public saveDataManager<Persistent, Run, Level>(
    key: string | object,
    v: SaveData<Persistent, Run, Level>,
    conditionalFunc?: () => boolean,
  ): void;
  // This is the overload for the case when saving data is disabled.
  public saveDataManager(
    key: string | object,
    v: SaveData,
    conditionalFunc: false,
  ): void;
  @Exported
  public saveDataManager<Persistent, Run, Level>(
    key: string | object,
    v: SaveData<Persistent, Run, Level>,
    conditionalFunc?: (() => boolean) | false,
  ): void {
    if (isTSTLClass(key)) {
      const className = getTSTLClassName(key);
      assertDefined(
        className,
        'Failed to get the class name for the submitted class (as part of the "key" parameter) when registering new data with the save data manager.',
      );

      key = className;
    }

    if (!isString(key)) {
      error(
        `The save data manager requires that keys are strings or TSTL classes. You tried to use a key of type: ${typeof key}`,
      );
    }

    if (this.saveDataMap.has(key)) {
      error(
        `The save data manager is already managing save data for a key of: ${key}`,
      );
    }

    // First, recursively look through the new save data for any classes, so we can register them
    // with the save data manager.
    this.storeClassConstructorsFromObject(v as LuaMap);

    // Add the new save data to the map.
    this.saveDataMap.set(key, v);

    // Convert the boolean to a function, if necessary. (Having the argument be a boolean is
    // necessary in order for the overloads to work properly.)
    if (conditionalFunc === false) {
      conditionalFunc = () => false;
    }

    // If the only key in the save data is "room", then we don't have to worry about saving this
    // data to disk (because the room would be reloaded upon resuming a continued run).
    const saveDataKeys = Object.keys(v);
    if (saveDataKeys.length === 1 && saveDataKeys[0] === "room") {
      conditionalFunc = () => false;
    }

    // Make a copy of the initial save data so that we can use it to restore the default values
    // later on.
    const saveDataCopy = deepCopy(v, SerializationType.NONE, key);
    this.saveDataDefaultsMap.set(key, saveDataCopy);

    // Store the conditional function for later, if present.
    if (conditionalFunc !== undefined) {
      this.saveDataConditionalFuncMap.set(key, conditionalFunc);
    }
  }

  /**
   * Recursively traverses an object, collecting all of the class constructors that it encounters.
   */
  private storeClassConstructorsFromObject(luaMap: LuaMap<AnyNotNil, unknown>) {
    const tstlClassName = getTSTLClassName(luaMap);
    if (
      tstlClassName !== undefined &&
      !NON_USER_DEFINED_CLASS_NAMES.has(tstlClassName)
    ) {
      this.classConstructors.set(tstlClassName, luaMap as unknown as AnyClass);
    }

    for (const [_key, value] of luaMap) {
      if (isTable(value)) {
        this.storeClassConstructorsFromObject(value);
      }
    }
  }

  /**
   * The save data manager will automatically load variables from disk at the appropriate times
   * (i.e. when a new run is started). Use this function to explicitly force the save data manager
   * to load all of its variables from disk immediately.
   *
   * Obviously, doing this will overwrite the current data, so using this function can potentially
   * result in lost state.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerLoad(): void {
    loadFromDisk(this.mod, this.saveDataMap, this.classConstructors);
  }

  /**
   * The save data manager will automatically save variables to disk at the appropriate times (i.e.
   * when the run is exited). Use this function to explicitly force the save data manager to write
   * all of its variables to disk immediately.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerSave(): void {
    saveToDisk(this.mod, this.saveDataMap, this.saveDataConditionalFuncMap);
  }

  /**
   * Sets the global variable of "g" equal to all of the save data variables for this mod.
   *
   * This can make debugging easier, as you can access the variables from the game's debug console.
   * e.g. `l print(g.feature1.run.foo)`
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerSetGlobal(): void {
    g = this.saveDataMap;
  }

  /**
   * By default, the save data manager will not be able to serialize/deserialize classes that are
   * nested inside of maps, sets, and arrays, because it does not have access to the corresponding
   * class constructor. If you want to use nested classes in this way, then use this function to
   * register the class constructor with the save data manager. Once registered, the save data
   * manager will automatically run the constructor when deserializing (in addition to copying over
   * the data fields).
   *
   * This function is variadic, which means you can pass as many classes as you want to register.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerRegisterClass(
    ...tstlClasses: readonly AnyClass[]
  ): void {
    for (const tstlClass of tstlClasses) {
      const { name } = tstlClass;
      assertDefined(
        // Since we are accepting untrusted user input, this might not be a real TSTL class.
        name as string | undefined,
        "Failed to register a class with the save data manager due to not being able to derive the name of the class.",
      );

      this.classConstructors.set(name, tstlClass);
    }
  }

  /**
   * Removes a previously registered key from the save data manager. This is the opposite of the
   * "saveDataManager" method.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerRemove(key: string): void {
    if (!isString(key)) {
      error(
        `The save data manager requires that keys are strings. You tried to use a key of type: ${typeof key}`,
      );
    }

    if (!this.saveDataMap.has(key)) {
      error(
        `The save data manager is not managing save data for a key of: ${key}`,
      );
    }

    // Delete the save data from the map.
    this.saveDataMap.delete(key);
    this.saveDataDefaultsMap.delete(key);
    this.saveDataConditionalFuncMap.delete(key);
    this.saveDataGlowingHourGlassMap.delete(key);
  }

  /**
   * The save data manager will automatically reset variables at the appropriate times, like when a
   * player enters a new room. Use this function to explicitly force the save data manager to reset
   * a specific variable group.
   *
   * For example:
   *
   * ```ts
   * const v = {
   *   room: {
   *     foo: 123,
   *   },
   * };
   *
   * mod.saveDataManager("file1", v);
   *
   * // Then, later on, to explicit reset all of the "room" variables:
   * mod.saveDataManagerReset("file1", "room");
   * ```
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerReset(key: string, childObjectKey: SaveDataKey): void {
    if (!isString(key)) {
      error(
        `The save data manager requires that keys are strings. You tried to use a key of type: ${typeof key}`,
      );
    }

    const saveData = this.saveDataMap.get(key);
    assertDefined(
      saveData,
      `The save data manager is not managing save data for a key of: ${key}`,
    );

    restoreDefaultForFeatureKey(
      this.saveDataDefaultsMap,
      key,
      saveData,
      childObjectKey,
    );
  }

  /**
   * Helper function to check to see if the game is in the menu, as far as the save data manager is
   * concerned. This function will return true when the game is first opened until the
   * `POST_PLAYER_INIT` callback fires. It will also return true in between the `PRE_GAME_EXIT`
   * callback firing and the `POST_PLAYER_INIT` callback firing.
   *
   * This function is useful because the `POST_ENTITY_REMOVE` callback fires after the
   * `PRE_GAME_EXIT` callback. Thus, if save data needs to be updated from the `POST_ENTITY_REMOVE`
   * callback and the player is in the process of saving and quitting, the feature will have to
   * explicitly call the `saveDataManagerSave` function.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.SAVE_DATA_MANAGER`.
   *
   * @public
   */
  @Exported
  public saveDataManagerInMenu(): boolean {
    return !this.inARun;
  }

  /**
   * Helper function to see all of the mod features that are using the save data manager. Useful for
   * debugging if a certain mod feature is not getting its data saved correctly.
   *
   * @public
   */
  @Exported
  public saveDataManagerLogSubscribers(): void {
    log("List of save data manager subscribers:");
    const keys = Object.keys(this.saveDataMap);
    keys.sort();
    for (const key of keys) {
      log(`- ${key}`);
    }
  }
}

----
classes\features\other\SpawnRockAltRewards.ts
import {
  CardType,
  CoinSubType,
  CollectibleType,
  EffectVariant,
  EntityType,
  HeartSubType,
  ItemPoolType,
  PillColor,
  RoomType,
  TrinketType,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { DISTANCE_OF_GRID_TILE } from "../../../core/constants";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { RockAltType } from "../../../enums/RockAltType";
import {
  spawnEffectWithSeed,
  spawnNPCWithSeed,
} from "../../../functions/entitiesSpecific";
import {
  spawnCardWithSeed,
  spawnCoinWithSeed,
  spawnHeartWithSeed,
  spawnPillWithSeed,
  spawnTrinketWithSeed,
} from "../../../functions/pickupsSpecific";
import { fireProjectilesInCircle } from "../../../functions/projectiles";
import { getRandom } from "../../../functions/random";
import { isRNG, newRNG } from "../../../functions/rng";
import { spawnCollectible } from "../../../functions/spawnCollectible";
import { repeat } from "../../../functions/utils";
import { getRandomVector, isVector } from "../../../functions/vector";
import { Feature } from "../../private/Feature";
import type { ItemPoolDetection } from "./ItemPoolDetection";

const ROCK_ALT_CHANCES = {
  NOTHING: 0.68,
  BASIC_DROP: 0.0967,

  /** Also used for e.g. black hearts from skulls. */
  TRINKET: 0.025,

  COLLECTIBLE: 0.005,
} as const;

const COIN_VELOCITY_MULTIPLIER = 2;

/** Matches the vanilla value, according to Fly's decompilation. */
const FIND_FREE_INITIAL_STEP = 70;

/** Matches the vanilla value, according to Fly's decompilation. */
const FART_RADIUS = DISTANCE_OF_GRID_TILE * 3;

const POLYP_PROJECTILE_SPEED = 10;
const POLYP_NUM_PROJECTILES = 6;

export class SpawnRockAltRewards extends Feature {
  private readonly itemPoolDetection: ItemPoolDetection;

  /** @internal */
  constructor(itemPoolDetection: ItemPoolDetection) {
    super();

    this.featuresUsed = [ISCFeature.ITEM_POOL_DETECTION];

    this.itemPoolDetection = itemPoolDetection;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks.
   *
   * Most of the time, this function will do nothing, similar to how most of the time, when an
   * individual urn is destroyed, nothing will spawn.
   *
   * Note that in vanilla, trinkets will not spawn if they have already been removed from the
   * trinket pool. This function cannot replicate that behavior because there is no way to check to
   * see if a trinket is still in the pool. Thus, it will always have a chance to spawn the
   * respective trinket
   * (e.g. Swallowed Penny from urns).
   *
   * When filled buckets are destroyed, 6 projectiles will always spawn in a random pattern (in
   * addition to any other rewards that are spawned). This function does not account for this, so if
   * you want to specifically emulate destroying a filled bucket, you have to account for the
   * projectiles yourself.
   *
   * The logic in this function is based on the rewards listed on the wiki:
   * https://bindingofisaacrebirth.fandom.com/wiki/Rocks
   *
   * If you want to spawn an unseeded reward, you must explicitly pass `undefined` to the
   * `seedOrRNG` parameter.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   *
   * @param positionOrGridIndex The position or grid index to spawn the reward.
   * @param rockAltType The type of reward to spawn. For example, `RockAltType.URN` will have a
   *                    chance at spawning coins and spiders.
   * @param seedOrRNG The `Seed` or `RNG` object to use. Normally, you should pass the `InitSeed` of
   *                  the grid entity that was broken. If an `RNG` object is provided, the
   *                  `RNG.Next` method will be called. If `undefined` is provided, it will default
   *                  to a random seed.
   * @returns Whether this function spawned something.
   * @public
   */
  @Exported
  public spawnRockAltReward(
    positionOrGridIndex: Vector | int,
    rockAltType: RockAltType,
    seedOrRNG: Seed | RNG | undefined,
  ): boolean {
    const room = game.GetRoom();
    const position = isVector(positionOrGridIndex)
      ? positionOrGridIndex
      : room.GetGridPosition(positionOrGridIndex);
    const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

    switch (rockAltType) {
      case RockAltType.URN: {
        return this.spawnRockAltRewardUrn(position, rng);
      }

      case RockAltType.MUSHROOM: {
        return this.spawnRockAltRewardMushroom(position, rng);
      }

      case RockAltType.SKULL: {
        return this.spawnRockAltRewardSkull(position, rng);
      }

      case RockAltType.POLYP: {
        return this.spawnRockAltRewardPolyp(position, rng);
      }

      case RockAltType.BUCKET_DOWNPOUR: {
        return this.spawnRockAltRewardBucketDownpour(position, rng);
      }

      case RockAltType.BUCKET_DROSS: {
        return this.spawnRockAltRewardBucketDross(position, rng);
      }
    }
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.URN`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardUrn(position: Vector, rng: RNG): boolean {
    const room = game.GetRoom();

    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      const numCoinsChance = getRandom(rng);
      const numCoins = numCoinsChance < 0.5 ? 1 : 2;
      repeat(numCoins, () => {
        const randomVector = getRandomVector(rng);
        const velocity = randomVector.mul(COIN_VELOCITY_MULTIPLIER);
        spawnCoinWithSeed(CoinSubType.NULL, position, rng, velocity);
      });
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnTrinketWithSeed(TrinketType.SWALLOWED_PENNY, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      const stillInPools = this.itemPoolDetection.isCollectibleInItemPool(
        CollectibleType.QUARTER,
        ItemPoolType.DEVIL,
      );
      if (stillInPools) {
        spawnCollectible(CollectibleType.QUARTER, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    const numEnemiesChance = getRandom(rng);
    const numEnemies = numEnemiesChance < 0.5 ? 1 : 2;
    repeat(numEnemies, () => {
      const targetPos = room.FindFreePickupSpawnPosition(
        position,
        FIND_FREE_INITIAL_STEP,
      );
      EntityNPC.ThrowSpider(position, undefined, targetPos, false, 0);
    });
    return true;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.MUSHROOM`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardMushroom(position: Vector, rng: RNG): boolean {
    const room = game.GetRoom();
    const roomType = room.GetType();

    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      spawnPillWithSeed(PillColor.NULL, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnTrinketWithSeed(TrinketType.LIBERTY_CAP, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      if (roomType === RoomType.SECRET) {
        const wavyCapChance = getRandom(rng);
        if (wavyCapChance < 0.0272) {
          const stillInPools = this.itemPoolDetection.isCollectibleInItemPool(
            CollectibleType.WAVY_CAP,
            ItemPoolType.SECRET,
          );
          if (stillInPools) {
            spawnCollectible(CollectibleType.WAVY_CAP, position, rng);
            return true;
          }
        }
      }

      const magicMushroomStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.MAGIC_MUSHROOM,
          ItemPoolType.TREASURE,
        );
      const miniMushStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.MINI_MUSH,
          ItemPoolType.TREASURE,
        );
      if (magicMushroomStillInPools && miniMushStillInPools) {
        const collectibleChance = getRandom(rng);
        const collectibleType =
          collectibleChance < 0.5
            ? CollectibleType.MAGIC_MUSHROOM // 12
            : CollectibleType.MINI_MUSH; // 71
        spawnCollectible(collectibleType, position, rng);
        return true;
      }

      if (magicMushroomStillInPools) {
        spawnCollectible(CollectibleType.MINI_MUSH, position, rng);
        return true;
      }

      if (miniMushStillInPools) {
        spawnCollectible(CollectibleType.MAGIC_MUSHROOM, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    game.Fart(position);
    game.ButterBeanFart(position, FART_RADIUS, undefined);
    return true;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.SKULL`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardSkull(position: Vector, rng: RNG): boolean {
    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      spawnCardWithSeed(CardType.NULL, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnHeartWithSeed(HeartSubType.BLACK, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      const ghostBabyStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.GHOST_BABY,
          ItemPoolType.TREASURE,
        );
      const dryBabyStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.DRY_BABY,
          ItemPoolType.TREASURE,
        );
      if (ghostBabyStillInPools && dryBabyStillInPools) {
        const collectibleChance = getRandom(rng);
        const collectibleType =
          collectibleChance < 0.5
            ? CollectibleType.GHOST_BABY // 163
            : CollectibleType.DRY_BABY; // 265
        spawnCollectible(collectibleType, position, rng);
        return true;
      }

      if (ghostBabyStillInPools) {
        spawnCollectible(CollectibleType.DRY_BABY, position, rng);
        return true;
      }

      if (dryBabyStillInPools) {
        spawnCollectible(CollectibleType.GHOST_BABY, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    spawnNPCWithSeed(EntityType.HOST, 0, 0, position, rng);
    return true;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.POLYP`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardPolyp(position: Vector, rng: RNG): boolean {
    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      spawnHeartWithSeed(HeartSubType.NULL, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnTrinketWithSeed(TrinketType.UMBILICAL_CORD, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      const placentaStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.PLACENTA,
          ItemPoolType.BOSS,
        );
      const bloodClotStillInPools =
        this.itemPoolDetection.isCollectibleInItemPool(
          CollectibleType.BLOOD_CLOT,
          ItemPoolType.BOSS,
        );
      if (placentaStillInPools && bloodClotStillInPools) {
        const collectibleChance = getRandom(rng);
        const collectibleType =
          collectibleChance < 0.5
            ? CollectibleType.PLACENTA // 218
            : CollectibleType.BLOOD_CLOT; // 254
        spawnCollectible(collectibleType, position, rng);
        return true;
      }

      if (placentaStillInPools) {
        spawnCollectible(CollectibleType.PLACENTA, position, rng);
        return true;
      }

      if (bloodClotStillInPools) {
        spawnCollectible(CollectibleType.BLOOD_CLOT, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    spawnEffectWithSeed(EffectVariant.CREEP_RED, 0, position, rng);
    fireProjectilesInCircle(
      undefined,
      position,
      POLYP_PROJECTILE_SPEED,
      POLYP_NUM_PROJECTILES,
    );

    return true;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.BUCKET_DOWNPOUR`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardBucketDownpour(position: Vector, rng: RNG): boolean {
    const room = game.GetRoom();

    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      const numCoinsChance = getRandom(rng);
      const numCoins = numCoinsChance < 0.5 ? 1 : 2;
      repeat(numCoins, () => {
        const randomVector = getRandomVector(rng);
        const velocity = randomVector.mul(COIN_VELOCITY_MULTIPLIER);
        spawnCoinWithSeed(CoinSubType.NULL, position, rng, velocity);
      });
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnTrinketWithSeed(TrinketType.SWALLOWED_PENNY, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      const stillInPools = this.itemPoolDetection.isCollectibleInItemPool(
        CollectibleType.LEECH,
        ItemPoolType.TREASURE,
      );
      if (stillInPools) {
        spawnCollectible(CollectibleType.LEECH, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    const enemiesChance = getRandom(rng);
    const entityType =
      enemiesChance < 0.5 ? EntityType.SPIDER : EntityType.SMALL_LEECH;

    const numEnemiesChance = getRandom(rng);
    const numEnemies = numEnemiesChance < 0.5 ? 1 : 2;
    repeat(numEnemies, () => {
      const targetPos = room.FindFreePickupSpawnPosition(
        position,
        FIND_FREE_INITIAL_STEP,
      );

      // If the room has water, Spiders will automatically be replaced with Striders.
      const spider = EntityNPC.ThrowSpider(
        position,
        undefined,
        targetPos,
        false,
        0,
      );

      // There is no `ThrowLeech` function exposed in the API, so we can piggyback off of the
      // `ThrowSpider` method.
      if (entityType === EntityType.SMALL_LEECH && spider.Type !== entityType) {
        spider.Morph(entityType, 0, 0, -1);
      }
    });

    return true;
  }

  /**
   * Helper function for emulating what happens when a vanilla `GridEntityType.ROCK_ALT` grid entity
   * breaks of `RockAltType.BUCKET_DROSS`.
   *
   * For more information, see the documentation for the `spawnRockAltReward` function.
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.SPAWN_ALT_ROCK_REWARDS`.
   */
  @Exported
  public spawnRockAltRewardBucketDross(position: Vector, rng: RNG): boolean {
    const room = game.GetRoom();

    const chance = getRandom(rng);
    let totalChance = 0;

    totalChance += ROCK_ALT_CHANCES.NOTHING;
    if (chance < totalChance) {
      return false;
    }

    totalChance += ROCK_ALT_CHANCES.BASIC_DROP;
    if (chance < totalChance) {
      const numCoinsChance = getRandom(rng);
      const numCoins = numCoinsChance < 0.5 ? 1 : 2;
      repeat(numCoins, () => {
        const randomVector = getRandomVector(rng);
        const velocity = randomVector.mul(COIN_VELOCITY_MULTIPLIER);
        spawnCoinWithSeed(CoinSubType.NULL, position, rng, velocity);
      });
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.TRINKET;
    if (chance < totalChance) {
      spawnTrinketWithSeed(TrinketType.BUTT_PENNY, position, rng);
      return true;
    }

    totalChance += ROCK_ALT_CHANCES.COLLECTIBLE;
    if (chance < totalChance) {
      const stillInPools = this.itemPoolDetection.isCollectibleInItemPool(
        CollectibleType.POOP,
        ItemPoolType.TREASURE,
      );
      if (stillInPools) {
        spawnCollectible(CollectibleType.POOP, position, rng);
        return true;
      }

      return false;
    }

    // Since the detrimental effect is the final option, we don't need to check the chance.
    const enemiesChance = getRandom(rng);
    const entityType =
      enemiesChance < 0.5 ? EntityType.DRIP : EntityType.SMALL_LEECH;

    const numEnemiesChance = getRandom(rng);
    const numEnemies = numEnemiesChance < 0.5 ? 1 : 2;
    repeat(numEnemies, () => {
      const targetPos = room.FindFreePickupSpawnPosition(
        position,
        FIND_FREE_INITIAL_STEP,
      );
      const spider = EntityNPC.ThrowSpider(
        position,
        undefined,
        targetPos,
        false,
        0,
      );

      // There is no `ThrowLeech` or `ThrowDrip` functions exposed in the API, so we can piggyback
      // off of the `ThrowSpider` method.
      spider.Morph(entityType, 0, 0, -1);
    });

    return true;
  }
}

----
classes\features\other\StageHistory.ts
import {
  GameStateFlag,
  LevelStage,
  StageType,
} from "isaac-typescript-definitions";
import { game } from "../../../core/cachedClasses";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { getNextStage, getNextStageType } from "../../../functions/nextStage";
import {
  calculateStageType,
  onRepentanceStage,
} from "../../../functions/stage";
import type { StageHistoryEntry } from "../../../interfaces/StageHistoryEntry";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    stageHistory: [] as StageHistoryEntry[],
  },
};

export class StageHistory extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_NEW_LEVEL_REORDERED, this.postNewLevelReordered],
    ];
  }

  // ModCallbackCustom.POST_NEW_LEVEL_REORDERED
  private readonly postNewLevelReordered = () => {
    const level = game.GetLevel();
    const stage = level.GetStage();
    const stageType = level.GetStageType();

    v.run.stageHistory.push({ stage, stageType });
  };

  /**
   * Helper function to get the stage type that a trapdoor or heaven door would take the player to,
   * based on the current stage, room, and game state flags.
   *
   * This function accounts for the previous floors that a player has visited thus far on the run so
   * that the next stage type can be properly calculated on The Ascent (which makes it unlike the
   * `getNextStageType` function).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.STAGE_HISTORY`.
   *
   * @param upwards Whether the player should go up to Cathedral in the case of being on Womb 2.
   *                Default is false.
   * @public
   */
  @Exported
  public getNextStageTypeWithHistory(upwards = false): StageType {
    const backwardsPath = game.GetStateFlag(GameStateFlag.BACKWARDS_PATH);
    if (!backwardsPath) {
      return getNextStageType(upwards);
    }

    const level = game.GetLevel();
    const stage = level.GetStage();
    const repentanceStage = onRepentanceStage();

    const visitedDownpour1 = this.hasVisitedStage(
      LevelStage.BASEMENT_1,
      StageType.REPENTANCE,
    );
    const visitedDross1 = this.hasVisitedStage(
      LevelStage.BASEMENT_1,
      StageType.REPENTANCE_B,
    );
    const visitedDownpour2 = this.hasVisitedStage(
      LevelStage.BASEMENT_2,
      StageType.REPENTANCE,
    );
    const visitedDross2 = this.hasVisitedStage(
      LevelStage.BASEMENT_2,
      StageType.REPENTANCE_B,
    );
    const visitedMines1 = this.hasVisitedStage(
      LevelStage.CAVES_1,
      StageType.REPENTANCE,
    );
    const visitedAshpit1 = this.hasVisitedStage(
      LevelStage.CAVES_1,
      StageType.REPENTANCE_B,
    );
    const visitedMines2 = this.hasVisitedStage(
      LevelStage.DEPTHS_2,
      StageType.REPENTANCE,
    );
    const visitedAshpit2 = this.hasVisitedStage(
      LevelStage.DEPTHS_2,
      StageType.REPENTANCE_B,
    );

    if (stage === LevelStage.BASEMENT_2 && repentanceStage) {
      if (visitedDownpour1) {
        return StageType.REPENTANCE;
      }

      if (visitedDross1) {
        return StageType.REPENTANCE_B;
      }
    }

    if (stage === LevelStage.CAVES_1 && repentanceStage) {
      if (visitedDownpour2) {
        return StageType.REPENTANCE;
      }

      if (visitedDross2) {
        return StageType.REPENTANCE_B;
      }
    }

    if (stage === LevelStage.CAVES_2 && !repentanceStage) {
      if (visitedDownpour2) {
        return StageType.REPENTANCE;
      }

      if (visitedDross2) {
        return StageType.REPENTANCE_B;
      }
    }

    if (stage === LevelStage.CAVES_2 && repentanceStage) {
      if (visitedMines1) {
        return StageType.REPENTANCE;
      }

      if (visitedAshpit1) {
        return StageType.REPENTANCE_B;
      }
    }

    if (stage === LevelStage.DEPTHS_2 && !repentanceStage) {
      if (visitedAshpit2) {
        return StageType.REPENTANCE_B;
      }

      if (visitedMines2) {
        return StageType.REPENTANCE;
      }
    }

    const nextStage = this.getNextStageWithHistory();
    return calculateStageType(nextStage);
  }

  /**
   * Helper function to get the stage that a trapdoor or heaven door would take the player to, based
   * on the current stage, room, and game state flags.
   *
   * This function accounts for the previous floors that a player has visited thus far on the run so
   * that the next stage can be properly calculated on The Ascent (which makes it unlike the
   * `getNextStage` function).
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.STAGE_HISTORY`.
   */
  @Exported
  public getNextStageWithHistory(): LevelStage {
    const backwardsPath = game.GetStateFlag(GameStateFlag.BACKWARDS_PATH);
    if (!backwardsPath) {
      return getNextStage();
    }

    const level = game.GetLevel();
    const stage = level.GetStage();
    const repentanceStage = onRepentanceStage();

    const visitedDownpour1 = this.hasVisitedStage(
      LevelStage.BASEMENT_1,
      StageType.REPENTANCE,
    );
    const visitedDross1 = this.hasVisitedStage(
      LevelStage.BASEMENT_1,
      StageType.REPENTANCE_B,
    );
    const visitedDownpour2 = this.hasVisitedStage(
      LevelStage.BASEMENT_2,
      StageType.REPENTANCE,
    );
    const visitedDross2 = this.hasVisitedStage(
      LevelStage.BASEMENT_2,
      StageType.REPENTANCE_B,
    );
    const visitedMines1 = this.hasVisitedStage(
      LevelStage.CAVES_1,
      StageType.REPENTANCE,
    );
    const visitedAshpit1 = this.hasVisitedStage(
      LevelStage.CAVES_1,
      StageType.REPENTANCE_B,
    );
    const visitedMines2 = this.hasVisitedStage(
      LevelStage.DEPTHS_2,
      StageType.REPENTANCE,
    );
    const visitedAshpit2 = this.hasVisitedStage(
      LevelStage.DEPTHS_2,
      StageType.REPENTANCE_B,
    );

    if (stage === LevelStage.BASEMENT_1) {
      if (repentanceStage) {
        // From Downpour 1 to Basement 1.
        return LevelStage.BASEMENT_1;
      }

      // From Basement 1 to Home.
      return LevelStage.HOME;
    }

    if (stage === LevelStage.BASEMENT_2) {
      if (repentanceStage) {
        if (visitedDownpour1 || visitedDross1) {
          // From Downpour 2 to Downpour 1.
          return LevelStage.BASEMENT_1;
        }

        // From Downpour 2 to Basement 2.
        return LevelStage.BASEMENT_2;
      }

      // From Basement 2 to Basement 1.
      return LevelStage.BASEMENT_1;
    }

    if (stage === LevelStage.CAVES_1) {
      if (repentanceStage) {
        if (visitedDownpour2 || visitedDross2) {
          // From Mines 1 to Downpour 1.
          return LevelStage.BASEMENT_2;
        }

        // From Mines 1 to Caves 1.
        return LevelStage.CAVES_1;
      }

      // From Caves 1 to Basement 2.
      return LevelStage.BASEMENT_2;
    }

    if (stage === LevelStage.CAVES_2) {
      if (repentanceStage) {
        if (visitedMines1 || visitedAshpit1) {
          // From Mines 2 to Mines 1.
          return LevelStage.CAVES_1;
        }

        // From Mines 2 to Caves 2.
        return LevelStage.CAVES_2;
      }

      // From Caves 2 to Caves 1.
      return LevelStage.CAVES_1;
    }

    if (stage === LevelStage.DEPTHS_1) {
      if (repentanceStage) {
        if (visitedMines2 || visitedAshpit2) {
          // From Mausoleum 1 to Mines 2.
          return LevelStage.CAVES_2;
        }

        // From Mausoleum 1 to Depths 1.
        return LevelStage.DEPTHS_1;
      }

      // From Depths 1 to Caves 2.
      return LevelStage.CAVES_2;
    }

    if (stage === LevelStage.DEPTHS_2) {
      if (repentanceStage) {
        // From Mausoleum 2 to Depths 2.
        return LevelStage.DEPTHS_2;
      }

      // From Depths 2 to Depths 1.
      return LevelStage.DEPTHS_1;
    }

    return stage - 1;
  }

  /**
   * Helper function to get all of the stages that a player has visited thus far on this run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.STAGE_HISTORY`.
   *
   * @public
   */
  @Exported
  public getStageHistory(): readonly StageHistoryEntry[] {
    return v.run.stageHistory;
  }

  /**
   * Helper function to check if a player has previous visited a particular stage (or stage + stage
   * type combination) on this run.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.STAGE_HISTORY`.
   *
   * @param stage The stage to check for.
   * @param stageType Optional. If provided, will check for a specific stage and stage type
   *                  combination.
   */
  @Exported
  public hasVisitedStage(stage: LevelStage, stageType?: StageType): boolean {
    if (stageType === undefined) {
      return v.run.stageHistory.some(
        (stageHistoryEntry) => stageHistoryEntry.stage === stage,
      );
    }

    return v.run.stageHistory.some(
      (stageHistoryEntry) =>
        stageHistoryEntry.stage === stage &&
        stageHistoryEntry.stageType === stageType,
    );
  }
}

----
classes\features\other\StartAmbush.ts
import { SackSubType } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { ISCFeature } from "../../../enums/ISCFeature";
import { removeEntities } from "../../../functions/entities";
import {
  getCoins,
  spawnSackWithSeed,
} from "../../../functions/pickupsSpecific";
import { Feature } from "../../private/Feature";
import type { RunInNFrames } from "./RunInNFrames";

/** Hard-coding this makes it easier to clean up the pickups afterwards. */
const SACK_SEED_THAT_SPAWNS_TWO_COINS = 6 as Seed;

export class StartAmbush extends Feature {
  private readonly runInNFrames: RunInNFrames;

  /** @internal */
  constructor(runInNFrames: RunInNFrames) {
    super();

    this.featuresUsed = [ISCFeature.RUN_IN_N_FRAMES];

    this.runInNFrames = runInNFrames;
  }

  /**
   * Helper function to start a Challenge Room or the Boss Rush.
   *
   * Specifically, this is performed by spawning a sack on top of the player, waiting a game frame,
   * and then removing the sack and the pickups that the sack dropped.
   *
   * In order to use this function, you must upgrade your mod with `ISCFeature.START_AMBUSH`.
   *
   * @public
   */
  @Exported
  public startAmbush(): void {
    const player = Isaac.GetPlayer();
    const sack = spawnSackWithSeed(
      SackSubType.NULL,
      player.Position,
      SACK_SEED_THAT_SPAWNS_TWO_COINS,
    );

    // The sack will play the "Appear" animation and the player will not be able to interact with it
    // while this is occurring. By stopping the animation, it will transition to the "Idle"
    // animation and be interactable on the next game frame.
    const sprite = sack.GetSprite();
    sprite.Stop();
    const sackPtr = EntityPtr(sack);
    this.runInNFrames.runNextGameFrame(() => {
      const futureSack = sackPtr.Ref;
      if (futureSack === undefined) {
        return;
      }

      futureSack.Remove();
      const sackPtrHash = GetPtrHash(futureSack);
      const coins = getCoins();
      const coinsFromSack = coins.filter(
        (pickup) =>
          pickup.SpawnerEntity !== undefined &&
          GetPtrHash(pickup.SpawnerEntity) === sackPtrHash,
      );
      removeEntities(coinsFromSack);
    });
  }
}

----
classes\features\other\TaintedLazarusPlayers.ts
import { ModCallback, PlayerType } from "isaac-typescript-definitions";
import { Exported } from "../../../decorators";
import { logError } from "../../../functions/log";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    queuedTaintedLazarus: [] as EntityPlayer[],
    queuedDeadTaintedLazarus: [] as EntityPlayer[],

    /**
     * The `POST_PLAYER_INIT` callback fires for Dead Tainted Lazarus at the beginning of the run.
     * However, the player index for the Dead Tainted Lazarus player object at that time does not
     * actually correspond to the player index for the real player once Flip has been used. Thus, we
     * revert to using PtrHash as an index for our map, which is consistent between the Dead Tainted
     * Lazarus object in the `POST_PLAYER_INIT` callback and the "real" Dead Tainted Lazarus.
     *
     * We use `EntityPlayer` as the value for the map instead of `EntityPtr` because using the
     * pointer does not work for some reason. (When we unwrap it after one or more flips have been
     * used, the pointers no longer point to the original objects, even if we manually update the
     * pointers in the `POST_FLIP` callback.)
     */
    subPlayerMap: new Map<PtrHash, EntityPlayer>(),
  },
};

/**
 * This feature provides a way for end-users to get the `EntityPlayer` object for the other Tainted
 * Lazarus.
 */
export class TaintedLazarusPlayers extends Feature {
  /** @internal */
  public override v = v;

  public override vConditionalFunc = (): boolean => false;

  /** @internal */
  constructor() {
    super();

    this.callbacksUsed = [
      // 9
      [ModCallback.POST_PLAYER_INIT, this.postPlayerInit],
    ];
  }

  // ModCallback.POST_PLAYER_INIT (9)
  private readonly postPlayerInit = (player: EntityPlayer) => {
    const character = player.GetPlayerType();

    if (character === PlayerType.LAZARUS_B) {
      v.run.queuedTaintedLazarus.push(player);
    } else if (character === PlayerType.LAZARUS_2_B) {
      v.run.queuedDeadTaintedLazarus.push(player);
    } else {
      return;
    }

    this.checkDequeue();
  };

  /**
   * Indexes are the `PtrHash`, values are the `EntityPtr` of the *other* Lazarus.
   *
   * When starting a run, the `POST_PLAYER_INIT` callback will fire first for Dead Tainted Lazarus,
   * then for Tainted Lazarus. When continuing a run, the `POST_PLAYER_INIT` callback will fire
   * first for the character that is currently active. Thus, since the order of the characters is
   * not certain, we insert each of their pointers into a queue, and then only populate the map when
   * we have one Tainted Lazarus and one Dead Tainted Lazarus.
   */
  private checkDequeue() {
    if (
      v.run.queuedTaintedLazarus.length === 0 ||
      v.run.queuedDeadTaintedLazarus.length === 0
    ) {
      return;
    }

    const taintedLazarus = v.run.queuedTaintedLazarus.shift();
    const deadTaintedLazarus = v.run.queuedDeadTaintedLazarus.shift();

    if (taintedLazarus === undefined || deadTaintedLazarus === undefined) {
      return;
    }

    const taintedLazarusPtrHash = GetPtrHash(taintedLazarus);
    const deadTaintedLazarusPtrHash = GetPtrHash(deadTaintedLazarus);

    if (taintedLazarusPtrHash === deadTaintedLazarusPtrHash) {
      logError(
        "Failed to cache the Tainted Lazarus player objects, since the hash for Tainted Lazarus and Dead Tainted Lazarus were the same.",
      );
      return;
    }

    v.run.subPlayerMap.set(taintedLazarusPtrHash, deadTaintedLazarus);
    v.run.subPlayerMap.set(deadTaintedLazarusPtrHash, taintedLazarus);
  }

  /**
   * Helper function to get the other version of Tainted Lazarus.
   *
   * - On Tainted Lazarus, returns the player object for Dead Tainted Lazarus.
   * - On Dead Tainted Lazarus, returns the player object for Tainted Lazarus.
   * - Returns undefined if player object retrieval failed for any reason.
   *
   * If you call the `EntityPlayer.Exists` method on the returned object, it will return false.
   * However, you can still call the other methods like you normally would (e.g.
   * `EntityPlayer.AddCollectible`).
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.CHARACTER_HEALTH_CONVERSION`.
   *
   * @public
   */
  @Exported
  public getTaintedLazarusSubPlayer(
    player: EntityPlayer,
  ): EntityPlayer | undefined {
    const ptrHash = GetPtrHash(player);
    return v.run.subPlayerMap.get(ptrHash);
  }
}

----
classes\features\other\UnlockAchievementsDetection.ts
import { SlotVariant } from "isaac-typescript-definitions";
import { VectorZero } from "../../../core/constants";
import { Exported } from "../../../decorators";
import { ModCallbackCustom } from "../../../enums/ModCallbackCustom";
import { spawnSlot } from "../../../functions/entitiesSpecific";
import { Feature } from "../../private/Feature";

const v = {
  run: {
    canRunUnlockAchievements: true,
  },
};

export class UnlockAchievementsDetection extends Feature {
  /** @internal */
  public override v = v;

  /** @internal */
  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_GAME_STARTED_REORDERED,
        this.postGameStartedReordered,
      ],
    ];
  }

  // ModCallbackCustom.POST_GAME_STARTED_REORDERED
  private readonly postGameStartedReordered = () => {
    const greedDonationMachine = spawnSlot(
      SlotVariant.GREED_DONATION_MACHINE,
      0,
      VectorZero,
    );
    v.run.canRunUnlockAchievements = greedDonationMachine.Exists();
    greedDonationMachine.Remove();
  };

  /**
   * Helper function to see if the current run can unlock achievements. For example, if playing on a
   * set seed or in a victory lap, achievements are disabled.
   *
   * Under the hood, this is determined by spawning a Greed Donation Machine at the beginning of the
   * run and then seeing if it exists before removing it. (The results are cached for the entire
   * run.)
   *
   * In order to use this function, you must upgrade your mod with
   * `ISCFeature.UNLOCK_ACHIEVEMENTS_DETECTION`.
   *
   * @public
   */
  @Exported
  public canRunUnlockAchievements(): boolean {
    return v.run.canRunUnlockAchievements;
  }
}

----
classes\features\other\customStages\backdrop.ts
// This file handles drawing the walls and floors for custom stages.

import {
  EffectVariant,
  EntityFlag,
  RoomShape,
  RoomType,
} from "isaac-typescript-definitions";
import { game } from "../../../../core/cachedClasses";
import { VectorZero } from "../../../../core/constants";
import { LadderSubTypeCustom } from "../../../../enums/LadderSubTypeCustom";
import { getRandomArrayElement } from "../../../../functions/array";
import { spawnEffectWithSeed } from "../../../../functions/entitiesSpecific";
import { newRNG } from "../../../../functions/rng";
import { isLRoomShape, isNarrowRoom } from "../../../../functions/roomShape";
import {
  removeCharactersBefore,
  trimPrefix,
} from "../../../../functions/string";
import { assertDefined, eRange, iRange } from "../../../../functions/utils";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";
import { ReadonlySet } from "../../../../types/ReadonlySet";
import { ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH } from "./constants";

enum BackdropKind {
  /** The "N" stands for narrow rooms. */
  N_FLOOR = "nFloors",

  /** The "L" stands for L rooms. */
  L_FLOOR = "lFloors",

  WALL = "walls",
  CORNER = "corners",
}

/** This is created by the vanilla Basement files. */
const DEFAULT_BACKDROP = {
  nFloors: [`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/backdrop/nfloor.png`],
  lFloors: [`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/backdrop/lfloor.png`], // cspell:ignore lfloor
  walls: [`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/backdrop/wall.png`],
  corners: [`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/backdrop/corner.png`],
} as const satisfies NonNullable<CustomStage["backdropPNGPaths"]>;

const ROOM_SHAPE_WALL_ANM2_LAYERS = {
  [RoomShape.SHAPE_1x1]: 44, // 1
  [RoomShape.IH]: 36, // 2
  [RoomShape.IV]: 28, // 3
  [RoomShape.SHAPE_1x2]: 58, // 4
  [RoomShape.IIV]: 42, // 5
  [RoomShape.SHAPE_2x1]: 63, // 6
  [RoomShape.IIH]: 62, // 7
  [RoomShape.SHAPE_2x2]: 63, // 8
  [RoomShape.LTL]: 63, // 9
  [RoomShape.LTR]: 63, // 10
  [RoomShape.LBL]: 63, // 11
  [RoomShape.LBR]: 63, // 12
} as const satisfies Record<RoomShape, int>;

// We don't use `as const` since we need the object to be indexable by all `RoomShape`.
// eslint-disable-next-line isaacscript/require-capital-const-assertions
const ROOM_SHAPE_WALL_EXTRA_ANM2_LAYERS: Readonly<
  Partial<Record<RoomShape, int>>
> = {
  [RoomShape.SHAPE_2x1]: 7, // 6
  [RoomShape.SHAPE_2x2]: 21, // 8
  [RoomShape.LTL]: 19, // 9
  [RoomShape.LTR]: 19, // 10
  [RoomShape.LBL]: 19, // 11
  [RoomShape.LBR]: 19, // 12
};

const WALL_OFFSET = Vector(-80, -80);

/** Corresponds to "floor-backdrop.anm2". */
const L_FLOOR_ANM2_LAYERS = [16, 17] as const;

/** Corresponds to "floor-backdrop.anm2". */
const N_FLOOR_ANM2_LAYERS = [18, 19] as const;

/**
 * Normally, we would make a custom entity to represent a backdrop effect, but we don't want to
 * interfere with the "entities2.xml" file in end-user mods. Thus, we must select a vanilla effect
 * to masquerade as a backdrop effect.
 *
 * We arbitrarily choose a ladder for this purpose because it will not automatically despawn after
 * time passes, like most other effects.
 */
const BACKDROP_EFFECT_VARIANT = EffectVariant.LADDER;
const BACKDROP_EFFECT_SUB_TYPE = LadderSubTypeCustom.CUSTOM_BACKDROP;

const BACKDROP_ROOM_TYPE_SET = new ReadonlySet<RoomType>([
  RoomType.DEFAULT,
  RoomType.BOSS,
  RoomType.MINI_BOSS,
]);

export function setCustomStageBackdrop(customStage: CustomStage): void {
  const room = game.GetRoom();
  const roomType = room.GetType();
  const decorationSeed = room.GetDecorationSeed();
  const rng = newRNG(decorationSeed);

  // We do not want to set the backdrop inside shops, Curse Rooms, and so on.
  if (!BACKDROP_ROOM_TYPE_SET.has(roomType)) {
    return;
  }

  spawnWallEntity(customStage, rng, false);
  spawnSecondWallEntity(customStage, rng);
  spawnFloorEntity(customStage, rng);
}

function getBackdropPNGPath(
  customStage: CustomStage,
  backdropKind: BackdropKind,
  rng: RNG,
) {
  const backdrop = customStage.backdropPNGPaths ?? DEFAULT_BACKDROP;
  const pathArray = backdrop[backdropKind];
  const randomPath = getRandomArrayElement(pathArray, rng);
  return removeCharactersBefore(randomPath, "gfx/");
}

function spawnWallEntity(
  customStage: CustomStage,
  rng: RNG,
  isExtraWall: boolean,
) {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();

  // We spawn an effect instead of simply rendering a static sprite in order to emulate how vanilla
  // does this. (`EntityFlag.RENDER_WALL` is intended for this purpose.)
  const seed = 1 as Seed;
  const wallEffect = spawnEffectWithSeed(
    BACKDROP_EFFECT_VARIANT,
    BACKDROP_EFFECT_SUB_TYPE,
    VectorZero,
    seed,
  );
  wallEffect.AddEntityFlags(EntityFlag.RENDER_WALL);

  const sprite = wallEffect.GetSprite();
  sprite.Load(`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/wall-backdrop.anm2`, false);

  const wallLayersArray = isExtraWall
    ? ROOM_SHAPE_WALL_EXTRA_ANM2_LAYERS
    : ROOM_SHAPE_WALL_ANM2_LAYERS;
  const numWallLayers = wallLayersArray[roomShape];
  assertDefined(
    numWallLayers,
    `Failed to get the layers when creating the backdrop for custom stage: ${customStage.name}`,
  );

  if (isLRoomShape(roomShape)) {
    const cornerPNGPath = getBackdropPNGPath(
      customStage,
      BackdropKind.CORNER,
      rng,
    );
    sprite.ReplaceSpritesheet(0, cornerPNGPath);
  }

  for (const layerID of iRange(1, numWallLayers)) {
    const wallPNGPath = getBackdropPNGPath(customStage, BackdropKind.WALL, rng);
    sprite.ReplaceSpritesheet(layerID, wallPNGPath);
  }

  const topLeftPos = room.GetTopLeftPos();
  const renderPos = topLeftPos.add(WALL_OFFSET);
  const modifiedOffset = renderPos.div(40).mul(26);
  wallEffect.SpriteOffset = modifiedOffset;

  sprite.LoadGraphics();
  const roomShapeName = RoomShape[roomShape];
  const animation = trimPrefix(roomShapeName, "SHAPE_");
  const modifiedAnimation = isExtraWall ? `${animation}X` : animation;
  sprite.Play(modifiedAnimation, true);
}

function spawnSecondWallEntity(customStage: CustomStage, rng: RNG) {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();
  const extraLayers = ROOM_SHAPE_WALL_EXTRA_ANM2_LAYERS[roomShape];
  const roomShapeHasExtraLayers = extraLayers !== undefined;
  if (roomShapeHasExtraLayers) {
    spawnWallEntity(customStage, rng, true);
  }
}

function spawnFloorEntity(customStage: CustomStage, rng: RNG) {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();

  // We spawn an effect instead of simply rendering a static sprite in order to emulate how vanilla
  // does this. (`EntityFlag.RENDER_FLOOR` is intended for this purpose.)
  const seed = 1 as Seed;
  const floorEffect = spawnEffectWithSeed(
    BACKDROP_EFFECT_VARIANT,
    0,
    VectorZero,
    seed,
  );
  floorEffect.AddEntityFlags(EntityFlag.RENDER_FLOOR);

  const sprite = floorEffect.GetSprite();
  sprite.Load(
    `${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/floor-backdrop.anm2`,
    false,
  );

  const numFloorLayers = getNumFloorLayers(roomShape);
  if (numFloorLayers !== undefined) {
    for (const layerID of eRange(numFloorLayers)) {
      // The wall spritesheet is used for the "normal" floors.
      const wallPNGPath = getBackdropPNGPath(
        customStage,
        BackdropKind.WALL,
        rng,
      );
      sprite.ReplaceSpritesheet(layerID, wallPNGPath);
    }
  } else if (isLRoomShape(roomShape)) {
    for (const layerID of L_FLOOR_ANM2_LAYERS) {
      const LFloorPNGPath = getBackdropPNGPath(
        customStage,
        BackdropKind.L_FLOOR,
        rng,
      );
      sprite.ReplaceSpritesheet(layerID, LFloorPNGPath);
    }
  } else if (isNarrowRoom(roomShape)) {
    for (const layerID of N_FLOOR_ANM2_LAYERS) {
      const NFloorPNGPath = getBackdropPNGPath(
        customStage,
        BackdropKind.N_FLOOR,
        rng,
      );
      sprite.ReplaceSpritesheet(layerID, NFloorPNGPath);
    }
  }

  const topLeftPos = room.GetTopLeftPos();
  const renderPos = topLeftPos;
  const modifiedOffset = renderPos.div(40).mul(26); // The magic numbers are copied from StageAPI.
  floorEffect.SpriteOffset = modifiedOffset;

  sprite.LoadGraphics();
  const roomShapeName = RoomShape[roomShape];
  const animation = trimPrefix(roomShapeName, "SHAPE_");
  sprite.Play(animation, true);
}

function getNumFloorLayers(roomShape: RoomShape) {
  switch (roomShape) {
    case RoomShape.SHAPE_1x1: {
      return 4;
    }

    case RoomShape.SHAPE_1x2:
    case RoomShape.SHAPE_2x1: {
      return 8;
    }

    case RoomShape.SHAPE_2x2: {
      return 16;
    }

    default: {
      // We have explicit logic elsewhere to handle narrow rooms and L rooms.
      return undefined;
    }
  }
}

----
classes\features\other\customStages\constants.ts
import { LevelStage, StageType } from "isaac-typescript-definitions";

export const CUSTOM_STAGE_FEATURE_NAME = "CustomStage";

export const ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH = "gfx/isaacscript-custom-stage";

export const DEFAULT_BASE_STAGE = LevelStage.BASEMENT_2;
export const DEFAULT_BASE_STAGE_TYPE = StageType.ORIGINAL;

/**
 * Equal to -1. Setting the stage to an invalid stage value is useful in that it prevents backdrops
 * and shadows from loading.
 */
export const CUSTOM_FLOOR_STAGE = -1 as LevelStage;

/**
 * We must use `StageType.WRATH_OF_THE_LAMB` instead of `StageType.ORIGINAL` or else the walls will
 * not render properly. DeadInfinity suspects that this might be because it is trying to use the
 * Dark Room's backdrop (instead of The Chest).
 */
export const CUSTOM_FLOOR_STAGE_TYPE = StageType.WRATH_OF_THE_LAMB;

----
classes\features\other\customStages\gridEntities.ts
import { GridEntityType, LevelStage } from "isaac-typescript-definitions";
import { removeGridEntity } from "../../../../functions/gridEntities";
import { calculateStageType } from "../../../../functions/stage";
import { removeCharactersBefore } from "../../../../functions/string";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";
import type { CustomTrapdoors } from "../CustomTrapdoors";
import { DEFAULT_BASE_STAGE } from "./constants";

/** For `GridEntityType.DECORATION` (1). */
export function setCustomDecorationGraphics(
  customStage: CustomStage,
  gridEntity: GridEntity,
): void {
  // If the end-user did not specify custom decoration graphics, default to Basement graphics. (We
  // don't have to adjust anything for this case.)
  if (
    customStage.decorationsPNGPath === undefined &&
    customStage.decorationsANM2Path === undefined
  ) {
    return;
  }

  const gridEntityType = gridEntity.GetType();
  if (gridEntityType !== GridEntityType.DECORATION) {
    return;
  }

  const sprite = gridEntity.GetSprite();
  const fileName = sprite.GetFilename();
  // On Windows, this is: gfx/grid/Props_01_Basement.anm2
  if (fileName.toLowerCase() !== "gfx/grid/props_01_basement.anm2") {
    return;
  }

  if (customStage.decorationsANM2Path !== undefined) {
    const anm2Path = removeCharactersBefore(
      customStage.decorationsANM2Path,
      "gfx/",
    );
    sprite.Load(anm2Path, true);
  } else if (customStage.decorationsPNGPath !== undefined) {
    const pngPath = removeCharactersBefore(
      customStage.decorationsPNGPath,
      "gfx/",
    );
    sprite.ReplaceSpritesheet(0, pngPath);
    sprite.LoadGraphics();
  }
}

/** For `GridEntityType.ROCK` (2). */
export function setCustomRockGraphics(
  customStage: CustomStage,
  gridEntity: GridEntity,
): void {
  // If the end-user did not specify custom rock graphics, default to Basement graphics. (We don't
  // have to adjust anything for this case.)
  if (
    customStage.rocksPNGPath === undefined &&
    customStage.rocksANM2Path === undefined
  ) {
    return;
  }

  const gridEntityRock = gridEntity.ToRock();
  if (gridEntityRock === undefined) {
    return;
  }

  const sprite = gridEntity.GetSprite();
  const fileName = sprite.GetFilename();

  switch (fileName) {
    case "gfx/grid/grid_rock.anm2": {
      // The normal case of a rock.
      if (customStage.rocksANM2Path !== undefined) {
        const anm2Path = removeCharactersBefore(
          customStage.rocksANM2Path,
          "gfx/",
        );
        sprite.Load(anm2Path, true);
      } else if (customStage.rocksPNGPath !== undefined) {
        const pngPath = removeCharactersBefore(
          customStage.rocksPNGPath,
          "gfx/",
        );
        sprite.ReplaceSpritesheet(0, pngPath);
        sprite.LoadGraphics();
      }

      break;
    }

    case "gfx/grid/grid_pit.anm2": {
      // The case of when a rock is blown on a pit to make a bridge.
      if (customStage.rocksPNGPath !== undefined) {
        const pngPath = removeCharactersBefore(
          customStage.rocksPNGPath,
          "gfx/",
        );
        sprite.ReplaceSpritesheet(1, pngPath);
        sprite.LoadGraphics();
      }

      break;
    }

    default: {
      break;
    }
  }
}

/** For `GridEntityType.PIT` (7). */
export function setCustomPitGraphics(
  customStage: CustomStage,
  gridEntity: GridEntity,
): void {
  // If the end-user did not specify custom pit graphics, default to Basement graphics. (We don't
  // have to adjust anything for this case.)
  if (customStage.pitsPNGPath === undefined) {
    return;
  }

  const pngPath = removeCharactersBefore(customStage.pitsPNGPath, "gfx/");

  const gridEntityPit = gridEntity.ToPit();
  if (gridEntityPit === undefined) {
    return;
  }

  const sprite = gridEntity.GetSprite();
  const fileName = sprite.GetFilename();
  if (fileName === "gfx/grid/grid_pit.anm2") {
    sprite.ReplaceSpritesheet(0, pngPath);
    sprite.LoadGraphics();
  }
}

/** For `GridEntityType.DOOR` (16). */
export function setCustomDoorGraphics(
  customStage: CustomStage,
  gridEntity: GridEntity,
): void {
  // If the end-user did not specify custom pit graphics, default to Basement graphics. (We don't
  // have to adjust anything for this case.)
  if (customStage.doorPNGPaths === undefined) {
    return;
  }

  const gridEntityDoor = gridEntity.ToDoor();
  if (gridEntityDoor === undefined) {
    return;
  }

  const sprite = gridEntity.GetSprite();
  const fileName = sprite.GetFilename();
  const doorPNGPath = getNewDoorPNGPath(customStage, fileName);
  if (doorPNGPath !== undefined) {
    const fixedPath = removeCharactersBefore(doorPNGPath, "gfx/");
    sprite.ReplaceSpritesheet(0, fixedPath);
    sprite.LoadGraphics();
  }
}

function getNewDoorPNGPath(
  customStage: CustomStage,
  fileName: string,
): string | undefined {
  switch (fileName) {
    case "gfx/grid/door_01_normaldoor.anm2": {
      return customStage.doorPNGPaths?.normal;
    }

    case "gfx/grid/door_02_treasureroomdoor.anm2": {
      return customStage.doorPNGPaths?.treasureRoom;
    }

    case "gfx/grid/door_03_ambushroomdoor.anm2": {
      return customStage.doorPNGPaths?.normalChallengeRoom;
    }

    case "gfx/grid/door_04_selfsacrificeroomdoor.anm2": {
      return customStage.doorPNGPaths?.curseRoom;
    }

    case "gfx/grid/door_05_arcaderoomdoor.anm2": {
      return customStage.doorPNGPaths?.arcade;
    }

    case "gfx/grid/door_07_devilroomdoor.anm2": {
      return customStage.doorPNGPaths?.devilRoom;
    }

    case "gfx/grid/door_07_holyroomdoor.anm2": {
      return customStage.doorPNGPaths?.angelRoom;
    }

    case "gfx/grid/door_08_holeinwall.anm2": {
      return customStage.doorPNGPaths?.secretRoom;
    }

    case "gfx/grid/door_09_bossambushroomdoor.anm2": {
      return customStage.doorPNGPaths?.bossChallengeRoom;
    }

    case "gfx/grid/door_10_bossroomdoor.anm2": {
      return customStage.doorPNGPaths?.bossRoom;
    }

    case "gfx/grid/door_15_bossrushdoor.anm2": {
      return customStage.doorPNGPaths?.bossRush;
    }

    default: {
      return undefined;
    }
  }
}

export function convertVanillaTrapdoors(
  customStage: CustomStage,
  gridEntity: GridEntity,
  isFirstFloor: boolean,
  customTrapdoors: CustomTrapdoors,
): void {
  const gridEntityType = gridEntity.GetType();
  if (gridEntityType !== GridEntityType.TRAPDOOR) {
    return;
  }

  removeGridEntity(gridEntity, true);

  if (isFirstFloor) {
    // If we are on the first floor of a custom stage, then the destination will be the second floor
    // of the custom stage. (e.g. Caves 1 to Caves 2)
    customTrapdoors.spawnCustomTrapdoor(
      gridEntity.Position,
      customStage.name,
      LevelStage.BASEMENT_2,
    );
  } else {
    // If we are on the second floor of a custom stage, then the destination will be the vanilla
    // floor equivalent to 2 floors after the floor used as a basis for the custom stage.
    const baseStage = customStage.baseStage ?? DEFAULT_BASE_STAGE;
    const destinationStage = (baseStage + 2) as LevelStage;
    const destinationStageType = calculateStageType(destinationStage);

    customTrapdoors.spawnCustomTrapdoor(
      gridEntity.Position,
      undefined,
      destinationStage,
      destinationStageType,
    );
  }
}

----
classes\features\other\customStages\shadows.ts
import { EffectVariant, RoomShape } from "isaac-typescript-definitions";
import { game } from "../../../../core/cachedClasses";
import { LadderSubTypeCustom } from "../../../../enums/LadderSubTypeCustom";
import { getRandomArrayElement } from "../../../../functions/array";
import { spawnEffectWithSeed } from "../../../../functions/entitiesSpecific";
import { removeCharactersBefore } from "../../../../functions/string";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";
import { ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH } from "./constants";

type ShadowAnimation = "1x1" | "1x2" | "2x1" | "2x2";

/**
 * Normally, we would make a custom entity to represent a shadow effect, but we don't want to
 * interfere with the "entities2.xml" file in end-user mods. Thus, we must select a vanilla effect
 * to masquerade as a backdrop effect.
 *
 * We arbitrarily choose a ladder for this purpose because it will not automatically despawn after
 * time passes, like most other effects.
 */
const SHADOW_EFFECT_VARIANT = EffectVariant.LADDER;
const SHADOW_EFFECT_SUB_TYPE = LadderSubTypeCustom.CUSTOM_SHADOW;

/** The animation comes from StageAPI. */
const ROOM_SHAPE_TO_SHADOW_ANIMATION = {
  [RoomShape.SHAPE_1x1]: "1x1", // 1
  [RoomShape.IH]: "1x1", // 2
  [RoomShape.IV]: "1x1", // 3
  [RoomShape.SHAPE_1x2]: "1x2", // 4
  [RoomShape.IIV]: "1x2", // 5
  [RoomShape.SHAPE_2x1]: "2x1", // 6
  [RoomShape.IIH]: "2x1", // 7
  [RoomShape.SHAPE_2x2]: "2x2", // 8
  [RoomShape.LTL]: "2x2", // 9
  [RoomShape.LTR]: "2x2", // 10
  [RoomShape.LBL]: "2x2", // 11
  [RoomShape.LBR]: "2x2", // 12
} as const satisfies Record<RoomShape, ShadowAnimation>;

const FADED_BLACK = Color(0, 0, 0, 0.25);

export function setShadows(customStage: CustomStage): void {
  if (customStage.shadows === undefined) {
    return;
  }

  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();
  const centerPos = room.GetCenterPos();
  const animation = ROOM_SHAPE_TO_SHADOW_ANIMATION[roomShape];
  const shadows = customStage.shadows[animation];
  if (shadows === undefined) {
    return;
  }

  // We spawn an effect instead of simply rendering a static sprite so that the effect will properly
  // slide in during a room transition animation. (It looks stupid if the shadow stays statically
  // rendering throughout this animation.)
  const seed = 1 as Seed;
  const shadowEffect = spawnEffectWithSeed(
    SHADOW_EFFECT_VARIANT,
    SHADOW_EFFECT_SUB_TYPE,
    centerPos,
    seed,
  );

  const sprite = shadowEffect.GetSprite();
  sprite.Load(`${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/stage-shadow.anm2`, false);
  const decorationSeed = room.GetDecorationSeed();
  const shadow = getRandomArrayElement(shadows, decorationSeed);
  const pngPath = removeCharactersBefore(shadow.pngPath, "gfx/");
  sprite.ReplaceSpritesheet(0, pngPath);
  sprite.LoadGraphics();
  sprite.SetFrame(animation, 0);
  sprite.Color =
    shadow.color === undefined
      ? FADED_BLACK
      : Color(shadow.color.r, shadow.color.g, shadow.color.b, shadow.color.a);
}

----
classes\features\other\customStages\streakText.ts
import { ButtonAction } from "isaac-typescript-definitions";
import { CONTROLLER_INDEX_VALUES } from "../../../../cachedEnumValues";
import { fonts, game } from "../../../../core/cachedClasses";
import { KColorDefault, VectorOne } from "../../../../core/constants";
import { UIStreakAnimation } from "../../../../enums/private/UIStreakAnimation";
import {
  getElapsedGameFramesSince,
  getElapsedRenderFramesSince,
} from "../../../../functions/frames";
import {
  getScreenBottomCenterPos,
  getScreenTopCenterPos,
} from "../../../../functions/ui";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";
import { v } from "./v";

/** Corresponds to "resources/gfx/ui/ui_streak.anm2". */
const UI_STREAK_ANIMATION_END_FRAMES = {
  [UIStreakAnimation.NONE]: 0,
  [UIStreakAnimation.TEXT]: 69,
  [UIStreakAnimation.TEXT_STAY]: 1,
} as const satisfies Record<UIStreakAnimation, int>;

/** This must match the name of the shader in "shaders.xml". */
const EMPTY_SHADER_NAME = "IsaacScript-RenderAboveHUD";

/**
 * The frame of the "Text" animation that corresponds to when it reaches the center of the screen
 * and stays put.
 */
const TEXT_STAY_FRAME = 8;

/** The frame of the "Text" animation that corresponds to when it starts to move right. */
const TEXT_OUT_FRAME = 60;

/** This matches the offset that the vanilla game uses; determined via trial and error. */
const STREAK_SPRITE_TOP_OFFSET = Vector(0, 47);

/** This matches the offset that the vanilla game uses; determined via trial and error. */
const STREAK_SPRITE_BOTTOM_OFFSET = Vector(0, -48.25);

/**
 * The offset from the bottom of the sprite that the rendered text should go; determined via trial
 * and error.
 */
const STREAK_TEXT_BOTTOM_Y_OFFSET = -9;

/**
 * Corresponds to the vanilla value; determined via trial and error.
 *
 * 8 is too little and 9 has the vanilla text come out just slightly ahead, so we go with 9.
 */
const NUM_RENDER_FRAMES_MAP_HELD_BEFORE_STREAK_TEXT = 11;

/** Taken from StageAPI. */
const TEXT_IN_ADJUSTMENTS = [-800, -639, -450, -250, -70, 10, 6, 3] as const;

/** Taken from StageAPI. */
const TEXT_OUT_ADJUSTMENTS = [
  0, -5, -10, -15, -20, 144, 308, 472, 636, 800,
] as const;

/** Taken from StageAPI. */
const TEXT_IN_SCALES = [
  Vector(3, 0.2),
  Vector(2.6, 0.36),
  Vector(2.2, 0.52),
  Vector(1.8, 0.68),
  Vector(1.4, 0.84),
  Vector(0.95, 1.05),
  Vector(0.97, 1.03),
  Vector(0.98, 1.02),
] as const;

/** Taken from StageAPI. */
const TEXT_OUT_SCALES = [
  Vector(1, 1),
  Vector(0.99, 1.03),
  Vector(0.98, 1.05),
  Vector(0.96, 1.08),
  Vector(0.95, 1.1),
  Vector(1.36, 0.92),
  Vector(1.77, 0.74),
  Vector(2.18, 0.56),
  Vector(2.59, 0.38),
  Vector(3, 0.2),
] as const;

// ModCallback.POST_RENDER (2)
export function streakTextPostRender(): void {
  // The top streak only plays when the player arrives on the floor (or continues a game from the
  // main menu.)
  checkEndTopStreakText();

  // The bottom streak only plays when the player holds down the map button.
  trackMapInputPressed();
  checkStartBottomStreakText();
  checkEndBottomStreakText();
}

function checkEndTopStreakText() {
  if (
    v.run.topStreakTextStartedRenderFrame === null ||
    v.run.topStreakText.animation !== UIStreakAnimation.TEXT_STAY
  ) {
    return;
  }

  const elapsedFrames = getElapsedRenderFramesSince(
    v.run.topStreakTextStartedRenderFrame,
  );
  if (elapsedFrames >= 115) {
    v.run.topStreakText.animation = UIStreakAnimation.TEXT;
    // We adjust by the frame backwards by an arbitrary amount to roughly align with the speed of
    // the vanilla animation.
    v.run.topStreakText.frame = TEXT_OUT_FRAME - 2;
  }
}

function trackMapInputPressed() {
  const gameFrameCount = game.GetFrameCount();

  for (const controllerIndex of CONTROLLER_INDEX_VALUES) {
    const oldPushedMapFrame =
      v.run.controllerIndexPushingMapRenderFrame.get(controllerIndex);
    const isPushingMap = Input.IsActionPressed(
      ButtonAction.MAP,
      controllerIndex,
    );

    if (isPushingMap) {
      if (oldPushedMapFrame === undefined) {
        v.run.controllerIndexPushingMapRenderFrame.set(
          controllerIndex,
          gameFrameCount,
        );
      }
    } else {
      v.run.controllerIndexPushingMapRenderFrame.delete(controllerIndex);
    }
  }
}

/**
 * If the map input has been pressed down for long enough, play the animation where the level streak
 * slides in from the left.
 */
function checkStartBottomStreakText() {
  if (v.run.bottomStreakText.animation !== UIStreakAnimation.NONE) {
    return;
  }

  const pushedMapFrames = [
    ...v.run.controllerIndexPushingMapRenderFrame.values(),
  ];
  if (pushedMapFrames.length === 0) {
    return;
  }

  const earliestFrame = Math.min(...pushedMapFrames);
  const elapsedFrames = getElapsedGameFramesSince(earliestFrame);
  if (elapsedFrames >= NUM_RENDER_FRAMES_MAP_HELD_BEFORE_STREAK_TEXT) {
    v.run.bottomStreakText.animation = UIStreakAnimation.TEXT;
    v.run.bottomStreakText.frame = 0;
  }
}

/**
 * If the map input has been released, play the animation where the level streak slides out to the
 * right.
 */
function checkEndBottomStreakText() {
  if (v.run.bottomStreakText.animation !== UIStreakAnimation.TEXT_STAY) {
    return;
  }

  const pushedMapFrames = [
    ...v.run.controllerIndexPushingMapRenderFrame.values(),
  ];
  if (pushedMapFrames.length === 0) {
    v.run.bottomStreakText.animation = UIStreakAnimation.TEXT;
    // We adjust by the frame backwards by an arbitrary amount to roughly align with the speed of
    // the vanilla animation.
    v.run.bottomStreakText.frame = TEXT_OUT_FRAME - 2;
  }
}

// ModCallback.GET_SHADER_PARAMS (22)
export function streakTextGetShaderParams(
  customStage: CustomStage,
  shaderName: string,
): void {
  if (shaderName !== EMPTY_SHADER_NAME) {
    return;
  }

  const topCenterPos = getScreenTopCenterPos();
  const topStreakPosition = topCenterPos.add(STREAK_SPRITE_TOP_OFFSET);
  renderStreakText(customStage, v.run.topStreakText, topStreakPosition);

  const bottomCenterPos = getScreenBottomCenterPos();
  const bottomStreakPosition = bottomCenterPos.add(STREAK_SPRITE_BOTTOM_OFFSET);
  renderStreakText(customStage, v.run.bottomStreakText, bottomStreakPosition);
}

function renderStreakText(
  customStage: CustomStage,
  streakText: { animation: UIStreakAnimation; frame: int; pauseFrame: boolean },
  position: Vector,
) {
  if (streakText.animation === UIStreakAnimation.NONE) {
    return;
  }

  if (streakText.animation !== UIStreakAnimation.TEXT_STAY) {
    const { pauseFrame } = streakText;
    streakText.pauseFrame = !streakText.pauseFrame;

    if (!pauseFrame) {
      streakText.frame++;
    }
  }

  const endFrame = UI_STREAK_ANIMATION_END_FRAMES[streakText.animation];
  if (streakText.frame > endFrame) {
    streakText.animation = UIStreakAnimation.NONE;
    streakText.frame = 0;
    return;
  }

  if (
    streakText.animation === UIStreakAnimation.TEXT &&
    streakText.frame === TEXT_STAY_FRAME
  ) {
    streakText.animation = UIStreakAnimation.TEXT_STAY;
    streakText.frame = 0;
  }

  const isPaused = game.IsPaused();
  if (isPaused) {
    return;
  }

  const font = fonts.upheaval;
  const { name } = customStage;
  const numberSuffix = v.run.firstFloor ? "I" : "II";
  const nameWithNumberSuffix = `${name} ${numberSuffix}`;
  const length = font.GetStringWidthUTF8(nameWithNumberSuffix);
  const centeredX = position.X - length / 2;

  let adjustment = 0;
  let scale = VectorOne;

  if (streakText.animation === UIStreakAnimation.TEXT) {
    if (streakText.frame < TEXT_STAY_FRAME) {
      adjustment = TEXT_IN_ADJUSTMENTS[streakText.frame] ?? 0;
      scale = TEXT_IN_SCALES[streakText.frame] ?? VectorOne;
    } else {
      const adjustedFrame = streakText.frame - TEXT_OUT_FRAME;
      adjustment = TEXT_OUT_ADJUSTMENTS[adjustedFrame] ?? 0;
      scale = TEXT_OUT_SCALES[adjustedFrame] ?? VectorOne;
    }
  }

  const adjustedX = centeredX + adjustment;
  const adjustedY = position.Y + STREAK_TEXT_BOTTOM_Y_OFFSET;

  font.DrawStringScaled(
    nameWithNumberSuffix,
    adjustedX,
    adjustedY,
    scale.X,
    scale.Y,
    KColorDefault,
  );
}

export function topStreakTextStart(): void {
  const level = game.GetLevel();
  const renderFrameCount = Isaac.GetFrameCount();

  // Show the vanilla streak text, which will have a blank name because of the -1 floor.
  level.ShowName(false);

  // Initiate the animation for the custom text.
  v.run.topStreakText.animation = UIStreakAnimation.TEXT;
  v.run.topStreakText.frame = 0;
  v.run.topStreakTextStartedRenderFrame = renderFrameCount;
}

----
classes\features\other\customStages\utils.ts
import { sumArray } from "../../../../functions/array";
import { log } from "../../../../functions/log";
import { getRandomFloat } from "../../../../functions/random";
import type {
  CustomStageBossPoolEntry,
  CustomStageRoomMetadata,
} from "../../../../interfaces/CustomStageTSConfig";

/**
 * Helper function to get a random custom stage room from an array of custom stage rooms.
 *
 * Note that this function does not simply choose a random element in the provided array; it will
 * properly account for each room weight using the algorithm from:
 * https://stackoverflow.com/questions/1761626/weighted-random-numbers
 */
export function getRandomCustomStageRoom(
  roomsMetadata: readonly CustomStageRoomMetadata[],
  seedOrRNG: Seed | RNG | undefined,
  verbose = false,
): CustomStageRoomMetadata {
  const totalWeight = getTotalWeightOfCustomStageRooms(roomsMetadata);
  if (verbose) {
    log(`Total weight of the custom stage rooms provided: ${totalWeight}`);
  }

  const chosenWeight = getRandomFloat(0, totalWeight, seedOrRNG);
  if (verbose) {
    log(`Randomly chose weight for custom stage room: ${chosenWeight}`);
  }

  return getCustomStageRoomWithChosenWeight(roomsMetadata, chosenWeight);
}

function getTotalWeightOfCustomStageRooms(
  roomsMetadata: readonly CustomStageRoomMetadata[],
): float {
  const weights = roomsMetadata.map((roomMetadata) => roomMetadata.weight);
  return sumArray(weights);
}

function getCustomStageRoomWithChosenWeight(
  roomsMetadata: readonly CustomStageRoomMetadata[],
  chosenWeight: float,
): CustomStageRoomMetadata {
  for (const roomMetadata of roomsMetadata) {
    if (chosenWeight < roomMetadata.weight) {
      return roomMetadata;
    }

    chosenWeight -= roomMetadata.weight;
  }

  error(
    `Failed to get a custom stage room with chosen weight: ${chosenWeight}`,
  );
}

export function getRandomBossRoomFromPool(
  roomsMetadata: readonly CustomStageRoomMetadata[],
  bossPool: readonly CustomStageBossPoolEntry[],
  seedOrRNG: Seed | RNG | undefined,
  verbose = false,
): CustomStageRoomMetadata {
  const totalWeight = getTotalWeightOfBossPool(bossPool);
  if (verbose) {
    log(`Total weight of the custom stage boss pool provided: ${totalWeight}`);
  }

  const chosenWeight = getRandomFloat(0, totalWeight, seedOrRNG);
  if (verbose) {
    log(`Randomly chose weight for custom stage boss pool: ${chosenWeight}`);
  }

  const bossEntry = getBossEntryWithChosenWeight(bossPool, chosenWeight);

  const roomsMetadataForBoss = roomsMetadata.filter(
    (roomMetadata) => roomMetadata.subType === bossEntry.subType,
  );
  return getRandomCustomStageRoom(roomsMetadataForBoss, seedOrRNG, verbose);
}

function getTotalWeightOfBossPool(
  bossPool: readonly CustomStageBossPoolEntry[],
): float {
  const weights = bossPool.map((bossEntry) => bossEntry.weight);
  return sumArray(weights);
}

function getBossEntryWithChosenWeight(
  bossPool: readonly CustomStageBossPoolEntry[],
  chosenWeight: float,
): CustomStageBossPoolEntry {
  for (const bossEntry of bossPool) {
    if (chosenWeight < bossEntry.weight) {
      return bossEntry;
    }

    chosenWeight -= bossEntry.weight;
  }

  error(
    `Failed to get a custom stage boss entry with chosen weight: ${chosenWeight}`,
  );
}

----
classes\features\other\customStages\v.ts
import type { ControllerIndex } from "isaac-typescript-definitions";
import { UIStreakAnimation } from "../../../../enums/private/UIStreakAnimation";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";

// This is registered in "CustomStages.ts".
// eslint-disable-next-line isaacscript/require-v-registration
export const v = {
  run: {
    currentCustomStage: null as CustomStage | null,

    /** Whether we are on e.g. Caves 1 or Caves 2. */
    firstFloor: true,

    showingBossVersusScreen: false,

    /** Values are the render frame that the controller first pressed the map button. */
    controllerIndexPushingMapRenderFrame: new Map<ControllerIndex, int>(),

    topStreakTextStartedRenderFrame: null as int | null,

    topStreakText: {
      animation: UIStreakAnimation.NONE,
      frame: 0,
      pauseFrame: false,
    },

    bottomStreakText: {
      animation: UIStreakAnimation.NONE,
      frame: 0,
      pauseFrame: false,
    },
  },
};

----
classes\features\other\customStages\versusScreen.ts
// This emulates the vanilla versus screen that shows up when you enter a boss room.

import {
  BossID,
  PlayerType,
  RoomType,
  SoundEffect,
  StageID,
} from "isaac-typescript-definitions";
import { game, sfxManager } from "../../../../core/cachedClasses";
import { arrayRemove } from "../../../../functions/array";
import { getBosses } from "../../../../functions/bosses";
import { getRoomSubType } from "../../../../functions/roomData";
import { removeCharactersBefore } from "../../../../functions/string";
import { getScreenCenterPos } from "../../../../functions/ui";
import { eRange } from "../../../../functions/utils";
import {
  getBossNamePNGFilePath,
  getBossPortraitPNGFilePath,
  getCharacterNamePNGFilePath,
  getCharacterPortraitPNGFilePath,
} from "../../../../functions/versusScreen";
import type { CustomStage } from "../../../../interfaces/private/CustomStage";
import { VERSUS_SCREEN_BACKGROUND_COLORS } from "../../../../objects/versusScreenBackgroundColors";
import { VERSUS_SCREEN_DIRT_SPOT_COLORS } from "../../../../objects/versusScreenDirtSpotColors";
import type { DisableAllSound } from "../DisableAllSound";
import type { Pause } from "../Pause";
import type { RunInNFrames } from "../RunInNFrames";
import {
  CUSTOM_FLOOR_STAGE,
  CUSTOM_FLOOR_STAGE_TYPE,
  CUSTOM_STAGE_FEATURE_NAME,
  DEFAULT_BASE_STAGE,
  DEFAULT_BASE_STAGE_TYPE,
  ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH,
} from "./constants";
import { v } from "./v";

const DEFAULT_STAGE_ID = StageID.BASEMENT;
const VERSUS_SCREEN_ANIMATION_NAME = "Scene";

/** The layers range from 0 to 13. */
const NUM_VERSUS_SCREEN_ANM2_LAYERS = 14;

/** Corresponds to "resources/gfx/ui/boss/versusscreen.anm2". */
enum VersusScreenLayer {
  BACKGROUND = 0,
  FRAME = 1,

  /** The boss dirt spot. */
  BOSS_SPOT = 2,

  /** The player dirt spot. */
  PLAYER_SPOT = 3,

  BOSS_PORTRAIT = 4,
  PLAYER_PORTRAIT = 5,
  PLAYER_NAME = 6,
  BOSS_NAME = 7,
  VS_TEXT = 8,
  BOSS_DOUBLE = 9,
  DT_TEXT = 10,
  OVERLAY = 11,

  /**
   * We only need to render either the normal player portrait layer or the alternate player portrait
   * layer. Rendering both will cause the player not to shake.
   */
  PLAYER_PORTRAIT_ALT = 12,

  BOSS_PORTRAIT_GROUND = 13,
  BOSS_PORTRAIT_2_GROUND = 14,
}

/** These are the non-special layers that we will render last. */
const OTHER_ANM2_LAYERS: readonly int[] = arrayRemove(
  eRange(NUM_VERSUS_SCREEN_ANM2_LAYERS),
  VersusScreenLayer.BACKGROUND,
  VersusScreenLayer.BOSS_SPOT,
  VersusScreenLayer.PLAYER_SPOT,
  VersusScreenLayer.OVERLAY,
  VersusScreenLayer.PLAYER_PORTRAIT_ALT,
);

const VANILLA_VERSUS_PLAYBACK_SPEED = 0.5;

/** We lazy load the sprite when first needed. */
const versusScreenSprite = Sprite();

/**
 * We lazy load the sprite when first needed.
 *
 * Unfortunately, we must split the background layer into an entirely different sprite so that we
 * can color it with the `Color` field.
 */
const versusScreenBackgroundSprite = Sprite();

/**
 * We lazy load the sprite when first needed.
 *
 * Unfortunately, we must split the dirt layer into an entirely different sprite so that we can
 * color it with the `Color` field.
 */
const versusScreenDirtSpotSprite = Sprite();

export function playVersusScreenAnimation(
  customStage: CustomStage,
  disableAllSound: DisableAllSound,
  pause: Pause,
  runInNFrames: RunInNFrames,
): void {
  const room = game.GetRoom();
  const roomType = room.GetType();
  const roomCleared = room.IsClear();
  const hud = game.GetHUD();

  if (roomType !== RoomType.BOSS) {
    return;
  }

  if (roomCleared) {
    return;
  }

  if (willVanillaVersusScreenPlay()) {
    // Since we are on an invalid stage, the versus screen will have a completely black background.
    // Revert to using the background from the default stage.
    const level = game.GetLevel();
    level.SetStage(DEFAULT_BASE_STAGE, DEFAULT_BASE_STAGE_TYPE);
    runInNFrames.runNextGameFrame(() => {
      const futureLevel = game.GetLevel();
      futureLevel.SetStage(CUSTOM_FLOOR_STAGE, CUSTOM_FLOOR_STAGE_TYPE);
    });
    return;
  }

  v.run.showingBossVersusScreen = true;

  pause.pause();
  hud.SetVisible(false);
  disableAllSound.disableAllSound(CUSTOM_STAGE_FEATURE_NAME);

  // In vanilla, the "overlay.png" file has a white background. We must convert it to a PNG that
  // uses a transparent background in order for the background behind it to be visible. We use the
  // same "overlay.png" file as StageAPI uses for this purpose.
  if (!versusScreenSprite.IsLoaded()) {
    versusScreenSprite.Load("gfx/ui/boss/versusscreen.anm2", false);
    versusScreenSprite.ReplaceSpritesheet(
      VersusScreenLayer.OVERLAY,
      `${ISAACSCRIPT_CUSTOM_STAGE_GFX_PATH}/overlay.png`,
    );
  }

  // Player
  {
    const { namePNGPath, portraitPNGPath } = getPlayerPNGPaths();
    versusScreenSprite.ReplaceSpritesheet(
      VersusScreenLayer.PLAYER_NAME,
      namePNGPath,
    );
    versusScreenSprite.ReplaceSpritesheet(
      VersusScreenLayer.PLAYER_PORTRAIT,
      portraitPNGPath,
    );
  }

  // Boss
  {
    const { namePNGPath, portraitPNGPath } = getBossPNGPaths(customStage);
    const trimmedNamePNGPath = removeCharactersBefore(namePNGPath, "gfx/");
    versusScreenSprite.ReplaceSpritesheet(
      VersusScreenLayer.BOSS_NAME,
      trimmedNamePNGPath,
    );
    const trimmedPortraitPNGPath = removeCharactersBefore(
      portraitPNGPath,
      "gfx/",
    );
    versusScreenSprite.ReplaceSpritesheet(
      VersusScreenLayer.BOSS_PORTRAIT,
      trimmedPortraitPNGPath,
    );
  }

  versusScreenSprite.LoadGraphics();

  if (!versusScreenBackgroundSprite.IsLoaded()) {
    versusScreenBackgroundSprite.Load("gfx/ui/boss/versusscreen.anm2", true);
  }

  let backgroundColor = VERSUS_SCREEN_BACKGROUND_COLORS[DEFAULT_STAGE_ID];
  if (customStage.versusScreen?.backgroundColor !== undefined) {
    const { r, g, b, a } = customStage.versusScreen.backgroundColor;
    backgroundColor = Color(r, g, b, a);
  }
  versusScreenBackgroundSprite.Color = backgroundColor;

  if (!versusScreenDirtSpotSprite.IsLoaded()) {
    versusScreenDirtSpotSprite.Load("gfx/ui/boss/versusscreen.anm2", true);
  }

  let dirtSpotColor = VERSUS_SCREEN_DIRT_SPOT_COLORS[DEFAULT_STAGE_ID];
  if (customStage.versusScreen?.dirtSpotColor !== undefined) {
    const { r, g, b } = customStage.versusScreen.dirtSpotColor;
    dirtSpotColor = Color(r, g, b);
  }
  versusScreenDirtSpotSprite.Color = dirtSpotColor;

  for (const sprite of [
    versusScreenBackgroundSprite,
    versusScreenDirtSpotSprite,
    versusScreenSprite,
  ]) {
    sprite.Play(VERSUS_SCREEN_ANIMATION_NAME, true);
    sprite.PlaybackSpeed = VANILLA_VERSUS_PLAYBACK_SPEED;
  }
}

function willVanillaVersusScreenPlay() {
  const bosses = getBosses();
  return bosses.some((boss) => boss.GetBossID() !== 0);
}

/** Use the character of the 0th player. */
function getPlayerPNGPaths(): {
  namePNGPath: string;
  portraitPNGPath: string;
} {
  const player = Isaac.GetPlayer();
  const character = player.GetPlayerType();
  if (character === PlayerType.POSSESSOR) {
    error("Failed to get the player PNG paths since they are a possessor.");
  }

  const namePNGPath = getCharacterNamePNGFilePath(character);
  const portraitPNGPath = getCharacterPortraitPNGFilePath(character);

  return { namePNGPath, portraitPNGPath };
}

/** Use the boss of the first boss found. */
function getBossPNGPaths(customStage: CustomStage): {
  namePNGPath: string;
  portraitPNGPath: string;
} {
  // Prefer the PNG paths specified by the end-user, if any.
  const paths = getBossPNGPathsCustom(customStage);
  if (paths !== undefined) {
    return paths;
  }

  // If this is not a vanilla boss, default to showing question marks.
  const bosses = getBosses();
  const firstBoss = bosses[0];
  const bossID = firstBoss === undefined ? 0 : firstBoss.GetBossID();
  if (bossID === 0) {
    const questionMarkPath = getBossNamePNGFilePath(BossID.BLUE_BABY);
    const namePNGPath = questionMarkPath;
    const portraitPNGPath = questionMarkPath;
    return { namePNGPath, portraitPNGPath };
  }

  // If this is a vanilla boss, it will have a boss ID, and we can use the corresponding vanilla
  // files.
  const namePNGPath = getBossNamePNGFilePath(bossID);
  const portraitPNGPath = getBossPortraitPNGFilePath(bossID);

  return { namePNGPath, portraitPNGPath };
}

function getBossPNGPathsCustom(
  customStage: CustomStage,
): { namePNGPath: string; portraitPNGPath: string } | undefined {
  if (customStage.bossPool === undefined) {
    return undefined;
  }

  const roomSubType = getRoomSubType();
  const matchingBossEntry = customStage.bossPool.find(
    (bossEntry) => bossEntry.subType === roomSubType,
  );
  if (matchingBossEntry === undefined) {
    return undefined;
  }

  return matchingBossEntry.versusScreen;
}

function finishVersusScreenAnimation(
  pause: Pause,
  disableAllSound: DisableAllSound,
) {
  const hud = game.GetHUD();

  v.run.showingBossVersusScreen = false;

  pause.unpause();
  hud.SetVisible(true);
  disableAllSound.enableAllSound(CUSTOM_STAGE_FEATURE_NAME);

  // The sound effect only plays once the versus cutscene is over.
  sfxManager.Play(SoundEffect.CASTLE_PORTCULLIS);
}

// ModCallback.POST_RENDER (2)
export function versusScreenPostRender(
  pause: Pause,
  disableAllSound: DisableAllSound,
): void {
  if (!v.run.showingBossVersusScreen) {
    return;
  }

  // We do not want to early return when the game is paused because we need to start displaying the
  // black screen as soon as the slide animation starts.

  if (versusScreenSprite.IsFinished(VERSUS_SCREEN_ANIMATION_NAME)) {
    finishVersusScreenAnimation(pause, disableAllSound);
    return;
  }

  const position = getScreenCenterPos();

  // First, we render the background.
  versusScreenBackgroundSprite.RenderLayer(
    VersusScreenLayer.BACKGROUND,
    position,
  );
  versusScreenBackgroundSprite.Update();

  // Second, we render the overlay.
  versusScreenSprite.RenderLayer(VersusScreenLayer.OVERLAY, position);

  // Third, we render the dirt.
  versusScreenDirtSpotSprite.RenderLayer(VersusScreenLayer.BOSS_SPOT, position);
  versusScreenDirtSpotSprite.RenderLayer(
    VersusScreenLayer.PLAYER_SPOT,
    position,
  );
  versusScreenDirtSpotSprite.Update();

  // Lastly, we render everything else.
  for (const layerID of OTHER_ANM2_LAYERS) {
    versusScreenSprite.RenderLayer(layerID, position);
  }
  versusScreenSprite.Update();
}

----
classes\features\other\debugDisplay\DebugDisplayBomb.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayBomb extends Feature {
  public textCallback: (bomb: EntityBomb) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 59
      [ModCallback.POST_BOMB_RENDER, this.postBombRender],
    ];
  }

  // ModCallback.POST_BOMB_RENDER (59)
  private readonly postBombRender = (bomb: EntityBomb) => {
    const text = this.textCallback(bomb);
    renderTextOnEntity(bomb, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayDoor.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayDoor extends Feature {
  public textCallback: (door: GridEntityDoor) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_DOOR_RENDER, this.postDoorRender],
    ];
  }

  // ModCallbackCustom.POST_DOOR_RENDER
  private readonly postDoorRender = (door: GridEntityDoor) => {
    const text = this.textCallback(door);
    renderTextOnEntity(door, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayEffect.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayEffect extends Feature {
  public textCallback: (effect: EntityEffect) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 56
      [ModCallback.POST_EFFECT_RENDER, this.postEffectRender],
    ];
  }

  // ModCallback.POST_EFFECT_RENDER (56)
  private readonly postEffectRender = (effect: EntityEffect) => {
    const text = this.textCallback(effect);
    renderTextOnEntity(effect, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayFamiliar.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayFamiliar extends Feature {
  public textCallback: (familiar: EntityFamiliar) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 25
      [ModCallback.POST_FAMILIAR_RENDER, this.postFamiliarRender],
    ];
  }

  // ModCallback.POST_FAMILIAR_RENDER (25)
  private readonly postFamiliarRender = (familiar: EntityFamiliar) => {
    const text = this.textCallback(familiar);
    renderTextOnEntity(familiar, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayKnife.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayKnife extends Feature {
  public textCallback: (knife: EntityKnife) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 52
      [ModCallback.POST_KNIFE_RENDER, this.postKnifeRender],
    ];
  }

  // ModCallback.POST_KNIFE_RENDER (52)
  private readonly postKnifeRender = (knife: EntityKnife) => {
    const text = this.textCallback(knife);
    renderTextOnEntity(knife, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayLaser.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayLaser extends Feature {
  public textCallback: (laser: EntityLaser) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 49
      [ModCallback.POST_LASER_RENDER, this.postLaserRender],
    ];
  }

  // ModCallback.POST_LASER_RENDER (49)
  private readonly postLaserRender = (laser: EntityLaser) => {
    const text = this.textCallback(laser);
    renderTextOnEntity(laser, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayNPC.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayNPC extends Feature {
  public textCallback: (npc: EntityNPC) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 28
      [ModCallback.POST_NPC_RENDER, this.postNPCRender],
    ];
  }

  // ModCallback.POST_NPC_RENDER (28)
  private readonly postNPCRender = (npc: EntityNPC) => {
    const text = this.textCallback(npc);
    renderTextOnEntity(npc, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayPickup.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayPickup extends Feature {
  public textCallback: (pickup: EntityPickup) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 36
      [ModCallback.POST_PICKUP_RENDER, this.postPickupRender],
    ];
  }

  // ModCallback.POST_PICKUP_RENDER (36)
  private readonly postPickupRender = (pickup: EntityPickup) => {
    const text = this.textCallback(pickup);
    renderTextOnEntity(pickup, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayPit.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayPit extends Feature {
  public textCallback: (pit: GridEntityPit) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_PIT_RENDER, this.postPitRender],
    ];
  }

  // ModCallbackCustom.POST_PIT_RENDER
  private readonly postPitRender = (pit: GridEntityPit) => {
    const text = this.textCallback(pit);
    renderTextOnEntity(pit, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayPlayer.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayPlayer extends Feature {
  public textCallback: (player: EntityPlayer) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PLAYER_RENDER_REORDERED,
        this.postPlayerRenderReordered,
      ],
    ];
  }

  // ModCallbackCustom.POST_PLAYER_RENDER_REORDERED
  private readonly postPlayerRenderReordered = (player: EntityPlayer) => {
    const text = this.textCallback(player);
    renderTextOnEntity(player, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayPoop.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayPoop extends Feature {
  public textCallback: (poop: GridEntityPoop) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_POOP_RENDER, this.postPoopRender],
    ];
  }

  // ModCallbackCustom.POST_POOP_RENDER
  private readonly postPoopRender = (poop: GridEntityPoop) => {
    const text = this.textCallback(poop);
    renderTextOnEntity(poop, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayPressurePlate.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayPressurePlate extends Feature {
  public textCallback: (pressurePlate: GridEntityPressurePlate) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [
        ModCallbackCustom.POST_PRESSURE_PLATE_RENDER,
        this.postPressurePlateRender,
      ],
    ];
  }

  // ModCallbackCustom.POST_PRESSURE_PLATE_RENDER
  private readonly postPressurePlateRender = (
    pressurePlate: GridEntityPressurePlate,
  ) => {
    const text = this.textCallback(pressurePlate);
    renderTextOnEntity(pressurePlate, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayProjectile.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayProjectile extends Feature {
  public textCallback: (projectile: EntityProjectile) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 45
      [ModCallback.POST_PROJECTILE_RENDER, this.postProjectileRender],
    ];
  }

  // ModCallback.POST_PROJECTILE_RENDER (45)
  private readonly postProjectileRender = (projectile: EntityProjectile) => {
    const text = this.textCallback(projectile);
    renderTextOnEntity(projectile, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayRock.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayRock extends Feature {
  public textCallback: (rock: GridEntityRock) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_ROCK_RENDER, this.postRockRender],
    ];
  }

  // ModCallbackCustom.POST_ROCK_RENDER
  private readonly postRockRender = (rock: GridEntityRock) => {
    const text = this.textCallback(rock);
    renderTextOnEntity(rock, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplaySlot.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplaySlot extends Feature {
  public textCallback: (slot: EntitySlot) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_SLOT_RENDER, this.postSlotRender],
    ];
  }

  // ModCallbackCustom.POST_SLOT_RENDER
  private readonly postSlotRender = (slot: EntitySlot) => {
    const text = this.textCallback(slot);
    renderTextOnEntity(slot, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplaySpikes.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplaySpikes extends Feature {
  public textCallback: (spikes: GridEntitySpikes) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_SPIKES_RENDER, this.postSpikesRender],
    ];
  }

  // ModCallbackCustom.POST_SPIKES_RENDER
  private readonly postSpikesRender = (spikes: GridEntitySpikes) => {
    const text = this.textCallback(spikes);
    renderTextOnEntity(spikes, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayTNT.ts
import { ModCallbackCustom } from "../../../../enums/ModCallbackCustom";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultGridEntityDisplayCallback } from "./utils";

export class DebugDisplayTNT extends Feature {
  public textCallback: (tnt: GridEntityTNT) => string =
    defaultGridEntityDisplayCallback;

  constructor() {
    super();

    this.customCallbacksUsed = [
      [ModCallbackCustom.POST_TNT_RENDER, this.postTNTRender],
    ];
  }

  // ModCallbackCustom.POST_TNT_RENDER
  private readonly postTNTRender = (tnt: GridEntityTNT) => {
    const text = this.textCallback(tnt);
    renderTextOnEntity(tnt, text);
  };
}

----
classes\features\other\debugDisplay\DebugDisplayTear.ts
import { ModCallback } from "isaac-typescript-definitions";
import { renderTextOnEntity } from "../../../../functions/render";
import { Feature } from "../../../private/Feature";
import { defaultEntityDisplayCallback } from "./utils";

export class DebugDisplayTear extends Feature {
  public textCallback: (tear: EntityTear) => string =
    defaultEntityDisplayCallback;

  constructor() {
    super();

    this.callbacksUsed = [
      // 41
      [ModCallback.POST_TEAR_RENDER, this.postTearRender],
    ];
  }

  // ModCallback.POST_TEAR_RENDER (41)
  private readonly postTearRender = (tear: EntityTear) => {
    const text = this.textCallback(tear);
    renderTextOnEntity(tear, text);
  };
}

----
classes\features\other\debugDisplay\utils.ts
import { getEntityID } from "../../../../functions/entities";
import { getGridEntityID } from "../../../../functions/gridEntities";

export function defaultEntityDisplayCallback(entity: Entity): string {
  return getEntityID(entity);
}

export function defaultGridEntityDisplayCallback(
  gridEntity: GridEntity,
): string {
  return getGridEntityID(gridEntity);
}

----
classes\features\other\extraConsoleCommands\commands.ts
// cspell:ignore addcharges

/*
eslint "sort-exports/sort-exports": [
  "error",
  {
    sortDir: "asc",
  },
],
*/

/* eslint "jsdoc/require-jsdoc": "error" */

/**
 * __DOCS_LINE_THAT_WILL_BE_AUTOMATICALLY_REMOVED__
 *
 * This is a list of custom console commands that are included with the standard library. By
 * default, they will not be enabled. You can enable them by upgrading your mod with
 * `ISCFeature.EXTRA_CONSOLE_COMMANDS`. (Also see the [Extra Console Commands](ExtraConsoleCommands)
 * feature documentation.)
 *
 * As a quality of life feature, you do not have to match the casing of the command. For example,
 * you can type the "addCharges" command as "addcharges", and it will still work the same.
 *
 * Additionally, you can also abbreviate any command by omitting letters that do not overlap with
 * any other command. For example, the command of "c" will be interpreted as the "card" command.
 *
 * In order for the custom console commands to work, you first have to enable
 * `ISCFeature.EXTRA_CONSOLE_COMMANDS` when upgrading your mod. (See the "Extra Console Commands
 * (Init)" page for more details.)
 *
 * Each command has a corresponding function of the same name, but these functions are not exported
 * for end-user consumption. (This is to cut down on namespace conflicts and because the names of
 * the functions are not very descriptive.)
 *
 * @module
 */

import type {
  CardType,
  PillEffect,
  TrinketType,
} from "isaac-typescript-definitions";
import {
  ActiveSlot,
  BossID,
  CacheFlag,
  Challenge,
  CollectibleType,
  Direction,
  DisplayFlag,
  GameStateFlag,
  GridEntityType,
  GridRoom,
  LevelStage,
  PillColor,
  PlayerType,
  PocketItemSlot,
  RoomType,
  SoundEffect,
  StageType,
} from "isaac-typescript-definitions";
import { GRID_ENTITY_TYPE_VALUES } from "../../../../cachedEnumValues";
import { game, sfxManager } from "../../../../core/cachedClasses";
import {
  DOGMA_ROOM_GRID_INDEX,
  MAX_LEVEL_GRID_INDEX,
  MAX_NUM_FAMILIARS,
} from "../../../../core/constants";
import {
  FIRST_CARD_TYPE,
  FIRST_HORSE_PILL_COLOR,
  FIRST_PILL_COLOR,
  LAST_VANILLA_CARD_TYPE,
} from "../../../../core/constantsFirstLast";
import { HealthType } from "../../../../enums/HealthType";
import { getCardName, isValidCardType } from "../../../../functions/cards";
import { getCharacterName } from "../../../../functions/characters";
import { addCharge, getTotalCharge } from "../../../../functions/charge";
import { isValidCollectibleType } from "../../../../functions/collectibles";
import { printEnabled } from "../../../../functions/console";
import { runDeepCopyTests } from "../../../../functions/deepCopyTests";
import { getNPCs } from "../../../../functions/entitiesSpecific";
import { isEnumValue } from "../../../../functions/enums";
import { addFlag } from "../../../../functions/flag";
import { spawnGridEntity } from "../../../../functions/gridEntities";
import { getRoomGridIndexesForType } from "../../../../functions/levelGrid";
import {
  logMusic,
  logPlayerEffects,
  logRoom,
  logSeedEffects,
  logSounds,
} from "../../../../functions/logMisc";
import { runMergeTests } from "../../../../functions/mergeTests";
import {
  spawnCard,
  spawnPill,
  spawnTrinket as spawnTrinketFunction,
} from "../../../../functions/pickupsSpecific";
import {
  getHorsePillColor,
  getPillEffectName,
  isValidPillEffect,
} from "../../../../functions/pills";
import {
  addCollectibleCostume,
  removeCollectibleCostume,
  useActiveItemTemp,
} from "../../../../functions/playerCollectibles";
import { getPlayers } from "../../../../functions/playerIndex";
import { getPlayerName } from "../../../../functions/players";
import { getRoomData } from "../../../../functions/roomData";
import { gridCoordinatesToWorldPosition } from "../../../../functions/roomGrid";
import { reloadRoom as reloadRoomFunction } from "../../../../functions/roomTransition";
import { changeRoom } from "../../../../functions/rooms";
import { onSetSeed, restart, setUnseeded } from "../../../../functions/run";
import { spawnCollectible as spawnCollectibleFunc } from "../../../../functions/spawnCollectible";
import { onStage, setStage } from "../../../../functions/stage";
import { getMapPartialMatch } from "../../../../functions/string";
import {
  getGoldenTrinketType,
  isValidTrinketType,
} from "../../../../functions/trinkets";
import { parseIntSafe } from "../../../../functions/types";
import { iRange } from "../../../../functions/utils";
import { CARD_NAME_TO_TYPE_MAP } from "../../../../maps/cardNameToTypeMap";
import { CHARACTER_NAME_TO_TYPE_MAP } from "../../../../maps/characterNameToTypeMap";
import { COLLECTIBLE_NAME_TO_TYPE_MAP } from "../../../../maps/collectibleNameToTypeMap";
import { PILL_NAME_TO_EFFECT_MAP } from "../../../../maps/pillNameToEffectMap";
import { ROOM_NAME_TO_TYPE_MAP } from "../../../../maps/roomNameToTypeMap";
import { TRINKET_NAME_TO_TYPE_MAP } from "../../../../maps/trinketNameToTypeMap";
import { ROOM_TYPE_NAMES } from "../../../../objects/roomTypeNames";
import {
  addHeart,
  devilAngel,
  listEntities,
  listGridEntities,
  movePlayer,
  spawnTrapdoorOrCrawlSpace,
  warpNextToRoomType,
  warpToRoomType,
} from "./subroutines";
import { v } from "./v";

/**
 * Adds a single charge to the player's specified active item. You must provide the active slot
 * number. Provide a second number to give a custom amount of charges. (You can use negative numbers
 * to remove charge.)
 */
export function addCharges(params: string): void {
  if (params === "") {
    print(
      "You must specify a slot number. (Use 0 for the primary slot, 1 for the Schoolbag slot, 2 for the pocket item slot, and 3 for the Dice Bag slot.)",
    );
    return;
  }

  const args = params.split(" ");

  if (args.length !== 1 && args.length !== 2) {
    print(`Invalid amount of arguments: ${args.length}`);
    return;
  }

  const [activeSlotString, numChargeString] = args;

  if (activeSlotString === undefined) {
    return;
  }

  const activeSlot = parseIntSafe(activeSlotString);
  if (activeSlot === undefined || !isEnumValue(activeSlot, ActiveSlot)) {
    print(`Invalid slot number: ${activeSlot}`);
    return;
  }

  let numCharges = 1;
  if (numChargeString !== undefined) {
    const numChargesAttempt = parseIntSafe(numChargeString);
    if (numChargesAttempt === undefined) {
      print(`Invalid charge amount: ${numChargeString}`);
      return;
    }
    numCharges = numChargesAttempt;
  }

  const player = Isaac.GetPlayer();
  addCharge(player, activeSlot, numCharges);
}

/**
 * Warps to the Angel Room for the floor. If the Devil Room has already been visited or initialized,
 * this will uninitialize it and make an Angel Room instead.
 */
export function angelRoom(): void {
  devilAngel(false);
}

/** Activates the flags for the Ascent (i.e. Backwards Path). */
export function ascent(): void {
  game.SetStateFlag(GameStateFlag.BACKWARDS_PATH_INIT, true);
  game.SetStateFlag(GameStateFlag.BACKWARDS_PATH, true);

  print("Set Ascent flags.");
}

/** Warps to the first Clean Bedroom or Dirty Bedroom on the floor. */
export function bedroom(): void {
  const cleanBedroomGridIndexes = getRoomGridIndexesForType(
    RoomType.CLEAN_BEDROOM,
  );
  if (cleanBedroomGridIndexes.length > 0) {
    warpToRoomType(RoomType.CLEAN_BEDROOM);
    return;
  }

  const dirtyBedroomGridIndexes = getRoomGridIndexesForType(
    RoomType.DIRTY_BEDROOM,
  );
  if (dirtyBedroomGridIndexes.length > 0) {
    warpToRoomType(RoomType.DIRTY_BEDROOM);
    return;
  }

  print("There are no Clean Bedrooms or Dirty Bedrooms on this floor.");
}

/**
 * Gives a half black heart. Provide a number to give a custom amount of hearts. (You can use
 * negative numbers to remove hearts.)
 */
export function blackHearts(params: string): void {
  addHeart(params, HealthType.BLACK);
}

/** Warps to the Black Market for the floor. */
export function blackMarket(): void {
  changeRoom(GridRoom.BLACK_MARKET);
}

/** Toggles permanent Curse of the Blind. */
export function blind(): void {
  v.persistent.blind = !v.persistent.blind;
  printEnabled(v.persistent.blind, "permanent Curse of the Blind");
}

/**
 * Gives a blood charge. This only affects Bethany. Provide a number to give a custom amount of
 * charges. (You can use negative numbers to remove charges.)
 */
export function bloodCharges(params: string): void {
  let charges = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid charge amount: ${num}`);
      return;
    }

    charges = num;
  }

  const player = Isaac.GetPlayer();
  player.AddBloodCharge(charges);
}

/** Alias for the "blackMarket" command. */
export function bm(): void {
  blackMarket();
}

/**
 * Gives a bomb. Provide a number to give a custom amount of bombs. (You can use negative numbers to
 * remove bombs.)
 */
export function bomb(params: string): void {
  let numBombs = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid bomb amount: ${num}`);
      return;
    }

    numBombs = num;
  }

  const player = Isaac.GetPlayer();
  player.AddBombs(numBombs);
}

/**
 * Gives 99 bombs. Provide a number to give a custom amount of bombs. (You can use negative numbers
 * to remove bombs.)
 */
export function bombs(params: string): void {
  let numBombs = 99;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid bomb amount: ${num}`);
      return;
    }

    numBombs = num;
  }

  const player = Isaac.GetPlayer();
  player.AddBombs(numBombs);
}

/**
 * Gives a bone heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function boneHearts(params: string): void {
  addHeart(params, HealthType.BONE);
}

/** Alias for the "bossRoom" command. */
export function boss(): void {
  bossRoom();
}

/** Warps to the room next to the first Boss Room on the floor. */
export function bossNextRoom(): void {
  warpNextToRoomType(RoomType.BOSS);
}

/** Warps to the first Boss Room on the floor (or the Delirium Boss Room if on The Void). */
export function bossRoom(): void {
  // Most of the logic here is copied from the "warpToRoomType" function.
  const roomType = RoomType.BOSS;
  const roomGridIndexes = getRoomGridIndexesForType(roomType);

  let roomGridIndex = roomGridIndexes[0];

  if (onStage(LevelStage.VOID)) {
    roomGridIndex = roomGridIndexes.find(
      (thisRoomGridIndex) =>
        getRoomData(thisRoomGridIndex)?.Subtype === BossID.DELIRIUM,
    );
  }

  const roomTypeName = ROOM_TYPE_NAMES[RoomType.BOSS];
  if (roomGridIndex === undefined) {
    print(`There are no ${roomTypeName}s on this floor.`);
    return;
  }

  changeRoom(roomGridIndex);
  print(`Warped to room type: ${roomTypeName} (${roomType})`);
}

/** Warps to the Boss Rush for the floor. */
export function bossRush(): void {
  changeRoom(GridRoom.BOSS_RUSH);
}

/**
 * Gives a broken heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function brokenHearts(params: string): void {
  addHeart(params, HealthType.BROKEN);
}

/**
 * Gives the specified card. Accepts either the card type or the partial name of the card.
 *
 * For example:
 * - card 5 - Gives The Emperor.
 * - card spa - Gives 2 of Spades.
 */
export function card(params: string): void {
  if (params === "") {
    print("You must specify a card name or number.");
    return;
  }

  let cardType: CardType;
  const num = parseIntSafe(params);
  if (num === undefined) {
    const match = getMapPartialMatch(params, CARD_NAME_TO_TYPE_MAP);
    if (match === undefined) {
      print(`Unknown card: ${params}`);
      return;
    }

    cardType = match[1];
  } else {
    if (!isValidCardType(num)) {
      print(`Invalid card type: ${num}`);
      return;
    }

    cardType = num;
  }

  const cardName = getCardName(cardType);
  Isaac.ExecuteCommand(`g k${cardType}`);
  print(`Gave card: ${cardName} (${cardType})`);
}

/** Spawns every card on the ground, starting at the top-left-most tile. */
export function cards(): void {
  let cardType = FIRST_CARD_TYPE;
  for (let y = 0; y <= 6; y++) {
    for (let x = 0; x <= 12; x++) {
      if (cardType > LAST_VANILLA_CARD_TYPE) {
        return;
      }

      const worldPosition = gridCoordinatesToWorldPosition(x, y);
      spawnCard(cardType, worldPosition);
      cardType++; // eslint-disable-line isaacscript/strict-enums
    }
  }
}

/** Alias for the "chaosCardTears" command. */
export function cc(): void {
  chaosCardTears();
}

/**
 * Toggles Chaos Card tears for the player. Useful for killing enemies very fast without using
 * "debug 10".
 */
export function chaosCardTears(): void {
  v.persistent.chaosCardTears = !v.persistent.chaosCardTears;
  printEnabled(v.persistent.chaosCardTears, "Chaos Card tears");
}

/**
 * Restart as the specified character. Accepts either the character sub-type or the partial name of
 * the character.
 *
 * For example:
 * - character 2 - Restarts as Cain.
 * - character ta - Restarts as Tainted Azazel.
 */
export function character(params: string): void {
  if (params === "") {
    print("You must specify a character name or number.");
    return;
  }

  let playerType: PlayerType;
  const num = parseIntSafe(params);
  if (num === undefined) {
    const match = getMapPartialMatch(params, CHARACTER_NAME_TO_TYPE_MAP);
    if (match === undefined) {
      print(`Unknown character: ${params}`);
      return;
    }

    playerType = match[1];
  } else {
    if (!isEnumValue(num, PlayerType) || num === PlayerType.POSSESSOR) {
      print(`Invalid character number: ${num}`);
      return;
    }

    playerType = num;
  }

  const characterName = getCharacterName(playerType);
  restart(playerType);
  print(`Restarting as character: ${characterName} (${playerType})`);
}

/** Alias for the "addCharges" command. */
export function charge(params: string): void {
  addCharges(params);
}

/** Warps to the first Clean Bedroom on the floor. */
export function cleanBedroom(): void {
  warpToRoomType(RoomType.CLEAN_BEDROOM);
}

/**
 * Gives a coin. Provide a number to give a custom amount of coins. (You can use negative numbers to
 * remove coins.)
 */
export function coin(params: string): void {
  let numCoins = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid coin amount: ${num}`);
      return;
    }

    numCoins = num;
  }

  const player = Isaac.GetPlayer();
  player.AddCoins(numCoins);
}

/**
 * Gives 999 coins. Provide a number to give a custom amount of coins. (You can use negative numbers
 * to remove coins.)
 */
export function coins(params: string): void {
  let numCoins = 999;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid coin amount: ${num}`);
      return;
    }

    numCoins = num;
  }

  const player = Isaac.GetPlayer();
  player.AddCoins(numCoins);
}

/** Alias for the "spawnCollectible" command. */
export function collectible(params: string): void {
  spawnCollectible(params);
}

/** Creates a crawl space next to the player. */
export function crawlSpace(): void {
  spawnTrapdoorOrCrawlSpace(false);
}

/** Toggles permanent Curse of the Cursed. */
export function cursed(): void {
  v.persistent.cursed = !v.persistent.cursed;
  printEnabled(v.persistent.cursed, "permanent Curse of the Cursed");
}

/** Uses the D20. */
export function d20(): void {
  const player = Isaac.GetPlayer();
  useActiveItemTemp(player, CollectibleType.D20);
}

/** Uses the D6. */
export function d6(): void {
  const player = Isaac.GetPlayer();
  useActiveItemTemp(player, CollectibleType.D6);
}

/** Warps to the Mausoleum 2 Boss Room that has Dad's Note in it. */
export function dadsNote(): void {
  game.SetStateFlag(GameStateFlag.BACKWARDS_PATH_INIT, true);
  setStage(LevelStage.DEPTHS_2, StageType.REPENTANCE);
  bossRoom();
}

/**
 * Toggles a set damage stat for the player. You can provide an optional argument to this command in
 * order to set the damage to a specific amount. Default is 500.
 */
export function damage(params: string): void {
  if (params !== "") {
    const num = tonumber(params); // Can be a float.
    if (num === undefined) {
      print(`Invalid damage amount: ${params}`);
      return;
    }

    v.persistent.damageAmount = num;
  }

  v.persistent.damage = !v.persistent.damage;

  const player = Isaac.GetPlayer();
  player.AddCacheFlags(CacheFlag.DAMAGE);
  player.EvaluateItems();

  printEnabled(v.persistent.damage, "set damage");
}

/** Toggles permanent Curse of Darkness. */
export function darkness(): void {
  v.persistent.darkness = !v.persistent.darkness;
  printEnabled(v.persistent.darkness, "permanent Curse of Darkness");
}

/** Alias for the "devil" command. */
export function dd(): void {
  devilRoom();
}

/**
 * Warps to the Devil Room for the floor. If the Angel Room has already been visited or initialized,
 * this will uninitialize it and make an Devil Room instead.
 */
export function devilRoom(): void {
  devilAngel(true);
}

/** Warps to the first Dirty Bedroom on the floor. */
export function dirtyBedroom(): void {
  warpToRoomType(RoomType.DIRTY_BEDROOM);
}

/** Toggles whether curses can appear. */
export function disableCurses(): void {
  v.persistent.disableCurses = !v.persistent.disableCurses;
  printEnabled(!v.persistent.disableCurses, "curses");
}

/** Warps to the Dogma Boss Room. */
export function dogma(): void {
  setStage(LevelStage.HOME, StageType.WRATH_OF_THE_LAMB);
  changeRoom(DOGMA_ROOM_GRID_INDEX);
}

/** Moves the player 0.5 units down. Provide a number to move a custom amount of units. */
export function down(params: string): void {
  movePlayer(params, Direction.DOWN);
}

/** Warps to the Dungeon (i.e. the crawl space room) for the floor. */
export function dungeon(): void {
  changeRoom(GridRoom.DUNGEON);
}

/** Logs the player's current temporary effects to the "log.txt" file. */
export function effects(): void {
  const player = Isaac.GetPlayer();
  logPlayerEffects(player);
  print('Logged the player\'s effects to the "log.txt" file.');
}

/** Alias for the "iAmError" command. */
export function errorRoom(): void {
  iAmErrorRoom();
}

/**
 * Gives an eternal heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function eternalHearts(params: string): void {
  addHeart(params, HealthType.ETERNAL);
}

/** Grants the maximum amount of blue flies to the player. */
export function flies(): void {
  const player = Isaac.GetPlayer();
  player.AddBlueFlies(MAX_NUM_FAMILIARS, player.Position, undefined);
}

/** Toggles flight for the player. */
export function flight(params: string): void {
  const player = Isaac.GetPlayer();

  v.persistent.flight = !v.persistent.flight;

  // Optionally, allow the toggle to be overridden by a parameter.
  if (params === "true") {
    v.persistent.flight = true;
  } else if (params === "false") {
    v.persistent.flight = false;
  }

  player.AddCacheFlags(CacheFlag.FLYING);
  player.EvaluateItems();

  const collectibleUsedToShowFlight = CollectibleType.FATE;
  if (v.persistent.flight) {
    addCollectibleCostume(player, collectibleUsedToShowFlight);
  } else {
    removeCollectibleCostume(player, collectibleUsedToShowFlight);
  }

  printEnabled(v.persistent.flight, "flight");
}

/** Alias for the "startingRoom" command. */
export function fool(): void {
  startingRoom();
}

/** Displays the current challenge, if any. */
export function getChallenge(): void {
  const challenge = Isaac.GetChallenge();
  const challengeName = Challenge[challenge];
  const challengeDescription =
    // Handle modded challenges.
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    challengeName === undefined
      ? `${challenge} (custom)`
      : `Challenge.${challengeName} (${challenge})`;
  print(`The current challenge is: ${challengeDescription}`);
}

/** Prints the charge for the specified slot. By default, will use `ActiveSlot.PRIMARY`. */
export function getCharge(params: string): void {
  let activeSlot = ActiveSlot.PRIMARY;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined || !isEnumValue(num, ActiveSlot)) {
      print(`Invalid slot number: ${params}`);
      return;
    }

    activeSlot = num;
  }

  const player = Isaac.GetPlayer();
  const totalCharge = getTotalCharge(player, activeSlot);
  print(
    `Total charge for ActiveSlot.${ActiveSlot[activeSlot]} (${activeSlot}) is: ${totalCharge}`,
  );
}

/** Prints the current position of all players. */
export function getPosition(): void {
  for (const player of getPlayers()) {
    const playerName = getPlayerName(player);
    print(
      `Player position for ${playerName}: (${player.Position.X}, ${player.Position.Y})`,
    );
  }
}

/** Toggles permanent Curse of the Giant. */
export function giant(): void {
  v.persistent.giant = !v.persistent.giant;
  printEnabled(v.persistent.giant, "permanent Curse of the Giant");
}

/**
 * Gives a Giga Bomb. Provide a number to give a custom amount of Giga Bombs. (You can use negative
 * numbers to remove bombs.)
 */
export function gigaBomb(params: string): void {
  let numBombs = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid Giga Bomb amount: ${num}`);
      return;
    }

    numBombs = num;
  }

  const player = Isaac.GetPlayer();
  player.AddGigaBombs(numBombs);
}

/** Alias for the "goldenBomb" command. */
export function goldBomb(): void {
  goldenBomb();
}

/** Alias for the "goldenHearts" command. */
export function goldHearts(params: string): void {
  goldenHearts(params);
}

/** Alias for the "goldenKey" command. */
export function goldKey(): void {
  goldenKey();
}

/** Alias for the "goldenPill" command. */
export function goldPill(): void {
  goldenPill();
}

/** Alias for the "spawnGoldenTrinket" command. */
export function goldTrinket(params: string): void {
  spawnGoldenTrinket(params);
}

/** Gives the player a golden bomb. */
export function goldenBomb(): void {
  const player = Isaac.GetPlayer();
  player.AddGoldenBomb();
}

/**
 * Gives a golden heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function goldenHearts(params: string): void {
  addHeart(params, HealthType.GOLDEN);
}

/** Gives the player a golden key. */
export function goldenKey(): void {
  const player = Isaac.GetPlayer();
  player.AddGoldenKey();
}

/** Gives the player a golden pill. */
export function goldenPill(): void {
  const player = Isaac.GetPlayer();
  player.AddPill(PillColor.GOLD);
}

/** Alias for the "spawnGoldenTrinket" command. */
export function goldenTrinket(params: string): void {
  spawnGoldenTrinket(params);
}

/**
 * Alias for the "debug 11" command. Useful for seeing the coordinates and grid index of each tile
 * in the room.
 */
export function grid(): void {
  Isaac.ExecuteCommand("debug 11");
}

/** Alias for the "gridCosts" command. */
export function grid2(): void {
  gridCosts();
}

/** Alias for the "debug 2" command. Useful for seeing the grid costs of each tile in the room. */
export function gridCosts(): void {
  Isaac.ExecuteCommand("debug 2");
}

/** Spawns every grid entity, starting at the top-left-most tile. */
export function gridEntities(): void {
  let gridEntityTypeIndex = -1;
  for (let y = 0; y <= 6; y++) {
    for (let x = 0; x <= 12; x++) {
      gridEntityTypeIndex++;
      const gridEntityType = GRID_ENTITY_TYPE_VALUES[gridEntityTypeIndex];
      if (gridEntityType === undefined) {
        return;
      }

      const worldPosition = gridCoordinatesToWorldPosition(x, y);
      spawnGridEntity(gridEntityType, worldPosition);
    }
  }
}

/**
 * Gives a half red heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function hearts(params: string): void {
  addHeart(params, HealthType.RED);
}

/** Alias for the "debug 6" command. */
export function hitboxes(): void {
  Isaac.ExecuteCommand("debug 6");
}

/** The same thing as the `pill` command, but gives a horse pill instead of a normal pill. */
export function horse(params: string): void {
  pill(params, true);
}

/** Warps to the Blue Womb Boss Room. */
export function hush(): void {
  setStage(LevelStage.BLUE_WOMB, StageType.ORIGINAL);
  bossRoom();
}

/** Warps to the I AM ERROR room for the floor. */
export function iAmErrorRoom(): void {
  changeRoom(GridRoom.ERROR);
}

/**
 * Gives a key. Provide a number to give a custom amount of key. (You can use negative numbers to
 * remove keys.)
 */
export function key(params: string): void {
  let numKeys = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid key amount: ${num}`);
      return;
    }

    numKeys = num;
  }

  const player = Isaac.GetPlayer();
  player.AddKeys(numKeys);
}

/**
 * Gives 99 keys. Provide a number to give a custom amount of coins. (You can use negative numbers
 * to remove keys.)
 */
export function keys(params: string): void {
  let numKeys = 99;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid key amount: ${num}`);
      return;
    }

    numKeys = num;
  }

  const player = Isaac.GetPlayer();
  player.AddKeys(numKeys);
}

/** Toggles permanent Curse of the Labyrinth. */
export function labyrinth(): void {
  v.persistent.labyrinth = !v.persistent.labyrinth;
  printEnabled(v.persistent.labyrinth, "permanent Curse of the Labyrinth");
}

/** Moves the player 0.5 units left. Provide a number to move a custom amount of units. */
export function left(params: string): void {
  movePlayer(params, Direction.LEFT);
}

/** Warps to the first Library on the floor. */
export function library(): void {
  warpToRoomType(RoomType.LIBRARY);
}

/**
 * Logs the entities in the room to the "log.txt" file. Provide a number to only log that specific
 * `EntityType`.
 *
 * By default, this command will exclude background effects. If that is not desired, use the
 * "listAll" command instead.
 */
export function list(params: string): void {
  listEntities(params, false);
}

/**
 * Logs the entities in the room to the "log.txt" file. Provide a number to only log that specific
 * `EntityType`.
 */
export function listAll(params: string): void {
  listEntities(params, true);
}

/**
 * Logs the grid entities in the room to the "log.txt" file. Provide a number to only log that
 * specific `GridEntityType`.
 *
 * By default, this command will exclude walls. If that is not desired, use the "listGridAll"
 * command instead.
 */
export function listGrid(params: string): void {
  listGridEntities(params, false);
}

/**
 * Logs the grid entities in the room to the "log.txt" file. Provide a number to only log that
 * specific `GridEntityType`.
 */
export function listGridAll(params: string): void {
  listGridEntities(params, true);
}

/** Toggles permanent Curse of the Lost. */
export function lost(): void {
  v.persistent.lost = !v.persistent.lost;
  printEnabled(v.persistent.lost, "permanent Curse of the Lost");
}

/** Alias for the "1hp" command. */
export function lowHP(): void {
  oneHP();
}

/** Alias for "debug 9". */
export function luck(): void {
  Isaac.ExecuteCommand("debug 9");
}

/** Alias for the "poopMana" command. */
export function mana(params: string): void {
  poopMana(params);
}

/** Completely reveals the entire map, including the Ultra Secret Room. */
export function map(): void {
  const level = game.GetLevel();

  const displayFlags = addFlag(
    DisplayFlag.VISIBLE, // 1 << 0
    DisplayFlag.SHADOW, // 1 << 1
    DisplayFlag.SHOW_ICON, // 1 << 2
  );

  for (const roomGridIndex of iRange(MAX_LEVEL_GRID_INDEX)) {
    const roomDesc = level.GetRoomByIdx(roomGridIndex);
    roomDesc.DisplayFlags = displayFlags;
  }

  // We must call the "Level.UpdateVisibility" method for the changes to be visible.
  level.UpdateVisibility();
}

/**
 * Gives a heart container. Provide a number to give a custom amount of heart containers. (You can
 * use negative numbers to remove heart containers.)
 */
export function maxHearts(params: string): void {
  addHeart(params, HealthType.MAX_HEARTS);
}

/** Toggles permanent Curse of the Maze. */
export function maze(): void {
  v.persistent.maze = !v.persistent.maze;
  printEnabled(v.persistent.maze, "permanent Curse of the Maze");
}

/** Warps to the Mega Satan room on the floor. (Every floor has a Mega Satan room.) */
export function megaSatan(): void {
  changeRoom(GridRoom.MEGA_SATAN);
}

/** Warps to the first Miniboss Room on the floor. */
export function miniboss(): void {
  warpToRoomType(RoomType.MINI_BOSS);
}

/** Logs the currently playing music track to the "log.txt" file. */
export function music(): void {
  logMusic();
  print('Logged the currently playing music track to the "log.txt" file.');
}

/** Alias for the "disableCurses" command. */
export function noCurses(): void {
  disableCurses();
}

/** Sets every NPC in the room to 1 HP. */
export function oneHP(): void {
  for (const npc of getNPCs()) {
    npc.HitPoints = 1;
  }

  print("Set every NPC to 1 HP.");
}

/**
 * Gives a pill with the specified pill effect. Accepts either the effect ID or the partial name of
 * the effect.
 *
 * For example:
 *
 * - `pill 5` - Gives a "Full Health" pill.
 * - `pill suns` - Gives a "Feels like I'm walking on sunshine" pill.
 */
export function pill(params: string, isHorse = false): void {
  if (params === "") {
    print("You must specify a pill name or number.");
    return;
  }

  let pillEffect: PillEffect;
  const num = parseIntSafe(params);
  if (num === undefined) {
    const match = getMapPartialMatch(params, PILL_NAME_TO_EFFECT_MAP);
    if (match === undefined) {
      print(`Unknown pill effect: ${params}`);
      return;
    }

    pillEffect = match[1];
  } else {
    if (!isValidPillEffect(num)) {
      print(`Invalid pill effect ID: ${num}`);
      return;
    }

    pillEffect = num;
  }

  const pillEffectName = getPillEffectName(pillEffect);
  Isaac.ExecuteCommand(`g p${pillEffect}`);

  if (isHorse) {
    const player = Isaac.GetPlayer();
    const pillColor = player.GetPill(PocketItemSlot.SLOT_1);
    const horsePillColor = getHorsePillColor(pillColor);
    player.SetPill(PocketItemSlot.SLOT_1, horsePillColor);
  }

  if (isHorse) {
    print(`Gave horse pill: ${pillEffectName} (${pillEffect})`);
  } else {
    print(`Gave pill: ${pillEffectName} (${pillEffect})`);
  }
}

/** Spawns every pill on the ground, starting at the top-left-most tile. */
export function pills(): void {
  let y: int;
  let pillColor: PillColor;

  y = 1;
  pillColor = FIRST_PILL_COLOR;
  for (let x = 0; x <= 12; x++) {
    if (pillColor >= PillColor.GOLD) {
      break;
    }

    const worldPosition = gridCoordinatesToWorldPosition(x, y);
    spawnPill(pillColor, worldPosition);
    pillColor++; // eslint-disable-line isaacscript/strict-enums
  }

  y = 2;
  pillColor = FIRST_HORSE_PILL_COLOR;
  for (let x = 0; x <= 12; x++) {
    if (pillColor >= PillColor.HORSE_GOLD) {
      break;
    }

    const worldPosition = gridCoordinatesToWorldPosition(x, y);
    spawnPill(pillColor, worldPosition);
    pillColor++; // eslint-disable-line isaacscript/strict-enums
  }

  y = 3;
  const worldPosition1 = gridCoordinatesToWorldPosition(0, y);
  spawnPill(PillColor.GOLD, worldPosition1);
  const worldPosition2 = gridCoordinatesToWorldPosition(1, y);
  spawnPill(PillColor.HORSE_GOLD, worldPosition2);
}

/** Warps to the first Planetarium on the floor. */
export function planetarium(): void {
  warpToRoomType(RoomType.PLANETARIUM);
}

/** Alias for the "sound" command. */
export function playSound(params: string): void {
  sound(params);
}

/** Sets the player's pocket item to the specified collectible type. */
export function pocket(params: string): void {
  if (params === "") {
    print("You must supply a collectible type to put as the pocket item.");
    return;
  }

  const collectibleType = parseIntSafe(params);
  if (
    collectibleType === undefined ||
    !isValidCollectibleType(collectibleType)
  ) {
    print(`Invalid collectible type: ${collectibleType}`);
    return;
  }

  const player = Isaac.GetPlayer();
  player.SetPocketActiveItem(collectibleType, ActiveSlot.POCKET);
}

/** Creates a poop grid entity next to the player. */
export function poop(): void {
  const roomClass = game.GetRoom();
  const player = Isaac.GetPlayer();
  const tilePosition = roomClass.FindFreeTilePosition(player.Position, 0);

  spawnGridEntity(GridEntityType.POOP, tilePosition);
}

/**
 * Gives a poop mana charge. This only affects Tainted Blue Baby. Provide a number to give a custom
 * amount of charges. (You can use negative numbers to remove charges.)
 */
export function poopMana(params: string): void {
  let charges = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid mana amount: ${num}`);
      return;
    }

    charges = num;
  }

  const player = Isaac.GetPlayer();
  player.AddPoopMana(charges);
}

/** Alias for the "getPosition" command. */
export function position(): void {
  getPosition();
}

/** Alias for the "hearts" command. */
export function redHearts(params: string): void {
  hearts(params);
}

/** Starts a room transition to the same room that you are already in. */
export function reloadRoom(): void {
  reloadRoomFunction();
}

/** Moves the player 0.5 units right. Provide a number to move a custom amount of units. */
export function right(params: string): void {
  movePlayer(params, Direction.RIGHT);
}

/** Logs information about the room to the "log.txt" file. */
export function room(): void {
  logRoom();
  print('Logged room information to the "log.txt" file.');
}

/**
 * Gives a rotten heart. Provide a number to give a custom amount of hearts. (You can use negative
 * numbers to remove hearts.)
 */
export function rottenHearts(params: string): void {
  addHeart(params, HealthType.ROTTEN);
}

/**
 * Run the suite of tests that prove that the "deepCopy" helper function and the "merge" function
 * work properly. For more information, see the `runDeepCopyTests` and the `runMergeTests`
 * functions.
 *
 * In general, running the tests is only useful if you are troubleshooting the save data manager.
 */
export function runTests(): void {
  runDeepCopyTests();
  runMergeTests();
}

/**
 * Alias for the "stage" command.
 *
 * For example:
 * - s 3 - Warps to Caves 1.
 * - s 1c - Warps to Downpour 1.
 */
export function s(params: string): void {
  if (params === "") {
    print("You must specify a stage number.");
    return;
  }

  const finalCharacter = params.slice(-1);
  let stageString: string;
  let stageTypeLetter: string;
  if (
    finalCharacter === "a" ||
    finalCharacter === "b" ||
    finalCharacter === "c" ||
    finalCharacter === "d"
  ) {
    // e.g. "s 11a" for going to The Chest
    stageString = params.slice(0, -1);
    stageTypeLetter = finalCharacter;
  } else {
    // e.g. "s 11" for going to the Dark Room
    stageString = params;
    stageTypeLetter = "";
  }

  const stage = parseIntSafe(stageString);
  if (stage === undefined || !isEnumValue(stage, StageType)) {
    print(`Invalid stage number: ${stage}`);
    return;
  }

  Isaac.ExecuteCommand(`stage ${stage}${stageTypeLetter}`);
}

/** Warps to the first Sacrifice Room on the floor. */
export function sacrificeRoom(): void {
  warpToRoomType(RoomType.SACRIFICE);
}

/** Warps to the first Secret Room on the floor. */
export function secretRoom(): void {
  warpToRoomType(RoomType.SECRET);
}

/** Warps to the Secret Shop that you would normally get to with a Member Card. */
export function secretShop(): void {
  changeRoom(GridRoom.SECRET_SHOP);
}

/** Changes to a seeded run, using the seed of the current run. */
export function seedStick(): void {
  const seedsClass = game.GetSeeds();
  const startSeedString = seedsClass.GetStartSeedString();
  Isaac.ExecuteCommand(`seed ${startSeedString}`);
  print(`Sticking to seed: ${startSeedString}`);
}

/** Logs all of the current run's seed effects to the "log.txt" file. */
export function seeds(): void {
  logSeedEffects();
  print('Logged the seed effects to the "log.txt" file.');
}

/**
 * Sets a charge to the player's specified active item. You must provide the active slot number and
 * the number of charges to set.
 */
export function setCharges(params: string): void {
  if (params === "") {
    print(
      "You must specify a slot number and a charge amount. (Use 0 for the primary slot, 1 for the Schoolbag slot, 2 for the pocket item slot, and 3 for the Dice Bag slot.)",
    );
    return;
  }

  const args = params.split(" ");

  if (args.length === 1) {
    print("You must specify the amount of charge to set.");
    return;
  }

  if (args.length !== 2) {
    print(`Invalid amount of arguments: ${args.length}`);
    return;
  }

  const [activeSlotString, chargeString] = args;

  if (activeSlotString === undefined || chargeString === undefined) {
    return;
  }

  const activeSlot = parseIntSafe(activeSlotString);
  if (activeSlot === undefined || !isEnumValue(activeSlot, ActiveSlot)) {
    print(`Invalid slot number: ${activeSlotString}`);
    return;
  }

  const chargeNum = parseIntSafe(chargeString);
  if (chargeNum === undefined) {
    print(`Invalid charge amount: ${chargeString}`);
    return;
  }

  if (chargeNum < 0) {
    print(`Invalid charge amount: ${chargeNum}`);
    return;
  }

  const player = Isaac.GetPlayer();
  player.SetActiveCharge(chargeNum, activeSlot);
}

/**
 * Moves the first player to the specified position.
 *
 * For example:
 * - setPosition 100 50
 */
export function setPosition(params: string): void {
  if (params === "") {
    print('You must specify a position. (e.g. "setPosition 100 50")');
    return;
  }

  const args = params.split(" ");
  if (args.length !== 2) {
    print('You must specify a position. (e.g. "setPosition 100 50")');
    return;
  }

  const [xString, yString] = args;

  if (xString === undefined || yString === undefined) {
    return;
  }

  const x = parseIntSafe(xString);
  if (x === undefined) {
    print(`Invalid x value: ${xString}`);
    return;
  }

  const y = parseIntSafe(yString);
  if (y === undefined) {
    print(`Invalid y value: ${yString}`);
    return;
  }

  const player = Isaac.GetPlayer();
  const newPosition = Vector(x, y);
  player.Position = newPosition;
}

/** Warps to the first shop on the floor. */
export function shop(): void {
  warpToRoomType(RoomType.SHOP);
}

/** Uses the Smelter to smelt the current player's trinket. */
export function smelt(): void {
  const player = Isaac.GetPlayer();
  useActiveItemTemp(player, CollectibleType.SMELTER);
}

/**
 * Gives a soul charge. This only affects Tainted Bethany. Provide a number to give a custom amount
 * of charges. (You can use negative numbers to remove charges.)
 */
export function soulCharges(params: string): void {
  let charges = 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print(`Invalid charges amount: ${num}`);
      return;
    }

    charges = num;
  }

  const player = Isaac.GetPlayer();
  player.AddSoulCharge(charges);
}

/**
 * Gives a half soul heart. Provide a number to give a custom amount of hearts. (You can use
 * negative numbers to remove hearts.)
 */
export function soulHearts(params: string): void {
  addHeart(params, HealthType.SOUL);
}

/**
 * Play the supplied sound effect.
 *
 * For example:
 * - sound 1 - Plays the 1-Up sound effect.
 */
export function sound(params: string): void {
  const soundEffect = parseIntSafe(params);
  if (soundEffect === undefined || !isEnumValue(soundEffect, SoundEffect)) {
    print(`Invalid sound effect ID: ${soundEffect}.`);
    return;
  }

  sfxManager.Play(soundEffect);
}

/** Logs all of the currently playing sound effects to the "log.txt" file. */
export function sounds(): void {
  logSounds();
  print('Logged the currently playing sound effects to the "log.txt" file.');
}

/**
 * Toggles spamming Blood Rights on every frame. Useful for killing enemies very fast without using
 * "debug 10".
 */
export function spam(): void {
  v.persistent.spamBloodRights = !v.persistent.spamBloodRights;
  printEnabled(v.persistent.spamBloodRights, "spamming Blood Rights");
}

/**
 * Spawns a collectible in the center of the room. You must specify the collectible name or the
 * number corresponding to the collectible type.
 *
 * For example, all of the following commands would spawn Spoon Bender:
 *
 * ```text
 * spawnCollectible spoon bender
 * spawnCollectible spoon
 * spawnCollectible spo
 * spawnCollectible 3
 * ```
 */
export function spawnCollectible(params: string): void {
  if (params === "") {
    print(
      "You must specify the collectible name or the number corresponding to the collectible type.",
    );
    return;
  }

  const num = parseIntSafe(params);
  let collectibleType: CollectibleType;
  if (num === undefined) {
    const match = getMapPartialMatch(params, COLLECTIBLE_NAME_TO_TYPE_MAP);
    if (match === undefined) {
      print(`Unknown collectible: ${params}`);
      return;
    }

    collectibleType = match[1];
  } else {
    if (!isValidCollectibleType(num)) {
      print(`Invalid collectible type: ${num}`);
    }
    collectibleType = num;
  }

  const roomClass = game.GetRoom();
  const centerPos = roomClass.GetCenterPos();
  spawnCollectibleFunc(collectibleType, centerPos, undefined);
}

/**
 * Spawns a collectible at a specific grid tile location. You must specify the number corresponding
 * to the collectible type and the number corresponding to the grid tile location.
 *
 * For example, this would spawn Spoon Bender in the top-left corner of a 1x1 room:
 *
 * ```text
 * spawnCollectibleAt 3 16
 * ```
 *
 * (You can use the "grid" command to toggle displaying the numerical grid indexes corresponding to
 * a grid tile.)
 */
export function spawnCollectibleAt(params: string): void {
  if (params === "") {
    print(
      "You must specify the number corresponding to the collectible type and the number corresponding to the grid tile location.",
    );
    return;
  }

  const args = params.split(" ");
  if (args.length !== 2) {
    print(
      "You must specify the number corresponding to the collectible type and the number corresponding to the grid tile location.",
    );
    return;
  }

  const [collectibleTypeString, gridIndexString] = args;

  if (collectibleTypeString === undefined || gridIndexString === undefined) {
    return;
  }

  const collectibleType = parseIntSafe(collectibleTypeString);
  if (
    collectibleType === undefined ||
    !isValidCollectibleType(collectibleType)
  ) {
    print(`Invalid collectible type: ${args[0]}`);
    return;
  }

  const gridIndex = parseIntSafe(gridIndexString);
  if (gridIndex === undefined || gridIndex < 0) {
    print(`Failed to parse the grid index of: ${args[1]}`);
    return;
  }

  spawnCollectibleFunc(collectibleType, gridIndex, undefined);
}

/** Alias for the `spawnGoldenTrinket` command. */
export function spawnGoldTrinket(params: string): void {
  spawnGoldenTrinket(params);
}

/**
 * The same thing as the `spawnTrinket` command but spawns a golden version of the specified
 * trinket.
 */
export function spawnGoldenTrinket(params: string): void {
  spawnTrinket(params, true);
}

/**
 * The same thing as the `spawnTrinketAt` command but spawns a golden version of the specified
 * trinket.
 */
export function spawnGoldenTrinketAt(params: string): void {
  spawnTrinketAt(params, true);
}

/**
 * Spawns a trinket in the center of the room. You must specify the trinket name or the number
 * corresponding to the trinket type.
 *
 * For example, all of the following commands would spawn the Wiggle Worm trinket:
 *
 * ```text
 * spawnTrinket wiggle worm
 * spawnTrinket wiggle
 * spawnTrinket wig
 * spawnTrinket 10
 * ```
 *
 * Also see the `spawnGoldenTrinket` command.
 */
export function spawnTrinket(params: string, golden = false): void {
  if (params === "") {
    print(
      "You must specify the name or number corresponding to the trinket type.",
    );
    return;
  }

  const num = parseIntSafe(params);
  let trinketType: TrinketType;
  if (num === undefined) {
    const match = getMapPartialMatch(params, TRINKET_NAME_TO_TYPE_MAP);
    if (match === undefined) {
      print(`Unknown trinket: ${params}`);
      return;
    }

    trinketType = match[1];
  } else {
    if (!isValidTrinketType(num)) {
      print(`Invalid trinket type: ${num}`);
      return;
    }
    trinketType = num;
  }

  const roomClass = game.GetRoom();
  const centerPos = roomClass.GetCenterPos();
  const goldenTrinketType = getGoldenTrinketType(trinketType);
  const trinketTypeToSpawn = golden ? goldenTrinketType : trinketType;
  spawnTrinketFunction(trinketTypeToSpawn, centerPos);
}

/**
 * Spawns a trinket at a specific grid tile location. You must specify the number corresponding to
 * the trinket type and the number corresponding to the grid tile location.
 *
 * For example, this would spawn Wiggle Worm in the top-left corner of a 1x1 room:
 *
 * ```text
 * spawnTrinketAt 10 16
 * ```
 *
 * (You can use the "grid" command to toggle displaying the numerical grid indexes corresponding to
 * a grid tile.)
 */
export function spawnTrinketAt(params: string, golden = false): void {
  if (params === "") {
    print(
      "You must specify the number corresponding to the trinket type and the number corresponding to the grid tile location.",
    );
    return;
  }

  const args = params.split(" ");
  if (args.length !== 2) {
    print(
      "You must specify the number corresponding to the trinket type and the number corresponding to the grid tile location.",
    );
    return;
  }

  const [trinketTypeString, gridIndexString] = args;

  if (trinketTypeString === undefined || gridIndexString === undefined) {
    return;
  }

  const trinketType = parseIntSafe(trinketTypeString);
  if (trinketType === undefined || !isValidTrinketType(trinketType)) {
    print(`Invalid trinket type: ${trinketTypeString}`);
    return;
  }

  const gridIndex = parseIntSafe(gridIndexString);
  if (gridIndex === undefined || gridIndex < 0) {
    print(`Failed to parse the grid index of: ${args[1]}`);
    return;
  }

  const goldenTrinketType = getGoldenTrinketType(trinketType);
  const trinketTypeToSpawn = golden ? goldenTrinketType : trinketType;
  spawnTrinketFunction(trinketTypeToSpawn, gridIndex);
}

/**
 * Toggles a set movement speed and flight for the player. You can provide an optional argument to
 * this command in order to set the speed to a specific amount. Default is 2.0 (which is the maximum
 * that the stat can be set to).
 */
export function speed(params: string): void {
  const player = Isaac.GetPlayer();

  if (params !== "") {
    const num = tonumber(params); // Can be a float.
    if (num === undefined) {
      print(`Invalid speed amount: ${params}`);
      return;
    }

    v.persistent.damageAmount = num;
  }

  v.persistent.speed = !v.persistent.speed;

  player.AddCacheFlags(CacheFlag.SPEED);
  player.EvaluateItems();

  const value = tostring(v.persistent.speed);
  flight(value);

  printEnabled(v.persistent.speed, "set speed");
}

/** Creates a spikes grid entity next to the player. */
export function spikes(): void {
  const roomClass = game.GetRoom();
  const player = Isaac.GetPlayer();
  const tilePosition = roomClass.FindFreeTilePosition(player.Position, 0);

  spawnGridEntity(GridEntityType.SPIKES, tilePosition);
}

/** Alias for the "startingRoom" command. */
export function startRoom(): void {
  startingRoom();
}

/** Warps to the starting room of the floor. */
export function startingRoom(): void {
  const level = game.GetLevel();
  const startingRoomIndex = level.GetStartingRoomIndex();
  changeRoom(startingRoomIndex);
}

/** Warps to the first Super Secret Room on the floor. */
export function superSecretRoom(): void {
  warpToRoomType(RoomType.SUPER_SECRET);
}

/**
 * Toggles a set tear delay (e.g. fire rate) for the player. You can provide an optional argument to
 * this command in order to set the tear delay to a specific amount. Default is 1 (which is
 * equivalent to the Soy Milk tear rate).
 */
export function tears(params: string): void {
  if (params !== "") {
    const num = tonumber(params); // Can be a float.
    if (num === undefined) {
      print(`Invalid tear delay amount: ${params}`);
      return;
    }

    v.persistent.tearsAmount = num;
  }

  v.persistent.tears = !v.persistent.tears;

  const player = Isaac.GetPlayer();
  player.AddCacheFlags(CacheFlag.FIRE_DELAY);
  player.EvaluateItems();

  printEnabled(v.persistent.damage, "set tear delay");
}

/** Alias for the "runTests" command. */
export function tests(): void {
  runTests();
}

/** Creates a trapdoor next to the player. */
export function trapdoor(): void {
  spawnTrapdoorOrCrawlSpace(true);
}

/** Warps to the first Treasure Room on the floor. */
export function treasureRoom(): void {
  warpToRoomType(RoomType.TREASURE);
}

/** Alias for the "spawnTrinket" command. */
export function trinket(params: string): void {
  spawnTrinket(params);
}

/** Warps to the first Ultra Secret Room on the floor. */
export function ultraSecretRoom(): void {
  warpToRoomType(RoomType.ULTRA_SECRET);
}

/** Toggles permanent Curse of the Unknown. */
export function unknown(): void {
  v.persistent.unknown = !v.persistent.unknown;
  printEnabled(v.persistent.unknown, "permanent Curse of the Unknown");
}

/** If currently on a set seed, changes to an unseeded state and restarts the game. */
export function unseed(): void {
  if (!onSetSeed()) {
    print("You are not on a set seed, so you cannot unseed the run.");
    return;
  }

  setUnseeded();
  restart();
}

/** Moves the player 0.5 units up. Provide a number to move a custom amount of units. */
export function up(params: string): void {
  movePlayer(params, Direction.UP);
}

/**
 * Warps to the specified room type. Accepts either the room type number or the partial name of the
 * room type.
 *
 * For example:
 * - warp 5 - Warps to the first Boss Room on the floor, if any.
 * - warp tr - Warps to the first Treasure Room on the floor, if any.
 */
export function warp(params: string): void {
  if (params === "") {
    print("You must specify a room type name or number.");
    return;
  }

  let roomType: RoomType;
  const num = parseIntSafe(params);
  if (num === undefined) {
    const match = getMapPartialMatch(params, ROOM_NAME_TO_TYPE_MAP);
    if (match === undefined) {
      print(`Unknown room type: ${params}`);
      return;
    }

    roomType = match[1];
  } else {
    if (!isEnumValue(num, RoomType)) {
      print(`Invalid room type: ${num}`);
      return;
    }

    roomType = num;
  }

  warpToRoomType(roomType);
}

/** Alias for the "labyrinth" command. */
export function xl(): void {
  labyrinth();
}

----
classes\features\other\extraConsoleCommands\subroutines.ts
import type { Direction, EntityType } from "isaac-typescript-definitions";
import {
  GridEntityType,
  GridRoom,
  RoomType,
} from "isaac-typescript-definitions";
import { game } from "../../../../core/cachedClasses";
import { HealthType } from "../../../../enums/HealthType";
import { directionToVector } from "../../../../functions/direction";
import { spawnGridEntity } from "../../../../functions/gridEntities";
import {
  getRoomAdjacentGridIndexes,
  getRoomGridIndexesForType,
} from "../../../../functions/levelGrid";
import {
  logAllEntities,
  logAllGridEntities,
} from "../../../../functions/logEntities";
import { addPlayerHealthType } from "../../../../functions/playerHealth";
import { getRoomData, getRoomDescriptor } from "../../../../functions/roomData";
import { changeRoom } from "../../../../functions/rooms";
import { parseIntSafe } from "../../../../functions/types";
import { ROOM_TYPE_NAMES } from "../../../../objects/roomTypeNames";

const DEFAULT_MOVE_UNITS = 0.5;

export function addHeart(params: string, healthType: HealthType): void {
  let numHearts = healthType === HealthType.MAX_HEARTS ? 2 : 1;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print("That is an invalid amount of hearts to add.");
      return;
    }

    numHearts = num;
  }

  const player = Isaac.GetPlayer();
  addPlayerHealthType(player, healthType, numHearts);
}

export function devilAngel(useDevil: boolean): void {
  const level = game.GetLevel();

  const devilAngelRoomData = getRoomData(GridRoom.DEVIL);
  if (devilAngelRoomData !== undefined) {
    const roomType = devilAngelRoomData.Type;
    const conflictingType = useDevil ? RoomType.ANGEL : RoomType.DEVIL;
    if (roomType === conflictingType) {
      // Delete the room data, which will allow the `Level.InitializeDevilAngelRoom` method to work.
      const roomDescriptor = getRoomDescriptor(GridRoom.DEVIL);
      roomDescriptor.Data = undefined;
    }
  }

  if (useDevil) {
    level.InitializeDevilAngelRoom(false, true);
  } else {
    level.InitializeDevilAngelRoom(true, false);
  }

  changeRoom(GridRoom.DEVIL);
}

export function listEntities(
  params: string,
  includeBackgroundEffects: boolean,
): void {
  let entityTypeFilter: EntityType | undefined;
  if (params !== "") {
    entityTypeFilter = parseIntSafe(params);
    if (entityTypeFilter === undefined) {
      print("That is an invalid entity type to filter by.");
      return;
    }
  }

  logAllEntities(includeBackgroundEffects, entityTypeFilter);
  print('Logged the entities in the room to the "log.txt" file.');
}

export function listGridEntities(params: string, includeWalls: boolean): void {
  let gridEntityTypeFilter: GridEntityType | undefined;
  if (params !== "") {
    gridEntityTypeFilter = parseIntSafe(params);
    if (gridEntityTypeFilter === undefined) {
      print("That is an invalid grid entity type to filter by.");
      return;
    }
  }

  logAllGridEntities(includeWalls, gridEntityTypeFilter);
  print('Logged the grid entities in the room to the "log.txt" file.');
}

export function movePlayer(params: string, direction: Direction): void {
  let amount = DEFAULT_MOVE_UNITS;
  if (params !== "") {
    const num = parseIntSafe(params);
    if (num === undefined) {
      print("That is an invalid amount of units to move.");
      return;
    }

    amount = num;
  }

  const player = Isaac.GetPlayer();
  const vector = directionToVector(direction);
  const modifiedVector = vector.mul(amount);
  player.Position = player.Position.add(modifiedVector);
}

export function spawnTrapdoorOrCrawlSpace(trapdoor: boolean): void {
  const room = game.GetRoom();
  const player = Isaac.GetPlayer();
  const position = room.FindFreeTilePosition(player.Position, 0);
  const gridEntityType = trapdoor
    ? GridEntityType.TRAPDOOR
    : GridEntityType.CRAWL_SPACE;

  spawnGridEntity(gridEntityType, position);
}

export function warpToRoomType(roomType: RoomType): void {
  const roomTypeName = ROOM_TYPE_NAMES[roomType];
  const gridIndexes = getRoomGridIndexesForType(roomType);
  const firstGridIndex = gridIndexes[0];
  if (firstGridIndex === undefined) {
    print(`There are no ${roomTypeName}s on this floor.`);
    return;
  }

  changeRoom(firstGridIndex);
  print(`Warped to room type: ${roomTypeName} (${roomType})`);
}

export function warpNextToRoomType(roomType: RoomType): void {
  const roomTypeName = ROOM_TYPE_NAMES[roomType];
  const gridIndexes = getRoomGridIndexesForType(roomType);
  const firstGridIndex = gridIndexes[0];
  if (firstGridIndex === undefined) {
    print(`There are no ${roomTypeName}s on this floor.`);
    return;
  }

  const adjacentRoomGridIndexes = getRoomAdjacentGridIndexes(firstGridIndex);

  for (const [_doorSlot, roomGridIndex] of adjacentRoomGridIndexes) {
    const roomData = getRoomData(roomGridIndex);
    if (roomData !== undefined && roomData.Type === RoomType.DEFAULT) {
      changeRoom(roomGridIndex);
      print(`Warped next to room type: ${roomTypeName} (${roomType})`);
      return;
    }
  }

  print(
    `Failed to find the room next to room type: ${roomTypeName} (${roomType})`,
  );
}

----
classes\features\other\extraConsoleCommands\v.ts
// This is registered in "ExtraConsoleCommands.ts".
// eslint-disable-next-line isaacscript/require-v-registration
export const v = {
  persistent: {
    // Curses
    darkness: false, // 1
    labyrinth: false, // 2
    lost: false, // 3
    unknown: false, // 4
    cursed: false, // 5
    maze: false, // 6
    blind: false, // 7
    giant: false, // 8
    disableCurses: false,

    // Stats
    damage: false,
    damageAmount: 500,
    speed: false,
    speedAmount: 2,
    tears: false,
    tearsAmount: 1, // In tear delay, not tears stat
    flight: false,

    // Other
    chaosCardTears: false,
    spamBloodRights: false,
  },
};

----
classes\features\other\saveDataManager\constants.ts
export const SAVE_DATA_MANAGER_DEBUG = false as boolean;

----
classes\features\other\saveDataManager\glowingHourGlass.ts
// The save data manager has a feature where certain variables will automatically be rolled back
// when the Glowing Hourglass is used.

import { SaveDataKey } from "../../../../enums/SaveDataKey";
import { SerializationType } from "../../../../enums/SerializationType";
import { deepCopy } from "../../../../functions/deepCopy";
import { merge } from "../../../../functions/merge";
import { iterateTableInOrder } from "../../../../functions/table";
import type { SaveData } from "../../../../interfaces/SaveData";
import type { AnyClass } from "../../../../types/AnyClass";
import { SAVE_DATA_MANAGER_DEBUG } from "./constants";

/**
 * When the Glowing Hourglass is used, certain save data keys will automatically be restored to a
 * backup.
 */
const GLOWING_HOUR_GLASS_BACKUP_KEYS = [
  SaveDataKey.RUN,
  SaveDataKey.LEVEL,
] as const;

const IGNORE_GLOWING_HOUR_GLASS_KEY = "__ignoreGlowingHourGlass";
const REWIND_WITH_GLOWING_HOUR_GLASS_KEY = "__rewindWithGlowingHourGlass";

export function makeGlowingHourGlassBackup(
  saveDataMap: LuaMap<string, SaveData>,
  saveDataConditionalFuncMap: LuaMap<string, () => boolean>,
  saveDataGlowingHourGlassMap: LuaMap<string, SaveData>,
): void {
  iterateTableInOrder(
    saveDataMap,
    (subscriberName, saveData) => {
      // We make the Glowing Hourglass backup using `SerializationType.SERIALIZE`, which means that
      // we cannot operate on unserializable data, such as functions. Save data that utilizes
      // unserializable data will typically be marked using a conditional function that evaluates to
      // false, so we skip all save data that matches this criteria.
      const conditionalFunc = saveDataConditionalFuncMap.get(subscriberName);
      if (conditionalFunc !== undefined) {
        const shouldSave = conditionalFunc();
        if (!shouldSave) {
          return;
        }
      }

      for (const saveDataKey of getKeysToBackup(saveData)) {
        const childTable = saveData[saveDataKey];
        if (childTable === undefined) {
          // This feature does not happen to store any variables on this particular child table.
          continue;
        }

        // Ignore child tables that the end-user has explicitly annotated.
        const childTableLuaMap = childTable as LuaMap<AnyNotNil, unknown>;
        if (childTableLuaMap.has(IGNORE_GLOWING_HOUR_GLASS_KEY)) {
          continue;
        }

        let saveDataGlowingHourGlass =
          saveDataGlowingHourGlassMap.get(subscriberName);
        if (saveDataGlowingHourGlass === undefined) {
          saveDataGlowingHourGlass = new LuaMap<string, unknown>() as SaveData;
          saveDataGlowingHourGlassMap.set(
            subscriberName,
            saveDataGlowingHourGlass,
          );
        }

        // We serialize the table so that we can use the `merge` function later on with no other
        // modifications.
        const copiedChildTable = deepCopy(
          childTable,
          SerializationType.SERIALIZE,
        ) as Record<string, unknown>;
        saveDataGlowingHourGlass[saveDataKey] = copiedChildTable;
      }
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

export function restoreGlowingHourGlassBackup(
  saveDataMap: LuaMap<string, SaveData>,
  saveDataConditionalFuncMap: LuaMap<string, () => boolean>,
  saveDataGlowingHourGlassMap: LuaMap<string, SaveData>,
  classConstructors: LuaMap<string, AnyClass>,
): void {
  iterateTableInOrder(
    saveDataMap,
    (subscriberName, saveData) => {
      // We make the Glowing Hourglass backup using `SerializationType.SERIALIZE`, which means that
      // we cannot operate on unserializable data, such as functions. Save data that utilizes
      // unserializable data will typically be marked using a conditional function that evaluates to
      // false, so we skip all save data that matches this criteria.
      const conditionalFunc = saveDataConditionalFuncMap.get(subscriberName);
      if (conditionalFunc !== undefined) {
        const shouldSave = conditionalFunc();
        if (!shouldSave) {
          return;
        }
      }

      for (const saveDataKey of getKeysToBackup(saveData)) {
        const childTable = saveData[saveDataKey];
        if (childTable === undefined) {
          // This feature does not happen to store any variables on this particular child table.
          continue;
        }

        // Ignore child tables that the end-user has explicitly annotated.
        const childTableLuaMap = childTable as LuaMap<AnyNotNil, unknown>;
        if (childTableLuaMap.has(IGNORE_GLOWING_HOUR_GLASS_KEY)) {
          continue;
        }

        const saveDataGlowingHourGlass =
          saveDataGlowingHourGlassMap.get(subscriberName);
        if (saveDataGlowingHourGlass === undefined) {
          // This should never happen.
          continue;
        }

        const childTableBackup = saveDataGlowingHourGlass[saveDataKey];
        if (childTableBackup === undefined) {
          // This should never happen.
          continue;
        }

        merge(
          childTable as LuaMap<AnyNotNil, unknown>,
          childTableBackup as LuaMap<AnyNotNil, unknown>,
          // Append an arbitrary suffix for better error messages.
          `${subscriberName}__glowingHourGlass`,
          classConstructors,
        );
      }
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

function getKeysToBackup(saveData: SaveData) {
  const shouldBackupPersistentObject =
    saveData.persistent !== undefined &&
    (saveData.persistent as LuaTable).has(REWIND_WITH_GLOWING_HOUR_GLASS_KEY);

  return shouldBackupPersistentObject
    ? ([...GLOWING_HOUR_GLASS_BACKUP_KEYS, SaveDataKey.PERSISTENT] as const)
    : GLOWING_HOUR_GLASS_BACKUP_KEYS;
}

----
classes\features\other\saveDataManager\loadFromDisk.ts
import { jsonDecode } from "../../../../functions/jsonHelpers";
import { log, logError } from "../../../../functions/log";
import { merge } from "../../../../functions/merge";
import { iterateTableInOrder } from "../../../../functions/table";
import { isString, isTable } from "../../../../functions/types";
import type { SaveData } from "../../../../interfaces/SaveData";
import type { AnyClass } from "../../../../types/AnyClass";
import { SAVE_DATA_MANAGER_DEBUG } from "./constants";

const DEFAULT_MOD_DATA = "{}";

export function loadFromDisk(
  mod: Mod,
  oldSaveData: LuaMap<string, SaveData>,
  classConstructors: LuaMap<string, AnyClass>,
): void {
  if (!mod.HasData()) {
    // There is no "save#.dat" file for this save slot.
    return;
  }

  // First, read the "save#.dat" file into a Lua table.
  const jsonString = readSaveDatFile(mod);
  const newSaveData = jsonDecode(jsonString);

  if (SAVE_DATA_MANAGER_DEBUG) {
    log('Converted data from the "save#.dat" to a Lua table.');
  }

  // Second, iterate over all the fields of the new table.)
  iterateTableInOrder(
    newSaveData,
    (subscriberName, saveData) => {
      // All elements of loaded save data should have keys that are strings equal to the name of the
      // subscriber/feature. Ignore elements with other types of keys.
      if (!isString(subscriberName)) {
        return;
      }

      // All elements of loaded save data should be tables that contain fields corresponding to the
      // `SaveData` interface. Ignore elements that are not tables.
      if (!isTable(saveData)) {
        return;
      }

      // Ignore elements that represent subscriptions that no longer exist in the current save data.
      const oldSaveDataForSubscriber = oldSaveData.get(subscriberName);
      if (oldSaveDataForSubscriber === undefined) {
        return;
      }

      if (SAVE_DATA_MANAGER_DEBUG) {
        log(`Merging in stored data for feature: ${subscriberName}`);
      }

      // We do not want to blow away the child tables of the existing map, because save data could
      // contain out-of-date fields. Instead, merge it one field at a time in a recursive way (and
      // convert Lua tables back to TypeScriptToLua Maps, if necessary).
      merge(
        oldSaveDataForSubscriber as LuaMap<AnyNotNil, unknown>,
        saveData,
        subscriberName,
        classConstructors,
      );
    },
    SAVE_DATA_MANAGER_DEBUG,
  );

  log(
    `The save data manager loaded data from the "save#.dat" file for mod: ${mod.Name}`,
  );
}

function readSaveDatFile(mod: Mod) {
  const renderFrameCount = Isaac.GetFrameCount();

  const [ok, jsonStringOrErrMsg] = pcall(tryLoadModData, mod);
  if (!ok) {
    logError(
      `Failed to read from the "save#.dat" file on render frame ${renderFrameCount}: ${jsonStringOrErrMsg}`,
    );
    return DEFAULT_MOD_DATA;
  }

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (jsonStringOrErrMsg === undefined) {
    return DEFAULT_MOD_DATA;
  }

  const jsonStringTrimmed = jsonStringOrErrMsg.trim();
  if (jsonStringTrimmed === "") {
    return DEFAULT_MOD_DATA;
  }

  return jsonStringTrimmed;
}

function tryLoadModData(this: void, mod: Mod) {
  return mod.LoadData();
}

----
classes\features\other\saveDataManager\restoreDefaults.ts
// The save data manager has a feature where certain variables are automatically restored to default
// values at certain times.

import { SaveDataKey } from "../../../../enums/SaveDataKey";
import { SerializationType } from "../../../../enums/SerializationType";
import { deepCopy } from "../../../../functions/deepCopy";
import { logError } from "../../../../functions/log";
import { clearTable, iterateTableInOrder } from "../../../../functions/table";
import type { SaveData } from "../../../../interfaces/SaveData";
import { ReadonlySet } from "../../../../types/ReadonlySet";
import { SAVE_DATA_MANAGER_DEBUG } from "./constants";

const RESETTABLE_SAVE_DATA_KEYS = new ReadonlySet<SaveDataKey>([
  SaveDataKey.RUN,
  SaveDataKey.LEVEL,
  SaveDataKey.ROOM,
]);

export function restoreDefaultsForAllFeaturesAndKeys(
  saveDataMap: LuaMap<string, SaveData>,
  saveDataDefaultsMap: LuaMap<string, SaveData>,
): void {
  for (const saveDataKey of RESETTABLE_SAVE_DATA_KEYS) {
    restoreDefaultsForAllFeaturesKey(
      saveDataMap,
      saveDataDefaultsMap,
      saveDataKey,
    );
  }
}

export function restoreDefaultsForAllFeaturesKey(
  saveDataMap: LuaMap<string, SaveData>,
  saveDataDefaultsMap: LuaMap<string, SaveData>,
  saveDataKey: SaveDataKey,
): void {
  iterateTableInOrder(
    saveDataMap,
    (subscriberName, saveData) => {
      restoreDefaultForFeatureKey(
        saveDataDefaultsMap,
        subscriberName,
        saveData,
        saveDataKey,
      );
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

export function restoreDefaultForFeatureKey(
  saveDataDefaultsMap: LuaMap<string, SaveData>,
  subscriberName: string,
  saveData: SaveData,
  saveDataKey: SaveDataKey,
): void {
  // Only allow certain save data keys to be reset.
  if (!RESETTABLE_SAVE_DATA_KEYS.has(saveDataKey)) {
    error(
      `Failed to restore default values for a save data key of "${saveDataKey}", since it is not on the allowed list of resettable save data keys.`,
    );
  }

  const childTable = saveData[saveDataKey];
  if (childTable === undefined) {
    // This feature does not happen to store any variables on this particular child table.
    return;
  }

  // Get the default values for this feature.
  const saveDataDefaults = saveDataDefaultsMap.get(subscriberName);
  if (saveDataDefaults === undefined) {
    logError(
      `Failed to find the default copy of the save data for subscriber: ${subscriberName}`,
    );
    return;
  }

  // Get the default values for the specific sub-table of this feature.
  const childTableDefaults = saveDataDefaults[saveDataKey];
  if (childTableDefaults === undefined) {
    logError(
      `Failed to find the default copy of the child table "${saveDataKey}" for subscriber "${subscriberName}". This error usually means that your mod-specific save data is out of date. You can try purging all of your mod-specific save data by deleting the following directory: C:\\Program Files (x86)\\Steam\\steamapps\\common\\The Binding of Isaac Rebirth\\data`,
    );
    return;
  }

  // Make a new copy of the default child table.
  const childTableDefaultsCopy = deepCopy(
    childTableDefaults,
    SerializationType.NONE,
    `${subscriberName} --> ${saveDataKey}`,
  ) as LuaMap<AnyNotNil, unknown>;

  // We do not want to blow away the existing child table because we do not want to break any
  // existing references. Instead, empty the table and copy all of the elements from the copy of the
  // defaults table.
  clearAndCopyAllElements(
    childTable as unknown as LuaMap<AnyNotNil, unknown>,
    childTableDefaultsCopy,
  );
}

/**
 * Will empty the old table of all elements, and then shallow copy all the elements from the new
 * table to the old table.
 */
function clearAndCopyAllElements(
  oldTable: LuaMap<AnyNotNil, unknown>,
  newTable: LuaMap<AnyNotNil, unknown>,
) {
  clearTable(oldTable);

  for (const [key, value] of newTable) {
    oldTable.set(key, value);
  }
}

----
classes\features\other\saveDataManager\saveToDisk.ts
import { SerializationType } from "../../../../enums/SerializationType";
import { deepCopy } from "../../../../functions/deepCopy";
import { jsonEncode } from "../../../../functions/jsonHelpers";
import { log } from "../../../../functions/log";
import { isTableEmpty, iterateTableInOrder } from "../../../../functions/table";
import type { SaveData } from "../../../../interfaces/SaveData";
import { SAVE_DATA_MANAGER_DEBUG } from "./constants";

export function saveToDisk(
  mod: Mod,
  saveDataMap: LuaMap<string, SaveData>,
  saveDataConditionalFuncMap: LuaMap<string, () => boolean>,
): void {
  const allSaveData = getAllSaveDataToWriteToDisk(
    saveDataMap,
    saveDataConditionalFuncMap,
  );
  const jsonString = jsonEncode(allSaveData);
  mod.SaveData(jsonString);
  log(
    `The save data manager wrote data to the "save#.dat" file for mod: ${mod.Name}`,
  );
}

function getAllSaveDataToWriteToDisk(
  saveDataMap: LuaMap<string, SaveData>,
  saveDataConditionalFuncMap: LuaMap<string, () => boolean>,
) {
  const allSaveData = new LuaMap<AnyNotNil, unknown>();

  iterateTableInOrder(
    saveDataMap,
    (subscriberName, saveData) => {
      // Handle the feature of the save data manager where certain mod features can conditionally
      // write their data to disk.
      const conditionalFunc = saveDataConditionalFuncMap.get(subscriberName);
      if (conditionalFunc !== undefined) {
        const shouldSave = conditionalFunc();
        if (!shouldSave) {
          return;
        }
      }

      // Strip out the room part of the save data (and any other arbitrary fields that they might
      // have added).
      const saveDataWithoutRoom: SaveData = {
        persistent: saveData.persistent,
        run: saveData.run,
        level: saveData.level,
      };

      // If there is no data, then we can move on to the next feature.
      if (isTableEmpty(saveDataWithoutRoom as LuaMap<AnyNotNil, unknown>)) {
        return;
      }

      // We need to serialize TypeScriptToLua maps and Isaac API objects such as `Color`.
      // Recursively convert all such objects to Lua tables.
      const saveDataCopy = deepCopy(
        saveDataWithoutRoom,
        SerializationType.SERIALIZE,
        subscriberName,
      );

      allSaveData.set(subscriberName, saveDataCopy);
    },
    SAVE_DATA_MANAGER_DEBUG,
  );

  return allSaveData;
}

----
classes\private\CustomCallback.ts
import type { CallbackPriority } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import { sortObjectArrayByKey, stableSort } from "../../functions/sort";
import type { AddCallbackParametersCustom } from "../../interfaces/private/AddCallbackParametersCustom";
import type { AllButFirst } from "../../types/AllButFirst";
import type { AnyFunction } from "../../types/AnyFunction";
import { Feature } from "./Feature";

export type FireArgs<T extends ModCallbackCustom> = Parameters<
  AddCallbackParametersCustom[T][0]
>;

export type OptionalArgs<T extends ModCallbackCustom> = AllButFirst<
  AddCallbackParametersCustom[T]
>;

interface Subscription<T extends ModCallbackCustom> {
  priority: CallbackPriority | int;
  callbackFunc: AddCallbackParametersCustom[T][0];
  optionalArgs: AllButFirst<AddCallbackParametersCustom[T]>;
}

/**
 * The base class for a custom callback. Individual custom callbacks (and validation callbacks) will
 * extend from this class.
 */
export abstract class CustomCallback<
  T extends ModCallbackCustom,
> extends Feature {
  private subscriptions: Array<Subscription<T>> = [];

  public addSubscriber(
    priority: CallbackPriority | int,
    callbackFunc: AddCallbackParametersCustom[T][0],
    ...optionalArgs: AllButFirst<AddCallbackParametersCustom[T]>
  ): void {
    const subscription: Subscription<T> = {
      priority,
      callbackFunc,
      optionalArgs,
    };
    this.subscriptions.push(subscription);

    // Sort the subscriptions by priority so that the callbacks with the lowest priority are first.
    // By default, the `Array.sort` method is transpiled to using Lua's sort, which is not stable.
    // We need to do a stable sort so that we preserve the subscription order.
    this.subscriptions = stableSort(
      this.subscriptions,
      sortObjectArrayByKey("priority"),
    );
  }

  /**
   * If the submitted function does not match any of the existing subscriptions, this method will do
   * nothing.
   */
  public removeSubscriber(callback: AddCallbackParametersCustom[T][0]): void {
    const subscriptionIndexMatchingCallback = this.subscriptions.findIndex(
      (subscription) => {
        const subscriptionCallback = subscription.callbackFunc;
        return callback === subscriptionCallback;
      },
    );
    if (subscriptionIndexMatchingCallback !== -1) {
      this.subscriptions.splice(subscriptionIndexMatchingCallback, 1);
    }
  }

  public fire = (
    ...fireArgs: FireArgs<T>
  ): ReturnType<AddCallbackParametersCustom[T][0]> => {
    for (const subscription of this.subscriptions) {
      const { callbackFunc, optionalArgs } = subscription;

      if (this.shouldFire(fireArgs, optionalArgs)) {
        // - TypeScript is not smart enough to know that the arguments match the function, so we
        //   must cast it to `AnyFunction`.
        // - We cannot use `...fireArgs` here because it would fail to pass any arguments that exist
        //   beyond `nil` elements.
        const value = (callbackFunc as AnyFunction)(
          fireArgs[0],
          fireArgs[1],
          fireArgs[2],
          fireArgs[3],
          fireArgs[4],
          fireArgs[5],
          fireArgs[6],
        );
        if (value !== undefined) {
          return value as ReturnType<AddCallbackParametersCustom[T][0]>;
        }
      }
    }

    return undefined as ReturnType<AddCallbackParametersCustom[T][0]>;
  };

  /**
   * This method needs to be overwritten for any callback that has optional filtration arguments.
   * See "shouldFire.ts" for methods tailored to specific kinds of callbacks.
   */
  protected shouldFire: (
    fireArgs: FireArgs<T>,
    optionalArgs: OptionalArgs<T>,
  ) => boolean = () => true;
}

----
classes\private\Feature.ts
import type { ISCFeature } from "../../enums/ISCFeature";
import type { SaveData } from "../../interfaces/SaveData";
import type {
  CallbackTuple,
  CustomCallbackTuple,
} from "../../types/private/CallbackTuple";

/**
 * The IsaacScript standard library contains many optional features, such as the ability to create
 * custom pickups. All features are optional and are only initialized when needed. This class
 * contains elements to facilitate that.
 *
 * Additionally, all custom callbacks extend from this class.
 */
export abstract class Feature {
  /**
   * All features should only be instantiated once and are passed around to other features using
   * dependency injection. We provide a run-time check in order to prevent the bug of any feature
   * accidentally being instantiated twice.
   */
  private static readonly constructedClassNames = new Set<string>();

  /** @internal */
  public initialized = false;

  /** @internal */
  public numConsumers = 0;

  /** @internal */
  public v?: SaveData;

  /** @internal */
  public vConditionalFunc?: () => boolean;

  /** @internal */
  public featuresUsed?: ISCFeature[];

  /** @internal */
  public callbacksUsed?: CallbackTuple[];

  /** @internal */
  public customCallbacksUsed?: CustomCallbackTuple[];

  constructor() {
    if (Feature.constructedClassNames.has(this.constructor.name)) {
      error(
        `Failed to instantiate feature class "${this.constructor.name}" because it has already been instantiated once.`,
      );
    }

    Feature.constructedClassNames.add(this.constructor.name);
  }
}

----
core\cachedClasses.ts
/**
 * A cached version of the class returned from the `Game()` constructor.
 *
 * Use this instead of invoking the constructor again for a miniscule performance increase.
 *
 * Caching the results of this constructor is safe, but caching other classes (like `Level` or
 * `Room`) is not safe and can lead to the game crashing in certain situations.
 */
export const game = Game();

/**
 * A cached version of the class returned from the `Isaac.GetItemConfig()` constructor.
 *
 * Use this instead of invoking the constructor again for a miniscule performance increase.
 *
 * Caching the results of this constructor is safe, but caching other classes (like `Level` or
 * `Room`) is not safe and can lead to the game crashing in certain situations.
 */
export const itemConfig = Isaac.GetItemConfig();

/**
 * A cached version of the class returned from the `MusicManager()` constructor.
 *
 * Use this instead of invoking the constructor again for a miniscule performance increase.
 *
 * Caching the results of this constructor is safe, but caching other classes (like `Level` or
 * `Room`) is not safe and can lead to the game crashing in certain situations.
 */
export const musicManager = MusicManager();

/**
 * A cached version of the class returned from the `SFXManager()` constructor.
 *
 * Use this instead of invoking the constructor again for a miniscule performance increase.
 *
 * Caching the results of this constructor is safe, but caching other classes (like `Level` or
 * `Room`) is not safe and can lead to the game crashing in certain situations.
 */
export const sfxManager = SFXManager();

/**
 * An object containing all 7 vanilla fonts that are pre-loaded and ready to use.
 *
 * For more information on the vanilla fonts and to see what they look like, see:
 * https://wofsauge.github.io/IsaacDocs/rep/tutorials/Tutorial-Rendertext.html
 */
export const fonts = {
  droid: Font(),
  pfTempestaSevenCondensed: Font(),
  teamMeatFont10: Font(),
  teamMeatFont12: Font(),
  teamMeatFont16Bold: Font(),
  terminus: Font(),
  upheaval: Font(),
} as const;

fonts.droid.Load("font/droid.fnt");
fonts.pfTempestaSevenCondensed.Load("font/pftempestasevencondensed.fnt");
fonts.teamMeatFont10.Load("font/teammeatfont10.fnt");
fonts.teamMeatFont12.Load("font/teammeatfont12.fnt");
fonts.teamMeatFont16Bold.Load("font/teammeatfont16bold.fnt");
fonts.terminus.Load("font/terminus.fnt");
fonts.upheaval.Load("font/upheaval.fnt");

----
core\constants.ts
import {
  CollectibleType,
  Dimension,
  DisplayFlag,
  ItemPoolType,
  PickupVariant,
  PlayerType,
  TrinketSlot,
} from "isaac-typescript-definitions";
import { getEnumLength } from "../functions/enums";
import { addFlag } from "../functions/flag";
import {
  newReadonlyColor,
  newReadonlyKColor,
  newReadonlyVector,
} from "../functions/readOnly";
import { asCollectibleType } from "../functions/types";
import { eRange } from "../functions/utils";
import { ReadonlySet } from "../types/ReadonlySet";
import { NUM_NORMAL_PILL_COLORS } from "./constantsFirstLast";

/**
 * The combination of the following flags:
 * - `DisplayFlag.VISIBLE` (1 << 0)
 * - `DisplayFlag.SHADOW` (1 << 1)
 * - `DisplayFlag.SHOW_ICON` (1 << 2)
 */
export const ALL_DISPLAY_FLAGS = addFlag(
  DisplayFlag.VISIBLE,
  DisplayFlag.SHADOW,
  DisplayFlag.SHOW_ICON,
);

/**
 * The distance of the laser when Azazel does not have any range up items yet. For more info, see
 * the documentation for the `getAzazelBrimstoneDistance` function.
 */
export const AZAZEL_DEFAULT_BRIMSTONE_DISTANCE = 75.125;

/**
 * The path to the png file for collectible items during Curse of the Blind, making them appear with
 * a red question mark.
 */
export const BLIND_ITEM_PNG_PATH = "gfx/items/collectibles/questionmark.png";

/** Bombs explode when their frame count is equal to this value. */
export const BOMB_EXPLODE_FRAME = 45;

export const CHEST_PICKUP_VARIANTS = [
  PickupVariant.CHEST, // 50
  PickupVariant.BOMB_CHEST, // 51
  PickupVariant.SPIKED_CHEST, // 52
  PickupVariant.ETERNAL_CHEST, // 53
  PickupVariant.MIMIC_CHEST, // 54
  PickupVariant.OLD_CHEST, // 55
  PickupVariant.WOODEN_CHEST, // 56
  PickupVariant.MEGA_CHEST, // 57
  PickupVariant.HAUNTED_CHEST, // 58
  PickupVariant.LOCKED_CHEST, // 60
  PickupVariant.RED_CHEST, // 360
  PickupVariant.MOMS_CHEST, // 390
] as const;

export const CHEST_PICKUP_VARIANTS_SET = new ReadonlySet<PickupVariant>(
  CHEST_PICKUP_VARIANTS,
);

/** This is the initial value of the `EntityPickup.Wait` field after a collectible is spawned. */
export const COLLECTIBLE_INITIAL_WAIT = 20;

export const DEFAULT_ITEM_POOL_TYPE = ItemPoolType.TREASURE;

/** This is also the distance that a player spawns from the door that they enter a room from. */
export const DISTANCE_OF_GRID_TILE = 40;

export const DOGMA_ROOM_GRID_INDEX = 109;

export const DOOR_HITBOX_RADIUS = 11;

/**
 * When Eggies take fatal damage, they go into NPCState.STATE_SUICIDE and spawn 14 Swarm Spiders
 * while their StateFrame ticks upwards. The 14th spider appears when the StateFrame is at this
 * value.
 */
export const EGGY_STATE_FRAME_OF_FINAL_SPIDER = 45;

/**
 * A non-existent or completely transparent PNG file for use in clearing sprites. For more
 * information, see the documentation for the `clearSprite` helper function.
 */
export const EMPTY_PNG_PATH = "gfx/none.png";

/**
 * The random items that appear when the player has TMTRAINER are generated on the fly as they are
 * encountered by the player. The first TMTRAINER item takes the final possible 32 bit number. The
 * second TMTRAINER item subtracts one from that, and so on.
 *
 * This is equal to 4294967295.
 */

export const FIRST_GLITCHED_COLLECTIBLE_TYPE = asCollectibleType((1 << 32) - 1);

/**
 * An array containing every flying character. This includes non-main characters such as The Soul.
 */
export const FLYING_CHARACTERS = [
  PlayerType.AZAZEL, // 7
  PlayerType.LOST, // 10
  PlayerType.SOUL, // 17
  PlayerType.LOST_B, // 31
  PlayerType.JACOB_2_B, // 39
  PlayerType.SOUL_B, // 40
] as const;

/** Game frames are what is returned by the `Game.GetFrameCount` method. */
export const GAME_FRAMES_PER_SECOND = 30;

/** Game frames are what is returned by the `Game.GetFrameCount` method. */
export const GAME_FRAMES_PER_MINUTE = GAME_FRAMES_PER_SECOND * 60;

/**
 * An array containing every character that is selectable from the main menu (and has achievements
 * related to completing the various bosses and so on).
 */
export const MAIN_CHARACTERS = [
  PlayerType.ISAAC, // 0
  PlayerType.MAGDALENE, // 1
  PlayerType.CAIN, // 2
  PlayerType.JUDAS, // 3
  PlayerType.BLUE_BABY, // 4
  PlayerType.EVE, // 5
  PlayerType.SAMSON, // 6
  PlayerType.AZAZEL, // 7
  PlayerType.LAZARUS, // 8
  PlayerType.EDEN, // 9
  PlayerType.LOST, // 10
  PlayerType.LILITH, // 13
  PlayerType.KEEPER, // 14
  PlayerType.APOLLYON, // 15
  PlayerType.FORGOTTEN, // 16
  PlayerType.BETHANY, // 18
  PlayerType.JACOB, // 19
  PlayerType.ISAAC_B, // 21
  PlayerType.MAGDALENE_B, // 22
  PlayerType.CAIN_B, // 23
  PlayerType.JUDAS_B, // 24
  PlayerType.BLUE_BABY_B, // 25
  PlayerType.EVE_B, // 26
  PlayerType.SAMSON_B, // 27
  PlayerType.AZAZEL_B, // 28
  PlayerType.LAZARUS_B, // 29
  PlayerType.EDEN_B, // 30
  PlayerType.LOST_B, // 31
  PlayerType.LILITH_B, // 32
  PlayerType.KEEPER_B, // 33
  PlayerType.APOLLYON_B, // 34
  PlayerType.FORGOTTEN_B, // 35
  PlayerType.BETHANY_B, // 36
  PlayerType.JACOB_B, // 37
] as const;

/** Render frames are what is returned by the `Isaac.GetFrameCount` method. */
export const RENDER_FRAMES_PER_SECOND = 60;

/** Render frames are what is returned by the `Isaac.GetFrameCount` method. */
export const RENDER_FRAMES_PER_MINUTE = RENDER_FRAMES_PER_SECOND * 60;

export const GRID_INDEX_CENTER_OF_1X1_ROOM = 67;

/**
 * The floor is represented by a 13x13 grid. Room indexes start at 0. The first column is
 * represented by grid indexes 0, 13, 26, and so on.
 */
export const LEVEL_GRID_COLUMN_HEIGHT = 13;

/**
 * The floor is represented by a 13x13 grid. Room indexes start at 0. The first row is represented
 * by grid indexes from 0 to 12. The second row is represented by grid indexes from 13 to 25, and so
 * on.
 */
export const LEVEL_GRID_ROW_WIDTH = 13;

/**
 * All of the collectibles that grant vision on the map.
 *
 * Note that:
 * - Spelunker Hat is included. Historically, Spelunker Hat was not considered to be mapping, but it
 *   was buffed in Repentance to show rooms two or more away.
 * - Book of Secrets is included, which is an "active mapping" instead of passive.
 * - Luna is included, even though it is not a very powerful mapping item.
 * - Cracked Orb is included, even though it requires the player to be damaged in order for it to be
 *   activated.
 */
export const MAPPING_COLLECTIBLES = [
  CollectibleType.COMPASS, // 21
  CollectibleType.TREASURE_MAP, // 54
  CollectibleType.SPELUNKER_HAT, // 91
  CollectibleType.CRYSTAL_BALL, // 158
  CollectibleType.BLUE_MAP, // 246
  CollectibleType.BOOK_OF_SECRETS, // 287
  CollectibleType.MIND, // 333
  CollectibleType.SOL, // 588
  CollectibleType.LUNA, // 589
  CollectibleType.CRACKED_ORB, // 675
] as const;

/**
 * The floor is represented by a 13x13 grid. Room indexes start at 0. The first row is represented
 * by grid indexes from 0 to 12. The second row is represented by grid indexes from 13 to 25, and so
 * on. The maximum room index possible is 168. (It is not 169 because we start at 0 instead of 1.)
 */
export const MAX_LEVEL_GRID_INDEX = 168;

/**
 * The game has a limit on the number of currently spawned familiars and will refuse to spawn any
 * more if it reaches the limit. Blue flies and blue spiders have a lower priority and will be
 * deleted to make room for other familiars.
 */
export const MAX_NUM_FAMILIARS = 64;

/** The game can only handle up to four different players. */
export const MAX_NUM_INPUTS = 4;

/** With Birthright, it is possible for Magdalene to have 18 heart containers. */
export const MAX_PLAYER_HEART_CONTAINERS = 18;

/**
 * As the player continues to move in a direction, they will accelerate. When going from one wall to
 * another in a 2x2 room at 2.0 speed (the maximum that the speed stat can rise to), the amount of
 * units moved per update frame will climb to around 9.797 as they hit the opposite wall. The
 * constant specifies a value of 9.8 to be safe.
 */
export const MAX_PLAYER_SPEED_IN_UNITS = 9.8;

export const MAX_PLAYER_TRINKET_SLOTS = getEnumLength(TrinketSlot);

/** If you set `EntityPlayer.ShotSpeed` lower than this value, it will have no effect. */
export const MIN_PLAYER_SHOT_SPEED_STAT = 0.6;

/** If you set `EntityPlayer.Speed` lower than this value, it will have no effect. */
export const MIN_PLAYER_SPEED_STAT = 0.1;

/**
 * The maximum speed stat that a player can have. Any additional speed beyond this will not take
 * effect.
 */
export const MAX_SPEED_STAT = 2;

/** This is in the center of the room. */
export const NEW_FLOOR_STARTING_POSITION_NORMAL_MODE = newReadonlyVector(
  320,
  280,
);

/** This is near the top door. */
export const NEW_FLOOR_STARTING_POSITION_GREED_MODE = newReadonlyVector(
  320,
  280,
);

/**
 * This is next to the bottom door. Presumably, the player does not start in the center of the room
 * (like they do when getting to a new stage) so that the controls graphic is more visible.
 */
export const NEW_RUN_PLAYER_STARTING_POSITION = newReadonlyVector(320, 380);

/** Corresponds to the maximum value for `EntityPlayer.SamsonBerserkCharge`. */
export const MAX_TAINTED_SAMSON_BERSERK_CHARGE = 100_000;

/**
 * The number of dimensions, not including `Dimension.CURRENT`. (This is derived from the
 * `Dimension` enum.)
 */
export const NUM_DIMENSIONS = getEnumLength(Dimension) - 1;

/**
 * An array containing every valid `Dimension`, not including `Dimension.CURRENT`. (This is derived
 * from the `NUM_DIMENSIONS` constant.)
 */
export const DIMENSIONS: readonly Dimension[] = eRange(
  NUM_DIMENSIONS,
) as Dimension[];

/**
 * The pill pool for each run is comprised of one effect for each unique pill color (minus gold and
 * horse pills.)
 */
// TypeDoc will not work properly with the preferred export form.
// eslint-disable-next-line unicorn/prefer-export-from
export const NUM_PILL_COLORS_IN_POOL = NUM_NORMAL_PILL_COLORS;

export const ONE_BY_ONE_ROOM_GRID_SIZE = 135;

/**
 * An array representing every valid collectible type quality. Specifically, this is: `[0, 1, 2, 3,
 * 4]`
 */
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const QUALITIES: readonly Quality[] = [0, 1, 2, 3, 4];
export const MAX_QUALITY: Quality = 4;

export const SECOND_IN_MILLISECONDS = 1000;
export const MINUTE_IN_MILLISECONDS = 60 * SECOND_IN_MILLISECONDS;

/** This is equivalent to the bottom-right screen position when the game is in full screen mode. */
export const RESOLUTION_FULL_SCREEN = Vector(480, 270);

/**
 * This is equivalent to the bottom-right screen position when the game is in windowed mode in a
 * 1600x900 resolution.
 */
export const RESOLUTION_1600_900 = Vector(533, 300);

/**
 * The starting room of the floor is always at the same grid index, which is in the middle of the
 * 13x13 grid.
 */
export const STARTING_ROOM_GRID_INDEX = 84;

/** After taking damage, `EntityPlayer.SamsonBerserkCharge` is incremented by this amount. */
export const TAINTED_SAMSON_BERSERK_CHARGE_FROM_TAKING_DAMAGE = 10_000;

/** For `GridEntityType.TELEPORTER` (23). */
export const TELEPORTER_ACTIVATION_DISTANCE = DISTANCE_OF_GRID_TILE / 2;

/** In milliseconds, as reported by the `Isaac.GetTime` method. */
export const TIME_GAME_OPENED = Isaac.GetTime();

/**
 * This is the number of draw coordinates that each heart spans on the UI in the upper left hand
 * corner.
 */
export const UI_HEART_WIDTH = 12;

/**
 * Equal to `Vector(1, 1)`.
 *
 * This is a safe version of the `Vector.One` constant. (Other mods can mutate `Vector.One`, so it
 * is not safe to use.)
 */
export const VectorOne = newReadonlyVector(1, 1);

/**
 * Equal to `Vector(0, 0)`.
 *
 * This is a safe version of the `Vector.Zero` constant. (Other mods can mutate `Vector.Zero`, so it
 * is not safe to use.)
 */
export const VectorZero = newReadonlyVector(0, 0);

/**
 * Equal to `Color(1, 1, 1)`.
 *
 * This is a safe version of the `Color.Default` constant. (Other mods can mutate `Color.Default`,
 * so it is not safe to use.)
 *
 * If you need to mutate this, make a copy first with the `copyColor` helper function.
 */
export const ColorDefault = newReadonlyColor(1, 1, 1);

/**
 * Equal to `KColor(1, 1, 1, 1)`.
 *
 * If you need to mutate this, make a copy first with the `copyKColor` helper function.
 */
export const KColorDefault = newReadonlyKColor(1, 1, 1, 1);

----
core\constantsFirstLast.ts
/**
 * Constants relating to the first and last value for various vanilla objects.
 *
 * @module
 */

import {
  CardType,
  Challenge,
  CollectibleType,
  PillColor,
  PillEffect,
  PlayerType,
  TrinketType,
} from "isaac-typescript-definitions";
import { getEnumLength, getHighestEnumValue } from "../functions/enums";

// ------------
// Collectibles
// ------------

/** Equal to `CollectibleType.SAD_ONION` (1). */
export const FIRST_COLLECTIBLE_TYPE = CollectibleType.SAD_ONION;

/**
 * Calculated from the `CollectibleType` enum.
 *
 * Note that this cannot be calculated from the length of the enum, because collectible types are
 * not contiguous.
 */
export const LAST_VANILLA_COLLECTIBLE_TYPE =
  getHighestEnumValue(CollectibleType);

/** Calculated from the `CollectibleType` enum. (`CollectibleType.NULL` is not included.) */
export const NUM_VANILLA_COLLECTIBLE_TYPES = getEnumLength(CollectibleType) - 1;

// --------
// Trinkets
// --------

/** Equal to `TrinketType.SWALLOWED_PENNY` (1). */
export const FIRST_TRINKET_TYPE = TrinketType.SWALLOWED_PENNY;

/**
 * Calculated from the `TrinketType` enum.
 *
 * Note that this cannot be calculated from the length of the enum, because trinket types are not
 * contiguous.
 */
export const LAST_VANILLA_TRINKET_TYPE = getHighestEnumValue(TrinketType);

/** Calculated from the `TrinketType` enum. (`TrinketType.NULL` is not included.) */
export const NUM_VANILLA_TRINKET_TYPES = getEnumLength(TrinketType) - 1;

// -----
// Cards
// -----

/** Equal to `Card.FOOL` (1). */
export const FIRST_CARD_TYPE = CardType.FOOL;

/** Calculated from the `CardType` enum. */
export const LAST_VANILLA_CARD_TYPE = getHighestEnumValue(CardType);

/** Calculated from the `Card` enum. `Card.NULL` is not included. */
export const NUM_VANILLA_CARD_TYPES = getEnumLength(CardType) - 1;

// ------------
// Pill Effects
// ------------

/** Equal to `PillEffect.BAD_GAS` (0). */
export const FIRST_PILL_EFFECT = PillEffect.BAD_GAS;

/** Calculated from the `PillEffect` enum. */
export const LAST_VANILLA_PILL_EFFECT = getHighestEnumValue(PillEffect);

/**
 * Calculated from the `PillEffect` enum. (There is no `PillEffect.NULL` in the custom enum, so we
 * do not have to subtract one here.)
 */
export const NUM_VANILLA_PILL_EFFECTS = getEnumLength(PillEffect);

// -----------
// Pill Colors
// -----------

/** Equal to `PillColor.BLUE_BLUE` (1). */
export const FIRST_PILL_COLOR = PillColor.BLUE_BLUE;

/**
 * Equal to `PillColor.WHITE_YELLOW` (13).
 *
 * Note that `PillColor.GOLD` is technically higher, but that is not considered for the purposes of
 * this constant.
 */
export const LAST_NORMAL_PILL_COLOR = PillColor.WHITE_YELLOW;

/** Equal to `PillColor.HORSE_BLUE_BLUE` (2049). */
export const FIRST_HORSE_PILL_COLOR = PillColor.HORSE_BLUE_BLUE;

/**
 * Equal to `PillColor.HORSE_WHITE_YELLOW` (2061).
 *
 * Note that `PillColor.HORSE_GOLD` is technically higher, but that is not considered for the
 * purposes of this constant.
 */
export const LAST_HORSE_PILL_COLOR = PillColor.HORSE_WHITE_YELLOW;

/**
 * Calculated from the difference between the first pill color and the last pill color. This does
 * not include Gold Pills. In Repentance, this should be equal to 13.
 */
export const NUM_NORMAL_PILL_COLORS =
  LAST_NORMAL_PILL_COLOR - FIRST_PILL_COLOR + 1;

// -------
// Players
// -------

/** Equal to `PlayerType.ISAAC` (0). */
export const FIRST_CHARACTER = PlayerType.ISAAC;

// It is not possible to determine "LAST_CHARACTER", since there is no associated config.

/** Calculated from the `PlayerType` enum. */
export const LAST_VANILLA_CHARACTER = getHighestEnumValue(PlayerType);

// ----------
// Challenges
// ----------

/** Calculated from the `Challenge` enum. `Challenge.NULL` is not included. */
export const NUM_VANILLA_CHALLENGES = getEnumLength(Challenge) - 1;

----
core\constantsVanilla.ts
/**
 * Constants relating to collections for various vanilla objects.
 *
 * @module
 */

import type {
  CardType,
  CollectibleType,
  PillEffect,
  TrinketType,
} from "isaac-typescript-definitions";
import {
  asCardType,
  asCollectibleType,
  asPillEffect,
  asTrinketType,
} from "../functions/types";
import { iRange } from "../functions/utils";
import { ReadonlySet } from "../types/ReadonlySet";
import { itemConfig } from "./cachedClasses";
import {
  FIRST_CARD_TYPE,
  FIRST_COLLECTIBLE_TYPE,
  FIRST_PILL_EFFECT,
  FIRST_TRINKET_TYPE,
  LAST_VANILLA_CARD_TYPE,
  LAST_VANILLA_COLLECTIBLE_TYPE,
  LAST_VANILLA_PILL_EFFECT,
  LAST_VANILLA_TRINKET_TYPE,
} from "./constantsFirstLast";

// ------------
// Collectibles
// ------------

/**
 * An array that represents the range from the first vanilla collectible type to the last vanilla
 * collectible type. This will include integers that do not represent any valid collectible types.
 *
 * This function is only useful when building collectible type objects. For most purposes, you
 * should use the `VANILLA_COLLECTIBLE_TYPES` or `VANILLA_COLLECTIBLE_TYPES_SET` constants instead.
 */
export const VANILLA_COLLECTIBLE_TYPE_RANGE: readonly int[] = iRange(
  FIRST_COLLECTIBLE_TYPE,
  LAST_VANILLA_COLLECTIBLE_TYPE,
);

/**
 * An array that contains every valid vanilla collectible type, as verified by the
 * `ItemConfig.GetCollectible` method. Vanilla collectible types are not contiguous, so every valid
 * must be verified. (There are several gaps, e.g. 666.)
 *
 * If you need to do O(1) lookups, use the `VANILLA_COLLECTIBLE_TYPES_SET` constant instead.
 */
// eslint-disable-next-line isaacscript/strict-enums
export const VANILLA_COLLECTIBLE_TYPES: readonly CollectibleType[] =
  VANILLA_COLLECTIBLE_TYPE_RANGE.filter((potentialCollectibleType) => {
    const collectibleType = asCollectibleType(potentialCollectibleType);
    const itemConfigItem = itemConfig.GetCollectible(collectibleType);
    return itemConfigItem !== undefined;
  });

/**
 * A set that contains every valid vanilla collectible type, as verified by the
 * `ItemConfig.GetCollectible` method. Vanilla collectible types are not contiguous, so every valid
 * must be verified. (There are several gaps, e.g. 666.)
 */
export const VANILLA_COLLECTIBLE_TYPES_SET = new ReadonlySet(
  VANILLA_COLLECTIBLE_TYPES,
);

// --------
// Trinkets
// --------

/**
 * An array that represents the range from the first vanilla trinket type to the last vanilla
 * trinket type. This will include integers that do not represent any valid trinket types.
 *
 * This function is only useful when building trinket type objects. For most purposes, you should
 * use the `VANILLA_TRINKET_TYPES` or `VANILLA_TRINKET_TYPES_SET` constants instead.
 */
export const VANILLA_TRINKET_TYPE_RANGE: readonly int[] = iRange(
  FIRST_TRINKET_TYPE,
  LAST_VANILLA_TRINKET_TYPE,
);

/**
 * An array that contains every valid vanilla trinket type, as verified by the
 * `ItemConfig.GetTrinket` method. Vanilla trinket types are not contiguous, so every valid must be
 * verified. (The only gap is 47 for `POLAROID_OBSOLETE`.)
 *
 * If you need to do O(1) lookups, use the `VANILLA_TRINKET_TYPES_SET` constant instead.
 */
// eslint-disable-next-line isaacscript/strict-enums
export const VANILLA_TRINKET_TYPES: readonly TrinketType[] =
  VANILLA_TRINKET_TYPE_RANGE.filter((potentialTrinketType) => {
    const trinketType = asTrinketType(potentialTrinketType);
    const itemConfigTrinket = itemConfig.GetTrinket(trinketType);
    return itemConfigTrinket !== undefined;
  });

/**
 * A set that contains every valid vanilla trinket type, as verified by the `ItemConfig.GetTrinket`
 * method. Vanilla trinket types are not contiguous, so every valid must be verified. (The only gap
 * is 47 for `POLAROID_OBSOLETE`.)
 */
export const VANILLA_TRINKET_TYPES_SET = new ReadonlySet(VANILLA_TRINKET_TYPES);

// ----------
// Card Types
// ----------

/**
 * An array that represents the range from the first vanilla card type to the last vanilla card
 * type.
 *
 * This function is only useful when building card type objects. For most purposes, you should use
 * the `VANILLA_CARD_TYPES` or `VANILLA_CARD_TYPES_SET` constants instead.
 */
export const VANILLA_CARD_TYPE_RANGE: readonly int[] = iRange(
  FIRST_CARD_TYPE,
  LAST_VANILLA_CARD_TYPE,
);

/**
 * An array that contains every valid vanilla card type, as verified by the `ItemConfig.GetCard`
 * method. Vanilla card types are contiguous, but we validate every entry to double check.
 *
 * If you need to do O(1) lookups, use the `VANILLA_CARD_TYPES_SET` constant instead.
 */
// eslint-disable-next-line isaacscript/strict-enums
export const VANILLA_CARD_TYPES: readonly CardType[] =
  VANILLA_CARD_TYPE_RANGE.filter((potentialCardType) => {
    const cardType = asCardType(potentialCardType);
    const itemConfigCard = itemConfig.GetCard(cardType);
    return itemConfigCard !== undefined;
  });

/**
 * A set that contains every valid vanilla card type, as verified by the `ItemConfig.GetCard`
 * method. Vanilla card types are contiguous, but we validate every entry to double check.
 */
export const VANILLA_CARD_TYPES_SET = new ReadonlySet(VANILLA_CARD_TYPES);

// ------------
// Pill Effects
// ------------

/**
 * An array that represents the range from the first vanilla pill effect to the last vanilla pill
 * effect.
 *
 * This function is only useful when building pill effect objects. For most purposes, you should use
 * the `VANILLA_PILL_EFFECTS` or `VANILLA_PILL_EFFECTS_SET` constants instead.
 */
export const VANILLA_PILL_EFFECT_RANGE: readonly int[] = iRange(
  FIRST_PILL_EFFECT,
  LAST_VANILLA_PILL_EFFECT,
);

/**
 * An array that contains every valid vanilla pill effect, as verified by the
 * `ItemConfig.GetPillEffect` method. Vanilla pill effects are contiguous, but we validate every
 * entry to double check.
 *
 * If you need to do O(1) lookups, use the `VANILLA_PILL_EFFECT_SET` constant instead.
 */
// eslint-disable-next-line isaacscript/strict-enums
export const VANILLA_PILL_EFFECTS: readonly PillEffect[] =
  VANILLA_PILL_EFFECT_RANGE.filter((potentialPillEffect) => {
    const pillEffect = asPillEffect(potentialPillEffect);
    const itemConfigPillEffect = itemConfig.GetPillEffect(pillEffect);
    return itemConfigPillEffect !== undefined;
  });

/**
 * A set that contains every valid vanilla pill effect, as verified by the
 * `ItemConfig.GetPillEffect` method. Vanilla pill effects are contiguous, but we validate every
 * entry to double check.
 */
export const VANILLA_PILL_EFFECTS_SET = new ReadonlySet(VANILLA_PILL_EFFECTS);

----
core\upgradeMod.ts
import { ModUpgraded } from "../classes/ModUpgraded";
import type { ISCFeature } from "../enums/ISCFeature";
import { patchErrorFunction } from "../patchErrorFunctions";
import { applyShaderCrashFix } from "../shaderCrashFix";
import type { AnyFunction } from "../types/AnyFunction";
import type { ModUpgradedWithFeatures } from "../types/private/ModUpgradedWithFeatures";

type ISCFeatureTuple<T extends readonly ISCFeature[]> =
  ISCFeature extends T["length"]
    ? 'The list of features must be a tuple. Use the "as const" assertion when declaring the array.'
    : T;

/**
 * Use this function to enable the custom callbacks and other optional features provided by
 * `isaacscript-common`.
 *
 * For example:
 *
 * ```ts
 * const modVanilla = RegisterMod("My Mod", 1);
 * const mod = upgradeMod(modVanilla);
 *
 * // Subscribe to vanilla callbacks.
 * mod.AddCallback(ModCallback.POST_UPDATE, postUpdate);
 *
 * // Subscribe to custom callbacks.
 * mod.AddCallbackCustom(ModCallbackCustom.POST_ITEM_PICKUP, postItemPickup);
 * ```
 *
 * @param modVanilla The mod object returned by the `RegisterMod` function.
 * @param features Optional. An array containing the optional standard library features that you
 *                 want to enable, if any. Default is an empty array.
 * @param debug Optional. Whether to log additional output when a callback is fired. Default is
 *              false.
 * @param timeThreshold Optional. If provided, will only log callbacks that take longer than the
 *                      specified number of seconds (if the "--luadebug" launch flag is turned on)
 *                      or milliseconds (if the "--luadebug" launch flag is turned off).
 * @returns The upgraded mod object.
 */
export function upgradeMod<T extends readonly ISCFeature[] = never[]>(
  modVanilla: Mod,
  features: ISCFeatureTuple<T> = [] as unknown as ISCFeatureTuple<T>,
  debug = false,
  timeThreshold?: float,
): ModUpgradedWithFeatures<T> {
  // First, validate that all of the features exist (for Lua users who don't have type-safety).
  for (const feature of features) {
    const featureType = type(feature);
    if (featureType !== "number") {
      error(
        `Failed to upgrade the mod due to one of the specified features being of type "${featureType}". (All of the features should be numbers represented by the "ISCFeature" enum.)`,
      );
    }
  }

  // Second, validate that all of the features are unique.
  const featureSet = new Set(features as ISCFeature[]);
  if (featureSet.size !== features.length) {
    error(
      'Failed to upgrade the mod since there are two or more of the same features specified in the "features" array. When you pass the array of features to the "upgradeMod" function, all of the elements should be unique.',
    );
  }

  patchErrorFunction();

  const mod = new ModUpgraded(modVanilla, debug, timeThreshold);
  applyShaderCrashFix(mod);
  initOptionalFeatures(mod, features as ISCFeature[]);

  return mod as ModUpgradedWithFeatures<T>;
}

/** Initialize every optional feature that the end-user specified, if any. */
function initOptionalFeatures(
  mod: ModUpgraded,
  features: readonly ISCFeature[],
) {
  for (const feature of features) {
    // We intentionally access the private method here, so we use the string index escape hatch:
    // https://github.com/microsoft/TypeScript/issues/19335
    // eslint-disable-next-line @typescript-eslint/dot-notation
    const exportedMethodTuples = mod["initOptionalFeature"](feature);

    // If the optional feature provides helper functions, attach them to the base mod object. (This
    // provides a convenient API for end-users.)
    const modRecord = mod as unknown as Record<string, AnyFunction>;
    for (const [funcName, func] of exportedMethodTuples) {
      if (modRecord[funcName] !== undefined) {
        error(
          `Failed to upgrade the mod since two or more features share the name function name of "${funcName}". This should never happen, so report this error to the library authors.`,
        );
      }
      modRecord[funcName] = func;
    }
  }
}

----
customStageMetadata.json
[]

----
data\itempools.json
{
  "ItemPools": {
    "Pool": [
      {
        "$": { "Name": "treasure" },
        "Item": [
          {
            "$": {
              "Id": "1",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "2",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "3",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "4",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "5",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "6",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "7",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "8",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "10",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "12",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "13",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "14",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "15",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "17",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "19",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "36",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "37",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "38",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "39",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "40",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "41",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "42",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "44",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "45",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "46",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "47",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "48",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "49",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "52",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "53",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "55",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "56",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "57",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "58",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "62",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "65",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "66",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "68",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "69",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "71",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "72",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "75",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "76",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "77",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "78",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "85",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "86",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "87",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "88",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "89",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "91",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "92",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "93",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "94",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "95",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "96",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "97",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "98",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "99",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "100",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "101",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "103",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "104",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "105",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "106",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "107",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "108",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "109",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "110",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "111",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "113",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "115",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "117",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "120",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "121",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "123",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "124",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "125",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "126",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "127",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "128",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "129",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "131",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "136",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "138",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "140",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "142",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "143",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "144",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "146",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "148",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "149",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "150",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "151",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "152",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "153",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "154",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "155",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "157",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "160",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "161",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "162",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "163",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "166",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "167",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "168",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "169",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "170",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "171",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "172",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "173",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "174",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "175",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "176",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "178",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "180",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "186",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "188",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "189",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "190",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "191",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "192",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "200",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "201",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "202",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "206",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "209",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "210",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "211",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "213",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "214",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "217",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "220",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "221",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "222",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "223",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "224",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "227",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "228",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "229",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "231",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "233",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "234",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "236",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "237",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "240",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "242",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "244",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "245",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "256",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "257",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "261",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "264",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "265",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "266",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "267",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "269",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "270",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "271",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "272",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "273",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "274",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "275",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "276",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "277",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "278",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "279",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "280",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "281",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "282",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "283",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "284",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "285",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "287",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "288",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "291",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "292",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "294",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "295",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "298",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "299",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "300",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "301",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "302",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "303",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "304",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "305",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "306",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "307",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "308",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "309",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "310",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "312",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "313",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "314",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "315",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "316",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "317",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "318",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "319",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "320",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "321",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "322",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "323",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "324",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "325",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "329",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "330",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "332",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "333",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "334",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "335",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "336",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "350",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "351",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "352",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "353",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "358",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "359",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "361",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "362",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "364",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "365",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "366",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "367",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "368",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "369",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "371",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "373",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "374",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "375",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "377",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "378",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "379",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "381",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "382",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "384",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "385",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "386",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "388",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "389",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "390",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "391",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "392",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "393",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "394",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "395",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "397",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "398",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "401",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "404",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "405",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "406",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "407",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "410",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "411",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "418",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "419",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "421",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "422",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "426",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "427",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "430",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "431",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "432",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "435",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "436",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "437",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "440",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "443",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "444",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "445",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "446",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "447",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "448",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "449",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "452",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "453",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "454",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "457",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "458",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "459",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "460",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "461",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "463",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "465",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "466",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "467",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "469",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "470",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "471",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "473",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "476",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "478",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "481",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "482",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "485",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "488",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "491",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "492",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "493",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "494",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "495",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "496",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "497",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "502",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "504",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "506",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "507",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "508",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "509",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "511",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "512",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "513",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "516",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "517",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "522",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "524",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "525",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "529",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "531",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "532",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "537",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "539",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "540",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "542",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "543",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "544",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "545",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "548",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "549",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "553",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "555",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "557",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "558",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "559",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "560",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "561",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "563",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "570",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "575",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "576",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "578",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "581",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "583",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "605",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "607",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "608",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "609",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "610",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "611",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "612",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "614",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "615",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "616",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "617",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "618",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "625",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "629",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "631",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "635",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "637",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "639",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "641",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "645",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "649",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "650",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "652",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "655",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "657",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "658",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "661",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "663",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "671",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "675",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "676",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "677",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "678",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "680",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "681",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "682",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "683",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "687",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "690",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "693",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "695",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "709",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "710",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "713",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "717",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "720",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "722",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "724",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "725",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "726",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "727",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "728",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "729",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "shop" },
        "Item": [
          {
            "$": {
              "Id": "21",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "33",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "54",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "60",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "63",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "64",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "75",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "85",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "116",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "139",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "147",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "156",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "164",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "177",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "199",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "203",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "204",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "205",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "208",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "227",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "232",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "246",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "247",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "248",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "249",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "250",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "251",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "252",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "260",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "286",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "289",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "290",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "295",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "296",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "297",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "337",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "338",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "347",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "348",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "349",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "356",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "357",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "372",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "376",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "380",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "383",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "396",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "402",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "403",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "414",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "416",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "422",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "424",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "425",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "434",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "472",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "479",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "480",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "483",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "485",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "486",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "487",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "505",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "514",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "515",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "518",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "520",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "521",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "523",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "527",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "534",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "535",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "566",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "585",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "599",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "602",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "603",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "604",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "619",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "621",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "623",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "624",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "638",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "642",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "647",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "660",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "670",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "716",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "719",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          }
        ]
      },
      {
        "$": { "Name": "boss" },
        "Item": [
          {
            "$": {
              "Id": "14",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "22",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "23",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "24",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "25",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "26",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "27",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "28",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "29",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "30",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "31",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "32",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "70",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "92",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "141",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "143",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "165",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "176",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "183",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "193",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "194",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "196",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "197",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "198",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "218",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "219",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "240",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "253",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "254",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "255",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "339",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "340",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "341",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "342",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "343",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "344",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "345",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "346",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "354",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "355",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "370",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "428",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "438",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "455",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "456",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "538",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "541",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "547",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "564",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "600",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "624",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "644",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "659",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "707",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "708",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "730",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "731",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "devil" },
        "Item": [
          {
            "$": {
              "Id": "8",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "34",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "74",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "81",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "82",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "83",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "84",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "97",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "109",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "113",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "115",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "118",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "122",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "123",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "127",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "133",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "134",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "145",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "157",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "159",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "163",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "172",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "186",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "187",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "215",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "216",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "230",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "237",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "241",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "259",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "262",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "269",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "275",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "278",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "292",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "311",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "360",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "391",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "399",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "408",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "409",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "411",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "412",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "417",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "420",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "431",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "433",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "441",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "442",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "462",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "468",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "477",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "498",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "506",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "519",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "526",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "530",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "536",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "545",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "554",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "556",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "569",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "572",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "577",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "606",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "634",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "646",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "665",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "672",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "679",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "684",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "694",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "695",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "698",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "699",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "702",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "704",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "705",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "706",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "712",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "728",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "angel" },
        "Item": [
          {
            "$": {
              "Id": "7",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "33",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "72",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "78",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "98",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "101",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "108",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "112",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "124",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "138",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "142",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "146",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "156",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "162",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "173",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "178",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "182",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "184",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "185",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "197",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "243",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "313",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "326",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "331",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "332",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "333",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "334",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "335",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "363",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "374",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "387",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "390",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "400",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "407",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "413",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "415",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "423",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "464",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "477",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "490",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "498",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "499",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "510",
              "Weight": "0.4",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.04"
            }
          },
          {
            "$": {
              "Id": "519",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "526",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "528",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "533",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "543",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "567",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "568",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "573",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "574",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "579",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "584",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "586",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "601",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "622",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "634",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "640",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "643",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "651",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "653",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "685",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "686",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "691",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "696",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "secret" },
        "Item": [
          {
            "$": {
              "Id": "11",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "16",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "17",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "20",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "84",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "120",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "121",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "127",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "168",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "190",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "213",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "226",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "242",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "258",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "262",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "263",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "271",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "286",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "287",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "316",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "321",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "348",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "388",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "389",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "402",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "405",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "424",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "450",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "489",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "500",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "501",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "546",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "562",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "571",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "582",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "609",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "612",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "625",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "628",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "632",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "636",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "664",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "667",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "669",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "674",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "675",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "677",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "688",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "689",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "691",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "697",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "700",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "701",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "716",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "717",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "719",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "721",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "library" },
        "Item": [
          {
            "$": {
              "Id": "33",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "34",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "58",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "65",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "78",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "97",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "123",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "192",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "282",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "287",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "292",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "545",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "584",
              "Weight": "0.2",
              "DecreaseBy": "0.02",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "712",
              "Weight": "0.2",
              "DecreaseBy": "0.02",
              "RemoveOn": "0.02"
            }
          }
        ]
      },
      {
        "$": { "Name": "shellGame" },
        "Item": [
          {
            "$": {
              "Id": "9",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "36",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "209",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "378",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "504",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "576",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "goldenChest" },
        "Item": [
          {
            "$": {
              "Id": "28",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "29",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "32",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "74",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "179",
              "Weight": "0.5",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "194",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "196",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "255",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "341",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "343",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "344",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "354",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "355",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "370",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "428",
              "Weight": "0.5",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "438",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "444",
              "Weight": "0.1",
              "DecreaseBy": "0.04",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "455",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "456",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "534",
              "Weight": "0.5",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "571",
              "Weight": "0.1",
              "DecreaseBy": "0.04",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "644",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "708",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "730",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "732",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "redChest" },
        "Item": [
          {
            "$": {
              "Id": "81",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "133",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "134",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "140",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "145",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "297",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "316",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "371",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.1",
              "DecreaseBy": "0.04",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "0.5",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "0.1",
              "DecreaseBy": "0.04",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "642",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "0.2",
              "DecreaseBy": "0.08",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "665",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "beggar" },
        "Item": [
          {
            "$": {
              "Id": "21",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "22",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "23",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "24",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "25",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "26",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "46",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "54",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "111",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "144",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "177",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "180",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "198",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "204",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "246",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "271",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "294",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "362",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "376",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "385",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "447",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "455",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "456",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "485",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "707",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "demonBeggar" },
        "Item": [
          {
            "$": {
              "Id": "13",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "14",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "70",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "82",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "83",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "87",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "122",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "126",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "127",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "143",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "159",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "216",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "230",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "240",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "241",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "259",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "262",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "278",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "340",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "345",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "409",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "420",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "487",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "493",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "496",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "672",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "676",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "curse" },
        "Item": [
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "81",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "126",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "133",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "134",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "145",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "215",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "216",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "241",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "260",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "371",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "408",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "442",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "468",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "496",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "536",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "569",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "642",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "665",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "694",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "697",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "702",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "keyMaster" },
        "Item": [
          {
            "$": {
              "Id": "10",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "57",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "128",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "175",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "199",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "264",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "272",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "279",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "320",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "343",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "364",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "365",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "388",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "426",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "430",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "492",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "527",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "581",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "629",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "649",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "693",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "batteryBum" },
        "Item": [
          {
            "$": {
              "Id": "63",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "116",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "205",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "356",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "372",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "494",
              "Weight": "0.1",
              "DecreaseBy": "0.05",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "520",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "559",
              "Weight": "0.1",
              "DecreaseBy": "0.05",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "603",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "647",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "momsChest" },
        "Item": [
          {
            "$": {
              "Id": "29",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "30",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "31",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "39",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "41",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "55",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "110",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "0.1",
              "DecreaseBy": "0.05",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "139",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "199",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "200",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "217",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "228",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "355",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "508",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "732",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedTreasure" },
        "Item": [
          {
            "$": {
              "Id": "1",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "2",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "3",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "4",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "5",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "6",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "7",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "8",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "10",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "12",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "13",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "17",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "34",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "37",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "38",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "42",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "45",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "47",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "48",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "50",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "52",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "55",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "56",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "57",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "62",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "64",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "65",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "68",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "69",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "77",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "78",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "85",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "87",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "88",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "89",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "93",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "94",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "95",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "96",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "97",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "98",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "99",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "100",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "101",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "103",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "104",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "106",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "107",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "108",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "110",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "111",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "115",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "117",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "120",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "121",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "124",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "125",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "126",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "128",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "131",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "132",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "138",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "140",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "142",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "146",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "148",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "149",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "150",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "151",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "152",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "153",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "154",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "155",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "157",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "161",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "162",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "163",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "167",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "168",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "169",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "170",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "172",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "174",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "175",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "186",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "188",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "189",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "190",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "191",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "192",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "200",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "201",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "206",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "209",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "210",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "213",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "214",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "217",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "220",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "221",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "222",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "223",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "224",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "226",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "228",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "229",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "231",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "233",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "234",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "236",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "237",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "242",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "244",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "245",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "254",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "256",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "257",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "258",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "261",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "264",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "265",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "266",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "267",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "269",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "271",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "273",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "274",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "277",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "279",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "280",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "281",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "288",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "291",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "299",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "300",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "301",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "302",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "303",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "305",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "306",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "307",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "308",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "309",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "310",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "312",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "315",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "316",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "317",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "318",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "319",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "320",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "321",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "322",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "325",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "329",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "330",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "332",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "333",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "334",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "335",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "336",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "349",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "351",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "352",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "353",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "357",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "358",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "359",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "362",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "364",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "365",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "366",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "367",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "368",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "369",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "371",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "373",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "374",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "375",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "377",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "378",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "379",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "380",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "382",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "383",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "384",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "389",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "391",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "392",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "393",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "394",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "395",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "397",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "398",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "401",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "407",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "410",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "411",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "416",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "421",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "422",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "425",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "426",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "430",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "431",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "432",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "434",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "436",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "440",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "443",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "444",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "445",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "446",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "447",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "448",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "449",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "450",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "452",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "453",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "454",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "457",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "458",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "459",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "460",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "461",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "463",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "465",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "466",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "467",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "469",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "470",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "471",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "473",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "493",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "494",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "495",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "496",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "497",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "502",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "504",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "506",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "507",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "508",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "509",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "511",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "512",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "513",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "514",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "515",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "516",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "517",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "518",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "520",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "522",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "524",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "525",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "529",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "531",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "532",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "537",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "539",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "540",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "542",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "543",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "544",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "545",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "548",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "549",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "553",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "555",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "557",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "558",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "559",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "560",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "561",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "563",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "570",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "575",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "576",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "578",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "581",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "583",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "605",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "607",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "608",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "609",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "610",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "611",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "612",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "614",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "615",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "616",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "617",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "618",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "625",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "629",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "631",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "635",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "637",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "639",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "641",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "645",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "649",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "650",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "652",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "655",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "657",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "658",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "661",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "663",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "671",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "675",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "676",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "677",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "678",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "680",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "681",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "682",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "683",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "687",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "690",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "693",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "695",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "709",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "710",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "713",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "716",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "717",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "719",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "720",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "721",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "722",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "724",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "725",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "726",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "727",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "728",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "729",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedBoss" },
        "Item": [
          {
            "$": {
              "Id": "12",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "14",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "15",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "16",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "22",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "23",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "24",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "25",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "26",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "27",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "28",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "29",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "30",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "31",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "32",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "70",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "71",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "73",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "101",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "120",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "121",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "132",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "143",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "176",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "183",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "193",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "194",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "196",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "197",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "198",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "207",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "240",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "253",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "254",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "255",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "314",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "339",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "340",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "341",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "342",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "343",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "344",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "345",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "346",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "354",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "355",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "370",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "428",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "438",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "455",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "456",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "538",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "541",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "547",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "564",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "600",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "624",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "644",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "659",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "707",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "708",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "730",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "731",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedShop" },
        "Item": [
          {
            "$": {
              "Id": "11",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "46",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "63",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "73",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "75",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "76",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "84",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "91",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "105",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "116",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "139",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "156",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "166",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "199",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "204",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "208",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "246",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "247",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "248",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "251",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "252",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "260",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "283",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "284",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "285",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "286",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "289",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "297",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "348",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "356",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "372",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "380",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "386",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "402",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "403",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "405",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "406",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "416",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "434",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "472",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "476",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "477",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "478",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "481",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "482",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "483",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "485",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "486",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "487",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "488",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "489",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "500",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "512",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "515",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "516",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "518",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "527",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "534",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "535",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "566",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "585",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "603",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "604",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "619",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "621",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "623",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "624",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "636",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "638",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "647",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "667",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "674",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "688",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "689",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "691",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "700",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "701",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "721",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "722",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "0.1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.01"
            }
          },
          {
            "$": {
              "Id": "732",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedCurse" },
        "Item": [
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "73",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "81",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "126",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "133",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "145",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "216",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "260",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "371",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "408",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "442",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "468",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "496",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "536",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "569",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "642",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "665",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "694",
              "Weight": "0.5",
              "DecreaseBy": "0.25",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "702",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedDevil" },
        "Item": [
          {
            "$": {
              "Id": "34",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "68",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "74",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "81",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "82",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "83",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "97",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "109",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "113",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "115",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "118",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "122",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "123",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "132",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "133",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "145",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "157",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "159",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "172",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "187",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "216",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "225",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "230",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "237",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "259",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "269",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "270",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "292",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "311",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "360",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "391",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "399",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "408",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "409",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "411",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "412",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "420",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "431",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "433",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "441",
              "Weight": "0.2",
              "DecreaseBy": "0.2",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "442",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "462",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "468",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "503",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "506",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "519",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "526",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "536",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "545",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "554",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "556",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "569",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "572",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "577",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "606",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "634",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "646",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "665",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "679",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "684",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "694",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "695",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "698",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "699",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "702",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "704",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "705",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "706",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "712",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "728",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedAngel" },
        "Item": [
          {
            "$": {
              "Id": "7",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "72",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "78",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "112",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "138",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "162",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "178",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "182",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "184",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "185",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "197",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "243",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "313",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "326",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "331",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "333",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "334",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "335",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "363",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "387",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "390",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "400",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "407",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "413",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "415",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "423",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "490",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "499",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "526",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "528",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "533",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "543",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "567",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "568",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "573",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "574",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "579",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "584",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "586",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "601",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "622",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "634",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "640",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "643",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "651",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "653",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "685",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "686",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "691",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "696",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "greedSecret" },
        "Item": [
          {
            "$": {
              "Id": "11",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "16",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "17",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "20",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "35",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "84",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "120",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "121",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "127",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "168",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "190",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "213",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "226",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "242",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "258",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "262",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "263",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "271",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "286",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "316",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "321",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "348",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "389",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "402",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "405",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "424",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "450",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "489",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "500",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "501",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "546",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "562",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "571",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "582",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "609",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "612",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "625",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "628",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "632",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "636",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "664",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "667",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "669",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "674",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "677",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "688",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "689",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "691",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "700",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "701",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "716",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "717",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "719",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "721",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "craneGame" },
        "Item": [
          {
            "$": {
              "Id": "1",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "3",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "4",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "5",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "21",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "32",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "38",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "44",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "46",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "47",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "48",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "49",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "63",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "66",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "68",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "77",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "85",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "89",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "90",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "91",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "93",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "95",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "105",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "116",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "136",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "147",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "152",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "153",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "166",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "189",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "194",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "196",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "208",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "212",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "227",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "232",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "244",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "251",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "255",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "263",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "267",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "283",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "284",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "285",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "337",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "338",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "352",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "357",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "362",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "370",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "382",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "383",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "386",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "395",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "397",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "403",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "406",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "419",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "422",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "425",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "427",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "437",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "438",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "444",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "451",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "465",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "476",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "478",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "488",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "494",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "505",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "515",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "516",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "518",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "524",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "527",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "538",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "599",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "604",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "609",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "617",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "624",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "629",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "638",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "644",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "649",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "655",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "687",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "709",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "720",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "723",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "730",
              "Weight": "1",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "ultraSecret" },
        "Item": [
          {
            "$": {
              "Id": "12",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "13",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "15",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "30",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "31",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "40",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "45",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "49",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "51",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "53",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "72",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "73",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "79",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "80",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "82",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "96",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "105",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "109",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "110",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "118",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "119",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "122",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "135",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "157",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "159",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "166",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "167",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "176",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "177",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "182",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "193",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "208",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "214",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "230",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "247",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "253",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "254",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "261",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "276",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "289",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "334",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "373",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "394",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "399",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "411",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "412",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "421",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "435",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "443",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "452",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "462",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "466",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "475",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "481",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "506",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "511",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "531",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "541",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "554",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "556",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "565",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "572",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "573",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "580",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "606",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "607",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "614",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "616",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "618",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "621",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "637",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "650",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "654",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "657",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "671",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "678",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "682",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "684",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "692",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "694",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "695",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "700",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "702",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "703",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "704",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "705",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "706",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "711",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "724",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "726",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "728",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "bombBum" },
        "Item": [
          {
            "$": {
              "Id": "37",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "106",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "125",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "137",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "140",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "190",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "209",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "220",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "256",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "353",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "366",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "367",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "432",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "483",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "517",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "563",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "583",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "614",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "646",
              "Weight": "0.2",
              "DecreaseBy": "0.1",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "727",
              "Weight": "1",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "planetarium" },
        "Item": [
          {
            "$": {
              "Id": "588",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "589",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "590",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "591",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "592",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "593",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "594",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "595",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "596",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "597",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "598",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "oldChest" },
        "Item": [
          {
            "$": {
              "Id": "29",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "30",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "31",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "39",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "41",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "55",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "102",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "110",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "114",
              "Weight": "0.2",
              "DecreaseBy": "0.08",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "139",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "175",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "195",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "199",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "200",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "217",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "228",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "341",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "355",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "455",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "508",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "546",
              "Weight": "0.2",
              "DecreaseBy": "0.08",
              "RemoveOn": "0.02"
            }
          },
          {
            "$": {
              "Id": "547",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "604",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "732",
              "Weight": "1",
              "DecreaseBy": "0.4",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "babyShop" },
        "Item": [
          {
            "$": {
              "Id": "8",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "10",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "57",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "67",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "73",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "88",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "95",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "96",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "99",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "100",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "112",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "113",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "117",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "128",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "144",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "155",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "163",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "167",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "170",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "172",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "174",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "188",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "207",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "264",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "265",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "266",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "267",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "269",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "270",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "272",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "273",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "274",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "275",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "277",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "278",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "279",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "280",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "281",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "320",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "322",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "360",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "361",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "363",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "364",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "365",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "372",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "384",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "385",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "388",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "390",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "403",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "404",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "417",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "426",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "430",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "435",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "468",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "470",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "471",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "472",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "473",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "491",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "492",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "509",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "511",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "518",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "519",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "537",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "575",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "581",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "607",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "608",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "610",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "612",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "615",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "629",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "635",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "645",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "649",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "661",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "679",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "682",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "698",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "woodenChest" },
        "Item": [
          {
            "$": {
              "Id": "7",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "27",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "60",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "138",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "183",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "349",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "362",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "439",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "488",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "527",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "719",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      },
      {
        "$": { "Name": "rottenBeggar" },
        "Item": [
          {
            "$": {
              "Id": "26",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "42",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "140",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "268",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "273",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "336",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "480",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          },
          {
            "$": {
              "Id": "618",
              "Weight": "0.5",
              "DecreaseBy": "0.5",
              "RemoveOn": "0.05"
            }
          },
          {
            "$": {
              "Id": "639",
              "Weight": "1",
              "DecreaseBy": "1",
              "RemoveOn": "0.1"
            }
          }
        ]
      }
    ]
  }
}

----
data\itempools.xml
<ItemPools>
  <Pool Name="treasure">
    <!--The Sad Onion-->
    <Item Id="1" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Inner Eye-->
    <Item Id="2" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spoon Bender-->
    <Item Id="3" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cricket's Head-->
    <Item Id="4" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Reflection-->
    <Item Id="5" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Number One-->
    <Item Id="6" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood of the Martyr-->
    <Item Id="7" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brother Bobby-->
    <Item Id="8" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Halo of Flies-->
    <Item Id="10" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Mushroom-->
    <Item Id="12" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--The Virus-->
    <Item Id="13" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Roid Rage-->
    <Item Id="14" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--<3-->
    <Item Id="15" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Skeleton Key-->
    <Item Id="17" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Boom!-->
    <Item Id="19" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Poop-->
    <Item Id="36" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Boom-->
    <Item Id="37" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tammy's Head-->
    <Item Id="38" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Bra-->
    <Item Id="39" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Kamikaze!-->
    <Item Id="40" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Pad-->
    <Item Id="41" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Rotten Head-->
    <Item Id="42" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Teleport!-->
    <Item Id="44" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Yum Heart-->
    <Item Id="45" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lucky Foot-->
    <Item Id="46" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Doctor's Remote-->
    <Item Id="47" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cupid's Arrow-->
    <Item Id="48" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shoop da Whoop!-->
    <Item Id="49" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dr. Fetus-->
    <Item Id="52" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magneto-->
    <Item Id="53" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Eye-->
    <Item Id="55" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lemon Mishap-->
    <Item Id="56" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Distant Admiration-->
    <Item Id="57" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Shadows-->
    <Item Id="58" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Charm of the Vampire-->
    <Item Id="62" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anarchist Cookbook-->
    <Item Id="65" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Hourglass-->
    <Item Id="66" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology-->
    <Item Id="68" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chocolate Milk-->
    <Item Id="69" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mini Mush-->
    <Item Id="71" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rosary-->
    <Item Id="72" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--PHD-->
    <Item Id="75" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--X-Ray Vision-->
    <Item Id="76" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Little Unicorn-->
    <Item Id="77" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Revelations-->
    <Item Id="78" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deck of Cards-->
    <Item Id="85" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monstro's Tooth-->
    <Item Id="86" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Loki's Horns-->
    <Item Id="87" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Chubby-->
    <Item Id="88" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spider Bite-->
    <Item Id="89" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spelunker Hat-->
    <Item Id="91" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Super Bandage-->
    <Item Id="92" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Gamekid-->
    <Item Id="93" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack of Pennies-->
    <Item Id="94" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby-->
    <Item Id="95" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little C.H.A.D.-->
    <Item Id="96" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Book of Sin-->
    <Item Id="97" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Relic-->
    <Item Id="98" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Little Gish-->
    <Item Id="99" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Steven-->
    <Item Id="100" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Halo-->
    <Item Id="101" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Common Cold-->
    <Item Id="103" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Parasite-->
    <Item Id="104" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The D6-->
    <Item Id="105" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Mega-->
    <Item Id="106" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Pinking Shears-->
    <Item Id="107" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Wafer-->
    <Item Id="108" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Money = Power-->
    <Item Id="109" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Contacts-->
    <Item Id="110" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Bean-->
    <Item Id="111" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Demon Baby-->
    <Item Id="113" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Ouija Board-->
    <Item Id="115" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Bird-->
    <Item Id="117" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="120" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="121" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monster Manual-->
    <Item Id="123" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Sea Scrolls-->
    <Item Id="124" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bobby-Bomb-->
    <Item Id="125" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Razor Blade-->
    <Item Id="126" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forget Me Now-->
    <Item Id="127" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forever alone-->
    <Item Id="128" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bucket of Lard-->
    <Item Id="129" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bomb Bag-->
    <Item Id="131" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Best Friend-->
    <Item Id="136" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stigmata-->
    <Item Id="138" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Curse-->
    <Item Id="140" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scapular-->
    <Item Id="142" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Speed Ball-->
    <Item Id="143" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bum Friend-->
    <Item Id="144" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Prayer Card-->
    <Item Id="146" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infestation-->
    <Item Id="148" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ipecac-->
    <Item Id="149" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tough Love-->
    <Item Id="150" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mulligan-->
    <Item Id="151" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology 2-->
    <Item Id="152" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mutant Spider-->
    <Item Id="153" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chemical Peel-->
    <Item Id="154" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Peeper-->
    <Item Id="155" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Lust-->
    <Item Id="157" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crack the Sky-->
    <Item Id="160" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ankh-->
    <Item Id="161" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Celtic Cross-->
    <Item Id="162" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Baby-->
    <Item Id="163" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D20-->
    <Item Id="166" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Harlequin Baby-->
    <Item Id="167" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epic Fetus-->
    <Item Id="168" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Polyphemus-->
    <Item Id="169" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Daddy Longlegs-->
    <Item Id="170" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spider Butt-->
    <Item Id="171" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Dagger-->
    <Item Id="172" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mitre-->
    <Item Id="173" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rainbow Baby-->
    <Item Id="174" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Key-->
    <Item Id="175" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stem Cells-->
    <Item Id="176" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Water-->
    <Item Id="178" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Black Bean-->
    <Item Id="180" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Rights-->
    <Item Id="186" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Abel-->
    <Item Id="188" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--SMB Super Fan-->
    <Item Id="189" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyro-->
    <Item Id="190" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--3 Dollar Bill-->
    <Item Id="191" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Telepathy For Dummies-->
    <Item Id="192" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Eyeshadow-->
    <Item Id="200" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Iron Bar-->
    <Item Id="201" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Midas' Touch-->
    <Item Id="202" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guillotine-->
    <Item Id="206" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Butt Bombs-->
    <Item Id="209" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gnawed Leaf-->
    <Item Id="210" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spiderbaby-->
    <Item Id="211" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Contact-->
    <Item Id="213" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anemic-->
    <Item Id="214" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Wig-->
    <Item Id="217" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sad Bombs-->
    <Item Id="220" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rubber Cement-->
    <Item Id="221" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anti-Gravity-->
    <Item Id="222" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyromaniac-->
    <Item Id="223" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cricket's Body-->
    <Item Id="224" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Piggy Bank-->
    <Item Id="227" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Perfume-->
    <Item Id="228" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monstro's Lung-->
    <Item Id="229" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ball of Tar-->
    <Item Id="231" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tiny Planet-->
    <Item Id="233" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infestation 2-->
    <Item Id="234" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--E. Coli-->
    <Item Id="236" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death's Touch-->
    <Item Id="237" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Experimental Treatment-->
    <Item Id="240" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infamy-->
    <Item Id="242" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tech.5-->
    <Item Id="244" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--20/20-->
    <Item Id="245" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hot Bombs-->
    <Item Id="256" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fire Mind-->
    <Item Id="257" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Proptosis-->
    <Item Id="261" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Smart Fly-->
    <Item Id="264" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dry Baby-->
    <Item Id="265" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Juicy Sack-->
    <Item Id="266" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby 2.0-->
    <Item Id="267" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Headless Baby-->
    <Item Id="269" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leech-->
    <Item Id="270" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Sack-->
    <Item Id="271" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--BBF-->
    <Item Id="272" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Brain-->
    <Item Id="273" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Best Bud-->
    <Item Id="274" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Brimstone-->
    <Item Id="275" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Isaac's Heart-->
    <Item Id="276" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Haunt-->
    <Item Id="277" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dark Bum-->
    <Item Id="278" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Fan-->
    <Item Id="279" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sissy Longlegs-->
    <Item Id="280" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Punching Bag-->
    <Item Id="281" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--How to Jump-->
    <Item Id="282" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D100-->
    <Item Id="283" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D4-->
    <Item Id="284" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D10-->
    <Item Id="285" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Secrets-->
    <Item Id="287" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box of Spiders-->
    <Item Id="288" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flush!-->
    <Item Id="291" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Satanic Bible-->
    <Item Id="292" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Butter Bean-->
    <Item Id="294" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Fingers-->
    <Item Id="295" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Unicorn Stump-->
    <Item Id="298" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Taurus-->
    <Item Id="299" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Aries-->
    <Item Id="300" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cancer-->
    <Item Id="301" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leo-->
    <Item Id="302" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Virgo-->
    <Item Id="303" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Libra-->
    <Item Id="304" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scorpio-->
    <Item Id="305" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sagittarius-->
    <Item Id="306" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Capricorn-->
    <Item Id="307" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Aquarius-->
    <Item Id="308" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pisces-->
    <Item Id="309" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eve's Mascara-->
    <Item Id="310" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Maggy's Bow-->
    <Item Id="312" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Mantle-->
    <Item Id="313" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Thunder Thighs-->
    <Item Id="314" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Strange Attractor-->
    <Item Id="315" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cursed Eye-->
    <Item Id="316" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mysterious Liquid-->
    <Item Id="317" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gemini-->
    <Item Id="318" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cain's Other Eye-->
    <Item Id="319" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--???'s Only Friend-->
    <Item Id="320" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Samson's Chains-->
    <Item Id="321" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mongo Baby-->
    <Item Id="322" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Isaac's Tears-->
    <Item Id="323" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Undefined-->
    <Item Id="324" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scissors-->
    <Item Id="325" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Ludovico Technique-->
    <Item Id="329" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Soy Milk-->
    <Item Id="330" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lazarus' Rags-->
    <Item Id="332" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mind-->
    <Item Id="333" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--The Body-->
    <Item Id="334" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--The Soul-->
    <Item Id="335" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Dead Onion-->
    <Item Id="336" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Toxic Shock-->
    <Item Id="350" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Bean-->
    <Item Id="351" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glass Cannon-->
    <Item Id="352" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bomber Boy-->
    <Item Id="353" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Wiz-->
    <Item Id="358" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--8 Inch Nails-->
    <Item Id="359" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fate's Reward-->
    <Item Id="361" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Chest-->
    <Item Id="362" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friend Zone-->
    <Item Id="364" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Fly-->
    <Item Id="365" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scatter Bombs-->
    <Item Id="366" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sticky Bombs-->
    <Item Id="367" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epiphora-->
    <Item Id="368" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Continuum-->
    <Item Id="369" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Curse of the Tower-->
    <Item Id="371" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Eye-->
    <Item Id="373" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Light-->
    <Item Id="374" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Host Hat-->
    <Item Id="375" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bursting Sack-->
    <Item Id="377" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--No. 2-->
    <Item Id="378" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pupula Duplex-->
    <Item Id="379" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eden's Blessing-->
    <Item Id="381" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friendly Ball-->
    <Item Id="382" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Gurdy-->
    <Item Id="384" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bumbo-->
    <Item Id="385" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D12-->
    <Item Id="386" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Key Bum-->
    <Item Id="388" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rune Bag-->
    <Item Id="389" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Seraphim-->
    <Item Id="390" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Betrayal-->
    <Item Id="391" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Zodiac-->
    <Item Id="392" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Serpent's Kiss-->
    <Item Id="393" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marked-->
    <Item Id="394" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tech X-->
    <Item Id="395" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tractor Beam-->
    <Item Id="397" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--God's Flesh-->
    <Item Id="398" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Explosivo-->
    <Item Id="401" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Farting Baby-->
    <Item Id="404" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--GB Bug-->
    <Item Id="405" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D8-->
    <Item Id="406" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purity-->
    <Item Id="407" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Evil Eye-->
    <Item Id="410" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lusty Blood-->
    <Item Id="411" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fruit Cake-->
    <Item Id="418" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Teleport 2.0-->
    <Item Id="419" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Kidney Bean-->
    <Item Id="421" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glowing Hourglass-->
    <Item Id="422" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Obsessed Fan-->
    <Item Id="426" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mine Crafter-->
    <Item Id="427" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Papa Fly-->
    <Item Id="430" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Multidimensional Baby-->
    <Item Id="431" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glitter Bombs-->
    <Item Id="432" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Loki-->
    <Item Id="435" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Milk!-->
    <Item Id="436" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D7-->
    <Item Id="437" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Kidney Stone-->
    <Item Id="440" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Apple!-->
    <Item Id="443" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lead Pencil-->
    <Item Id="444" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dog Tooth-->
    <Item Id="445" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Tooth-->
    <Item Id="446" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Linger Bean-->
    <Item Id="447" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shard of Glass-->
    <Item Id="448" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Metal Plate-->
    <Item Id="449" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Varicose Veins-->
    <Item Id="452" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Compound Fracture-->
    <Item Id="453" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Polydactyly-->
    <Item Id="454" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cone Head-->
    <Item Id="457" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Belly Button-->
    <Item Id="458" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sinus Infection-->
    <Item Id="459" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glaucoma-->
    <Item Id="460" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Parasitoid-->
    <Item Id="461" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sulfuric Acid-->
    <Item Id="463" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Analog Stick-->
    <Item Id="465" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Contagion-->
    <Item Id="466" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Finger!-->
    <Item Id="467" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Depression-->
    <Item Id="469" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hushy-->
    <Item Id="470" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Monstro-->
    <Item Id="471" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Chubby-->
    <Item Id="473" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D1-->
    <Item Id="476" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pause-->
    <Item Id="478" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dataminer-->
    <Item Id="481" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Clicker-->
    <Item Id="482" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crooked Penny-->
    <Item Id="485" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Metronome-->
    <Item Id="488" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Acid Baby-->
    <Item Id="491" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--YO LISTEN!-->
    <Item Id="492" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Adrenaline-->
    <Item Id="493" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jacob's Ladder-->
    <Item Id="494" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Pepper-->
    <Item Id="495" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Euthanasia-->
    <Item Id="496" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Camo Undies-->
    <Item Id="497" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Large Zit-->
    <Item Id="502" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brown Nugget-->
    <Item Id="504" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Backstabber-->
    <Item Id="506" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sharp Straw-->
    <Item Id="507" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Razor-->
    <Item Id="508" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloodshot Eye-->
    <Item Id="509" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Angry Fly-->
    <Item Id="511" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Hole-->
    <Item Id="512" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bozo-->
    <Item Id="513" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sprinkler-->
    <Item Id="516" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fast Bombs-->
    <Item Id="517" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Telekinesis-->
    <Item Id="522" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology Zero-->
    <Item Id="524" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leprosy-->
    <Item Id="525" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pop!-->
    <Item Id="529" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Haemolacria-->
    <Item Id="531" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lachryphagy-->
    <Item Id="532" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Spewer-->
    <Item Id="537" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Egg-->
    <Item Id="539" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flat Stone-->
    <Item Id="540" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Slipped Rib-->
    <Item Id="542" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hallowed Ground-->
    <Item Id="543" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pointy Rib-->
    <Item Id="544" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of the Dead-->
    <Item Id="545" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jaw Bone-->
    <Item Id="548" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brittle Bones-->
    <Item Id="549" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mucormycosis-->
    <Item Id="553" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Golden Razor-->
    <Item Id="555" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fortune Cookie-->
    <Item Id="557" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye Sore-->
    <Item Id="558" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--120 Volt-->
    <Item Id="559" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--It Hurts-->
    <Item Id="560" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Almond Milk-->
    <Item Id="561" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Nancy Bombs-->
    <Item Id="563" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Playdough Cookie-->
    <Item Id="570" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Intruder-->
    <Item Id="575" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dirty Mind-->
    <Item Id="576" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Free Lemonade-->
    <Item Id="578" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Psy Fly-->
    <Item Id="581" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rocket in a Jar-->
    <Item Id="583" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Scooper-->
    <Item Id="605" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Boiled Baby-->
    <Item Id="607" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Freezer Baby-->
    <Item Id="608" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eternal D6-->
    <Item Id="609" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Bird Cage-->
    <Item Id="610" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Larynx-->
    <Item Id="611" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Soul-->
    <Item Id="612" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Bombs-->
    <Item Id="614" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Dumpy-->
    <Item Id="615" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bird's Eye-->
    <Item Id="616" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lodestone-->
    <Item Id="617" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Tomato-->
    <Item Id="618" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Mush-->
    <Item Id="625" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Bot Fly-->
    <Item Id="629" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Meat Cleaver-->
    <Item Id="631" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stitches-->
    <Item Id="635" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Knockout Drops-->
    <Item Id="637" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Yuck Heart-->
    <Item Id="639" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Akeldama-->
    <Item Id="641" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tinytoma-->
    <Item Id="645" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fruity Plum-->
    <Item Id="649" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Plum Flute-->
    <Item Id="650" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Cube Baby-->
    <Item Id="652" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spin to Win-->
    <Item Id="655" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vasculitis-->
    <Item Id="657" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Giant Cell-->
    <Item Id="658" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Quints-->
    <Item Id="661" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tooth and Nail-->
    <Item Id="663" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Candy Heart-->
    <Item Id="671" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cracked Orb-->
    <Item Id="675" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Empty Heart-->
    <Item Id="676" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Astral Projection-->
    <Item Id="677" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--C Section-->
    <Item Id="678" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Montezuma's Revenge-->
    <Item Id="680" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Portal-->
    <Item Id="681" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Worm Friend-->
    <Item Id="682" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bone Spurs-->
    <Item Id="683" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friend Finder-->
    <Item Id="687" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Belly Jelly-->
    <Item Id="690" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Swarm-->
    <Item Id="693" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Gust-->
    <Item Id="695" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Suplex!-->
    <Item Id="709" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bag of Crafting-->
    <Item Id="710" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sumptorium-->
    <Item Id="713" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Kin-->
    <Item Id="717" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Everything Jar-->
    <Item Id="720" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anima Sola-->
    <Item Id="722" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Hypercoagulation-->
    <Item Id="724" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--IBS-->
    <Item Id="725" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hemoptysis-->
    <Item Id="726" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Bombs-->
    <Item Id="727" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gello-->
    <Item Id="728" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Decap Attack-->
    <Item Id="729" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="shop">
    <!--The Compass-->
    <Item Id="21" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Bible-->
    <Item Id="33" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Treasure Map-->
    <Item Id="54" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Ladder-->
    <Item Id="60" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Battery-->
    <Item Id="63" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Steam Sale-->
    <Item Id="64" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--PHD-->
    <Item Id="75" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deck of Cards-->
    <Item Id="85" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--9 Volt-->
    <Item Id="116" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Purse-->
    <Item Id="139" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Notched Axe-->
    <Item Id="147" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Habit-->
    <Item Id="156" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Candle-->
    <Item Id="164" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Portable Slot-->
    <Item Id="177" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Key-->
    <Item Id="199" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Humbleing Bundle-->
    <Item Id="203" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fanny Pack-->
    <Item Id="204" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sharp Plug-->
    <Item Id="205" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Champion Belt-->
    <Item Id="208" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Piggy Bank-->
    <Item Id="227" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stop Watch-->
    <Item Id="232" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blue Map-->
    <Item Id="246" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--BFFS!-->
    <Item Id="247" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hive Mind-->
    <Item Id="248" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--There's Options-->
    <Item Id="249" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--BOGO Bombs-->
    <Item Id="250" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Starter Deck-->
    <Item Id="251" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Baggy-->
    <Item Id="252" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Candle-->
    <Item Id="260" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blank Card-->
    <Item Id="286" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Red Candle-->
    <Item Id="289" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Jar-->
    <Item Id="290" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Fingers-->
    <Item Id="295" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Converter-->
    <Item Id="296" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pandora's Box-->
    <Item Id="297" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Broken Watch-->
    <Item Id="337" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Boomerang-->
    <Item Id="338" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Diplopia-->
    <Item Id="347" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Placebo-->
    <Item Id="348" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Nickel-->
    <Item Id="349" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Car Battery-->
    <Item Id="356" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box of Friends-->
    <Item Id="357" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Charged Baby-->
    <Item Id="372" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Restock-->
    <Item Id="376" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pay To Play-->
    <Item Id="380" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tear Detonator-->
    <Item Id="383" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ventricle Razor-->
    <Item Id="396" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chaos-->
    <Item Id="402" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Spider Mod-->
    <Item Id="403" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--More Options-->
    <Item Id="414" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deep Pockets-->
    <Item Id="416" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glowing Hourglass-->
    <Item Id="422" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack Head-->
    <Item Id="424" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Night Light-->
    <Item Id="425" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jar of Flies-->
    <Item Id="434" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--King Baby-->
    <Item Id="472" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Smelter-->
    <Item Id="479" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Compost-->
    <Item Id="480" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mama Mega!-->
    <Item Id="483" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Crooked Penny-->
    <Item Id="485" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Dull Razor-->
    <Item Id="486" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Potato Peeler-->
    <Item Id="487" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Poke Go-->
    <Item Id="505" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Broken Modem-->
    <Item Id="514" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Gift-->
    <Item Id="515" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Buddy in a Box-->
    <Item Id="518" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jumper Cables-->
    <Item Id="520" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Coupon-->
    <Item Id="521" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Moving Box-->
    <Item Id="523" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. ME!-->
    <Item Id="527" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Schoolbag-->
    <Item Id="534" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blanket-->
    <Item Id="535" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dream Catcher-->
    <Item Id="566" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Alabaster Box-->
    <Item Id="585" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Voodoo Head-->
    <Item Id="599" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Member Card-->
    <Item Id="602" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Battery Pack-->
    <Item Id="603" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Bracelet-->
    <Item Id="604" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Birthright-->
    <Item Id="619" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Red Stew-->
    <Item Id="621" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sharp Key-->
    <Item Id="623" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Booster Pack-->
    <Item Id="624" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eraser-->
    <Item Id="638" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Skin-->
    <Item Id="642" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--4.5 Volt-->
    <Item Id="647" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Card Reading-->
    <Item Id="660" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Options?-->
    <Item Id="670" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Sack-->
    <Item Id="716" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Box-->
    <Item Id="719" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
  </Pool>
  <Pool Name="boss">
    <!--Roid Rage-->
    <Item Id="14" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lunch-->
    <Item Id="22" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dinner-->
    <Item Id="23" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dessert-->
    <Item Id="24" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Breakfast-->
    <Item Id="25" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Meat-->
    <Item Id="26" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Spoon-->
    <Item Id="27" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Belt-->
    <Item Id="28" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Underwear-->
    <Item Id="29" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Heels-->
    <Item Id="30" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Lipstick-->
    <Item Id="31" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wire Coat Hanger-->
    <Item Id="32" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Growth Hormones-->
    <Item Id="70" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Super Bandage-->
    <Item Id="92" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Pageant Boy-->
    <Item Id="141" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Speed Ball-->
    <Item Id="143" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cat-o-nine-tails-->
    <Item Id="165" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stem Cells-->
    <Item Id="176" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tooth Picks-->
    <Item Id="183" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--MEAT!-->
    <Item Id="193" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic 8 Ball-->
    <Item Id="194" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Squeezy-->
    <Item Id="196" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jesus Juice-->
    <Item Id="197" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box-->
    <Item Id="198" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Placenta-->
    <Item Id="218" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Old Bandage-->
    <Item Id="219" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Experimental Treatment-->
    <Item Id="240" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Scab-->
    <Item Id="253" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Clot-->
    <Item Id="254" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Screw-->
    <Item Id="255" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Safety Pin-->
    <Item Id="339" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Caffeine Pill-->
    <Item Id="340" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Torn Photo-->
    <Item Id="341" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blue Cap-->
    <Item Id="342" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Latch Key-->
    <Item Id="343" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Match Book-->
    <Item Id="344" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Synthoil-->
    <Item Id="345" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Snack-->
    <Item Id="346" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crack Jacks-->
    <Item Id="354" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Pearls-->
    <Item Id="355" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Dolly-->
    <Item Id="370" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--PJs-->
    <Item Id="428" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Binky-->
    <Item Id="438" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Lost Coin-->
    <Item Id="455" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Midnight Snack-->
    <Item Id="456" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marbles-->
    <Item Id="538" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marrow-->
    <Item Id="541" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Divorce Papers-->
    <Item Id="547" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Bar of Soap-->
    <Item Id="564" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye Drops-->
    <Item Id="600" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Booster Pack-->
    <Item Id="624" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Consolation Prize-->
    <Item Id="644" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tropicamide-->
    <Item Id="659" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Supper-->
    <Item Id="707" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stapler-->
    <Item Id="708" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glass Eye-->
    <Item Id="730" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stye-->
    <Item Id="731" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="devil">
    <!--Brother Bobby-->
    <Item Id="8" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Book of Belial-->
    <Item Id="34" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Quarter-->
    <Item Id="74" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Cat-->
    <Item Id="81" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lord of the Pit-->
    <Item Id="82" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Nail-->
    <Item Id="83" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--We Need To Go Deeper!-->
    <Item Id="84" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Book of Sin-->
    <Item Id="97" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Money = Power-->
    <Item Id="109" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Demon Baby-->
    <Item Id="113" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ouija Board-->
    <Item Id="115" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brimstone-->
    <Item Id="118" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Whore of Babylon-->
    <Item Id="122" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monster Manual-->
    <Item Id="123" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forget Me Now-->
    <Item Id="127" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Guppy's Paw-->
    <Item Id="133" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Tail-->
    <Item Id="134" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Head-->
    <Item Id="145" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Lust-->
    <Item Id="157" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit of the Night-->
    <Item Id="159" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Baby-->
    <Item Id="163" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Dagger-->
    <Item Id="172" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Rights-->
    <Item Id="186" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Hairball-->
    <Item Id="187" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Goat Head-->
    <Item Id="215" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ceremonial Robes-->
    <Item Id="216" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Abaddon-->
    <Item Id="230" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death's Touch-->
    <Item Id="237" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Contract from Below-->
    <Item Id="241" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dark Matter-->
    <Item Id="259" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing Page 2-->
    <Item Id="262" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Headless Baby-->
    <Item Id="269" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Brimstone-->
    <Item Id="275" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dark Bum-->
    <Item Id="278" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Satanic Bible-->
    <Item Id="292" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Judas' Shadow-->
    <Item Id="311" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Incubus-->
    <Item Id="360" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Betrayal-->
    <Item Id="391" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Maw Of The Void-->
    <Item Id="399" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Athame-->
    <Item Id="408" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Empty Vessel-->
    <Item Id="409" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lusty Blood-->
    <Item Id="411" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cambion Conception-->
    <Item Id="412" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Succubus-->
    <Item Id="417" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Powder-->
    <Item Id="420" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Multidimensional Baby-->
    <Item Id="431" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Shadow-->
    <Item Id="433" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Blast-->
    <Item Id="441" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Dark Prince's Crown-->
    <Item Id="442" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of Belial-->
    <Item Id="462" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shade-->
    <Item Id="468" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Void-->
    <Item Id="477" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Duality-->
    <Item Id="498" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Backstabber-->
    <Item Id="506" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Delirium-->
    <Item Id="519" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--7 Seals-->
    <Item Id="526" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death's List-->
    <Item Id="530" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Altar-->
    <Item Id="536" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of the Dead-->
    <Item Id="545" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--2Spooky-->
    <Item Id="554" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sulfur-->
    <Item Id="556" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Oath-->
    <Item Id="569" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of the Occult-->
    <Item Id="572" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Damocles-->
    <Item Id="577" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ocular Rift-->
    <Item Id="606" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purgatory-->
    <Item Id="634" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brimstone Bombs-->
    <Item Id="646" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Eye-->
    <Item Id="665" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Pound of Flesh-->
    <Item Id="672" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Abaddon-->
    <Item Id="679" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hungry Soul-->
    <Item Id="684" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Heartbreak-->
    <Item Id="694" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Bloody Gust-->
    <Item Id="695" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Twisted Pair-->
    <Item Id="698" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Azazel's Rage-->
    <Item Id="699" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vengeful Spirit-->
    <Item Id="702" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Berserk!-->
    <Item Id="704" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Dark Arts-->
    <Item Id="705" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Abyss-->
    <Item Id="706" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Lemegeton-->
    <Item Id="712" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Gello-->
    <Item Id="728" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="angel">
    <!--Blood of the Martyr-->
    <Item Id="7" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Bible-->
    <Item Id="33" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rosary-->
    <Item Id="72" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Revelations-->
    <Item Id="78" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Relic-->
    <Item Id="98" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Halo-->
    <Item Id="101" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Wafer-->
    <Item Id="108" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guardian Angel-->
    <Item Id="112" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Sea Scrolls-->
    <Item Id="124" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stigmata-->
    <Item Id="138" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scapular-->
    <Item Id="142" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Prayer Card-->
    <Item Id="146" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Habit-->
    <Item Id="156" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Celtic Cross-->
    <Item Id="162" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mitre-->
    <Item Id="173" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Water-->
    <Item Id="178" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Heart-->
    <Item Id="182" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Grail-->
    <Item Id="184" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Dove-->
    <Item Id="185" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jesus Juice-->
    <Item Id="197" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Trinity Shield-->
    <Item Id="243" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Mantle-->
    <Item Id="313" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Breath of Life-->
    <Item Id="326" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Godhead-->
    <Item Id="331" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lazarus' Rags-->
    <Item Id="332" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mind-->
    <Item Id="333" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Body-->
    <Item Id="334" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Soul-->
    <Item Id="335" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sworn Protector-->
    <Item Id="363" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Light-->
    <Item Id="374" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Censer-->
    <Item Id="387" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Seraphim-->
    <Item Id="390" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spear Of Destiny-->
    <Item Id="400" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purity-->
    <Item Id="407" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Immaculate Conception-->
    <Item Id="413" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crown Of Light-->
    <Item Id="415" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Circle of Protection-->
    <Item Id="423" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glyph of Balance-->
    <Item Id="464" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Void-->
    <Item Id="477" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Eden's Soul-->
    <Item Id="490" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Duality-->
    <Item Id="498" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eucharist-->
    <Item Id="499" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Delirious-->
    <Item Id="510" Weight="0.4" DecreaseBy="0.4" RemoveOn="0.04" />
    <!--Lil Delirium-->
    <Item Id="519" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--7 Seals-->
    <Item Id="526" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Angelic Prism-->
    <Item Id="528" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Trisagion-->
    <Item Id="533" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hallowed Ground-->
    <Item Id="543" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Paschal Candle-->
    <Item Id="567" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Divine Intervention-->
    <Item Id="568" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Immaculate Heart-->
    <Item Id="573" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monstrance-->
    <Item Id="574" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit Sword-->
    <Item Id="579" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Virtues-->
    <Item Id="584" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--The Stairway-->
    <Item Id="586" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Act of Contrition-->
    <Item Id="601" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Genesis-->
    <Item Id="622" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purgatory-->
    <Item Id="634" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Urn of Souls-->
    <Item Id="640" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Revelation-->
    <Item Id="643" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Star of Bethlehem-->
    <Item Id="651" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vade Retro-->
    <Item Id="653" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jar of Wisps-->
    <Item Id="685" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Soul Locket-->
    <Item Id="686" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Orb-->
    <Item Id="691" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Salvation-->
    <Item Id="696" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="secret">
    <!--1up!-->
    <Item Id="11" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Raw Liver-->
    <Item Id="16" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Skeleton Key-->
    <Item Id="17" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Transcendence-->
    <Item Id="20" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--We Need To Go Deeper!-->
    <Item Id="84" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="120" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="121" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forget Me Now-->
    <Item Id="127" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epic Fetus-->
    <Item Id="168" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyro-->
    <Item Id="190" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Contact-->
    <Item Id="213" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Lotus-->
    <Item Id="226" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infamy-->
    <Item Id="242" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing No.-->
    <Item Id="258" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing Page 2-->
    <Item Id="262" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Clear Rune-->
    <Item Id="263" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Sack-->
    <Item Id="271" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blank Card-->
    <Item Id="286" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Secrets-->
    <Item Id="287" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cursed Eye-->
    <Item Id="316" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Samson's Chains-->
    <Item Id="321" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Placebo-->
    <Item Id="348" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Key Bum-->
    <Item Id="388" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rune Bag-->
    <Item Id="389" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chaos-->
    <Item Id="402" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--GB Bug-->
    <Item Id="405" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack Head-->
    <Item Id="424" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of Greed-->
    <Item Id="450" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D infinity-->
    <Item Id="489" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack of Sacks-->
    <Item Id="500" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Greed's Gullet-->
    <Item Id="501" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Ring-->
    <Item Id="546" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rock Bottom-->
    <Item Id="562" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Orphan Socks-->
    <Item Id="571" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Red Key-->
    <Item Id="580" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wavy Cap-->
    <Item Id="582" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eternal D6-->
    <Item Id="609" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Soul-->
    <Item Id="612" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Mush-->
    <Item Id="625" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death Certificate-->
    <Item Id="628" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Evil Charm-->
    <Item Id="632" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--R Key-->
    <Item Id="636" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Binge Eater-->
    <Item Id="664" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Strawman-->
    <Item Id="667" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sausage-->
    <Item Id="669" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit Shackles-->
    <Item Id="674" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cracked Orb-->
    <Item Id="675" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Astral Projection-->
    <Item Id="677" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Inner Child-->
    <Item Id="688" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glitched Crown-->
    <Item Id="689" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Orb-->
    <Item Id="691" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Vanishing Twin-->
    <Item Id="697" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Echo Chamber-->
    <Item Id="700" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Isaac's Tomb-->
    <Item Id="701" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flip-->
    <Item Id="711" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Sack-->
    <Item Id="716" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Kin-->
    <Item Id="717" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Box-->
    <Item Id="719" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--TMTRAINER-->
    <Item Id="721" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="library">
    <!--The Bible-->
    <Item Id="33" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Book of Belial-->
    <Item Id="34" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Book of Shadows-->
    <Item Id="58" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Anarchist Cookbook-->
    <Item Id="65" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Book of Revelations-->
    <Item Id="78" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Book of Sin-->
    <Item Id="97" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Monster Manual-->
    <Item Id="123" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Telepathy For Dummies-->
    <Item Id="192" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--How to Jump-->
    <Item Id="282" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Book of Secrets-->
    <Item Id="287" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Satanic Bible-->
    <Item Id="292" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Book of the Dead-->
    <Item Id="545" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Book of Virtues-->
    <Item Id="584" Weight="0.2" DecreaseBy="0.02" RemoveOn="0.02" />
    <!--Lemegeton-->
    <Item Id="712" Weight="0.2" DecreaseBy="0.02" RemoveOn="0.02" />
  </Pool>
  <Pool Name="shellGame">
    <!--Skatole-->
    <Item Id="9" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Poop-->
    <Item Id="36" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Butt Bombs-->
    <Item Id="209" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--No. 2-->
    <Item Id="378" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Brown Nugget-->
    <Item Id="504" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dirty Mind-->
    <Item Id="576" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="goldenChest">
    <!--The Belt-->
    <Item Id="28" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Underwear-->
    <Item Id="29" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Wire Coat Hanger-->
    <Item Id="32" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--A Quarter-->
    <Item Id="74" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Fate-->
    <Item Id="179" Weight="0.5" DecreaseBy="0.2" RemoveOn="0.05" />
    <!--Magic 8 Ball-->
    <Item Id="194" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Squeezy-->
    <Item Id="196" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Screw-->
    <Item Id="255" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Torn Photo-->
    <Item Id="341" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Latch Key-->
    <Item Id="343" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Match Book-->
    <Item Id="344" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Crack Jacks-->
    <Item Id="354" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Pearls-->
    <Item Id="355" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mr. Dolly-->
    <Item Id="370" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--PJs-->
    <Item Id="428" Weight="0.5" DecreaseBy="0.2" RemoveOn="0.05" />
    <!--Binky-->
    <Item Id="438" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Lead Pencil-->
    <Item Id="444" Weight="0.1" DecreaseBy="0.04" RemoveOn="0.01" />
    <!--Dad's Lost Coin-->
    <Item Id="455" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Midnight Snack-->
    <Item Id="456" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Schoolbag-->
    <Item Id="534" Weight="0.5" DecreaseBy="0.2" RemoveOn="0.05" />
    <!--Orphan Socks-->
    <Item Id="571" Weight="0.1" DecreaseBy="0.04" RemoveOn="0.01" />
    <!--Consolation Prize-->
    <Item Id="644" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Stapler-->
    <Item Id="708" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Glass Eye-->
    <Item Id="730" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Ring-->
    <Item Id="732" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
  </Pool>
  <Pool Name="redChest">
    <!--Dead Cat-->
    <Item Id="81" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Guppy's Paw-->
    <Item Id="133" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Guppy's Tail-->
    <Item Id="134" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Bob's Curse-->
    <Item Id="140" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Guppy's Head-->
    <Item Id="145" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Pandora's Box-->
    <Item Id="297" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Cursed Eye-->
    <Item Id="316" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Curse of the Tower-->
    <Item Id="371" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.1" DecreaseBy="0.04" RemoveOn="0.01" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="0.5" DecreaseBy="0.2" RemoveOn="0.05" />
    <!--Red Key-->
    <Item Id="580" Weight="0.1" DecreaseBy="0.04" RemoveOn="0.01" />
    <!--Magic Skin-->
    <Item Id="642" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="0.2" DecreaseBy="0.08" RemoveOn="0.02" />
    <!--Guppy's Eye-->
    <Item Id="665" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
  </Pool>
  <Pool Name="beggar">
    <!--The Compass-->
    <Item Id="21" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Lunch-->
    <Item Id="22" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dinner-->
    <Item Id="23" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dessert-->
    <Item Id="24" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Breakfast-->
    <Item Id="25" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Rotten Meat-->
    <Item Id="26" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Lucky Foot-->
    <Item Id="46" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Treasure Map-->
    <Item Id="54" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Bean-->
    <Item Id="111" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bum Friend-->
    <Item Id="144" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Portable Slot-->
    <Item Id="177" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Black Bean-->
    <Item Id="180" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Box-->
    <Item Id="198" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Fanny Pack-->
    <Item Id="204" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blue Map-->
    <Item Id="246" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mystery Sack-->
    <Item Id="271" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Butter Bean-->
    <Item Id="294" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Lil Chest-->
    <Item Id="362" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Restock-->
    <Item Id="376" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bumbo-->
    <Item Id="385" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Linger Bean-->
    <Item Id="447" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dad's Lost Coin-->
    <Item Id="455" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Midnight Snack-->
    <Item Id="456" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Crooked Penny-->
    <Item Id="485" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Supper-->
    <Item Id="707" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="demonBeggar">
    <!--The Virus-->
    <Item Id="13" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Roid Rage-->
    <Item Id="14" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Growth Hormones-->
    <Item Id="70" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Lord of the Pit-->
    <Item Id="82" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--The Nail-->
    <Item Id="83" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Loki's Horns-->
    <Item Id="87" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Whore of Babylon-->
    <Item Id="122" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Razor Blade-->
    <Item Id="126" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Forget Me Now-->
    <Item Id="127" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Speed Ball-->
    <Item Id="143" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Spirit of the Night-->
    <Item Id="159" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Ceremonial Robes-->
    <Item Id="216" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Abaddon-->
    <Item Id="230" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Experimental Treatment-->
    <Item Id="240" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Contract from Below-->
    <Item Id="241" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dark Matter-->
    <Item Id="259" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Missing Page 2-->
    <Item Id="262" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dark Bum-->
    <Item Id="278" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Caffeine Pill-->
    <Item Id="340" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Synthoil-->
    <Item Id="345" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Empty Vessel-->
    <Item Id="409" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Black Powder-->
    <Item Id="420" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Potato Peeler-->
    <Item Id="487" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Adrenaline-->
    <Item Id="493" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Euthanasia-->
    <Item Id="496" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--A Pound of Flesh-->
    <Item Id="672" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Empty Heart-->
    <Item Id="676" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="curse">
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dead Cat-->
    <Item Id="81" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Razor Blade-->
    <Item Id="126" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Paw-->
    <Item Id="133" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Tail-->
    <Item Id="134" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Head-->
    <Item Id="145" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Goat Head-->
    <Item Id="215" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Ceremonial Robes-->
    <Item Id="216" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Contract from Below-->
    <Item Id="241" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Black Candle-->
    <Item Id="260" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Curse of the Tower-->
    <Item Id="371" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Athame-->
    <Item Id="408" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dark Prince's Crown-->
    <Item Id="442" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Shade-->
    <Item Id="468" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Euthanasia-->
    <Item Id="496" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sacrificial Altar-->
    <Item Id="536" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blood Oath-->
    <Item Id="569" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Red Key-->
    <Item Id="580" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Magic Skin-->
    <Item Id="642" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Guppy's Eye-->
    <Item Id="665" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Heartbreak-->
    <Item Id="694" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Vanishing Twin-->
    <Item Id="697" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Vengeful Spirit-->
    <Item Id="702" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Flip-->
    <Item Id="711" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="keyMaster">
    <!--Halo of Flies-->
    <Item Id="10" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Distant Admiration-->
    <Item Id="57" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Forever alone-->
    <Item Id="128" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dad's Key-->
    <Item Id="175" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Key-->
    <Item Id="199" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Smart Fly-->
    <Item Id="264" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--BBF-->
    <Item Id="272" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Big Fan-->
    <Item Id="279" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--???'s Only Friend-->
    <Item Id="320" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Latch Key-->
    <Item Id="343" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Friend Zone-->
    <Item Id="364" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Lost Fly-->
    <Item Id="365" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Key Bum-->
    <Item Id="388" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Obsessed Fan-->
    <Item Id="426" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Papa Fly-->
    <Item Id="430" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--YO LISTEN!-->
    <Item Id="492" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mr. ME!-->
    <Item Id="527" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Red Key-->
    <Item Id="580" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Psy Fly-->
    <Item Id="581" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bot Fly-->
    <Item Id="629" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Fruity Plum-->
    <Item Id="649" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Swarm-->
    <Item Id="693" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="batteryBum">
    <!--The Battery-->
    <Item Id="63" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--9 Volt-->
    <Item Id="116" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sharp Plug-->
    <Item Id="205" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Car Battery-->
    <Item Id="356" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Charged Baby-->
    <Item Id="372" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Jacob's Ladder-->
    <Item Id="494" Weight="0.1" DecreaseBy="0.05" RemoveOn="0.01" />
    <!--Jumper Cables-->
    <Item Id="520" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--120 Volt-->
    <Item Id="559" Weight="0.1" DecreaseBy="0.05" RemoveOn="0.01" />
    <!--Battery Pack-->
    <Item Id="603" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--4.5 Volt-->
    <Item Id="647" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="momsChest">
    <!--Mom's Underwear-->
    <Item Id="29" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Heels-->
    <Item Id="30" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Lipstick-->
    <Item Id="31" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Bra-->
    <Item Id="39" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Pad-->
    <Item Id="41" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Eye-->
    <Item Id="55" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Contacts-->
    <Item Id="110" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="0.1" DecreaseBy="0.05" RemoveOn="0.01" />
    <!--Mom's Purse-->
    <Item Id="139" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Key-->
    <Item Id="199" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Eyeshadow-->
    <Item Id="200" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Wig-->
    <Item Id="217" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Perfume-->
    <Item Id="228" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Pearls-->
    <Item Id="355" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mom's Razor-->
    <Item Id="508" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Red Key-->
    <Item Id="580" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Mom's Ring-->
    <Item Id="732" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedTreasure">
    <!--The Sad Onion-->
    <Item Id="1" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Inner Eye-->
    <Item Id="2" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spoon Bender-->
    <Item Id="3" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cricket's Head-->
    <Item Id="4" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Reflection-->
    <Item Id="5" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Number One-->
    <Item Id="6" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood of the Martyr-->
    <Item Id="7" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brother Bobby-->
    <Item Id="8" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Halo of Flies-->
    <Item Id="10" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Mushroom-->
    <Item Id="12" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--The Virus-->
    <Item Id="13" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Skeleton Key-->
    <Item Id="17" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--The Book of Belial-->
    <Item Id="34" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Boom-->
    <Item Id="37" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tammy's Head-->
    <Item Id="38" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Rotten Head-->
    <Item Id="42" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Yum Heart-->
    <Item Id="45" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Doctor's Remote-->
    <Item Id="47" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cupid's Arrow-->
    <Item Id="48" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Steven-->
    <Item Id="50" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dr. Fetus-->
    <Item Id="52" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Eye-->
    <Item Id="55" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lemon Mishap-->
    <Item Id="56" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Distant Admiration-->
    <Item Id="57" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Charm of the Vampire-->
    <Item Id="62" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Steam Sale-->
    <Item Id="64" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anarchist Cookbook-->
    <Item Id="65" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology-->
    <Item Id="68" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chocolate Milk-->
    <Item Id="69" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Little Unicorn-->
    <Item Id="77" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Revelations-->
    <Item Id="78" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deck of Cards-->
    <Item Id="85" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Loki's Horns-->
    <Item Id="87" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Chubby-->
    <Item Id="88" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spider Bite-->
    <Item Id="89" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Gamekid-->
    <Item Id="93" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack of Pennies-->
    <Item Id="94" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby-->
    <Item Id="95" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little C.H.A.D.-->
    <Item Id="96" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Book of Sin-->
    <Item Id="97" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Relic-->
    <Item Id="98" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Little Gish-->
    <Item Id="99" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Steven-->
    <Item Id="100" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Halo-->
    <Item Id="101" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Common Cold-->
    <Item Id="103" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Parasite-->
    <Item Id="104" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Mega-->
    <Item Id="106" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Pinking Shears-->
    <Item Id="107" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Wafer-->
    <Item Id="108" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Contacts-->
    <Item Id="110" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Bean-->
    <Item Id="111" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Ouija Board-->
    <Item Id="115" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Bird-->
    <Item Id="117" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="120" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="121" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Sea Scrolls-->
    <Item Id="124" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bobby-Bomb-->
    <Item Id="125" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Razor Blade-->
    <Item Id="126" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forever alone-->
    <Item Id="128" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bomb Bag-->
    <Item Id="131" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Lump of Coal-->
    <Item Id="132" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stigmata-->
    <Item Id="138" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Curse-->
    <Item Id="140" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scapular-->
    <Item Id="142" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Prayer Card-->
    <Item Id="146" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infestation-->
    <Item Id="148" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ipecac-->
    <Item Id="149" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tough Love-->
    <Item Id="150" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mulligan-->
    <Item Id="151" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology 2-->
    <Item Id="152" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mutant Spider-->
    <Item Id="153" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chemical Peel-->
    <Item Id="154" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Peeper-->
    <Item Id="155" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Lust-->
    <Item Id="157" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ankh-->
    <Item Id="161" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Celtic Cross-->
    <Item Id="162" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Baby-->
    <Item Id="163" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Harlequin Baby-->
    <Item Id="167" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epic Fetus-->
    <Item Id="168" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Polyphemus-->
    <Item Id="169" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Daddy Longlegs-->
    <Item Id="170" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Dagger-->
    <Item Id="172" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rainbow Baby-->
    <Item Id="174" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Key-->
    <Item Id="175" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Rights-->
    <Item Id="186" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Abel-->
    <Item Id="188" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--SMB Super Fan-->
    <Item Id="189" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyro-->
    <Item Id="190" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--3 Dollar Bill-->
    <Item Id="191" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Telepathy For Dummies-->
    <Item Id="192" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Eyeshadow-->
    <Item Id="200" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Iron Bar-->
    <Item Id="201" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guillotine-->
    <Item Id="206" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Butt Bombs-->
    <Item Id="209" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gnawed Leaf-->
    <Item Id="210" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Contact-->
    <Item Id="213" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anemic-->
    <Item Id="214" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Wig-->
    <Item Id="217" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sad Bombs-->
    <Item Id="220" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rubber Cement-->
    <Item Id="221" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Anti-Gravity-->
    <Item Id="222" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyromaniac-->
    <Item Id="223" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cricket's Body-->
    <Item Id="224" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Lotus-->
    <Item Id="226" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Perfume-->
    <Item Id="228" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monstro's Lung-->
    <Item Id="229" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ball of Tar-->
    <Item Id="231" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tiny Planet-->
    <Item Id="233" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infestation 2-->
    <Item Id="234" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--E. Coli-->
    <Item Id="236" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death's Touch-->
    <Item Id="237" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Infamy-->
    <Item Id="242" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tech.5-->
    <Item Id="244" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--20/20-->
    <Item Id="245" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Clot-->
    <Item Id="254" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hot Bombs-->
    <Item Id="256" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fire Mind-->
    <Item Id="257" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing No.-->
    <Item Id="258" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Proptosis-->
    <Item Id="261" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Smart Fly-->
    <Item Id="264" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dry Baby-->
    <Item Id="265" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Juicy Sack-->
    <Item Id="266" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby 2.0-->
    <Item Id="267" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Headless Baby-->
    <Item Id="269" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Sack-->
    <Item Id="271" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Brain-->
    <Item Id="273" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Best Bud-->
    <Item Id="274" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Haunt-->
    <Item Id="277" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Fan-->
    <Item Id="279" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sissy Longlegs-->
    <Item Id="280" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Punching Bag-->
    <Item Id="281" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box of Spiders-->
    <Item Id="288" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flush!-->
    <Item Id="291" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Taurus-->
    <Item Id="299" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Aries-->
    <Item Id="300" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cancer-->
    <Item Id="301" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leo-->
    <Item Id="302" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Virgo-->
    <Item Id="303" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scorpio-->
    <Item Id="305" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sagittarius-->
    <Item Id="306" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Capricorn-->
    <Item Id="307" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Aquarius-->
    <Item Id="308" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pisces-->
    <Item Id="309" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eve's Mascara-->
    <Item Id="310" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Maggy's Bow-->
    <Item Id="312" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Strange Attractor-->
    <Item Id="315" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cursed Eye-->
    <Item Id="316" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mysterious Liquid-->
    <Item Id="317" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gemini-->
    <Item Id="318" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cain's Other Eye-->
    <Item Id="319" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--???'s Only Friend-->
    <Item Id="320" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Samson's Chains-->
    <Item Id="321" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mongo Baby-->
    <Item Id="322" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scissors-->
    <Item Id="325" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Ludovico Technique-->
    <Item Id="329" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Soy Milk-->
    <Item Id="330" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lazarus' Rags-->
    <Item Id="332" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mind-->
    <Item Id="333" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--The Body-->
    <Item Id="334" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--The Soul-->
    <Item Id="335" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Dead Onion-->
    <Item Id="336" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Nickel-->
    <Item Id="349" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Bean-->
    <Item Id="351" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glass Cannon-->
    <Item Id="352" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bomber Boy-->
    <Item Id="353" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box of Friends-->
    <Item Id="357" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Wiz-->
    <Item Id="358" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--8 Inch Nails-->
    <Item Id="359" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Chest-->
    <Item Id="362" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friend Zone-->
    <Item Id="364" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Fly-->
    <Item Id="365" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Scatter Bombs-->
    <Item Id="366" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sticky Bombs-->
    <Item Id="367" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epiphora-->
    <Item Id="368" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Continuum-->
    <Item Id="369" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Curse of the Tower-->
    <Item Id="371" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Eye-->
    <Item Id="373" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Light-->
    <Item Id="374" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Host Hat-->
    <Item Id="375" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bursting Sack-->
    <Item Id="377" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--No. 2-->
    <Item Id="378" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pupula Duplex-->
    <Item Id="379" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pay To Play-->
    <Item Id="380" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friendly Ball-->
    <Item Id="382" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tear Detonator-->
    <Item Id="383" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Gurdy-->
    <Item Id="384" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rune Bag-->
    <Item Id="389" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Betrayal-->
    <Item Id="391" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Zodiac-->
    <Item Id="392" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Serpent's Kiss-->
    <Item Id="393" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marked-->
    <Item Id="394" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tech X-->
    <Item Id="395" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tractor Beam-->
    <Item Id="397" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--God's Flesh-->
    <Item Id="398" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Explosivo-->
    <Item Id="401" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purity-->
    <Item Id="407" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Evil Eye-->
    <Item Id="410" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lusty Blood-->
    <Item Id="411" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deep Pockets-->
    <Item Id="416" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Kidney Bean-->
    <Item Id="421" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glowing Hourglass-->
    <Item Id="422" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Night Light-->
    <Item Id="425" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Obsessed Fan-->
    <Item Id="426" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Papa Fly-->
    <Item Id="430" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Multidimensional Baby-->
    <Item Id="431" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glitter Bombs-->
    <Item Id="432" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jar of Flies-->
    <Item Id="434" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Milk!-->
    <Item Id="436" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Kidney Stone-->
    <Item Id="440" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Apple!-->
    <Item Id="443" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lead Pencil-->
    <Item Id="444" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dog Tooth-->
    <Item Id="445" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Tooth-->
    <Item Id="446" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Linger Bean-->
    <Item Id="447" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shard of Glass-->
    <Item Id="448" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Metal Plate-->
    <Item Id="449" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of Greed-->
    <Item Id="450" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Varicose Veins-->
    <Item Id="452" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Compound Fracture-->
    <Item Id="453" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Polydactyly-->
    <Item Id="454" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cone Head-->
    <Item Id="457" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Belly Button-->
    <Item Id="458" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sinus Infection-->
    <Item Id="459" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glaucoma-->
    <Item Id="460" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Parasitoid-->
    <Item Id="461" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sulfuric Acid-->
    <Item Id="463" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Analog Stick-->
    <Item Id="465" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Contagion-->
    <Item Id="466" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Finger!-->
    <Item Id="467" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Depression-->
    <Item Id="469" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hushy-->
    <Item Id="470" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Monstro-->
    <Item Id="471" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Chubby-->
    <Item Id="473" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Adrenaline-->
    <Item Id="493" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jacob's Ladder-->
    <Item Id="494" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Pepper-->
    <Item Id="495" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Euthanasia-->
    <Item Id="496" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Camo Undies-->
    <Item Id="497" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Large Zit-->
    <Item Id="502" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brown Nugget-->
    <Item Id="504" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Backstabber-->
    <Item Id="506" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sharp Straw-->
    <Item Id="507" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Razor-->
    <Item Id="508" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloodshot Eye-->
    <Item Id="509" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Angry Fly-->
    <Item Id="511" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Hole-->
    <Item Id="512" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bozo-->
    <Item Id="513" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Broken Modem-->
    <Item Id="514" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Gift-->
    <Item Id="515" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sprinkler-->
    <Item Id="516" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fast Bombs-->
    <Item Id="517" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Buddy in a Box-->
    <Item Id="518" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jumper Cables-->
    <Item Id="520" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Telekinesis-->
    <Item Id="522" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology Zero-->
    <Item Id="524" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leprosy-->
    <Item Id="525" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pop!-->
    <Item Id="529" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Haemolacria-->
    <Item Id="531" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lachryphagy-->
    <Item Id="532" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Spewer-->
    <Item Id="537" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Egg-->
    <Item Id="539" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flat Stone-->
    <Item Id="540" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Slipped Rib-->
    <Item Id="542" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hallowed Ground-->
    <Item Id="543" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pointy Rib-->
    <Item Id="544" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of the Dead-->
    <Item Id="545" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jaw Bone-->
    <Item Id="548" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brittle Bones-->
    <Item Id="549" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mucormycosis-->
    <Item Id="553" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Golden Razor-->
    <Item Id="555" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fortune Cookie-->
    <Item Id="557" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye Sore-->
    <Item Id="558" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--120 Volt-->
    <Item Id="559" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--It Hurts-->
    <Item Id="560" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Almond Milk-->
    <Item Id="561" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Nancy Bombs-->
    <Item Id="563" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Playdough Cookie-->
    <Item Id="570" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Intruder-->
    <Item Id="575" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dirty Mind-->
    <Item Id="576" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Free Lemonade-->
    <Item Id="578" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Psy Fly-->
    <Item Id="581" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rocket in a Jar-->
    <Item Id="583" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Scooper-->
    <Item Id="605" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Boiled Baby-->
    <Item Id="607" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Freezer Baby-->
    <Item Id="608" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eternal D6-->
    <Item Id="609" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Bird Cage-->
    <Item Id="610" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Larynx-->
    <Item Id="611" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Soul-->
    <Item Id="612" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Bombs-->
    <Item Id="614" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Dumpy-->
    <Item Id="615" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bird's Eye-->
    <Item Id="616" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lodestone-->
    <Item Id="617" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Tomato-->
    <Item Id="618" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Mush-->
    <Item Id="625" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Bot Fly-->
    <Item Id="629" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Meat Cleaver-->
    <Item Id="631" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stitches-->
    <Item Id="635" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Knockout Drops-->
    <Item Id="637" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Yuck Heart-->
    <Item Id="639" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Akeldama-->
    <Item Id="641" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tinytoma-->
    <Item Id="645" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fruity Plum-->
    <Item Id="649" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Plum Flute-->
    <Item Id="650" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Cube Baby-->
    <Item Id="652" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spin to Win-->
    <Item Id="655" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vasculitis-->
    <Item Id="657" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Giant Cell-->
    <Item Id="658" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Quints-->
    <Item Id="661" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tooth and Nail-->
    <Item Id="663" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Candy Heart-->
    <Item Id="671" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cracked Orb-->
    <Item Id="675" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Empty Heart-->
    <Item Id="676" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Astral Projection-->
    <Item Id="677" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--C Section-->
    <Item Id="678" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Montezuma's Revenge-->
    <Item Id="680" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Portal-->
    <Item Id="681" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Worm Friend-->
    <Item Id="682" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bone Spurs-->
    <Item Id="683" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friend Finder-->
    <Item Id="687" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Belly Jelly-->
    <Item Id="690" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Swarm-->
    <Item Id="693" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Gust-->
    <Item Id="695" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Suplex!-->
    <Item Id="709" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bag of Crafting-->
    <Item Id="710" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sumptorium-->
    <Item Id="713" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Sack-->
    <Item Id="716" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Keeper's Kin-->
    <Item Id="717" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Keeper's Box-->
    <Item Id="719" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Everything Jar-->
    <Item Id="720" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--TMTRAINER-->
    <Item Id="721" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Anima Sola-->
    <Item Id="722" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Hypercoagulation-->
    <Item Id="724" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--IBS-->
    <Item Id="725" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hemoptysis-->
    <Item Id="726" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Bombs-->
    <Item Id="727" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gello-->
    <Item Id="728" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Decap Attack-->
    <Item Id="729" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedBoss">
    <!--Magic Mushroom-->
    <Item Id="12" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Roid Rage-->
    <Item Id="14" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--<3-->
    <Item Id="15" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Raw Liver-->
    <Item Id="16" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lunch-->
    <Item Id="22" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dinner-->
    <Item Id="23" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dessert-->
    <Item Id="24" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Breakfast-->
    <Item Id="25" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Meat-->
    <Item Id="26" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Spoon-->
    <Item Id="27" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Belt-->
    <Item Id="28" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Underwear-->
    <Item Id="29" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Heels-->
    <Item Id="30" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Lipstick-->
    <Item Id="31" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wire Coat Hanger-->
    <Item Id="32" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Growth Hormones-->
    <Item Id="70" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mini Mush-->
    <Item Id="71" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cube of Meat-->
    <Item Id="73" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Halo-->
    <Item Id="101" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Odd Mushroom-->
    <Item Id="120" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="121" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Lump of Coal-->
    <Item Id="132" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Speed Ball-->
    <Item Id="143" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stem Cells-->
    <Item Id="176" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tooth Picks-->
    <Item Id="183" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--MEAT!-->
    <Item Id="193" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic 8 Ball-->
    <Item Id="194" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Squeezy-->
    <Item Id="196" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jesus Juice-->
    <Item Id="197" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Box-->
    <Item Id="198" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ball of Bandages-->
    <Item Id="207" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Experimental Treatment-->
    <Item Id="240" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Magic Scab-->
    <Item Id="253" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Clot-->
    <Item Id="254" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Screw-->
    <Item Id="255" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Thunder Thighs-->
    <Item Id="314" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Safety Pin-->
    <Item Id="339" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Caffeine Pill-->
    <Item Id="340" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Torn Photo-->
    <Item Id="341" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blue Cap-->
    <Item Id="342" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Latch Key-->
    <Item Id="343" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Match Book-->
    <Item Id="344" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Synthoil-->
    <Item Id="345" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Snack-->
    <Item Id="346" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crack Jacks-->
    <Item Id="354" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Pearls-->
    <Item Id="355" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. Dolly-->
    <Item Id="370" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--PJs-->
    <Item Id="428" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Binky-->
    <Item Id="438" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Lost Coin-->
    <Item Id="455" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Midnight Snack-->
    <Item Id="456" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marbles-->
    <Item Id="538" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Marrow-->
    <Item Id="541" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Divorce Papers-->
    <Item Id="547" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Bar of Soap-->
    <Item Id="564" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye Drops-->
    <Item Id="600" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Booster Pack-->
    <Item Id="624" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Consolation Prize-->
    <Item Id="644" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tropicamide-->
    <Item Id="659" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Supper-->
    <Item Id="707" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stapler-->
    <Item Id="708" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glass Eye-->
    <Item Id="730" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stye-->
    <Item Id="731" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedShop">
    <!--1up!-->
    <Item Id="11" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Lucky Foot-->
    <Item Id="46" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Battery-->
    <Item Id="63" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cube of Meat-->
    <Item Id="73" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--PHD-->
    <Item Id="75" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--X-Ray Vision-->
    <Item Id="76" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--We Need To Go Deeper!-->
    <Item Id="84" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spelunker Hat-->
    <Item Id="91" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The D6-->
    <Item Id="105" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--9 Volt-->
    <Item Id="116" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Purse-->
    <Item Id="139" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Habit-->
    <Item Id="156" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D20-->
    <Item Id="166" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Key-->
    <Item Id="199" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fanny Pack-->
    <Item Id="204" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Champion Belt-->
    <Item Id="208" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blue Map-->
    <Item Id="246" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--BFFS!-->
    <Item Id="247" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hive Mind-->
    <Item Id="248" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Starter Deck-->
    <Item Id="251" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Baggy-->
    <Item Id="252" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Candle-->
    <Item Id="260" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D100-->
    <Item Id="283" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D4-->
    <Item Id="284" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D10-->
    <Item Id="285" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blank Card-->
    <Item Id="286" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Red Candle-->
    <Item Id="289" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pandora's Box-->
    <Item Id="297" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Placebo-->
    <Item Id="348" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Car Battery-->
    <Item Id="356" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Charged Baby-->
    <Item Id="372" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pay To Play-->
    <Item Id="380" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D12-->
    <Item Id="386" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chaos-->
    <Item Id="402" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Spider Mod-->
    <Item Id="403" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--GB Bug-->
    <Item Id="405" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D8-->
    <Item Id="406" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Deep Pockets-->
    <Item Id="416" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jar of Flies-->
    <Item Id="434" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--King Baby-->
    <Item Id="472" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--D1-->
    <Item Id="476" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Void-->
    <Item Id="477" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pause-->
    <Item Id="478" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dataminer-->
    <Item Id="481" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Clicker-->
    <Item Id="482" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mama Mega!-->
    <Item Id="483" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Crooked Penny-->
    <Item Id="485" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dull Razor-->
    <Item Id="486" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Potato Peeler-->
    <Item Id="487" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Metronome-->
    <Item Id="488" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D infinity-->
    <Item Id="489" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Sack of Sacks-->
    <Item Id="500" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Hole-->
    <Item Id="512" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Gift-->
    <Item Id="515" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sprinkler-->
    <Item Id="516" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Buddy in a Box-->
    <Item Id="518" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. ME!-->
    <Item Id="527" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Schoolbag-->
    <Item Id="534" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blanket-->
    <Item Id="535" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dream Catcher-->
    <Item Id="566" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Alabaster Box-->
    <Item Id="585" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Battery Pack-->
    <Item Id="603" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Bracelet-->
    <Item Id="604" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Birthright-->
    <Item Id="619" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Red Stew-->
    <Item Id="621" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sharp Key-->
    <Item Id="623" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Booster Pack-->
    <Item Id="624" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--R Key-->
    <Item Id="636" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Eraser-->
    <Item Id="638" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--4.5 Volt-->
    <Item Id="647" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Strawman-->
    <Item Id="667" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Spirit Shackles-->
    <Item Id="674" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Inner Child-->
    <Item Id="688" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Glitched Crown-->
    <Item Id="689" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Sacred Orb-->
    <Item Id="691" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Echo Chamber-->
    <Item Id="700" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Isaac's Tomb-->
    <Item Id="701" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Flip-->
    <Item Id="711" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--TMTRAINER-->
    <Item Id="721" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Anima Sola-->
    <Item Id="722" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="0.1" DecreaseBy="0.1" RemoveOn="0.01" />
    <!--Mom's Ring-->
    <Item Id="732" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedCurse">
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Cube of Meat-->
    <Item Id="73" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dead Cat-->
    <Item Id="81" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Razor Blade-->
    <Item Id="126" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Paw-->
    <Item Id="133" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Head-->
    <Item Id="145" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Ceremonial Robes-->
    <Item Id="216" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Black Candle-->
    <Item Id="260" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Curse of the Tower-->
    <Item Id="371" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Athame-->
    <Item Id="408" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Dark Prince's Crown-->
    <Item Id="442" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Shade-->
    <Item Id="468" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Euthanasia-->
    <Item Id="496" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sacrificial Altar-->
    <Item Id="536" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blood Oath-->
    <Item Id="569" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Magic Skin-->
    <Item Id="642" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Guppy's Eye-->
    <Item Id="665" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Heartbreak-->
    <Item Id="694" Weight="0.5" DecreaseBy="0.25" RemoveOn="0.05" />
    <!--Vengeful Spirit-->
    <Item Id="702" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Flip-->
    <Item Id="711" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedDevil">
    <!--The Book of Belial-->
    <Item Id="34" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Technology-->
    <Item Id="68" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--A Quarter-->
    <Item Id="74" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Cat-->
    <Item Id="81" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lord of the Pit-->
    <Item Id="82" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Nail-->
    <Item Id="83" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Book of Sin-->
    <Item Id="97" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Money = Power-->
    <Item Id="109" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Demon Baby-->
    <Item Id="113" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ouija Board-->
    <Item Id="115" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brimstone-->
    <Item Id="118" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Whore of Babylon-->
    <Item Id="122" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monster Manual-->
    <Item Id="123" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--A Lump of Coal-->
    <Item Id="132" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Paw-->
    <Item Id="133" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Head-->
    <Item Id="145" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloody Lust-->
    <Item Id="157" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit of the Night-->
    <Item Id="159" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Dagger-->
    <Item Id="172" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Hairball-->
    <Item Id="187" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ceremonial Robes-->
    <Item Id="216" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Gimpy-->
    <Item Id="225" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Abaddon-->
    <Item Id="230" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death's Touch-->
    <Item Id="237" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dark Matter-->
    <Item Id="259" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Headless Baby-->
    <Item Id="269" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leech-->
    <Item Id="270" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Satanic Bible-->
    <Item Id="292" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Judas' Shadow-->
    <Item Id="311" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Incubus-->
    <Item Id="360" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Betrayal-->
    <Item Id="391" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Maw Of The Void-->
    <Item Id="399" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Athame-->
    <Item Id="408" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Empty Vessel-->
    <Item Id="409" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lusty Blood-->
    <Item Id="411" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cambion Conception-->
    <Item Id="412" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Powder-->
    <Item Id="420" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Multidimensional Baby-->
    <Item Id="431" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--My Shadow-->
    <Item Id="433" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Blast-->
    <Item Id="441" Weight="0.2" DecreaseBy="0.2" RemoveOn="0.02" />
    <!--Dark Prince's Crown-->
    <Item Id="442" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of Belial-->
    <Item Id="462" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shade-->
    <Item Id="468" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Horn-->
    <Item Id="503" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Backstabber-->
    <Item Id="506" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Delirium-->
    <Item Id="519" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--7 Seals-->
    <Item Id="526" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Altar-->
    <Item Id="536" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of the Dead-->
    <Item Id="545" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--2Spooky-->
    <Item Id="554" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sulfur-->
    <Item Id="556" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blood Oath-->
    <Item Id="569" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of the Occult-->
    <Item Id="572" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Damocles-->
    <Item Id="577" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ocular Rift-->
    <Item Id="606" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purgatory-->
    <Item Id="634" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Brimstone Bombs-->
    <Item Id="646" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guppy's Eye-->
    <Item Id="665" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Abaddon-->
    <Item Id="679" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hungry Soul-->
    <Item Id="684" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Heartbreak-->
    <Item Id="694" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Bloody Gust-->
    <Item Id="695" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Twisted Pair-->
    <Item Id="698" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Azazel's Rage-->
    <Item Id="699" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vengeful Spirit-->
    <Item Id="702" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Berserk!-->
    <Item Id="704" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Dark Arts-->
    <Item Id="705" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Abyss-->
    <Item Id="706" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Lemegeton-->
    <Item Id="712" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Gello-->
    <Item Id="728" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedAngel">
    <!--Blood of the Martyr-->
    <Item Id="7" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rosary-->
    <Item Id="72" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Revelations-->
    <Item Id="78" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guardian Angel-->
    <Item Id="112" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stigmata-->
    <Item Id="138" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Celtic Cross-->
    <Item Id="162" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Water-->
    <Item Id="178" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Heart-->
    <Item Id="182" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Grail-->
    <Item Id="184" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Dove-->
    <Item Id="185" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jesus Juice-->
    <Item Id="197" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Trinity Shield-->
    <Item Id="243" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Holy Mantle-->
    <Item Id="313" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Breath of Life-->
    <Item Id="326" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Godhead-->
    <Item Id="331" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Mind-->
    <Item Id="333" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Body-->
    <Item Id="334" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Soul-->
    <Item Id="335" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sworn Protector-->
    <Item Id="363" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Censer-->
    <Item Id="387" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Seraphim-->
    <Item Id="390" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spear Of Destiny-->
    <Item Id="400" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purity-->
    <Item Id="407" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Immaculate Conception-->
    <Item Id="413" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Crown Of Light-->
    <Item Id="415" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Circle of Protection-->
    <Item Id="423" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eden's Soul-->
    <Item Id="490" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eucharist-->
    <Item Id="499" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--7 Seals-->
    <Item Id="526" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Angelic Prism-->
    <Item Id="528" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Trisagion-->
    <Item Id="533" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hallowed Ground-->
    <Item Id="543" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Paschal Candle-->
    <Item Id="567" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Divine Intervention-->
    <Item Id="568" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Immaculate Heart-->
    <Item Id="573" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Monstrance-->
    <Item Id="574" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit Sword-->
    <Item Id="579" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Book of Virtues-->
    <Item Id="584" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--The Stairway-->
    <Item Id="586" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Act of Contrition-->
    <Item Id="601" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Genesis-->
    <Item Id="622" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Purgatory-->
    <Item Id="634" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Urn of Souls-->
    <Item Id="640" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Revelation-->
    <Item Id="643" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Star of Bethlehem-->
    <Item Id="651" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Vade Retro-->
    <Item Id="653" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jar of Wisps-->
    <Item Id="685" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Soul Locket-->
    <Item Id="686" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Orb-->
    <Item Id="691" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Salvation-->
    <Item Id="696" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="greedSecret">
    <!--1up!-->
    <Item Id="11" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Raw Liver-->
    <Item Id="16" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Skeleton Key-->
    <Item Id="17" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Transcendence-->
    <Item Id="20" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Necronomicon-->
    <Item Id="35" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--We Need To Go Deeper!-->
    <Item Id="84" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="120" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Odd Mushroom-->
    <Item Id="121" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forget Me Now-->
    <Item Id="127" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Epic Fetus-->
    <Item Id="168" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pyro-->
    <Item Id="190" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Contact-->
    <Item Id="213" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Black Lotus-->
    <Item Id="226" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Infamy-->
    <Item Id="242" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing No.-->
    <Item Id="258" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Missing Page 2-->
    <Item Id="262" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Clear Rune-->
    <Item Id="263" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mystery Sack-->
    <Item Id="271" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Blank Card-->
    <Item Id="286" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cursed Eye-->
    <Item Id="316" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Samson's Chains-->
    <Item Id="321" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Placebo-->
    <Item Id="348" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rune Bag-->
    <Item Id="389" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Chaos-->
    <Item Id="402" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--GB Bug-->
    <Item Id="405" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack Head-->
    <Item Id="424" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eye of Greed-->
    <Item Id="450" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--D infinity-->
    <Item Id="489" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sack of Sacks-->
    <Item Id="500" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Greed's Gullet-->
    <Item Id="501" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dad's Ring-->
    <Item Id="546" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rock Bottom-->
    <Item Id="562" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Orphan Socks-->
    <Item Id="571" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wavy Cap-->
    <Item Id="582" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Eternal D6-->
    <Item Id="609" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Soul-->
    <Item Id="612" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mega Mush-->
    <Item Id="625" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Death Certificate-->
    <Item Id="628" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Evil Charm-->
    <Item Id="632" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--R Key-->
    <Item Id="636" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Binge Eater-->
    <Item Id="664" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Strawman-->
    <Item Id="667" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sausage-->
    <Item Id="669" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spirit Shackles-->
    <Item Id="674" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Astral Projection-->
    <Item Id="677" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Inner Child-->
    <Item Id="688" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Glitched Crown-->
    <Item Id="689" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacred Orb-->
    <Item Id="691" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Echo Chamber-->
    <Item Id="700" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Isaac's Tomb-->
    <Item Id="701" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Flip-->
    <Item Id="711" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Sack-->
    <Item Id="716" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Kin-->
    <Item Id="717" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Box-->
    <Item Id="719" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--TMTRAINER-->
    <Item Id="721" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="craneGame">
    <!--The Sad Onion-->
    <Item Id="1" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spoon Bender-->
    <Item Id="3" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Cricket's Head-->
    <Item Id="4" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--My Reflection-->
    <Item Id="5" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Compass-->
    <Item Id="21" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Wire Coat Hanger-->
    <Item Id="32" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tammy's Head-->
    <Item Id="38" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Teleport!-->
    <Item Id="44" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Lucky Foot-->
    <Item Id="46" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Doctor's Remote-->
    <Item Id="47" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Cupid's Arrow-->
    <Item Id="48" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Shoop da Whoop!-->
    <Item Id="49" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Battery-->
    <Item Id="63" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Hourglass-->
    <Item Id="66" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Technology-->
    <Item Id="68" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--My Little Unicorn-->
    <Item Id="77" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Deck of Cards-->
    <Item Id="85" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spider Bite-->
    <Item Id="89" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Small Rock-->
    <Item Id="90" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spelunker Hat-->
    <Item Id="91" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Gamekid-->
    <Item Id="93" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Robo-Baby-->
    <Item Id="95" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The D6-->
    <Item Id="105" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--9 Volt-->
    <Item Id="116" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Best Friend-->
    <Item Id="136" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Notched Axe-->
    <Item Id="147" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Technology 2-->
    <Item Id="152" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mutant Spider-->
    <Item Id="153" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D20-->
    <Item Id="166" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--SMB Super Fan-->
    <Item Id="189" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Magic 8 Ball-->
    <Item Id="194" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Squeezy-->
    <Item Id="196" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Champion Belt-->
    <Item Id="208" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Guppy's Collar-->
    <Item Id="212" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Piggy Bank-->
    <Item Id="227" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Stop Watch-->
    <Item Id="232" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tech.5-->
    <Item Id="244" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Starter Deck-->
    <Item Id="251" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Screw-->
    <Item Id="255" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Clear Rune-->
    <Item Id="263" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Robo-Baby 2.0-->
    <Item Id="267" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D100-->
    <Item Id="283" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D4-->
    <Item Id="284" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D10-->
    <Item Id="285" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Broken Watch-->
    <Item Id="337" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--The Boomerang-->
    <Item Id="338" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Glass Cannon-->
    <Item Id="352" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Box of Friends-->
    <Item Id="357" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Lil Chest-->
    <Item Id="362" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mr. Dolly-->
    <Item Id="370" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Friendly Ball-->
    <Item Id="382" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tear Detonator-->
    <Item Id="383" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D12-->
    <Item Id="386" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tech X-->
    <Item Id="395" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tractor Beam-->
    <Item Id="397" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spider Mod-->
    <Item Id="403" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D8-->
    <Item Id="406" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Teleport 2.0-->
    <Item Id="419" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Glowing Hourglass-->
    <Item Id="422" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Night Light-->
    <Item Id="425" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mine Crafter-->
    <Item Id="427" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D7-->
    <Item Id="437" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Binky-->
    <Item Id="438" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Lead Pencil-->
    <Item Id="444" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Tarot Cloth-->
    <Item Id="451" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Analog Stick-->
    <Item Id="465" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--D1-->
    <Item Id="476" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Pause-->
    <Item Id="478" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Metronome-->
    <Item Id="488" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Jacob's Ladder-->
    <Item Id="494" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Poke Go-->
    <Item Id="505" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mystery Gift-->
    <Item Id="515" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Sprinkler-->
    <Item Id="516" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Buddy in a Box-->
    <Item Id="518" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Technology Zero-->
    <Item Id="524" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mr. ME!-->
    <Item Id="527" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Marbles-->
    <Item Id="538" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Voodoo Head-->
    <Item Id="599" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Mom's Bracelet-->
    <Item Id="604" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Eternal D6-->
    <Item Id="609" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Lodestone-->
    <Item Id="617" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Booster Pack-->
    <Item Id="624" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Bot Fly-->
    <Item Id="629" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Eraser-->
    <Item Id="638" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Consolation Prize-->
    <Item Id="644" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Fruity Plum-->
    <Item Id="649" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spin to Win-->
    <Item Id="655" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Friend Finder-->
    <Item Id="687" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Suplex!-->
    <Item Id="709" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Everything Jar-->
    <Item Id="720" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Spindown Dice-->
    <Item Id="723" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
    <!--Glass Eye-->
    <Item Id="730" Weight="1" DecreaseBy="0.1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="ultraSecret">
    <!--Magic Mushroom-->
    <Item Id="12" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--The Virus-->
    <Item Id="13" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--<3-->
    <Item Id="15" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Heels-->
    <Item Id="30" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Lipstick-->
    <Item Id="31" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Kamikaze!-->
    <Item Id="40" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Yum Heart-->
    <Item Id="45" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Shoop da Whoop!-->
    <Item Id="49" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Pentagram-->
    <Item Id="51" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Magneto-->
    <Item Id="53" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Rosary-->
    <Item Id="72" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Cube of Meat-->
    <Item Id="73" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--The Mark-->
    <Item Id="79" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--The Pact-->
    <Item Id="80" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Lord of the Pit-->
    <Item Id="82" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Little C.H.A.D.-->
    <Item Id="96" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--The D6-->
    <Item Id="105" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Money = Power-->
    <Item Id="109" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Contacts-->
    <Item Id="110" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Brimstone-->
    <Item Id="118" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Blood Bag-->
    <Item Id="119" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Whore of Babylon-->
    <Item Id="122" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--IV Bag-->
    <Item Id="135" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Bloody Lust-->
    <Item Id="157" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Spirit of the Night-->
    <Item Id="159" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--D20-->
    <Item Id="166" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Harlequin Baby-->
    <Item Id="167" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Stem Cells-->
    <Item Id="176" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Portable Slot-->
    <Item Id="177" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Sacred Heart-->
    <Item Id="182" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--MEAT!-->
    <Item Id="193" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Champion Belt-->
    <Item Id="208" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Anemic-->
    <Item Id="214" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Abaddon-->
    <Item Id="230" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--BFFS!-->
    <Item Id="247" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Magic Scab-->
    <Item Id="253" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Blood Clot-->
    <Item Id="254" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Proptosis-->
    <Item Id="261" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Isaac's Heart-->
    <Item Id="276" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Red Candle-->
    <Item Id="289" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--The Body-->
    <Item Id="334" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dead Eye-->
    <Item Id="373" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Marked-->
    <Item Id="394" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Maw Of The Void-->
    <Item Id="399" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Lusty Blood-->
    <Item Id="411" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Cambion Conception-->
    <Item Id="412" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Kidney Bean-->
    <Item Id="421" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Lil Loki-->
    <Item Id="435" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Apple!-->
    <Item Id="443" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Varicose Veins-->
    <Item Id="452" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Eye of Belial-->
    <Item Id="462" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Contagion-->
    <Item Id="466" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Plan C-->
    <Item Id="475" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dataminer-->
    <Item Id="481" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Backstabber-->
    <Item Id="506" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Angry Fly-->
    <Item Id="511" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Haemolacria-->
    <Item Id="531" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Marrow-->
    <Item Id="541" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--2Spooky-->
    <Item Id="554" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Sulfur-->
    <Item Id="556" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Blood Puppy-->
    <Item Id="565" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Eye of the Occult-->
    <Item Id="572" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Immaculate Heart-->
    <Item Id="573" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Red Key-->
    <Item Id="580" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Ocular Rift-->
    <Item Id="606" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Boiled Baby-->
    <Item Id="607" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Blood Bombs-->
    <Item Id="614" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Bird's Eye-->
    <Item Id="616" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Rotten Tomato-->
    <Item Id="618" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Red Stew-->
    <Item Id="621" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Knockout Drops-->
    <Item Id="637" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Plum Flute-->
    <Item Id="650" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--False PHD-->
    <Item Id="654" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Vasculitis-->
    <Item Id="657" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Candy Heart-->
    <Item Id="671" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--C Section-->
    <Item Id="678" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Worm Friend-->
    <Item Id="682" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Hungry Soul-->
    <Item Id="684" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Sanguine Bond-->
    <Item Id="692" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Heartbreak-->
    <Item Id="694" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Bloody Gust-->
    <Item Id="695" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Echo Chamber-->
    <Item Id="700" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Vengeful Spirit-->
    <Item Id="702" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Esau Jr.-->
    <Item Id="703" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Berserk!-->
    <Item Id="704" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dark Arts-->
    <Item Id="705" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Abyss-->
    <Item Id="706" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Flip-->
    <Item Id="711" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Hypercoagulation-->
    <Item Id="724" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Hemoptysis-->
    <Item Id="726" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Gello-->
    <Item Id="728" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
  </Pool>
  <Pool Name="bombBum">
    <!--Mr. Boom-->
    <Item Id="37" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mr. Mega-->
    <Item Id="106" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bobby-Bomb-->
    <Item Id="125" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Remote Detonator-->
    <Item Id="137" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bob's Curse-->
    <Item Id="140" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Pyro-->
    <Item Id="190" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Butt Bombs-->
    <Item Id="209" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sad Bombs-->
    <Item Id="220" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Hot Bombs-->
    <Item Id="256" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Bomber Boy-->
    <Item Id="353" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Scatter Bombs-->
    <Item Id="366" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Sticky Bombs-->
    <Item Id="367" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Glitter Bombs-->
    <Item Id="432" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Mama Mega!-->
    <Item Id="483" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Fast Bombs-->
    <Item Id="517" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Nancy Bombs-->
    <Item Id="563" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Rocket in a Jar-->
    <Item Id="583" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Blood Bombs-->
    <Item Id="614" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
    <!--Brimstone Bombs-->
    <Item Id="646" Weight="0.2" DecreaseBy="0.1" RemoveOn="0.02" />
    <!--Ghost Bombs-->
    <Item Id="727" Weight="1" DecreaseBy="0.5" RemoveOn="0.1" />
  </Pool>
  <Pool Name="planetarium">
    <!--Sol-->
    <Item Id="588" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Luna-->
    <Item Id="589" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mercurius-->
    <Item Id="590" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Venus-->
    <Item Id="591" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Terra-->
    <Item Id="592" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mars-->
    <Item Id="593" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Jupiter-->
    <Item Id="594" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Saturnus-->
    <Item Id="595" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Uranus-->
    <Item Id="596" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Neptunus-->
    <Item Id="597" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Pluto-->
    <Item Id="598" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="oldChest">
    <!--Mom's Underwear-->
    <Item Id="29" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Heels-->
    <Item Id="30" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Lipstick-->
    <Item Id="31" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Bra-->
    <Item Id="39" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Pad-->
    <Item Id="41" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Eye-->
    <Item Id="55" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Bottle of Pills-->
    <Item Id="102" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Contacts-->
    <Item Id="110" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Knife-->
    <Item Id="114" Weight="0.2" DecreaseBy="0.08" RemoveOn="0.02" />
    <!--Mom's Purse-->
    <Item Id="139" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dad's Key-->
    <Item Id="175" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Coin Purse-->
    <Item Id="195" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Key-->
    <Item Id="199" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Eyeshadow-->
    <Item Id="200" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Wig-->
    <Item Id="217" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Perfume-->
    <Item Id="228" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Torn Photo-->
    <Item Id="341" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Pearls-->
    <Item Id="355" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dad's Lost Coin-->
    <Item Id="455" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Razor-->
    <Item Id="508" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Dad's Ring-->
    <Item Id="546" Weight="0.2" DecreaseBy="0.08" RemoveOn="0.02" />
    <!--Divorce Papers-->
    <Item Id="547" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Bracelet-->
    <Item Id="604" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
    <!--Mom's Ring-->
    <Item Id="732" Weight="1" DecreaseBy="0.4" RemoveOn="0.1" />
  </Pool>
  <Pool Name="babyShop">
    <!--Brother Bobby-->
    <Item Id="8" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Halo of Flies-->
    <Item Id="10" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Distant Admiration-->
    <Item Id="57" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sister Maggy-->
    <Item Id="67" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Cube of Meat-->
    <Item Id="73" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Chubby-->
    <Item Id="88" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby-->
    <Item Id="95" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little C.H.A.D.-->
    <Item Id="96" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Gish-->
    <Item Id="99" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Little Steven-->
    <Item Id="100" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Guardian Angel-->
    <Item Id="112" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Demon Baby-->
    <Item Id="113" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Bird-->
    <Item Id="117" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Forever alone-->
    <Item Id="128" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bum Friend-->
    <Item Id="144" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Peeper-->
    <Item Id="155" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ghost Baby-->
    <Item Id="163" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Harlequin Baby-->
    <Item Id="167" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Daddy Longlegs-->
    <Item Id="170" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sacrificial Dagger-->
    <Item Id="172" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rainbow Baby-->
    <Item Id="174" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Abel-->
    <Item Id="188" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Ball of Bandages-->
    <Item Id="207" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Smart Fly-->
    <Item Id="264" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dry Baby-->
    <Item Id="265" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Juicy Sack-->
    <Item Id="266" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Robo-Baby 2.0-->
    <Item Id="267" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Headless Baby-->
    <Item Id="269" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Leech-->
    <Item Id="270" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--BBF-->
    <Item Id="272" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Brain-->
    <Item Id="273" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Best Bud-->
    <Item Id="274" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Brimstone-->
    <Item Id="275" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Haunt-->
    <Item Id="277" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dark Bum-->
    <Item Id="278" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Fan-->
    <Item Id="279" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sissy Longlegs-->
    <Item Id="280" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Punching Bag-->
    <Item Id="281" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--???'s Only Friend-->
    <Item Id="320" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mongo Baby-->
    <Item Id="322" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Incubus-->
    <Item Id="360" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fate's Reward-->
    <Item Id="361" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Sworn Protector-->
    <Item Id="363" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Friend Zone-->
    <Item Id="364" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Fly-->
    <Item Id="365" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Charged Baby-->
    <Item Id="372" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Gurdy-->
    <Item Id="384" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bumbo-->
    <Item Id="385" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Key Bum-->
    <Item Id="388" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Seraphim-->
    <Item Id="390" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Spider Mod-->
    <Item Id="403" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Farting Baby-->
    <Item Id="404" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Succubus-->
    <Item Id="417" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Obsessed Fan-->
    <Item Id="426" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Papa Fly-->
    <Item Id="430" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Loki-->
    <Item Id="435" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Shade-->
    <Item Id="468" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Hushy-->
    <Item Id="470" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Monstro-->
    <Item Id="471" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--King Baby-->
    <Item Id="472" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Big Chubby-->
    <Item Id="473" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Acid Baby-->
    <Item Id="491" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--YO LISTEN!-->
    <Item Id="492" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bloodshot Eye-->
    <Item Id="509" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Angry Fly-->
    <Item Id="511" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Buddy in a Box-->
    <Item Id="518" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Delirium-->
    <Item Id="519" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Spewer-->
    <Item Id="537" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Intruder-->
    <Item Id="575" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Psy Fly-->
    <Item Id="581" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Boiled Baby-->
    <Item Id="607" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Freezer Baby-->
    <Item Id="608" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bird Cage-->
    <Item Id="610" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lost Soul-->
    <Item Id="612" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Dumpy-->
    <Item Id="615" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bot Fly-->
    <Item Id="629" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stitches-->
    <Item Id="635" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tinytoma-->
    <Item Id="645" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Fruity Plum-->
    <Item Id="649" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Quints-->
    <Item Id="661" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Abaddon-->
    <Item Id="679" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Worm Friend-->
    <Item Id="682" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Twisted Pair-->
    <Item Id="698" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="woodenChest">
    <!--Blood of the Martyr-->
    <Item Id="7" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Spoon-->
    <Item Id="27" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--The Ladder-->
    <Item Id="60" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Stigmata-->
    <Item Id="138" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Tooth Picks-->
    <Item Id="183" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Wooden Nickel-->
    <Item Id="349" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Lil Chest-->
    <Item Id="362" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mom's Box-->
    <Item Id="439" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Metronome-->
    <Item Id="488" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Mr. ME!-->
    <Item Id="527" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Keeper's Box-->
    <Item Id="719" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
  <Pool Name="rottenBeggar">
    <!--Rotten Meat-->
    <Item Id="26" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Rotten Head-->
    <Item Id="42" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Curse-->
    <Item Id="140" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Baby-->
    <Item Id="268" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Bob's Brain-->
    <Item Id="273" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Dead Onion-->
    <Item Id="336" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Compost-->
    <Item Id="480" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
    <!--Rotten Tomato-->
    <Item Id="618" Weight="0.5" DecreaseBy="0.5" RemoveOn="0.05" />
    <!--Yuck Heart-->
    <Item Id="639" Weight="1" DecreaseBy="1" RemoveOn="0.1" />
  </Pool>
</ItemPools>

----
decorators.ts
import type { Feature } from "./classes/private/Feature";
import { getTSTLClassName } from "./functions/tstlClass";

export const EXPORTED_METHOD_NAMES_KEY = "__exportedMethodNames";

/**
 * A decorator function that signifies that the decorated class method should be added to the
 * `ModUpgraded` object.
 *
 * This is only meant to be used internally.
 */
export function Exported<Class extends Feature>(
  target: Class,
  propertyKey: keyof Class,
): void {
  // Since the decorator runs prior to instantiation, we only have access to get and set static
  // properties, which are located on the "constructor" table.
  const constructor = target.constructor as unknown as
    | Record<string, unknown>
    | undefined;

  if (constructor === undefined) {
    const tstlClassName = getTSTLClassName(target) ?? "Unknown";
    error(
      `Failed to get the constructor for class "${tstlClassName}". Did you decorate a static method? You can only decorate non-static class methods.`,
    );
  }

  let exportedMethodNames = constructor[EXPORTED_METHOD_NAMES_KEY] as
    | unknown[]
    | undefined;
  if (exportedMethodNames === undefined) {
    exportedMethodNames = [];
    constructor[EXPORTED_METHOD_NAMES_KEY] = exportedMethodNames;
  }

  exportedMethodNames.push(propertyKey as string);
}

----
enums\AmbushType.ts
/** This is used by the `POST_AMBUSH_STARTED` and `POST_AMBUSH_FINISHED` custom callbacks. */
export enum AmbushType {
  CHALLENGE_ROOM,
  BOSS_RUSH,
}

----
enums\CornerType.ts
/** This is used by the `getRoomShapeCorners` helper function. */
export enum CornerType {
  TOP_LEFT,
  TOP_RIGHT,
  BOTTOM_LEFT,
  BOTTOM_RIGHT,
}

----
enums\HealthType.ts
/**
 * This represents the type of health that is either given or taken away from a player. Note that we
 * cannot use the `HeartSubType` enum for this purpose this since it has no value for broken hearts
 * or max hearts.
 */
export enum HealthType {
  RED, // 5.10.1
  SOUL, // 5.10.3
  ETERNAL, // 5.10.4
  BLACK, // 5.10.6
  GOLDEN, // 5.10.7
  BONE, // 5.10.11
  ROTTEN, // 5.10.12
  BROKEN,
  MAX_HEARTS,
}

----
enums\ISCFeature.ts
export enum ISCFeature {
  // Callback logic
  CUSTOM_REVIVE,
  ESAU_JR_DETECTION,
  FLIP_DETECTION,
  GRID_ENTITY_COLLISION_DETECTION,
  GRID_ENTITY_RENDER_DETECTION,
  GRID_ENTITY_UPDATE_DETECTION,
  GAME_REORDERED_CALLBACKS,
  ITEM_PICKUP_DETECTION,
  PICKUP_CHANGE_DETECTION,
  PLAYER_COLLECTIBLE_DETECTION,
  PLAYER_REORDERED_CALLBACKS,
  SLOT_DESTROYED_DETECTION,
  SLOT_RENDER_DETECTION,
  SLOT_UPDATE_DETECTION,

  // Extra features
  CHARACTER_HEALTH_CONVERSION,
  CHARACTER_STATS,
  COLLECTIBLE_ITEM_POOL_TYPE,
  CUSTOM_GRID_ENTITIES,
  CUSTOM_ITEM_POOLS,
  CUSTOM_HOTKEYS,
  CUSTOM_PICKUPS,
  CUSTOM_STAGES,
  CUSTOM_TRAPDOORS,
  DEBUG_DISPLAY,
  DEPLOY_JSON_ROOM,
  DISABLE_ALL_SOUND,
  DISABLE_INPUTS,
  EDEN_STARTING_STATS_HEALTH,
  FADE_IN_REMOVER,
  FAST_RESET,
  FLYING_DETECTION,
  FORGOTTEN_SWITCH,
  EXTRA_CONSOLE_COMMANDS,
  ITEM_POOL_DETECTION,
  MODDED_ELEMENT_DETECTION,
  MODDED_ELEMENT_SETS,
  NO_SIREN_STEAL,
  PAUSE,
  PERSISTENT_ENTITIES,
  PICKUP_INDEX_CREATION,
  PLAYER_COLLECTIBLE_TRACKING,
  PONY_DETECTION,
  PRESS_INPUT,
  PREVENT_CHILD_ENTITIES,
  PREVENT_GRID_ENTITY_RESPAWN,
  RERUN_DETECTION,
  ROOM_CLEAR_FRAME,
  ROOM_HISTORY,
  RUN_IN_N_FRAMES,
  RUN_NEXT_ROOM,
  RUN_NEXT_RUN,
  SAVE_DATA_MANAGER,
  SPAWN_ALT_ROCK_REWARDS,
  STAGE_HISTORY,
  START_AMBUSH,
  TAINTED_LAZARUS_PLAYERS,
  UNLOCK_ACHIEVEMENTS_DETECTION,
}

----
enums\LadderSubTypeCustom.ts
/**
 * For `EntityType.EFFECT` (1000), `EffectVariant.LADDER` (8).
 *
 * Note that vanilla ladders only use a sub-type of 0. The `isaacscript-common` library uses ladders
 * to represent custom objects, since they are non-interacting and will not automatically despawn
 * after time passes, unlike most other effects.
 *
 * This enum tracks the kinds of custom objects that are represented by vanilla ladders. We start
 * assigning sub-types after 100 as to not interfere with any possible modded ladder variants.
 */
export enum LadderSubTypeCustom {
  LADDER = 0,

  CUSTOM_BACKDROP = 101,
  CUSTOM_SHADOW = 102,
  CUSTOM_PICKUP = 103,
}

----
enums\ModCallbackCustom.ts
/**
 * - The Isaac API offers a lot of callbacks, but a lot of times there isn't one for the specific
 *   thing that you are looking to do. So, `isaacscript-common` adds a bunch of new callbacks that
 *   you can use.
 * - The extra callbacks are efficient such that no code is executed until there is one or more
 *   subscriptions.
 * - You must upgrade your mod with the `upgradeMod` helper function before using a custom callback.
 */
export enum ModCallbackCustom {
  /**
   * The exact same thing as the vanilla `ENTITY_TAKE_DMG` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function entityTakeDmgFilter(
   *   entity: Entity,
   *   amount: float,
   *   damageFlags: BitFlags<DamageFlag>,
   *   source: EntityRef,
   *   countdownFrames: int,
   * ): boolean | undefined {}
   * ```
   */
  ENTITY_TAKE_DMG_FILTER,

  /**
   * The exact same thing as the vanilla `ENTITY_TAKE_DMG` callback, except this callback
   * automatically filters for `EntityType.ENTITY_PLAYER` and casts the `Entity` object to a
   * `EntityPlayer`.
   *
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function entityTakeDmgPlayer(
   *   player: EntityPlayer,
   *   amount: float,
   *   damageFlags: BitFlags<DamageFlag>,
   *   source: EntityRef,
   *   countdownFrames: int,
   * ): boolean | undefined {}
   * ```
   */
  ENTITY_TAKE_DMG_PLAYER,

  /**
   * The exact same thing as the vanilla `INPUT_ACTION` callback, except this callback allows you to
   * specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `InputHook` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `ButtonAction` provided.
   *
   * ```ts
   * function inputActionFilter(
   *   entity: Entity | undefined,
   *   inputHook: InputHook,
   *   buttonAction: ButtonAction,
   * ): boolean | undefined {}
   * ```
   */
  INPUT_ACTION_FILTER,

  /**
   * The exact same thing as the vanilla `INPUT_ACTION` callback, except this callback automatically
   * filters for `EntityType.ENTITY_PLAYER` and casts the `Entity` object to a `EntityPlayer`. It
   * also allows you to specify extra arguments for additional filtration.
   *
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the `InputHook` provided.
   * - You can provide an optional sixth argument that will make the callback only fire if it
   *   matches the `ButtonAction` provided.
   *
   * ```ts
   * function inputActionPlayer(
   *   player: EntityPlayer,
   *   inputHook: InputHook,
   *   buttonAction: ButtonAction,
   * ): boolean | undefined {}
   * ```
   */
  INPUT_ACTION_PLAYER,

  /**
   * Fires from the `POST_UPDATE` callback when a Challenge Room or Boss Rush is started.
   * Specifically, this happens on the first frame that `Room.IsAmbushDone` is true.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `AmbushType` provided.
   *
   * ```ts
   * function postAmbushFinished(ambushType: AmbushType): void {}
   * ```
   */
  POST_AMBUSH_FINISHED,

  /**
   * Fires from the `POST_UPDATE` callback when a Challenge Room or Boss Rush is completed.
   * Specifically, this happens on the first frame that `Room.IsAmbushActive` is true.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `AmbushType` provided.
   *
   * ```ts
   * function postAmbushStarted(ambushType: AmbushType): void {}
   * ```
   */
  POST_AMBUSH_STARTED,

  /**
   * Fires on the `POST_BOMB_UPDATE` callback that it explodes.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postBombDetonated(bomb: EntityBomb): void {}
   * ```
   */
  POST_BOMB_EXPLODED,

  /**
   * The exact same thing as the vanilla `POST_BOMB_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postBombInitFilter(bomb: EntityBomb): void {}
   * ```
   */
  POST_BOMB_INIT_FILTER,

  /**
   * Fires on the first `POST_BOMB_UPDATE` frame for each bomb.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_BOMB_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postBombInitLate(bomb: EntityBomb): void {}
   * ```
   */
  POST_BOMB_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_BOMB_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postBombRenderFilter(bomb: EntityBomb, renderOffset: Vector): void {}
   * ```
   */
  POST_BOMB_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_BOMB_UPDATE` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postBombUpdateFilter(bomb: EntityBomb): void {}
   * ```
   */
  POST_BOMB_UPDATE_FILTER,

  /**
   * Fires from the `POST_RENDER` callback when one of Forgotten's bone clubs is swung or thrown.
   *
   * ```ts
   * function postBoneSwing(boneClub: EntityKnife): void {}
   * ```
   */
  POST_BONE_SWING,

  /**
   * Fires from the `POST_PICKUP_UPDATE` callback when a collectible goes from a non-zero sub-type
   * to `CollectibleType.NULL` (i.e. an "empty" pedestal).
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the
   *   pedestal changed from the `CollectibleType` provided.
   *
   * ```ts
   * function postCollectibleEmpty(
   *   collectible: EntityPickupCollectible,
   *   oldCollectibleType: CollectibleType,
   * ): void {}
   * ```
   */
  POST_COLLECTIBLE_EMPTY,

  /**
   * Fires from the `POST_PLAYER_RENDER` callback on the first frame that the "TeleportUp" animation
   * begins playing after a player triggers a Cursed Eye teleport or a Cursed Skull teleport. (Both
   * of these have the same effect in causing Isaac to be teleported to a random room.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postCursedTeleport(player: EntityPlayer): void {}
   * ```
   */
  POST_CURSED_TELEPORT,

  /**
   * Fires from the `POST_PLAYER_UPDATE` callback after the player has finished the death animation,
   * has teleported to the previous room, and is ready to play the animation for the modded revival
   * item. The `revivalType` will match the value returned from the `PRE_CUSTOM_REVIVE` callback.
   *
   * In this callback, you must play an animation with something along the lines of
   * `player.AnimateCollectible(CollectibleTypeCustom.COLLECTIBLE_MY_REVIVAL_ITEM);`, otherwise the
   * animation for a 1-Up will play.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the
   *   revival type matches the one provided.
   *
   * ```ts
   * function postCustomRevive(player: EntityPlayer, revivalType: int): void {}
   * ```
   */
  POST_CUSTOM_REVIVE,

  /**
   * Fires from the `EFFECT_POST_UPDATE` callback after a player has entered the range of a Dice
   * Room floor.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `DiceFloorSubType` provided.
   *
   * ```ts
   * function postDiceRoomActivated(
   *   player: EntityPlayer,
   *   diceFloorSubType: DiceFloorSubType,
   * ): void {}
   * ```
   */
  POST_DICE_ROOM_ACTIVATED,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a door exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postDoorRender(door: GridEntityDoor): void {}
   * ```
   */
  POST_DOOR_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a door exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postDoorUpdate(door: GridEntityDoor): void {}
   * ```
   */
  POST_DOOR_UPDATE,

  /**
   * The exact same thing as the vanilla `POST_EFFECT_INIT` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EffectVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEffectInitFilter(effect: EntityEffect): void {}
   * ```
   */
  POST_EFFECT_INIT_FILTER,

  /**
   * Fires on the first `POST_EFFECT_UPDATE` frame for each effect.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_EFFECT_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EffectVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEffectInitLate(effect: EntityEffect): void {}
   * ```
   */
  POST_EFFECT_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_EFFECT_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EffectVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEffectRenderFilter(effect: EntityEffect, renderOffset: Vector): void {}
   * ```
   */
  POST_EFFECT_RENDER_FILTER,

  /**
   * Fires from the `POST_EFFECT_UPDATE` callback when an effect's state has changed from what it
   * was on the previous frame. (In this context, "state" refers to the `EntityEffect.State` field.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EffectVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEffectStateChanged(
   *   effect: EntityEffect,
   *   previousState: int,
   *   currentState: int,
   * ): void {}
   * ```
   */
  POST_EFFECT_STATE_CHANGED,

  /**
   * The exact same thing as the vanilla `POST_EFFECT_UPDATE` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EffectVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEffectUpdateFilter(effect: EntityEffect): void {}
   * ```
   */
  POST_EFFECT_UPDATE_FILTER,

  /**
   * The exact same thing as the vanilla `POST_ENTITY_KILL` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postEntityKillFilter(entity: Entity): void {}
   * ```
   */
  POST_ENTITY_KILL_FILTER,

  /**
   * Fires one `POST_UPDATE` frame after the player has used the Esau Jr. item. (The player is not
   * updated to the new character until a game frame has passed.)
   *
   * ```ts
   * function postEsauJr(player: EntityPlayer): void {}
   * ```
   */
  POST_ESAU_JR,

  /**
   * The exact same thing as the vanilla `POST_FAMILIAR_INIT` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postFamiliarInitFilter(familiar: EntityFamiliar): void {}
   * ```
   */
  POST_FAMILIAR_INIT_FILTER,

  /**
   * Fires on the first `FAMILIAR_UPDATE` frame for each familiar.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_TEAR_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postFamiliarInitLate(familiar: EntityFamiliar): void {}
   * ```
   */
  POST_FAMILIAR_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_FAMILIAR_RENDER` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postFamiliarRenderFilter(familiar: EntityFamiliar, renderOffset: Vector): void {}
   * ```
   */
  POST_FAMILIAR_RENDER_FILTER,

  /**
   * Fires from the `POST_FAMILIAR_UPDATE` callback when a familiar's state has changed from what it
   * was on the previous frame. (In this context, "state" refers to the `EntityFamiliar.State`
   * field.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postFamiliarStateChanged(
   *   familiar: EntityFamiliar,
   *   previousState: int,
   *   currentState: int,
   * ): void {}
   * ```
   */
  POST_FAMILIAR_STATE_CHANGED,

  /**
   * The exact same thing as the vanilla `POST_FAMILIAR_UPDATE` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postFamiliarUpdateFilter(familiar: EntityFamiliar): void {}
   * ```
   */
  POST_FAMILIAR_UPDATE_FILTER,

  /**
   * Fires one `POST_UPDATE` frame after the player has first used the Esau Jr. item. (The player is
   * not updated to the new character until a game frame has passed.)
   *
   * This callback is useful because there is no way to get access to the Esau Jr. character entity
   * before the player has actually used the Esau Jr. item.
   *
   * ```ts
   * function postFirstEsauJr(player: EntityPlayer): void {}
   * ```
   */
  POST_FIRST_ESAU_JR,

  /**
   * Fires after the player has used the Flip item for the first time. Unlike the vanilla `USE_ITEM`
   * callback, this callback will return the player object for the new Lazarus (not the one who used
   * the Flip item).
   *
   * This callback is useful because there is no way to get access to the "flipped" character entity
   * before the player has actually used the Flip item.
   *
   * ```ts
   * function postFirstFlip(newLazarus: EntityPlayer, oldLazarus: EntityPlayer): void {}
   * ```
   */
  POST_FIRST_FLIP,

  /**
   * Fires after the player has used the Flip item. Unlike the vanilla `USE_ITEM` callback, this
   * callback will return the player object for the new Lazarus (not the one who used the Flip
   * item).
   *
   * This callback is useful because there is no way to get access to the "flipped" character entity
   * before the player has actually used the Flip item.
   *
   * ```ts
   * function postFlip(newLazarus: EntityPlayer, oldLazarus: EntityPlayer): void {}
   * ```
   */
  POST_FLIP,

  /**
   * The exact same thing as the vanilla `POST_GAME_END` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `isGameOver` value provided.
   *
   * ```ts
   * function postGameEndFilter(isGameOver: boolean): void {}
   * ```
   */
  POST_GAME_END_FILTER,

  /**
   * Similar to the vanilla callback of the same name, but fires in the correct order with respect
   * to the `POST_NEW_LEVEL` and the `POST_NEW_ROOM` callbacks:
   *
   * `POST_GAME_STARTED_REORDERED` --> `POST_NEW_LEVEL_REORDERED` --> `POST_NEW_ROOM_REORDERED`
   *
   * - You must provide a third argument:
   *   - Pass true if you want the callback to only fire if the run is continued.
   *   - Pass false if you want the callback to only fire when the run is not continued.
   *   - Pass undefined if you want the callback to fire in both situations.
   *
   * (The third argument for this callback is mandatory in order to prevent users from shooting
   * themselves in the foot with respect to logic unexpectedly being executed on continued runs.)
   *
   * ```ts
   * function postGameStartedReordered(isContinued: boolean): void {}
   * ```
   */
  POST_GAME_STARTED_REORDERED,

  /**
   * Similar to the `POST_GAME_STARTED_REORDERED` callback, but fires after all of the subscribed
   * callbacks have finished firing. Thus, you can use this callback to do perform things after a
   * new run has started (or continued), but you can be sure that all new-run-related initialization
   * has been completed.
   *
   * - You must provide a third argument:
   *   - Pass true if you want the callback to only fire if the run is continued.
   *   - Pass false if you want the callback to only fire when the run is not continued.
   *   - Pass undefined if you want the callback to fire in both situations.
   *
   * (The third argument for this callback is mandatory in order to prevent users from shooting
   * themselves in the foot with respect to logic unexpectedly being executed on continued runs.)
   *
   * ```ts
   * function postGameStartedReorderedLast(isContinued: boolean): void {}
   * ```
   */
  POST_GAME_STARTED_REORDERED_LAST,

  /**
   * Fires from the `POST_UPDATE` callback when the Greed Mode wave increases.
   *
   * ```ts
   * function postGreedModeWave(oldWave: int, newWave: int): void {}
   * ```
   */
  POST_GREED_MODE_WAVE,

  /**
   * Fires from the `POST_UPDATE` callback when a grid entity changes to a state that corresponds to
   * the broken state for the respective grid entity type. (For example, this will fire for a
   * `GridEntityType.ROCK` (2) when its state changes to `RockState.BROKEN` (2).)
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_BROKEN` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityBroken(gridEntity: GridEntity): void {}
   * ```
   */
  POST_GRID_ENTITY_BROKEN,

  /**
   * Fires from the `POST_UPDATE` callback when a new entity collides with a grid entity. (After
   * this, the callback will not continue to fire. It will only fire again once the entity moves out
   * of range and then moves back into range.)
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_COLLISION` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided (for the grid entity).
   * - You can provide an optional fifth argument that will make the callback only fire if the
   *   colliding entity matches the `EntityType` provided.
   * - You can provide an optional sixth argument that will make the callback only fire if the
   *   colliding entity matches the variant provided.
   * - You can provide an optional seventh argument that will make the callback only fire if the
   *   colliding entity matches the sub-type provided.
   *
   * ```ts
   * function postGridEntityCollision(
   *   gridEntity: GridEntity,
   *   entity: Entity,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_COLLISION,

  /**
   * The same as the `POST_GRID_ENTITY_BROKEN` callback, but only fires for grid entities created
   * with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomBroken(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_BROKEN,

  /**
   * The same as the `POST_GRID_ENTITY_COLLISION` callback, but only fires for grid entities created
   * with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   * - You can provide an optional fourth argument that will make the callback only fire if the
   *   colliding entity matches the `EntityType` provided.
   * - You can provide an optional fifth argument that will make the callback only fire if the
   *   colliding entity matches the variant provided.
   * - You can provide an optional sixth argument that will make the callback only fire if the
   *   colliding entity matches the sub-type provided.
   *
   * ```ts
   * function postGridEntityCustomCollision(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   *   entity: Entity,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_COLLISION,

  /**
   * The same as the `POST_GRID_ENTITY_INIT` callback, but only fires for grid entities created with
   * the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomInit(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_INIT,

  /**
   * The same as the `POST_GRID_ENTITY_REMOVE` callback, but only fires for grid entities created
   * with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomRemove(
   *   gridIndex: int,
   *   gridEntityTypeCustom: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_REMOVE,

  /**
   * The same as the `POST_GRID_ENTITY_RENDER` callback, but only fires for grid entities created
   * with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomRender(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_RENDER,

  /**
   * The same as the `POST_GRID_ENTITY_STATE_CHANGED` callback, but only fires for grid entities
   * created with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomStateChanged(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   *   oldState: int,
   *   newState: int,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_STATE_CHANGED,

  /**
   * The same as the `POST_GRID_ENTITY_UPDATE` callback, but only fires for grid entities created
   * with the `spawnCustomGridEntity` helper function.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the custom `GridEntityType` provided. (Custom grid entities do not have variants, so
   *   there is no need for an optional argument to filter by variant.)
   *
   * ```ts
   * function postGridEntityCustomUpdate(
   *   gridEntity: GridEntity,
   *   gridEntityTypeCustom: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_CUSTOM_UPDATE,

  /**
   * Fires when a new grid entity is initialized. Specifically, this is either:
   *
   * - in the `POST_NEW_ROOM_REORDERED` callback (firing every time a room is entered, even if the
   *   entity was previously there on a previous room entry)
   * - in the `POST_UPDATE` callback (if the entity appeared mid-way through the room, like when the
   *   trapdoor appears after defeating It Lives)
   *
   * For grid entities created with `spawnCustomGridEntity`, use the `POST_GRID_ENTITY_CUSTOM_INIT`
   * callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityInit(gridEntity: GridEntity): void {}
   * ```
   */
  POST_GRID_ENTITY_INIT,

  /**
   * Fires from the `POST_UPDATE` callback when a new grid entity is removed. Specifically, this on
   * the frame after it no longer exists (where it did exist a frame ago).
   *
   * (Leaving a room with a grid entity does not count as "removing" it.)
   *
   * This will fire when a Polty/Kineti picks up a grid entity.
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_REMOVE` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityRemove(
   *   gridIndex: int,
   *   gridEntityType: GridEntityType,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_REMOVE,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a grid entity exists.
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_RENDER` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityRender(gridEntity: GridEntity): void {}
   * ```
   */
  POST_GRID_ENTITY_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback when a grid entity changes its state. (In this context,
   * "state" refers to the `GridEntity.State` field.)
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_STATE_CHANGED` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityStateChanged(
   *   gridEntity: GridEntity,
   *   oldState: int,
   *   newState: int,
   * ): void {}
   * ```
   */
  POST_GRID_ENTITY_STATE_CHANGED,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a grid entity exists.
   *
   * For grid entities created with `spawnCustomGridEntity`, use the
   * `POST_GRID_ENTITY_CUSTOM_UPDATE` callback instead.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postGridEntityUpdate(gridEntity: GridEntity): void {}
   * ```
   */
  POST_GRID_ENTITY_UPDATE,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when the player loses a Holy Mantle
   * temporary collectible effect.
   *
   * This callback is useful because you might want to have code that happens when the player is hit
   * from an enemy. Normally, you would accomplish this via the `ENTITY_TAKE_DMG` callback, but that
   * callback never fires if the player has a Holy Mantle shield.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerInitReordered(
   *   player: EntityPlayer,
   *   oldNumHolyMantles: int,
   *   newNumHolyMantles: int,
   * ): void {}
   * ```
   */
  POST_HOLY_MANTLE_REMOVED,

  /**
   * Fires from `POST_PEFFECT_UPDATE_REORDERED` callback when the player loses charge on their
   * active collectible item, implying that the item was just used.
   *
   * This callback is useful because the `USE_ITEM` callback does not fire when The Candle, Red
   * Candle, and Bob's Rotten Brain are discharged.
   *
   * Note that this callback will not fire if the active item is both discharged and swapped for
   * another item / discharged on the same frame, like in the case of Alabaster Box.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `CollectibleType` provided.
   *
   * ```ts
   * function postItemDischarge(
   *   player: EntityPlayer,
   *   collectibleType: CollectibleType,
   *   activeSlot: ActiveSlot,
   * ): void {}
   * ```
   */
  POST_ITEM_DISCHARGE,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when an item is no longer queued (i.e.
   * when the animation of the player holding the item above their head is finished and the item is
   * actually added to the player's inventory).
   *
   * Note that this callback will only fire once per Forgotten/Soul pair.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ItemType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if the
   *   sub-type matches the `CollectibleType` or the `TrinketType` provided.
   *
   * ```ts
   * function postItemPickup(
   *   player: EntityPlayer,
   *   pickingUpItem: PickingUpItem,
   * ): void {}
   * ```
   */
  POST_ITEM_PICKUP,

  /**
   * Fires on the first `POST_RENDER` frame after a key on the keyboard has been pressed or
   * released. (In other words, the callback only fires when the "pressed" status is different than
   * what it was on the previous frame.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `Keyboard` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the pressed state provided. (`true` for pressed, `false` for released.)
   *
   * ```ts
   * function postKeyboardChanged(keyboard: Keyboard, pressed: boolean): void {}
   * ```
   */
  POST_KEYBOARD_CHANGED,

  /**
   * The exact same thing as the vanilla `POST_KNIFE_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `KnifeVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postKnifeInitFilter(knife: EntityKnife): void {}
   * ```
   */
  POST_KNIFE_INIT_FILTER,

  /**
   * Fires on the first `POST_KNIFE_UPDATE` frame for each knife.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_KNIFE_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `KnifeVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postKnifeInitLate(knife: EntityKnife): void {}
   * ```
   */
  POST_KNIFE_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_KNIFE_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `KnifeVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postKnifeRenderFilter(knife: EntityKnife, renderOffset: Vector): void {}
   * ```
   */
  POST_KNIFE_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_KNIFE_UPDATE` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `KnifeVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postKnifeUpdateFilter(knife: EntityKnife): void {}
   * ```
   */
  POST_KNIFE_UPDATE_FILTER,

  /**
   * The exact same thing as the vanilla `POST_LASER_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `LaserVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postLaserInitFilter(laser: EntityLaser): void {}
   * ```
   */
  POST_LASER_INIT_FILTER,

  /**
   * Fires on the first `POST_LASER_UPDATE` frame for each laser.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_LASER_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `LaserVariant` provided.
   * - You can provide an optional forth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postLaserInitLate(laser: EntityLaser): void {}
   * ```
   */
  POST_LASER_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_LASER_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `LaserVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postLaserRenderFilter(laser: EntityLaser, renderOffset: Vector): void {}
   * ```
   */
  POST_LASER_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_LASER_UPDATE` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `LaserVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postLaserUpdateFilter(laser: EntityLaser): void {}
   * ```
   */
  POST_LASER_UPDATE_FILTER,

  /**
   * The same as the vanilla callback of the same name, but fires in the correct order with respect
   * to the `POST_GAME_STARTED` and the `POST_NEW_ROOM` callbacks:
   *
   * `POST_GAME_STARTED_REORDERED` --> `POST_NEW_LEVEL_REORDERED` --> `POST_NEW_ROOM_REORDERED`
   *
   * Additionally, this callback will pass the `LevelStage` as the first callback argument and the
   * `StageType` as the second callback argument.
   *
   * Note that similar to the vanilla `POST_NEW_LEVEL` callback, this callback will not fire when a
   * player resumes a saved run. (In that case, only the `POST_GAME_STARTED_REORDERED` and the
   * `POST_NEW_ROOM_REORDERED` callbacks will fire, in that order).
   *
   * If some specific cases, mods can change the current level during run initialization (on the 0th
   * frame). However, due to how the callback reordering works, the custom
   * `POST_NEW_LEVEL_REORDERED` callback will never fire on the 0th frame. To get around this, call
   * the `forceNewLevelCallback()` function before changing levels to temporarily force the callback
   * to fire.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `LevelStage` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `StageType` provided.
   *
   * ```ts
   * function postNewLevelReordered(stage: LevelStage, stageType: StageType): void {}
   * ```
   */
  POST_NEW_LEVEL_REORDERED,

  /**
   * Fires on the first `POST_NEW_ROOM` or `PRE_ENTITY_SPAWN` callback where being in a new room is
   * detected. This is useful because the vanilla `POST_NEW_ROOM` callback fires only after entities
   * in the room have been initialized and updated once, which means that it is possible for
   * entity-related code to run before room-related-initialization has been performed.
   *
   * Additionally, this callback will pass the `RoomType` as the first callback argument.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `RoomType` provided.
   *
   * ```ts
   * function postNewRoomEarly(roomType: RoomType): void {}
   * ```
   */
  POST_NEW_ROOM_EARLY,

  /**
   * The same as the vanilla callback of the same name, but fires in the correct order with respect
   * to the `POST_GAME_STARTED` and the `POST_NEW_LEVEL` callbacks:
   *
   * `POST_GAME_STARTED_REORDERED` --> `POST_NEW_LEVEL_REORDERED` --> `POST_NEW_ROOM_REORDERED`
   *
   * Additionally, this callback will pass the `RoomType` as the first callback argument.
   *
   * If some specific cases, mods can change the current room during run initialization (on the 0th
   * frame). However, due to how the callback reordering works, the custom `POST_NEW_ROOM_REORDERED`
   * callback will never fire on the 0th frame. To get around this, call the
   * `forceNewRoomCallback()` function before changing levels to temporarily force the callback to
   * fire.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `RoomType` provided.
   *
   * ```ts
   * function postNewRoomReordered(roomType: RoomType): void {}
   * ```
   */
  POST_NEW_ROOM_REORDERED,

  /**
   * The exact same thing as the vanilla `POST_NPC_DEATH` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCDeathFilter(npc: EntityNPC): void {}
   * ```
   */
  POST_NPC_DEATH_FILTER,

  /**
   * The exact same thing as the vanilla `POST_NPC_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCInitFilter(npc: EntityNPC): void {}
   * ```
   */
  POST_NPC_INIT_FILTER,

  /**
   * Fires on the first `NPC_UPDATE` frame for each NPC.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_NPC_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCInitLate(npc: EntityNPC): void {}
   * ```
   */
  POST_NPC_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_NPC_RENDER` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCRenderFilter(npc: EntityNPC, renderOffset: Vector): void {}
   * ```
   */
  POST_NPC_RENDER_FILTER,

  /**
   * Fires from the `POST_NPC_UPDATE` callback when an NPC's state has changed from what it was on
   * the previous frame. (In this context, "state" refers to the `EntityNPC.State` field.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCStateChanged(
   *   npc: EntityNPC,
   *   previousState: int,
   *   currentState: int,
   * ): void {}
   * ```
   */
  POST_NPC_STATE_CHANGED,

  /**
   * The exact same thing as the vanilla `POST_NPC_UPDATE` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postNPCUpdateFilter(npc: EntityNPC): void {}
   * ```
   */
  POST_NPC_UPDATE_FILTER,

  /**
   * Similar to the vanilla callback of the same name, but fires after the
   * `POST_GAME_STARTED_REORDERED` callback fires (if the player is being updated on the 0th game
   * frame of the run).
   *
   * This callback is useful for two reasons:
   *
   * 1. Normally, `POST_PEFFECT_UPDATE` fires before `POST_GAME_STARTED`. Since mod variables are
   *    often initialized at the beginning of the `POST_GAME_STARTED` callback, this can cause
   *    problems.
   * 1. Some functions do not work (or crash the game) when called before the `POST_NEW_ROOM`
   *    callback. For example, since the level is not generated yet, you will not be able to access
   *    any rooms.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPEffectUpdateReordered(player: EntityPlayer): void {}
   * ```
   */
  POST_PEFFECT_UPDATE_REORDERED,

  /**
   * Fires from the `POST_PICKUP_UPDATE` callback when a pickup has a different variant or sub-type
   * than what it was on the previous frame.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the new
   *   pickup matches the `PickupVariant` provided.
   * - You can provide an optional third argument that will make the callback only fire if the new
   *   pickup matches the sub-type provided.
   *
   * ```ts
   * function postPickupChanged(
   *   pickup: EntityPickup,
   *   oldVariant: PickupVariant,
   *   oldSubType: int,
   *   newVariant: PickupVariant,
   *   newSubType: int,
   * ): void {}
   * ```
   */
  POST_PICKUP_CHANGED,

  /**
   * Fires on the first `POST_RENDER` frame that a pickup plays the "Collect" animation.
   *
   * Use this callback to know when a pickup is added to the player's inventory or health.
   *
   * Note that this will not fire when the player takes a collectible; use either the
   * `POST_PLAYER_COLLECTIBLE_ADDED` or the `PRE_ITEM_PICKUP` callback for that.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupCollect(pickup: EntityPickup, player: EntityPlayer): void {}
   * ```
   */
  POST_PICKUP_COLLECT,

  /**
   * The exact same thing as the vanilla `POST_PICKUP_INIT` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupInitFilter(pickup: EntityPickup): void {}
   * ```
   */
  POST_PICKUP_INIT_FILTER,

  /**
   * Fires from the `POST_PICKUP_INIT` callback on the first time that a player has seen the
   * respective pickup on the run.
   *
   * This callback is useful because pickups will despawn upon leaving the room and respawn upon
   * re-entering the room.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupInitFirst(pickup: EntityPickup): void {}
   * ```
   */
  POST_PICKUP_INIT_FIRST,

  /**
   * Fires on the first `POST_PICKUP_UPDATE` frame for each pickup.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_PICKUP_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupInitLate(pickup: EntityPickup): void {}
   * ```
   */
  POST_PICKUP_INIT_LATE,

  /**
   * The exact same thing as the vanilla `POST_PICKUP_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupRenderFilter(pickup: EntityPickup, renderOffset: Vector): void {}
   * ```
   */
  POST_PICKUP_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_PICKUP_SELECTION` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupSelectionFilter(
   *   pickup: EntityPickup,
   *   variant: PickupVariant,
   *   subType: int,
   * ): [pickupVariant: PickupVariant, subType: int] | undefined {}
   * ```
   */
  POST_PICKUP_SELECTION_FILTER,

  /**
   * Fires from the `POST_PICKUP_UPDATE` callback when a pickup's state has changed from what it was
   * on the previous frame. (In this context, "state" refers to the `EntityPickup.State` field.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupStateChanged(
   *   pickup: EntityPickup,
   *   previousState: int,
   *   currentState: int,
   * ): void {}
   * ```
   */
  POST_PICKUP_STATE_CHANGED,

  /**
   * The exact same thing as the vanilla `POST_PICKUP_UPDATE` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPickupUpdateFilter(pickup: EntityPickup): void {}
   * ```
   */
  POST_PICKUP_UPDATE_FILTER,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a pit exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPitRender(pit: GridEntityPit): void {}
   * ```
   */
  POST_PIT_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a pit exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPitUpdate(pit: GridEntityPit): void {}
   * ```
   */
  POST_PIT_UPDATE,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player's health (i.e. hearts) is
   * different than what it was on the previous frame. For more information, see the `PlayerHealth`
   * enum.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerChangeHealth(
   *   player: EntityPlayer,
   *   healthType: HealthType,
   *   difference: int,
   *   oldValue: int,
   *   newValue: int,
   * ): void {}
   * ```
   */
  POST_PLAYER_CHANGE_HEALTH,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when one of the player's stats change
   * from what they were on the previous frame.
   *
   * The type of `oldValue` and `newValue` will depend on what kind of stat it is. For example,
   * `StatType.FLYING` will be a boolean. (You can use the "Types" helper functions to narrow the
   * type.)
   *
   * For `StatType.TEAR_FLAG`, `StatType.TEAR_COLOR`, `StatType.FLYING`, and `StatType.SIZE`, the
   * `difference` argument will always be a value of 0, since the type of these stats are not
   * numbers. (For these cases, you should examine the `oldValue` and `newValue` arguments
   * accordingly.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerChangeStat<T extends StatType>(
   *   player: EntityPlayer,
   *   statType: T,
   *   difference: int,
   *   oldValue: StatTypeType[T],
   *   newValue: StatTypeType[T],
   * ) => void {}
   * ```
   */
  POST_PLAYER_CHANGE_STAT,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player entity changes its player
   * type
   * (i.e. character) from what it was on the previous frame. For example, it will fire after using
   * Clicker, after dying with the Judas' Shadow collectible, etc.
   *
   * Notably, it does not fire after the player uses the Flip item or the Esau Jr. item, because
   * those items cause separate player entities to be created. Use the `POST_FLIP` and
   * `POST_ESAU_JR` callbacks to handle those situations.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   *
   * ```ts
   * function postPlayerChangeType(
   *   player: EntityPlayer,
   *   oldCharacter: PlayerType,
   *   newCharacter: PlayerType,
   * ): void {}
   * ```
   */
  POST_PLAYER_CHANGE_TYPE,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player's collectible count is
   * higher than what it was on the previous frame, or when the active items change, or when the
   * build is rerolled.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the
   *   collectible matches the `CollectibleType` provided.
   *
   * ```ts
   * function postPlayerCollectibleAdded(
   *   player: EntityPlayer,
   *   collectibleType: CollectibleType,
   * ): void {}
   * ```
   */
  POST_PLAYER_COLLECTIBLE_ADDED,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player's collectible count is
   * lower than what it was on the previous frame, or when the active items change, or when the
   * build is rerolled.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the
   *   collectible matches the `CollectibleType` provided.
   *
   * ```ts
   * function postPlayerCollectibleRemoved(
   *   player: EntityPlayer,
   *   collectibleType: CollectibleType,
   * ): void {}
   * ```
   */
  POST_PLAYER_COLLECTIBLE_REMOVED,

  /**
   * Fires from the `ENTITY_TAKE_DMG` callback when a player takes fatal damage. Return false to
   * prevent the fatal damage.
   *
   * Note that this function does properly take into account Guppy's Collar, Broken Ankh, Spirit
   * Shackles, and Mysterious Paper. It also takes into account using The Bible on Satan.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerFatalDamage(player: EntityPlayer): boolean | undefined {}
   * ```
   */
  POST_PLAYER_FATAL_DAMAGE,

  /**
   * Fires on the first `POST_PEFFECT_UPDATE_REORDERED` frame for each player, similar to the
   * `POST_PLAYER_INIT_LATE` callback, with two changes:
   *
   * - This will not fire for "child" players (e.g. non-real players like the Strawman Keeper).
   * - This will fire when the player enters a Genesis room and all of their items are taken away.
   *
   * You should use this callback for any player-related initialization logic, like giving the
   * character their starting items for the run. (You do not want to use the vanilla
   * `POST_PLAYER_INIT` callback for this because it fires when a run is continued.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerInitFirst(player: EntityPlayer): void {}
   * ```
   */
  POST_PLAYER_INIT_FIRST,

  /**
   * Fires on the first `POST_PEFFECT_UPDATE_REORDERED` frame for each player.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_PLAYER_INIT` callback.
   *
   * For initializing a player with custom items and so forth, use the `POST_PLAYER_INIT_FIRST`
   * callback instead to handle the case of a Genesis room.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerInitLate(pickup: EntityPickup): void {}
   * ```
   */
  POST_PLAYER_INIT_LATE,

  /**
   * Similar to the vanilla callback of the same name, but fires after the `POST_GAME_STARTED`
   * callback fires (if the player is spawning on the 0th game frame of the run).
   *
   * This callback is useful for two reasons:
   *
   * 1. Normally, `POST_PLAYER_RENDER` fires before `POST_GAME_STARTED`. Since mod variables are
   *    often initialized at the beginning of the `POST_GAME_STARTED` callback, this can cause
   *    problems.
   * 1. Some functions do not work (or crash the game) when called before the `POST_NEW_ROOM`
   *    callback. For example, since the level is not generated yet, you will not be able to access
   *    any rooms.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerRenderReordered(player: EntityPlayer, renderOffset: Vector): void {}
   * ```
   */
  POST_PLAYER_RENDER_REORDERED,

  /**
   * Similar to the vanilla callback of the same name, but fires after the
   * `POST_GAME_STARTED_REORDERED` callback fires (if the player is being updated on the 0th game
   * frame of the run).
   *
   * This callback is useful for two reasons:
   *
   * 1. Normally, `POST_PLAYER_UPDATE` fires before `POST_GAME_STARTED`. Since mod variables are
   *    often initialized at the beginning of the `POST_GAME_STARTED` callback, this can cause
   *    problems.
   * 1. Some functions do not work (or crash the game) when called before the `POST_NEW_ROOM`
   *    callback. For example, since the level is not generated yet, you will not be able to access
   *    any rooms.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postPlayerUpdateReordered(player: EntityPlayer): void {}
   * ```
   */
  POST_PLAYER_UPDATE_REORDERED,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a poop exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPoopRender(poop: GridEntityPoop): void {}
   * ```
   */
  POST_POOP_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a poop exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPoopUpdate(poop: GridEntityPoop): void {}
   * ```
   */
  POST_POOP_UPDATE,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a pressure plate exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPressurePlateRender(pressurePlate: GridEntityPressurePlate): void {}
   * ```
   */
  POST_PRESSURE_PLATE_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a pressure plate exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postPressurePlateUpdate(pressurePlate: GridEntityPressurePlate): void {}
   * ```
   */
  POST_PRESSURE_PLATE_UPDATE,

  /**
   * The exact same thing as the vanilla `POST_PROJECTILE_INIT` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postProjectileInitFilter(projectile: EntityProjectile): void {}
   * ```
   */
  POST_PROJECTILE_INIT_FILTER,

  /**
   * Fires on the first `POST_PROJECTILE_UPDATE` frame for each projectile.
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_PROJECTILE_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if matches
   *   the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postProjectileInitLate(projectile: EntityProjectile): void {}
   * ```
   */
  POST_PROJECTILE_INIT_LATE,

  /**
   * Fires when the provided projectile is removed after colliding with an entity or grid entity.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postProjectileKill(projectile: EntityProjectile): void {}
   * ```
   */
  POST_PROJECTILE_KILL,

  /**
   * The exact same thing as the vanilla `POST_PROJECTILE_RENDER` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postProjectileRenderFilter(projectile: EntityProjectile, renderOffset: Vector): void {}
   * ```
   */
  POST_PROJECTILE_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_PROJECTILE_INIT` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postProjectileUpdateFilter(projectile: EntityProjectile): void {}
   * ```
   */
  POST_PROJECTILE_UPDATE_FILTER,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player first picks up a new
   * item. The pickup returned in the callback is assumed to be the first pickup that no longer
   * exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PickupVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postPurchase(player: EntityPlayer, pickup: EntityPickup): void {}
   * ```
   */
  POST_PURCHASE,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a rock exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postRockRender(rock: GridEntityRock): void {}
   * ```
   */
  POST_ROCK_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a rock exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `GridEntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postRockUpdate(rock: GridEntityRock): void {}
   * ```
   */
  POST_ROCK_UPDATE,

  /**
   * Fires from the `POST_UPDATE` callback when the clear state of a room changes (as according to
   * the `Room.IsClear` method).
   *
   * For example, this callback fires when you defeat all the enemies in a room (clear --> not
   * clear) or when you bomb an angel statue (not clear --> clear). This callback does not fire when
   * you travel between a cleared room and an uncleared room.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if the room
   *   clear state matches the boolean provided.
   *
   * ```ts
   * function postRoomClearChanged(roomClear: boolean): void {}
   * ```
   */
  POST_ROOM_CLEAR_CHANGED,

  /**
   * Fires from the `ENTITY_TAKE_DMG` callback when a player takes damage from spikes in a Sacrifice
   * Room.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function postSacrifice(player: EntityPlayer, numSacrifices: int): void {}
   * ```
   */
  POST_SACRIFICE,

  /**
   * Fires from the `POST_RENDER` callback when a slot entity's animation changes.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postSlotAnimationChanged(
   *   slot: Entity,
   *   previousAnimation: string,
   *   currentAnimation: string,
   * ): void {}
   * ```
   */
  POST_SLOT_ANIMATION_CHANGED,

  /**
   * Fires from the `PRE_PLAYER_COLLISION` callback when when a player collides with a slot entity.
   * (It will not fire if any other type of entity collides with the slot entity.)
   *
   * When a player runs into a slot entity, this callback will continually fire, since the player is
   * colliding with it on every frame. Thus, you should only perform actions in this callback under
   * certain conditions, like if the slot entity is playing the "Idle" animation, and so on.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   * - (Only players will cause this callback to fire, so there is no need for an optional argument
   *   to filter by `EntityType`.)
   *
   * ```ts
   * function postSlotCollision(
   *   slot: EntitySlot,
   *   entity: Entity,
   * ): void {}
   * ```
   */
  POST_SLOT_COLLISION,

  /**
   * Fires from the `POST_SLOT_UPDATE` or the `POST_ENTITY_REMOVE` callback when a slot machine is
   * destroyed or a beggar is removed.
   *
   * This callback will fire in four different kinds of situations:
   *
   * 1. When slot machine entities (e.g. `SlotVariant.SLOT_MACHINE` and
   *    `SlotVariant.BLOOD_DONATION_MACHINE`) are destroyed with an explosion. When this happens,
   *    they typically stay in the room and can be pushed around. This state is detected via a
   *    change in the `GridCollisionClass`.
   * 2. When slot machine entities pay out with a collectible item. When this happens, they
   *    immediately despawn without playing any special animation.
   * 3. When beggar entities (e.g. `SlotVariant.BEGGAR` and `SlotVariant.SHELL_GAME`) are destroyed
   *    with an explosion. When this happens, they immediately despawn without playing any special
   *    animation.
   * 4. When beggar entities pay out with a collectible item. When this happens, they despawn after
   *    playing the "Teleport" animation. (This is not technically a "destruction" event, but the
   *    callback will fire for this to remain consistent with the other types of slot entities.)
   *
   * Depending on the specific types of slot removal that you need to detect, you can filter using:
   *
   * 1. The `isSlotMachine` helper function to differentiate between slot machines and beggars.
   * 2. The passed callback argument of `SlotDestructionType` to differentiate between bombed slots
   *    and slots that paid out with a collectible item.
   *
   * Note that when a Crane Game explodes after paying out three collectibles, the
   * `SlotDestructionType` will be equal to `SlotDestructionType.NORMAL` instead of
   * `SlotDestructionType.COLLECTIBLE_PAYOUT` like you might expect. (This is because it only
   * explodes after a short delay, and when doing so, it produces rewards in the same way that would
   * happen if you bombed it.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postSlotDestroyed(slot: Entity, slotDestructionType: SlotDestructionType): void {}
   * ```
   */
  POST_SLOT_DESTROYED,

  /**
   * Fires when a new slot entity is initialized. Specifically, this is either:
   *
   * - in the `POST_NEW_ROOM_REORDERED` callback (firing every time a room is entered, even if the
   *   entity was previously there on a previous room entry)
   * - in the `POST_UPDATE` callback (if the entity appeared mid-way through the room, like when a
   *   Wheel of Fortune card is used)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postSlotInit(slot: Entity): void {}
   * ```
   */
  POST_SLOT_INIT,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a slot entity exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postSlotRender(slot: Entity): void {}
   * ```
   */
  POST_SLOT_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a slot entity exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `SlotVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postSlotUpdate(slot: Entity): void {}
   * ```
   */
  POST_SLOT_UPDATE,

  /**
   * Fires from the `POST_RENDER` callback on every frame that spikes exist.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postSpikesRender(spikes: GridEntitySpikes): void {}
   * ```
   */
  POST_SPIKES_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that spikes exist.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postSpikesUpdate(spikes: GridEntitySpikes): void {}
   * ```
   */
  POST_SPIKES_UPDATE,

  /**
   * The exact same thing as the vanilla `POST_TEAR_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearInitFilter(tear: EntityTear): void {}
   * ```
   */
  POST_TEAR_INIT_FILTER,

  /**
   * Fires on the first `POST_TEAR_UPDATE` frame for each tear (which is when
   * `EntityTear.FrameCount` is equal to 0).
   *
   * This callback is useful because many attributes cannot be set or retrieved properly in the
   * normal `POST_TEAR_INIT` callback.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearInitLate(tear: EntityTear): void {}
   * ```
   */
  POST_TEAR_INIT_LATE,

  /**
   * Fires on the second `POST_TEAR_UPDATE` frame for each tear (which is when
   * `EntityTear.FrameCount` is equal to 1).
   *
   * This callback is useful because Incubus tears are not distinguishable until the second frame.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearInitVeryLate(tear: EntityTear): void {}
   * ```
   */
  POST_TEAR_INIT_VERY_LATE,

  /**
   * Fires when the provided tear is removed after colliding with an entity or grid entity.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearKill(tear: EntityTear): void {}
   * ```
   */
  POST_TEAR_KILL,

  /**
   * The exact same thing as the vanilla `POST_TEAR_RENDER` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearRenderFilter(tear: EntityTear, renderOffset: Vector): void {}
   * ```
   */
  POST_TEAR_RENDER_FILTER,

  /**
   * The exact same thing as the vanilla `POST_TEAR_INIT` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function postTearUpdateFilter(tear: EntityTear): void {}
   * ```
   */
  POST_TEAR_UPDATE_FILTER,

  /**
   * Fires from the `POST_RENDER` callback on every frame that a TNT exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postTNTRender(tnt: GridEntityTNT): void {}
   * ```
   */
  POST_TNT_RENDER,

  /**
   * Fires from the `POST_UPDATE` callback on every frame that a TNT exists.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the variant provided.
   *
   * ```ts
   * function postTNTUpdate(tnt: GridEntityTNT): void {}
   * ```
   */
  POST_TNT_UPDATE,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when a player gains or loses a new
   * transformation.
   *
   * Note that this callback will only fire once per Forgotten/Soul pair.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerForm` provided.
   *
   * ```ts
   * function postTransformation(
   *   player: EntityPlayer,
   *   playerForm: PlayerForm,
   *   hasForm: boolean,
   * ): void {}
   * ```
   */
  POST_TRANSFORMATION,

  /**
   * Fires from `ENTITY_TAKE_DMG` callback when a Wishbone or a Walnut breaks.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TrinketType` provided.
   *
   * ```ts
   * function postTrinketBreak(
   *   player: EntityPlayer,
   *   trinketType: TrinketType,
   * ): void {}
   * ```
   */
  POST_TRINKET_BREAK,

  /**
   * The same thing as the vanilla `POST_USE_PILL` callback, except this callback passes the
   * `PillColor` of the used pill as the final argument. It allows you to filter by the `PillColor`.
   *
   * In order to accomplish this, this callback tracks the held pills of the player on every frame.
   * If a matching `PillColor` could not be found, this callback passes `PillColor.NULL` (0).
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PillEffect` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PillColor` provided.
   *
   * ```ts
   * function postUsePillFilter(
   *   pillEffect: PillEffect,
   *   pillColor: PillColor,
   *   player: EntityPlayer,
   *   useFlags: BitFlags<UseFlag>,
   * ): void {}
   * ```
   */
  POST_USE_PILL_FILTER,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback on the frame before a Berserk effect
   * ends when the player is predicted to die (e.g. they currently have no health left or they took
   * damage in a "Lost" form).
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function preBerserkDeath(player: EntityPlayer): void {}
   * ```
   */
  PRE_BERSERK_DEATH,

  /**
   * The exact same thing as the vanilla `PRE_BOMB_COLLISION` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `BombVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preBombCollisionFilter(
   *   bomb: EntityBomb,
   *   collider: Entity,
   *   low: boolean,
   * ): void {}
   * ```
   */
  PRE_BOMB_COLLISION_FILTER,

  /**
   * Fires from the `POST_PLAYER_FATAL_DAMAGE` callback when a player is about to die. If you want
   * to initiate a custom revival, return an integer that corresponds to the item or type of revival
   * that you are doing. Otherwise, return undefined to continue the fatal damage.
   *
   * This callback is useful because reviving the player after the game things that player should
   * have died will result in the save data for the run getting deleted.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function preCustomRevive(player: EntityPlayer): int | undefined {}
   * ```
   */
  PRE_CUSTOM_REVIVE,

  /**
   * The exact same thing as the vanilla `PRE_ENTITY_SPAWN` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preEntitySpawnFilter(
   *   entityType: EntityType,
   *   variant: int,
   *   subType: int,
   *   position: Vector,
   *   velocity: Vector,
   *   spawner: Entity | undefined,
   *   initSeed: Seed,
   * ): [entityType: EntityType, variant: int, subType: int, initSeed: Seed] | undefined {}
   * ```
   */
  PRE_ENTITY_SPAWN_FILTER,

  /**
   * The exact same thing as the vanilla `PRE_FAMILIAR_COLLISION` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `FamiliarVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preFamiliarCollisionFilter(
   *   familiar: EntityFamiliar,
   *   collider: Entity,
   *   low: boolean,
   * ): void {}
   * ```
   */
  PRE_FAMILIAR_COLLISION_FILTER,

  /**
   * Fires from the `PRE_PICKUP_COLLISION` callback when a player touches a collectible pedestal and
   * meets all of the conditions to pick it up.
   *
   * The return values of this callback are the same as the `PRE_PICKUP_COLLISION` callback. For
   * example, you can prevent a player from picking up the collectible by returning false. (However,
   * note that this callback will continue to fire for every frame that the player touches the
   * pedestal, so you would need to continue returning false.)
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `PlayerVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the `PlayerType` provided.
   *
   * ```ts
   * function preGetPedestal(player: EntityPlayer, collectible: EntityPickupCollectible): void {}
   * ```
   */
  PRE_GET_PEDESTAL,

  /**
   * Fires from the `POST_PEFFECT_UPDATE_REORDERED` callback when an item becomes queued (i.e. when
   * the player begins to hold the item above their head).
   *
   * Note that this callback will only fire once per Forgotten/Soul pair.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ItemType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if the
   *   sub-type matches the `CollectibleType` or the `TrinketType` provided.
   *
   * ```ts
   * function preItemPickup(
   *   player: EntityPlayer,
   *   pickingUpItem: PickingUpItem,
   * ): void {}
   * ```
   */
  PRE_ITEM_PICKUP,

  /**
   * The exact same thing as the vanilla `PRE_KNIFE_COLLISION` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `KnifeVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preKnifeCollisionFilter(
   *   knife: EntityKnife,
   *   collider: Entity,
   *   low: boolean,
   * ): void {}
   * ```
   */
  PRE_KNIFE_COLLISION_FILTER,

  /**
   * Fires on the `POST_RENDER` frame before the player is taken to a new floor. Only fires when a
   * player jumps into a trapdoor or enters a heaven door (beam of light). Does not fire on the
   * first floor of the run. Does not fire when the player reloads/reseeds the current floor (i.e.
   * Forget Me Now, 5-pip dice room).
   *
   * This callback passes the `EntityPlayer` object for the player who jumped into the trapdoor or
   * entered the heaven door, if needed.
   *
   * ```ts
   * function preNewLevel(player: EntityPlayer): void {}
   * ```
   */
  PRE_NEW_LEVEL,

  /**
   * The exact same thing as the vanilla `PRE_NPC_COLLISION` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preNPCCollisionFilter(
   *   npc: EntityNPC,
   *   collider: Entity,
   *   low: boolean,
   * ): boolean | undefined {}
   * ```
   */
  PRE_NPC_COLLISION_FILTER,

  /**
   * The exact same thing as the vanilla `PRE_NPC_UPDATE` callback, except this callback allows you
   * to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preNPCUpdateFilter(entity: Entity): boolean | undefined {}
   * ```
   */
  PRE_NPC_UPDATE_FILTER,

  /**
   * The exact same thing as the vanilla `PRE_PROJECTILE_COLLISION` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `ProjectileVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preProjectileCollisionFilter(
   *   tear: EntityTear,
   *   collider: Entity,
   *   low: boolean,
   * ): void {}
   * ```
   */
  PRE_PROJECTILE_COLLISION_FILTER,

  /**
   * The exact same thing as the vanilla `PRE_ROOM_ENTITY_SPAWN` callback, except this callback
   * allows you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `EntityType` or `GridEntityXMLType` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the variant provided.
   * - You can provide an optional fifth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * You can use the `isGridEntityXMLType` helper function to convert the
   * `entityTypeOrGridEntityXMLType` argument to an `EntityType` or `GridEntityXMLType`, if needed.
   *
   * ```ts
   * function preRoomEntitySpawnFilter(
   *   entityTypeOrGridEntityXMLType: EntityType | GridEntityXMLType,
   *   variant: int,
   *   subType: int,
   *   gridIndex: int,
   *   seed: Seed,
   * ): [type: EntityType | GridEntityXMLType, variant: int, subType: int] | undefined {}
   * ```
   */
  PRE_ROOM_ENTITY_SPAWN_FILTER,

  /**
   * The exact same thing as the vanilla `PRE_TEAR_COLLISION` callback, except this callback allows
   * you to specify extra arguments for additional filtration.
   *
   * When registering the callback with the `ModUpgraded.AddCallbackCustom` method:
   * - You can provide an optional third argument that will make the callback only fire if it
   *   matches the `TearVariant` provided.
   * - You can provide an optional fourth argument that will make the callback only fire if it
   *   matches the sub-type provided.
   *
   * ```ts
   * function preTearCollisionFilter(
   *   tear: EntityTear,
   *   collider: Entity,
   *   low: boolean,
   * ): void {}
   * ```
   */
  PRE_TEAR_COLLISION_FILTER,
}

----
enums\MysteriousPaperEffect.ts
/**
 * The possible effects that the Mysterious Paper trinket can grant.
 *
 * This enum has hard-coded values because they correspond to the specific in-game frame count of
 * the player.
 */
export enum MysteriousPaperEffect {
  POLAROID = 0,
  NEGATIVE = 1,
  MISSING_PAGE = 2,
  MISSING_POSTER = 3,
}

----
enums\PlayerStat.ts
/** This represents the kinds of stats that a player can have. */
export enum PlayerStat {
  /** Corresponds to `CacheFlag.DAMAGE` (1 << 0) and `EntityPlayer.Damage`. */
  DAMAGE,

  /** Corresponds to `CacheFlag.FIRE_DELAY` (1 << 1) and `EntityPlayer.MaxFireDelay`. */
  FIRE_DELAY,

  /** Corresponds to `CacheFlag.SHOT_SPEED` (1 << 2) and `EntityPlayer.ShotSpeed`. */
  SHOT_SPEED,

  /** Corresponds to `CacheFlag.RANGE` (1 << 3) and `EntityPlayer.TearHeight`. */
  TEAR_HEIGHT,

  /** Corresponds to `CacheFlag.RANGE` (1 << 3) and `EntityPlayer.TearRange`. */
  TEAR_RANGE,

  /** Corresponds to `CacheFlag.RANGE` (1 << 3) and `EntityPlayer.TearFallingAcceleration`. */
  TEAR_FALLING_ACCELERATION,

  /** Corresponds to `CacheFlag.RANGE` (1 << 3) and `EntityPlayer.TearFallingSpeed`. */
  TEAR_FALLING_SPEED,

  /** Corresponds to `CacheFlag.SPEED` (1 << 4) and `EntityPlayer.MoveSpeed`. */
  MOVE_SPEED,

  /** Corresponds to `CacheFlag.TEAR_FLAG` (1 << 5) and `EntityPlayer.TearFlags`. */
  TEAR_FLAG,

  /** Corresponds to `CacheFlag.TEAR_COLOR` (1 << 6) and `EntityPlayer.TearColor`. */
  TEAR_COLOR,

  /** Corresponds to `CacheFlag.FLYING` (1 << 7) and `EntityPlayer.CanFly`. */
  FLYING,

  // - `CacheFlag.WEAPON` (1 << 8) does not have a corresponding `EntityPlayer` field.
  // - `CacheFlag.FAMILIARS` (1 << 9) does not have a corresponding `EntityPlayer` field.

  /** Corresponds to `CacheFlag.LUCK` (1 << 10) and `EntityPlayer.Luck`. */
  LUCK,

  /** Corresponds to `CacheFlag.SIZE` (1 << 11) and `EntityPlayer.SpriteScale`. */
  SIZE,

  // - `CacheFlag.COLOR` (1 << 12) does not have a corresponding `EntityPlayer` field.
  // - `CacheFlag.PICKUP_VISION` (1 << 13) does not have a corresponding `EntityPlayer` field.
}

----
enums\PocketItemType.ts
/** This is used in the various pocket item helper functions. */
export enum PocketItemType {
  EMPTY,
  CARD,
  PILL,
  ACTIVE_ITEM,
  DICE_BAG_DICE,
  UNDETERMINABLE,
}

----
enums\RockAltType.ts
/** This is used in the various rock alt type helper functions. */
export enum RockAltType {
  URN,
  MUSHROOM,
  SKULL,
  POLYP,

  /**
   * Destroying buckets in Downpour give different outcomes than in Dross.
   *
   * See: https://bindingofisaacrebirth.fandom.com/wiki/Rocks#Buckets
   */
  BUCKET_DOWNPOUR,

  /**
   * Destroying buckets in Dross give different outcomes than in Downpour.
   *
   * See: https://bindingofisaacrebirth.fandom.com/wiki/Rocks#Buckets
   */
  BUCKET_DROSS,
}

----
enums\SaveDataKey.ts
/**
 * These are the types of keys that you can put on the local variables that you feed to the save
 * data manager.
 */
export enum SaveDataKey {
  PERSISTENT = "persistent",
  RUN = "run",
  LEVEL = "level",
  ROOM = "room",
}

----
enums\SerializationType.ts
/** This is used with the `deepCopy` and `merge` functions. */
export enum SerializationType {
  NONE,
  SERIALIZE,
  DESERIALIZE,
}

----
enums\SlotDestructionType.ts
/** This is used in the `POST_SLOT_DESTROYED` custom callback. */
export enum SlotDestructionType {
  /**
   * When a machine or a beggar is blown up by a bomb or is otherwise removed without spawning a
   * collectible.
   *
   * Note that the destruction type for a Crane Game will be `SlotDestructionType.NORMAL`, even if
   * it destroyed via spawning three separate collectibles.
   */
  NORMAL,

  /**
   * When a machine or a beggar is removed while spawning a collectible reward.
   *
   * Note that the destruction type for a Crane Game will be `SlotDestructionType.NORMAL`, even if
   * it destroyed via spawning three separate collectibles.
   */
  COLLECTIBLE_PAYOUT,
}

----
enums\private\GridEntityTypeCustom.ts
import type { GridEntityType } from "isaac-typescript-definitions";

export const GridEntityTypeCustom = {
  /**
   * We arbitrarily choose 1000 as to not conflict with end-user mods. (The expectation is that
   * end-user mods will begin their enums with values of 0 and increment upwards.)
   */
  TRAPDOOR_CUSTOM: 1000 as GridEntityType,
} as const;

----
enums\private\SerializationBrand.ts
/**
 * During serialization, we write an arbitrary string key to the object with a value of an empty
 * string. This is used during deserialization to instantiate the correct type of object.
 */
export enum SerializationBrand {
  // Specific TSTL class brands.
  DEFAULT_MAP = "__TSTL_DEFAULT_MAP",
  MAP = "__TSTL_MAP",
  SET = "__TSTL_SET",

  // Specific Isaac API class brands.
  BIT_SET_128 = "__BIT_SET_128",
  COLOR = "__COLOR",
  K_COLOR = "__K_COLOR",
  RNG = "__RNG",
  VECTOR = "__VECTOR",

  /**
   * This is set to the value that represents the default value (instead of an empty string like the
   * other brands are).
   */
  DEFAULT_MAP_VALUE = "__TSTL_DEFAULT_MAP_VALUE",

  /**
   * The JSON library is unable to distinguish between a maps with number keys and an array. It will
   * assume that both of these are an array. Thus, in the case of a map with number keys, it will
   * insert null in every empty spot, leading to crashes.
   *
   * For example, a map with keys of 5 and 10 would be converted to the following array: `[null,
   * null, null, null, "myValueForKey5", null, null, null, null, "myValueForKey10"]`
   *
   * The deep copier works around this by converting number keys to strings. It inserts this brand
   * to keep track of the mutation.
   */
  OBJECT_WITH_NUMBER_KEYS = "__TSTL_OBJECT_WITH_NUMBER_KEYS",

  /**
   * This brand represents a user-defined class other than a `DefaultMap`, `Map`, or `Set`. It will
   * have a string value that corresponds to the name of the class.
   */
  TSTL_CLASS = "__TSTL_CLASS",
}

----
enums\private\StageTravelState.ts
export enum StageTravelState {
  NONE,
  PLAYERS_JUMPING_DOWN,
  PIXELATION_TO_BLACK,
  WAITING_FOR_FIRST_PIXELATION_TO_END,
  WAITING_FOR_SECOND_PIXELATION_TO_GET_HALF_WAY,
  PIXELATION_TO_ROOM,
  PLAYERS_LAYING_DOWN,
}

----
enums\private\TrapdoorAnimation.ts
export enum TrapdoorAnimation {
  OPENED = "Opened",
  CLOSED = "Closed",
  OPEN_ANIMATION = "Open Animation",
}

----
enums\private\UIStreakAnimation.ts
/** Corresponds to "resources/gfx/ui/ui_streak.anm2". */
export enum UIStreakAnimation {
  NONE,
  TEXT,
  TEXT_STAY,
}

----
features.ts
import type { ModCallbackCustomToClass } from "./callbacks";
import { CustomGridEntities } from "./classes/features/callbackLogic/CustomGridEntities";
import { CustomRevive } from "./classes/features/callbackLogic/CustomRevive";
import { EsauJrDetection } from "./classes/features/callbackLogic/EsauJrDetection";
import { FlipDetection } from "./classes/features/callbackLogic/FlipDetection";
import { GameReorderedCallbacks } from "./classes/features/callbackLogic/GameReorderedCallbacks";
import { GridEntityCollisionDetection } from "./classes/features/callbackLogic/GridEntityCollisionDetection";
import { GridEntityRenderDetection } from "./classes/features/callbackLogic/GridEntityRenderDetection";
import { GridEntityUpdateDetection } from "./classes/features/callbackLogic/GridEntityUpdateDetection";
import { ItemPickupDetection } from "./classes/features/callbackLogic/ItemPickupDetection";
import { PickupChangeDetection } from "./classes/features/callbackLogic/PickupChangeDetection";
import { PlayerCollectibleDetection } from "./classes/features/callbackLogic/PlayerCollectibleDetection";
import { PlayerReorderedCallbacks } from "./classes/features/callbackLogic/PlayerReorderedCallbacks";
import { SlotDestroyedDetection } from "./classes/features/callbackLogic/SlotDestroyedDetection";
import { SlotRenderDetection } from "./classes/features/callbackLogic/SlotRenderDetection";
import { SlotUpdateDetection } from "./classes/features/callbackLogic/SlotUpdateDetection";
import { CharacterHealthConversion } from "./classes/features/other/CharacterHealthConversion";
import { CharacterStats } from "./classes/features/other/CharacterStats";
import { CollectibleItemPoolType } from "./classes/features/other/CollectibleItemPoolType";
import { CustomHotkeys } from "./classes/features/other/CustomHotkeys";
import { CustomItemPools } from "./classes/features/other/CustomItemPools";
import { CustomPickups } from "./classes/features/other/CustomPickups";
import { CustomStages } from "./classes/features/other/CustomStages";
import { CustomTrapdoors } from "./classes/features/other/CustomTrapdoors";
import { DebugDisplay } from "./classes/features/other/DebugDisplay";
import { DeployJSONRoom } from "./classes/features/other/DeployJSONRoom";
import { DisableAllSound } from "./classes/features/other/DisableAllSound";
import { DisableInputs } from "./classes/features/other/DisableInputs";
import { EdenStartingStatsHealth } from "./classes/features/other/EdenStartingStatsHealth";
import { ExtraConsoleCommands } from "./classes/features/other/ExtraConsoleCommands";
import { FadeInRemover } from "./classes/features/other/FadeInRemover";
import { FastReset } from "./classes/features/other/FastReset";
import { FlyingDetection } from "./classes/features/other/FlyingDetection";
import { ForgottenSwitch } from "./classes/features/other/ForgottenSwitch";
import { ItemPoolDetection } from "./classes/features/other/ItemPoolDetection";
import { ModdedElementDetection } from "./classes/features/other/ModdedElementDetection";
import { ModdedElementSets } from "./classes/features/other/ModdedElementSets";
import { NoSirenSteal } from "./classes/features/other/NoSirenSteal";
import { Pause } from "./classes/features/other/Pause";
import { PersistentEntities } from "./classes/features/other/PersistentEntities";
import { PickupIndexCreation } from "./classes/features/other/PickupIndexCreation";
import { PlayerCollectibleTracking } from "./classes/features/other/PlayerCollectibleTracking";
import { PonyDetection } from "./classes/features/other/PonyDetection";
import { PressInput } from "./classes/features/other/PressInput";
import { PreventChildEntities } from "./classes/features/other/PreventChildEntities";
import { PreventGridEntityRespawn } from "./classes/features/other/PreventGridEntityRespawn";
import { RerunDetection } from "./classes/features/other/RerunDetection";
import { RoomClearFrame } from "./classes/features/other/RoomClearFrame";
import { RoomHistory } from "./classes/features/other/RoomHistory";
import { RunInNFrames } from "./classes/features/other/RunInNFrames";
import { RunNextRoom } from "./classes/features/other/RunNextRoom";
import { RunNextRun } from "./classes/features/other/RunNextRun";
import { SaveDataManager } from "./classes/features/other/SaveDataManager";
import { SpawnRockAltRewards } from "./classes/features/other/SpawnRockAltRewards";
import { StageHistory } from "./classes/features/other/StageHistory";
import { StartAmbush } from "./classes/features/other/StartAmbush";
import { TaintedLazarusPlayers } from "./classes/features/other/TaintedLazarusPlayers";
import { UnlockAchievementsDetection } from "./classes/features/other/UnlockAchievementsDetection";
import type { Feature } from "./classes/private/Feature";
import { ISCFeature } from "./enums/ISCFeature";
import { ModCallbackCustom } from "./enums/ModCallbackCustom";
import { interfaceSatisfiesEnum } from "./functions/enums";
import type { ModUpgradedInterface } from "./interfaces/private/ModUpgradedInterface";

export interface ISCFeatureToClass {
  // Callback logic
  [ISCFeature.CUSTOM_REVIVE]: CustomRevive;
  [ISCFeature.ESAU_JR_DETECTION]: EsauJrDetection;
  [ISCFeature.FLIP_DETECTION]: FlipDetection;
  [ISCFeature.GRID_ENTITY_COLLISION_DETECTION]: GridEntityCollisionDetection;
  [ISCFeature.GRID_ENTITY_RENDER_DETECTION]: GridEntityRenderDetection;
  [ISCFeature.GRID_ENTITY_UPDATE_DETECTION]: GridEntityUpdateDetection;
  [ISCFeature.GAME_REORDERED_CALLBACKS]: GameReorderedCallbacks;
  [ISCFeature.ITEM_PICKUP_DETECTION]: ItemPickupDetection;
  [ISCFeature.PICKUP_CHANGE_DETECTION]: PickupChangeDetection;
  [ISCFeature.PLAYER_COLLECTIBLE_DETECTION]: PlayerCollectibleDetection;
  [ISCFeature.PLAYER_REORDERED_CALLBACKS]: PlayerReorderedCallbacks;
  [ISCFeature.SLOT_DESTROYED_DETECTION]: SlotDestroyedDetection;
  [ISCFeature.SLOT_RENDER_DETECTION]: SlotRenderDetection;
  [ISCFeature.SLOT_UPDATE_DETECTION]: SlotUpdateDetection;

  // Extra features
  [ISCFeature.CHARACTER_HEALTH_CONVERSION]: CharacterHealthConversion;
  [ISCFeature.CHARACTER_STATS]: CharacterStats;
  [ISCFeature.COLLECTIBLE_ITEM_POOL_TYPE]: CollectibleItemPoolType;
  [ISCFeature.CUSTOM_GRID_ENTITIES]: CustomGridEntities;
  [ISCFeature.CUSTOM_ITEM_POOLS]: CustomItemPools;
  [ISCFeature.CUSTOM_HOTKEYS]: CustomHotkeys;
  [ISCFeature.CUSTOM_PICKUPS]: CustomPickups;
  [ISCFeature.CUSTOM_STAGES]: CustomStages;
  [ISCFeature.CUSTOM_TRAPDOORS]: CustomTrapdoors;
  [ISCFeature.DEBUG_DISPLAY]: DebugDisplay;
  [ISCFeature.DEPLOY_JSON_ROOM]: DeployJSONRoom;
  [ISCFeature.DISABLE_ALL_SOUND]: DisableAllSound;
  [ISCFeature.DISABLE_INPUTS]: DisableInputs;
  [ISCFeature.EDEN_STARTING_STATS_HEALTH]: EdenStartingStatsHealth;
  [ISCFeature.FADE_IN_REMOVER]: FadeInRemover;
  [ISCFeature.FAST_RESET]: FastReset;
  [ISCFeature.FLYING_DETECTION]: FlyingDetection;
  [ISCFeature.FORGOTTEN_SWITCH]: ForgottenSwitch;
  [ISCFeature.EXTRA_CONSOLE_COMMANDS]: ExtraConsoleCommands;
  [ISCFeature.ITEM_POOL_DETECTION]: ItemPoolDetection;
  [ISCFeature.MODDED_ELEMENT_DETECTION]: ModdedElementDetection;
  [ISCFeature.MODDED_ELEMENT_SETS]: ModdedElementSets;
  [ISCFeature.NO_SIREN_STEAL]: NoSirenSteal;
  [ISCFeature.PAUSE]: Pause;
  [ISCFeature.PERSISTENT_ENTITIES]: PersistentEntities;
  [ISCFeature.PICKUP_INDEX_CREATION]: PickupIndexCreation;
  [ISCFeature.PLAYER_COLLECTIBLE_TRACKING]: PlayerCollectibleTracking;
  [ISCFeature.PONY_DETECTION]: PonyDetection;
  [ISCFeature.PRESS_INPUT]: PressInput;
  [ISCFeature.PREVENT_CHILD_ENTITIES]: PreventChildEntities;
  [ISCFeature.PREVENT_GRID_ENTITY_RESPAWN]: PreventGridEntityRespawn;
  [ISCFeature.RERUN_DETECTION]: RerunDetection;
  [ISCFeature.ROOM_CLEAR_FRAME]: RoomClearFrame;
  [ISCFeature.ROOM_HISTORY]: RoomHistory;
  [ISCFeature.RUN_IN_N_FRAMES]: RunInNFrames;
  [ISCFeature.RUN_NEXT_ROOM]: RunNextRoom;
  [ISCFeature.RUN_NEXT_RUN]: RunNextRun;
  [ISCFeature.SAVE_DATA_MANAGER]: SaveDataManager;
  [ISCFeature.SPAWN_ALT_ROCK_REWARDS]: SpawnRockAltRewards;
  [ISCFeature.STAGE_HISTORY]: StageHistory;
  [ISCFeature.START_AMBUSH]: StartAmbush;
  [ISCFeature.TAINTED_LAZARUS_PLAYERS]: TaintedLazarusPlayers;
  [ISCFeature.UNLOCK_ACHIEVEMENTS_DETECTION]: UnlockAchievementsDetection;
}

interfaceSatisfiesEnum<ISCFeatureToClass, ISCFeature>();

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function getFeatures(
  mod: ModUpgradedInterface,
  callbacks: ModCallbackCustomToClass,
) {
  // Some features rely on other features; we must initialize those first.
  const gameReorderedCallbacks = new GameReorderedCallbacks(
    callbacks[ModCallbackCustom.POST_GAME_STARTED_REORDERED],
    callbacks[ModCallbackCustom.POST_NEW_LEVEL_REORDERED],
    callbacks[ModCallbackCustom.POST_NEW_ROOM_REORDERED],
    callbacks[ModCallbackCustom.POST_GAME_STARTED_REORDERED_LAST],
  );

  const disableAllSound = new DisableAllSound();
  const disableInputs = new DisableInputs();
  const moddedElementDetection = new ModdedElementDetection();
  const ponyDetection = new PonyDetection();
  const pressInput = new PressInput();
  const roomClearFrame = new RoomClearFrame();
  const roomHistory = new RoomHistory();
  const runNextRoom = new RunNextRoom();
  const saveDataManager = new SaveDataManager(mod);
  const stageHistory = new StageHistory();

  const runInNFrames = new RunInNFrames(roomHistory);
  const pickupIndexCreation = new PickupIndexCreation(
    roomHistory,
    saveDataManager,
  );

  const customGridEntities = new CustomGridEntities(runInNFrames);
  const moddedElementSets = new ModdedElementSets(moddedElementDetection);
  const itemPoolDetection = new ItemPoolDetection(moddedElementSets);
  const pause = new Pause(disableInputs);
  const preventGridEntityRespawn = new PreventGridEntityRespawn(runInNFrames);

  const customTrapdoors = new CustomTrapdoors(
    customGridEntities,
    disableInputs,
    ponyDetection,
    roomClearFrame,
    runInNFrames,
    runNextRoom,
    stageHistory,
  );

  const features = {
    // Callback logic
    [ISCFeature.CUSTOM_REVIVE]: new CustomRevive(
      callbacks[ModCallbackCustom.PRE_CUSTOM_REVIVE],
      callbacks[ModCallbackCustom.POST_CUSTOM_REVIVE],
      runInNFrames,
    ),
    [ISCFeature.ESAU_JR_DETECTION]: new EsauJrDetection(
      callbacks[ModCallbackCustom.POST_ESAU_JR],
      callbacks[ModCallbackCustom.POST_FIRST_ESAU_JR],
    ),
    [ISCFeature.FLIP_DETECTION]: new FlipDetection(
      callbacks[ModCallbackCustom.POST_FLIP],
      callbacks[ModCallbackCustom.POST_FIRST_FLIP],
    ),
    [ISCFeature.GRID_ENTITY_COLLISION_DETECTION]:
      new GridEntityCollisionDetection(
        callbacks[ModCallbackCustom.POST_GRID_ENTITY_COLLISION],
        callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_COLLISION],
        customGridEntities,
      ),
    [ISCFeature.GRID_ENTITY_UPDATE_DETECTION]: new GridEntityUpdateDetection(
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_INIT],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_INIT],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_UPDATE],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_REMOVE],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_REMOVE],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_STATE_CHANGED],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_STATE_CHANGED],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_BROKEN],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_BROKEN],
      customGridEntities,
    ),
    [ISCFeature.GRID_ENTITY_RENDER_DETECTION]: new GridEntityRenderDetection(
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_RENDER],
      callbacks[ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_RENDER],
      customGridEntities,
    ),
    [ISCFeature.GAME_REORDERED_CALLBACKS]: gameReorderedCallbacks,
    [ISCFeature.ITEM_PICKUP_DETECTION]: new ItemPickupDetection(
      callbacks[ModCallbackCustom.POST_ITEM_PICKUP],
      callbacks[ModCallbackCustom.PRE_ITEM_PICKUP],
    ),
    [ISCFeature.PICKUP_CHANGE_DETECTION]: new PickupChangeDetection(
      callbacks[ModCallbackCustom.POST_PICKUP_CHANGED],
      pickupIndexCreation,
    ),
    [ISCFeature.PLAYER_COLLECTIBLE_DETECTION]: new PlayerCollectibleDetection(
      callbacks[ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED],
      callbacks[ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED],
      moddedElementSets,
      runInNFrames,
    ),
    [ISCFeature.PLAYER_REORDERED_CALLBACKS]: new PlayerReorderedCallbacks(
      callbacks[ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED],
      callbacks[ModCallbackCustom.POST_PLAYER_RENDER_REORDERED],
      callbacks[ModCallbackCustom.POST_PLAYER_UPDATE_REORDERED],
    ),
    [ISCFeature.SLOT_DESTROYED_DETECTION]: new SlotDestroyedDetection(
      callbacks[ModCallbackCustom.POST_SLOT_DESTROYED],
      roomHistory,
    ),
    [ISCFeature.SLOT_RENDER_DETECTION]: new SlotRenderDetection(
      callbacks[ModCallbackCustom.POST_SLOT_RENDER],
      callbacks[ModCallbackCustom.POST_SLOT_ANIMATION_CHANGED],
    ),
    [ISCFeature.SLOT_UPDATE_DETECTION]: new SlotUpdateDetection(
      callbacks[ModCallbackCustom.POST_SLOT_INIT],
      callbacks[ModCallbackCustom.POST_SLOT_UPDATE],
    ),

    // Extra features
    [ISCFeature.CHARACTER_HEALTH_CONVERSION]: new CharacterHealthConversion(),
    [ISCFeature.CHARACTER_STATS]: new CharacterStats(),
    [ISCFeature.COLLECTIBLE_ITEM_POOL_TYPE]: new CollectibleItemPoolType(
      pickupIndexCreation,
    ),
    [ISCFeature.CUSTOM_GRID_ENTITIES]: customGridEntities,
    [ISCFeature.CUSTOM_ITEM_POOLS]: new CustomItemPools(),
    [ISCFeature.CUSTOM_HOTKEYS]: new CustomHotkeys(),
    [ISCFeature.CUSTOM_PICKUPS]: new CustomPickups(),
    [ISCFeature.CUSTOM_STAGES]: new CustomStages(
      customGridEntities,
      customTrapdoors,
      disableAllSound,
      gameReorderedCallbacks,
      pause,
      runInNFrames,
    ),
    [ISCFeature.CUSTOM_TRAPDOORS]: customTrapdoors,
    [ISCFeature.DEBUG_DISPLAY]: new DebugDisplay(mod),
    [ISCFeature.DEPLOY_JSON_ROOM]: new DeployJSONRoom(preventGridEntityRespawn),
    [ISCFeature.DISABLE_ALL_SOUND]: disableAllSound,
    [ISCFeature.DISABLE_INPUTS]: disableInputs,
    [ISCFeature.EDEN_STARTING_STATS_HEALTH]: new EdenStartingStatsHealth(),
    [ISCFeature.FADE_IN_REMOVER]: new FadeInRemover(),
    [ISCFeature.FAST_RESET]: new FastReset(),
    [ISCFeature.FLYING_DETECTION]: new FlyingDetection(moddedElementSets),
    [ISCFeature.FORGOTTEN_SWITCH]: new ForgottenSwitch(pressInput),
    [ISCFeature.EXTRA_CONSOLE_COMMANDS]: new ExtraConsoleCommands(),
    [ISCFeature.ITEM_POOL_DETECTION]: itemPoolDetection,
    [ISCFeature.MODDED_ELEMENT_DETECTION]: moddedElementDetection,
    [ISCFeature.MODDED_ELEMENT_SETS]: moddedElementSets,
    [ISCFeature.NO_SIREN_STEAL]: new NoSirenSteal(),
    [ISCFeature.PAUSE]: pause,
    [ISCFeature.PERSISTENT_ENTITIES]: new PersistentEntities(roomHistory),
    [ISCFeature.PICKUP_INDEX_CREATION]: pickupIndexCreation,
    [ISCFeature.PLAYER_COLLECTIBLE_TRACKING]: new PlayerCollectibleTracking(),
    [ISCFeature.PONY_DETECTION]: ponyDetection,
    [ISCFeature.PRESS_INPUT]: pressInput,
    [ISCFeature.PREVENT_CHILD_ENTITIES]: new PreventChildEntities(),
    [ISCFeature.PREVENT_GRID_ENTITY_RESPAWN]: preventGridEntityRespawn,
    [ISCFeature.RERUN_DETECTION]: new RerunDetection(),
    [ISCFeature.ROOM_CLEAR_FRAME]: roomClearFrame,
    [ISCFeature.ROOM_HISTORY]: roomHistory,
    [ISCFeature.RUN_IN_N_FRAMES]: runInNFrames,
    [ISCFeature.RUN_NEXT_ROOM]: runNextRoom,
    [ISCFeature.RUN_NEXT_RUN]: new RunNextRun(),
    [ISCFeature.SAVE_DATA_MANAGER]: saveDataManager,
    [ISCFeature.SPAWN_ALT_ROCK_REWARDS]: new SpawnRockAltRewards(
      itemPoolDetection,
    ),
    [ISCFeature.STAGE_HISTORY]: stageHistory,
    [ISCFeature.START_AMBUSH]: new StartAmbush(runInNFrames),
    [ISCFeature.TAINTED_LAZARUS_PLAYERS]: new TaintedLazarusPlayers(),
    [ISCFeature.UNLOCK_ACHIEVEMENTS_DETECTION]:
      new UnlockAchievementsDetection(),
  } as const satisfies Record<ISCFeature, Feature>;

  return features;
}

----
functions\ambush.ts
import { RoomType } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { AmbushType } from "../enums/AmbushType";

/**
 * Helper function to get the corresponding ambush type for the current room. Returns undefined if
 * the current room does not correspond to any particular ambush type.
 */
export function getAmbushType(): AmbushType | undefined {
  const room = game.GetRoom();
  const roomType = room.GetType();

  switch (roomType) {
    case RoomType.BOSS_RUSH: {
      return AmbushType.BOSS_RUSH;
    }

    case RoomType.CHALLENGE: {
      return AmbushType.CHALLENGE_ROOM;
    }

    default: {
      return undefined;
    }
  }
}

----
functions\array.ts
import { ReadonlySet } from "../types/ReadonlySet";
import type { WidenLiteral } from "../types/WidenLiteral";
import { getRandomInt } from "./random";
import { isRNG, newRNG } from "./rng";
import { sortNormal } from "./sort";
import { isNumber, isTable } from "./types";
import { assertDefined, eRange } from "./utils";

/**
 * Helper function for determining if two arrays contain the exact same elements. Note that this
 * only performs a shallow comparison.
 */
export function arrayEquals<T>(
  array1: readonly T[],
  array2: readonly T[],
): boolean {
  if (array1.length !== array2.length) {
    return false;
  }

  return array1.every((array1Element, i) => {
    const array2Element = array2[i];
    return array1Element === array2Element;
  });
}

/**
 * Builds a new array based on the original array without the specified element(s). Returns the new
 * array. If the specified element(s) are not found in the array, it will simply return a shallow
 * copy of the array.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 *
 * If there is more than one matching element in the array, this function will only remove the first
 * matching element. If you want to remove all of the elements, use the `arrayRemoveAll` function
 * instead.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function arrayRemove<T>(
  originalArray: readonly T[],
  ...elementsToRemove: readonly T[]
): T[] {
  const elementsToRemoveSet = new ReadonlySet(elementsToRemove);

  const array: T[] = [];
  for (const element of originalArray) {
    if (!elementsToRemoveSet.has(element)) {
      array.push(element);
    }
  }

  return array;
}

/**
 * Shallow copies and removes the specified element(s) from the array. Returns the copied array. If
 * the specified element(s) are not found in the array, it will simply return a shallow copy of the
 * array.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 *
 * If there is more than one matching element in the array, this function will remove every matching
 * element. If you want to only remove the first matching element, use the `arrayRemove` function
 * instead.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function arrayRemoveAll<T>(
  originalArray: readonly T[],
  ...elementsToRemove: readonly T[]
): T[] {
  const array = copyArray(originalArray);
  arrayRemoveAllInPlace(array, ...elementsToRemove);
  return array;
}

/**
 * Removes all of the specified element(s) from the array. If the specified element(s) are not found
 * in the array, this function will do nothing.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 *
 * If there is more than one matching element in the array, this function will remove every matching
 * element. If you want to only remove the first matching element, use the `arrayRemoveInPlace`
 * function instead.
 *
 * @returns True if one or more elements were removed, false otherwise.
 */
export function arrayRemoveAllInPlace<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  ...elementsToRemove: readonly T[]
): boolean {
  let removedOneOrMoreElements = false;
  for (const element of elementsToRemove) {
    let index: number;
    do {
      index = array.indexOf(element);
      if (index > -1) {
        removedOneOrMoreElements = true;
        array.splice(index, 1);
      }
    } while (index > -1);
  }

  return removedOneOrMoreElements;
}

/**
 * Removes the specified element(s) from the array. If the specified element(s) are not found in the
 * array, this function will do nothing.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 *
 * If there is more than one matching element in the array, this function will only remove the first
 * matching element. If you want to remove all of the elements, use the `arrayRemoveAllInPlace`
 * function instead.
 *
 * @returns The removed elements. This will be an empty array if no elements were removed.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function arrayRemoveInPlace<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  ...elementsToRemove: readonly T[]
): T[] {
  const removedElements: T[] = [];

  for (const element of elementsToRemove) {
    const index = array.indexOf(element);
    if (index > -1) {
      const removedElement = array.splice(index, 1);
      removedElements.push(...removedElement);
    }
  }

  return removedElements;
}

/**
 * Shallow copies and removes the elements at the specified indexes from the array. Returns the
 * copied array. If the specified indexes are not found in the array, it will simply return a
 * shallow copy of the array.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function arrayRemoveIndex<T>(
  originalArray: readonly T[],
  ...indexesToRemove: readonly int[]
): T[] {
  const indexesToRemoveSet = new ReadonlySet(indexesToRemove);

  const array: T[] = [];
  for (const [i, element] of originalArray.entries()) {
    if (!indexesToRemoveSet.has(i)) {
      array.push(element);
    }
  }

  return array;
}

/**
 * Removes the elements at the specified indexes from the array. If the specified indexes are not
 * found in the array, this function will do nothing.
 *
 * This function is variadic, meaning that you can specify N arguments to remove N elements.
 *
 * @returns The removed elements. This will be an empty array if no elements were removed.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function arrayRemoveIndexInPlace<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  ...indexesToRemove: readonly int[]
): T[] {
  const legalIndexes = indexesToRemove.filter(
    (i) => i >= 0 && i < array.length,
  );

  if (legalIndexes.length === 0) {
    return [];
  }

  const legalIndexesSet = new ReadonlySet(legalIndexes);
  const removedElements: T[] = [];

  for (let i = array.length - 1; i >= 0; i--) {
    if (legalIndexesSet.has(i)) {
      const removedElement = array.splice(i, 1);
      removedElements.push(...removedElement);
    }
  }

  return removedElements;
}

export function arrayToString(array: readonly unknown[]): string {
  if (array.length === 0) {
    return "[]";
  }

  const strings = array.map((element) => tostring(element));
  const commaSeparatedStrings = strings.join(", ");
  return `[${commaSeparatedStrings}]`;
}

/**
 * Helper function to combine two or more arrays. Returns a new array that is the composition of all
 * of the specified arrays.
 *
 * This function is variadic, meaning that you can specify N arguments to combine N arrays. Note
 * that this will only perform a shallow copy of the array elements.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function combineArrays<T>(...arrays: ReadonlyArray<readonly T[]>): T[] {
  const elements: T[] = [];
  for (const array of arrays) {
    for (const element of array) {
      elements.push(element);
    }
  }

  return elements;
}

/**
 * Helper function to perform a shallow copy.
 *
 * @param oldArray The array to copy.
 * @param numElements Optional. If specified, will only copy the first N elements. By default, the
 *                    entire array will be copied.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function copyArray<T>(oldArray: readonly T[], numElements?: int): T[] {
  // Using the spread operator was benchmarked to be faster than manually creating an array using
  // the below algorithm.
  if (numElements === undefined) {
    return [...oldArray];
  }

  const newArrayWithFirstNElements: T[] = [];
  for (let i = 0; i < numElements; i++) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    newArrayWithFirstNElements.push(oldArray[i]!);
  }

  return newArrayWithFirstNElements;
}

/** Helper function to remove all of the elements in an array in-place. */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function emptyArray<T>(array: T[]): void {
  array.splice(0, array.length);
}

/**
 * Helper function to perform a filter and a map at the same time. Similar to `Array.map`, provide a
 * function that transforms a value, but return `undefined` if the value should be skipped. (Thus,
 * this function cannot be used in situations where `undefined` can be a valid array element.)
 *
 * This function is useful because the `Array.map` method will always produce an array with the same
 * amount of elements as the original array.
 *
 * This is named `filterMap` after the Rust function:
 * https://doc.rust-lang.org/std/iter/struct.FilterMap.html
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function filterMap<OldT, NewT>(
  array: readonly OldT[],
  func: (element: OldT) => NewT | undefined,
): NewT[] {
  const filteredArray: NewT[] = [];

  for (const element of array) {
    const newElement = func(element);
    if (newElement !== undefined) {
      filteredArray.push(newElement);
    }
  }

  return filteredArray;
}

/**
 * Helper function to get all possible combinations of the given array. This includes the
 * combination of an empty array.
 *
 * For example, if this function is provided an array containing 1, 2, and 3, then it will return an
 * array containing the following arrays:
 *
 * - [] (if `includeEmptyArray` is set to true)
 * - [1]
 * - [2]
 * - [3]
 * - [1, 2]
 * - [1, 3]
 * - [2, 3]
 * - [1, 2, 3]
 *
 * From: https://github.com/firstandthird/combinations/blob/master/index.js
 *
 * @param array The array to get the combinations of.
 * @param includeEmptyArray Whether to include an empty array in the combinations.
 * @param min Optional. The minimum number of elements to include in each combination. Default is 1.
 * @param max Optional. The maximum number of elements to include in each combination. Default is
 *            the length of the array.
 */
export function getArrayCombinations<T>(
  array: readonly T[],
  includeEmptyArray: boolean,
  min?: int,
  max?: int,
): ReadonlyArray<readonly T[]> {
  if (min === undefined || min <= 0) {
    min = 1;
  }
  if (max === undefined || max <= 0) {
    max = array.length;
  }

  const all: Array<readonly T[]> = [];
  for (let i = min; i < array.length; i++) {
    addCombinations(i, array, [], all);
  }
  if (array.length === max) {
    all.push(array);
  }

  // Finally, account for the empty array combination.
  if (includeEmptyArray) {
    all.unshift([]);
  }

  return all;
}

/** Mutates the `all` array in-place. */
function addCombinations<T>(
  n: number,
  src: readonly T[],
  got: readonly T[],
  all: Array<readonly T[]>,
) {
  if (n === 0) {
    if (got.length > 0) {
      all[all.length] = got;
    }

    return;
  }

  for (const [i, element] of src.entries()) {
    addCombinations(n - 1, src.slice(i + 1), [...got, element], all);
  }
}

/**
 * Helper function to get the duplicate elements in an array. Only one element for each value will
 * be returned. The elements will be sorted before they are returned.
 */
export function getArrayDuplicateElements<T extends number | string>(
  array: readonly T[],
): readonly T[] {
  const duplicateElements = new Set<T>();
  const set = new Set<T>();

  for (const element of array) {
    if (set.has(element)) {
      duplicateElements.add(element);
    }
    set.add(element);
  }

  const values = [...duplicateElements];
  return values.sort(sortNormal);
}

/**
 * Helper function to get an array containing the indexes of an array.
 *
 * For example, an array of `["Apple", "Banana"]` would return an array of `[0, 1]`.
 *
 * Note that normally, you would use the `Object.keys` method to get the indexes of an array, but
 * due to implementation details of TypeScriptToLua, this results in an array of 1 through N
 * (instead of an array of 0 through N -1).
 */
export function getArrayIndexes<T>(array: readonly T[]): readonly int[] {
  return eRange(array.length);
}

/**
 * Helper function to get the highest value in an array. Returns undefined if there were no elements
 * in the array.
 */
export function getHighestArrayElement(
  array: readonly number[],
): number | undefined {
  if (array.length === 0) {
    return undefined;
  }

  let highestValue: number | undefined;

  for (const element of array) {
    if (highestValue === undefined || element > highestValue) {
      highestValue = element;
    }
  }

  return highestValue;
}

/**
 * Helper function to get the lowest value in an array. Returns undefined if there were no elements
 * in the array.
 */
export function getLowestArrayElement(
  array: readonly number[],
): number | undefined {
  if (array.length === 0) {
    return undefined;
  }

  let lowestValue: number | undefined;

  for (const element of array) {
    if (lowestValue === undefined || element < lowestValue) {
      lowestValue = element;
    }
  }

  return lowestValue;
}

/**
 * Helper function to get a random element from the provided array.
 *
 * If you want to get an unseeded element, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param array The array to get an element from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of elements to skip over if selected.
 */
export function getRandomArrayElement<T>(
  array: readonly T[],
  seedOrRNG: Seed | RNG | undefined,
  exceptions: readonly T[] = [],
): T {
  if (array.length === 0) {
    error(
      "Failed to get a random array element since the provided array is empty.",
    );
  }

  const arrayToUse =
    exceptions.length > 0 ? arrayRemove(array, ...exceptions) : array;
  const randomIndex = getRandomArrayIndex(arrayToUse, seedOrRNG);
  const randomElement = arrayToUse[randomIndex];
  assertDefined(
    randomElement,
    `Failed to get a random array element since the random index of ${randomIndex} was not valid.`,
  );

  return randomElement;
}

/**
 * Helper function to get a random element from the provided array. Once the random element is
 * decided, it is then removed from the array (in-place).
 *
 * If you want to get an unseeded element, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param array The array to get an element from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of elements to skip over if selected.
 */
export function getRandomArrayElementAndRemove<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  seedOrRNG: Seed | RNG | undefined,
  exceptions: readonly T[] = [],
): T {
  const randomArrayElement = getRandomArrayElement(
    array,
    seedOrRNG,
    exceptions,
  );
  arrayRemoveInPlace(array, randomArrayElement);
  return randomArrayElement;
}

/**
 * Helper function to get a random index from the provided array.
 *
 * If you want to get an unseeded index, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param array The array to get the index from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of indexes that will be skipped over when getting the random
 *                   index. Default is an empty array.
 */
export function getRandomArrayIndex<T>(
  array: readonly T[],
  seedOrRNG: Seed | RNG | undefined,
  exceptions: readonly int[] = [],
): int {
  if (array.length === 0) {
    error(
      "Failed to get a random array index since the provided array is empty.",
    );
  }

  return getRandomInt(0, array.length - 1, seedOrRNG, exceptions);
}

/**
 * Similar to the `Array.includes` method, but works on a widened version of the array.
 *
 * This is useful when the normal `Array.includes` produces a type error from an array that uses an
 * `as const` assertion.
 */
export function includes<T, TupleElement extends WidenLiteral<T>>(
  array: readonly TupleElement[],
  searchElement: WidenLiteral<T>,
): searchElement is TupleElement {
  const widenedArray: ReadonlyArray<WidenLiteral<T>> = array;
  return widenedArray.includes(searchElement);
}

/**
 * Since Lua uses tables for every non-primitive data structure, it is non-trivial to determine if a
 * particular table is being used as an array. `isArray` returns true if:
 *
 * - the table contains all numerical indexes that are contiguous, starting at 1
 * - the table has no keys (i.e. an "empty" table)
 *
 * @param object The object to analyze.
 * @param ensureContiguousValues Optional. Whether the Lua table has to have all contiguous keys in
 *                               order to be considered an array. Default is true.
 */
export function isArray(
  object: unknown,
  ensureContiguousValues = true,
): object is unknown[] {
  if (!isTable(object)) {
    return false;
  }

  // First, if there is a metatable, this cannot be a simple array and must be a more complex
  // object.
  const metatable = getmetatable(object);
  if (metatable !== undefined) {
    return false;
  }

  // Second, handle the case of an "empty" table.
  const keys = Object.keys(object);
  if (keys.length === 0) {
    return true;
  }

  // Third, handle the case of non-numerical keys.
  const hasAllNumberKeys = keys.every((key) => isNumber(key));
  if (!hasAllNumberKeys) {
    return false;
  }

  // Fourth, check for non-contiguous elements. (Lua tables start at an index of 1.)
  if (ensureContiguousValues) {
    for (let i = 1; i <= keys.length; i++) {
      const element = object.get(i);
      if (element === undefined) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Helper function to see if every element in the array is N + 1.
 *
 * For example, `[2, 3, 4]` would return true, and `[2, 3, 5]` would return false.
 */
export function isArrayContiguous(array: readonly int[]): boolean {
  let lastValue: int | undefined;
  for (const element of array) {
    if (lastValue === undefined) {
      lastValue = element - 1;
    }

    if (element !== lastValue - 1) {
      return false;
    }
  }

  return true;
}

/**
 * Helper function to check if all the elements of an array are unique within that array.
 *
 * Under the hood, this is performed by converting the array to a set.
 */
export function isArrayElementsUnique(array: readonly unknown[]): boolean {
  const set = new Set(array);
  return set.size === array.length;
}

/** Checks if an array is in the provided 2-dimensional array. */
export function isArrayInArray<T>(
  arrayToMatch: readonly T[],
  parentArray: ReadonlyArray<readonly T[]>,
): boolean {
  return parentArray.some((element) => arrayEquals(element, arrayToMatch));
}

/** Helper function to set every element in an array to a specific value. */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function setAllArrayElements<T>(array: T[], value: T): void {
  for (let i = 0; i < array.length; i++) {
    array[i] = value;
  }
}

/**
 * Shallow copies and shuffles the array using the Fisher-Yates algorithm. Returns the copied array.
 *
 * If you want an unseeded shuffle, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * From: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 *
 * @param originalArray The array to shuffle.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function shuffleArray<T>(
  originalArray: readonly T[],
  seedOrRNG: Seed | RNG | undefined,
): T[] {
  const array = copyArray(originalArray);
  shuffleArrayInPlace(array, seedOrRNG);

  return array;
}

/**
 * Shuffles the provided array in-place using the Fisher-Yates algorithm.
 *
 * If you want an unseeded shuffle, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * From: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
 *
 * @param array The array to shuffle.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function shuffleArrayInPlace<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  seedOrRNG: Seed | RNG | undefined,
): void {
  let currentIndex = array.length;

  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  while (currentIndex > 0) {
    currentIndex--;

    const randomIndex = getRandomArrayIndex(array, rng);
    swapArrayElements(array, currentIndex, randomIndex);
  }
}

/** Helper function to sum every value in an array together. */
export function sumArray(array: readonly number[]): number {
  return array.reduce((accumulator, element) => accumulator + element, 0);
}

/**
 * Helper function to swap two different array elements. (The elements will be swapped in-place.)
 */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function swapArrayElements<T>(array: T[], i: number, j: number): void {
  const value1 = array[i]!; // eslint-disable-line @typescript-eslint/no-non-null-assertion
  const value2 = array[j]!; // eslint-disable-line @typescript-eslint/no-non-null-assertion

  array[i] = value2;
  array[j] = value1;
}

----
functions\arrayLua.ts
/**
 * These are a collection of functions for non-TypeScript users so that they can access some of
 * useful methods offered on the `Array` class in the JavaScript standard library.
 *
 * If you are a TypeScript user, you should never use these functions, and instead use the more
 * idiomatic object-oriented approach.
 *
 * @module
 */

/**
 * Helper function for non-TypeScript users to check if every element in the array is equal to a
 * condition.
 *
 * Internally, this just calls `Array.every`.
 */
export function every<T>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => boolean,
): boolean {
  return array.every(func);
}

/**
 * Helper function for non-TypeScript users to filter the elements in an array. Returns the filtered
 * array.
 *
 * Internally, this just calls `Array.filter`.
 */
export function filter<T>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => boolean,
): readonly T[] {
  return array.filter(func);
}

/**
 * Helper function for non-TypeScript users to find an element in an array.
 *
 * Internally, this just calls `Array.find`.
 */
export function find<T>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => boolean,
): T | undefined {
  return array.find(func);
}

/**
 * Helper function for non-TypeScript users to iterate over an array.
 *
 * Internally, this just calls `Array.forEach`.
 */
export function forEach<T>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => void,
): void {
  array.forEach(func); // eslint-disable-line unicorn/no-array-for-each
}

// `includes` is not included since there is a normal array helper function of that name.

/**
 * Helper function for non-TypeScript users to convert an array to a string with the specified
 * separator.
 *
 * Internally, this just calls `Array.join`.
 */
export function join<T>(array: readonly T[], separator: string): string {
  return array.join(separator);
}

/**
 * Helper function for non-TypeScript users to convert all of the elements in an array to something
 * else.
 *
 * Internally, this just calls `Array.map`.
 */
export function map<T, U>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => U,
): readonly U[] {
  return array.map(func);
}

/**
 * Helper function for non-TypeScript users to check if one or more elements in the array is equal
 * to a condition.
 *
 * Internally, this just calls `Array.some`.
 */
export function some<T>(
  array: readonly T[],
  func: (value: T, index: number, array: readonly T[]) => boolean,
): boolean {
  return array.some(func);
}

----
functions\benchmark.ts
import { log } from "./log";

/**
 * Helper function to benchmark the performance of a function.
 *
 * This function is variadic, which means that you can supply as many functions as you want to
 * benchmark.
 *
 * This function uses the `Isaac.GetTime` method to record how long the function took to execute.
 * This method only reports time in milliseconds. For this reason, if you are benchmarking smaller
 * functions, then you should provide a very high value for the number of trials.
 *
 * @returns An array containing the average time in milliseconds for each function. (This will also
 *          be printed to the log.)
 */
export function benchmark(
  numTrials: int,
  ...functions: ReadonlyArray<() => void>
): readonly int[] {
  log(`Benchmarking ${functions.length} function(s) with ${numTrials} trials.`);

  const averages: int[] = [];
  for (const [i, func] of functions.entries()) {
    let totalTimeMilliseconds = 0;
    for (let j = 0; j < numTrials; j++) {
      const startTimeMilliseconds = Isaac.GetTime();
      func();
      const endTimeMilliseconds = Isaac.GetTime();
      const elapsedTimeMilliseconds =
        endTimeMilliseconds - startTimeMilliseconds;
      totalTimeMilliseconds += elapsedTimeMilliseconds;
    }
    const averageTimeMilliseconds = totalTimeMilliseconds / numTrials;
    log(
      `The average time of the function at index ${i} is: ${averageTimeMilliseconds} milliseconds`,
    );
    averages.push(averageTimeMilliseconds);
  }

  return averages;
}

----
functions\bitSet128.ts
import type { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { isIsaacAPIClassOfType } from "./isaacAPIClass";
import {
  copyUserdataValuesToTable,
  getNumbersFromTable,
  tableHasKeys,
} from "./table";
import { isTable } from "./types";
import { assertDefined } from "./utils";

export type SerializedBitSet128 = LuaMap<string, unknown> & {
  readonly __serializedBitSet128Brand: symbol;
  readonly __kind: CopyableIsaacAPIClassType.BIT_SET_128;
};

const OBJECT_NAME = "BitSet128";
const KEYS = ["l", "h"] as const;

/** Helper function to copy a `BitSet128` Isaac API class. */
export function copyBitSet128(bitSet128: BitSet128): BitSet128 {
  if (!isBitSet128(bitSet128)) {
    error(
      `Failed to copy a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const lowBits = bitSet128.l;
  const highBits = bitSet128.h;

  return BitSet128(lowBits, highBits);
}

/**
 * Helper function to convert a `SerializedBitSet128` object to a normal `BitSet128` object. (This
 * is used by the save data manager when reading data from the "save#.dat" file.)
 */
export function deserializeBitSet128(
  bitSet128: SerializedBitSet128,
): BitSet128 {
  if (!isTable(bitSet128)) {
    error(
      `Failed to deserialize a ${OBJECT_NAME} object since the provided object was not a Lua table.`,
    );
  }

  const [l, h] = getNumbersFromTable(bitSet128, OBJECT_NAME, ...KEYS);

  assertDefined(
    l,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: l`,
  );
  assertDefined(
    h,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: h`,
  );

  return BitSet128(l, h);
}

/** Helper function to check if something is an instantiated `BitSet128` object. */
export function isBitSet128(object: unknown): object is BitSet128 {
  return isIsaacAPIClassOfType(object, OBJECT_NAME);
}

/**
 * Used to determine is the given table is a serialized `BitSet128` object created by the `deepCopy`
 * function.
 */
export function isSerializedBitSet128(
  object: unknown,
): object is SerializedBitSet128 {
  if (!isTable(object)) {
    return false;
  }

  return (
    tableHasKeys(object, ...KEYS) && object.has(SerializationBrand.BIT_SET_128)
  );
}

/**
 * Helper function to convert a `BitSet128` object to a `SerializedBitSet128` object. (This is used
 * by the save data manager when writing data from the "save#.dat" file.)
 */
export function serializeBitSet128(bitSet128: BitSet128): SerializedBitSet128 {
  if (!isBitSet128(bitSet128)) {
    error(
      `Failed to serialize a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const bitSet128Table = new LuaMap<string, unknown>();
  copyUserdataValuesToTable(bitSet128, KEYS, bitSet128Table);
  bitSet128Table.set(SerializationBrand.BIT_SET_128, "");
  return bitSet128Table as SerializedBitSet128;
}

----
functions\bitwise.ts
import { addFlag } from "./flag";
import { parseIntSafe } from "./types";
import { assertDefined } from "./utils";

/** Helper function to convert a set of flags to a single `BitFlags` object. */
export function arrayToBitFlags<T extends BitFlag | BitFlag128>(
  array: readonly T[],
): BitFlags<T> {
  let flags = 0 as BitFlags<T>;
  for (const flag of array) {
    flags = addFlag(flags, flag);
  }

  return flags;
}

/** Helper function to convert an array of bits to the resulting decimal number. */
export function convertBinaryToDecimal(bits: readonly int[]): number {
  const bitsString = bits.join("");
  return Number.parseInt(bitsString, 2);
}

/**
 * Helper function to convert a number to an array of bits.
 *
 * @param num The number to convert.
 * @param minLength Optional. Equal to the minimum amount of bits that should be returned. If the
 *                  converted number of bits is below this number, 0's will be padded to the left
 *                  side until the minimum length is met. Default is undefined (which will not cause
 *                  any padding).
 */
export function convertDecimalToBinary(
  num: number,
  minLength?: int,
): readonly int[] {
  const bits: int[] = [];

  const bitsString = num.toString(2);
  for (const bitString of bitsString) {
    const bit = parseIntSafe(bitString);
    assertDefined(
      bit,
      `Failed to convert the following number to binary: ${num}`,
    );

    bits.push(bit);
  }

  if (minLength !== undefined) {
    while (bits.length < minLength) {
      bits.unshift(0);
    }
  }

  return bits;
}

/**
 * Helper function to count the number of bits that are set to 1 in a binary representation of a
 * number.
 */
export function countSetBits(num: int): int {
  let count = 0;

  while (num > 0) {
    num &= num - 1;
    count++;
  }

  return count;
}

/** Helper function to get the value of a specific but in a binary representation of a number. */
export function getKBitOfN(k: int, n: int): int {
  return (n >>> k) & 1;
}

/** Helper function to get the number of bits in a binary representation of a number. */
export function getNumBitsOfN(n: int): int {
  let numBits = 0;
  while (n > 0) {
    numBits++;
    n >>>= 1;
  }

  return numBits;
}

/** Helper function to convert a set of flags to a single `BitFlags` object. */
export function setToBitFlags<T extends BitFlag | BitFlag128>(
  set: ReadonlySet<T>,
): BitFlags<T> {
  let flags = 0 as BitFlags<T>;
  for (const flag of set) {
    flags = addFlag(flags, flag);
  }

  return flags;
}

----
functions\bombs.ts
/** Helper function to find out how large a bomb explosion is based on the damage inflicted. */
export function getBombRadiusFromDamage(damage: float): float {
  if (damage > 175) {
    return 105;
  }

  if (damage <= 140) {
    return 75;
  }

  return 90;
}

----
functions\bosses.ts
import type { LevelStage, StageID } from "isaac-typescript-definitions";
import {
  BossID,
  EntityType,
  LokiVariant,
  UltraGreedVariant,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { VectorZero } from "../core/constants";
import { ENTITY_TYPE_VARIANT_TO_BOSS_ID_MAP } from "../maps/entityTypeVariantToBossIDMap";
import { BOSS_ID_TO_ENTITY_TYPE_VARIANT } from "../objects/bossIDToEntityTypeVariant";
import { BOSS_NAMES, DEFAULT_BOSS_NAME } from "../objects/bossNames";
import {
  ALL_BOSSES,
  BOSS_ID_TO_STAGE_IDS,
  NON_STORY_BOSSES,
  STAGE_ID_TO_BOSS_IDS,
  STAGE_TO_COMBINED_BOSS_SET_MAP,
} from "../sets/bossSets";
import { REPENTANCE_ONLY_BOSS_IDS_SET } from "../sets/repentanceBossIDsSet";
import { SIN_ENTITY_TYPES_SET } from "../sets/sinEntityTypesSet";
import { ReadonlySet } from "../types/ReadonlySet";
import { doesEntityExist } from "./entities";
import { getNPCs, spawnNPC } from "./entitiesSpecific";
import { getAliveNPCs } from "./npcs";
import { isRNG } from "./rng";
import { inBeastRoom, inDogmaRoom } from "./rooms";
import { repeat } from "./utils";

const BOSSES_THAT_REQUIRE_MULTIPLE_SPAWNS = new ReadonlySet<EntityType>([
  EntityType.LARRY_JR, // 19 (and The Hollow / Tuff Twins / The Shell)
  EntityType.CHUB, // 28 (and C.H.A.D. / The Carrion Queen)
  EntityType.LOKI, // 69 (only for Lokii)
  EntityType.GURGLING, // 237 (and Turdling)
  EntityType.TURDLET, // 918
]);

const DEFAULT_BOSS_MULTI_SEGMENTS = 4;

/**
 * Helper function to get all of the non-dead bosses in the room.
 *
 * This function will not include bosses on an internal blacklist, such as Death's scythes or Big
 * Horn holes.
 *
 * @param entityType Optional. If specified, will only get the bosses that match the type. Default
 *                   is -1, which matches every type.
 * @param variant Optional. If specified, will only get the bosses that match the variant. Default
 *                is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the bosses that match the sub-type. Default
 *                is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. Default is false.
 */
export function getAliveBosses(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): readonly EntityNPC[] {
  const aliveNPCs = getAliveNPCs(entityType, variant, subType, ignoreFriendly);
  return aliveNPCs.filter((aliveNPC) => aliveNPC.IsBoss());
}

/**
 * Helper function to get an array with every boss in the game. This is derived from the `BossID`
 * enum.
 *
 * This includes:
 * - Ultra Greed
 * - Ultra Greedier
 *
 * This does not include:
 * - mini-bosses (e.g. Ultra Pride, Krampus)
 * - bosses that do not appear in Boss Rooms (e.g. Uriel, Gabriel)
 * - the second phase of multi-phase bosses (e.g. Mega Satan 2)
 * - sub-bosses of The Beast fight (e.g. Ultra Famine, Ultra Pestilence, Ultra War, Ultra Death)
 * - bosses that do not have any Boss Rooms defined due to being unfinished (e.g. Raglich)
 *
 * Also see the `getAllNonStoryBosses` function.
 */
export function getAllBosses(): readonly BossID[] {
  return ALL_BOSSES;
}

/**
 * Helper function to get an array with every boss in the game. This is derived from the `BossID`
 * enum. This is the same thing as the `getAllBosses` helper function, but with story bosses
 * filtered out.
 */
export function getAllNonStoryBosses(): readonly BossID[] {
  return NON_STORY_BOSSES;
}

/**
 * Helper function to get the boss ID corresponding to the current room. Returns undefined if the
 * current room is not a Boss Room.
 *
 * Use this instead of the vanilla `Room.GetBossID` method since it has a saner return type and it
 * correctly handles Dogma, The Beast, and Ultra Greedier.
 */
export function getBossID(): BossID | undefined {
  if (inDogmaRoom()) {
    return BossID.DOGMA;
  }

  if (inBeastRoom()) {
    return BossID.BEAST;
  }

  const room = game.GetRoom();

  // eslint-disable-next-line deprecation/deprecation
  const bossID = room.GetBossID();
  if (bossID === 0) {
    return undefined;
  }

  // The Ultra Greed room holds both Ultra Greed and Ultra Greedier.
  if (
    bossID === BossID.ULTRA_GREED &&
    doesEntityExist(EntityType.ULTRA_GREED, UltraGreedVariant.ULTRA_GREEDIER)
  ) {
    return BossID.ULTRA_GREEDIER;
  }

  return bossID;
}

export function getBossIDFromEntityTypeVariant(
  entityType: EntityType,
  variant: int,
): BossID | undefined {
  const entityTypeVariant = `${entityType}.${variant}`;
  return ENTITY_TYPE_VARIANT_TO_BOSS_ID_MAP.get(entityTypeVariant);
}

/**
 * Helper function to get the set of vanilla bosses for a particular stage across all of the stage
 * types. For example, specifying `LevelStage.BASEMENT_2` will return a set with all of the bosses
 * for Basement, Cellar, Burning Basement, Downpour, and Dross.
 *
 * Also see the `getAllBossesSet` and `getBossIDsForStageID` functions.
 */
export function getBossIDsForStage(
  stage: LevelStage,
): ReadonlySet<BossID> | undefined {
  return STAGE_TO_COMBINED_BOSS_SET_MAP.get(stage);
}

/**
 * Helper function to get the set of vanilla bosses that can randomly appear on a particular stage
 * ID.
 *
 * Also see the `getAllBossesSet` and `getBossIDsForStage` functions.
 */
export function getBossIDsForStageID(
  stageID: StageID,
): readonly BossID[] | undefined {
  return STAGE_ID_TO_BOSS_IDS.get(stageID);
}

/**
 * Helper function to get the proper English name for a boss. For example, the name for
 * `BossID.WRETCHED` (36) is "The Wretched".
 */
export function getBossName(bossID: BossID): string {
  // Handle modded boss IDs.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return BOSS_NAMES[bossID] ?? DEFAULT_BOSS_NAME;
}

/** Helper function to get the set of stage IDs that a particular boss naturally appears in. */
export function getBossStageIDs(bossID: BossID): ReadonlySet<StageID> {
  return BOSS_ID_TO_STAGE_IDS[bossID];
}

/**
 * Helper function to get all of the bosses in the room.
 *
 * @param entityType Optional. If specified, will only get the bosses that match the type. Default
 *                   is -1, which matches every type.
 * @param variant Optional. If specified, will only get the bosses that match the variant. Default
 *                is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the bosses that match the sub-type. Default
 *                is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. Default is false.
 */
export function getBosses(
  entityType?: EntityType,
  variant?: int,
  subType?: int,
  ignoreFriendly = false,
): readonly EntityNPC[] {
  const npcs = getNPCs(entityType, variant, subType, ignoreFriendly);
  return npcs.filter((npc) => npc.IsBoss());
}

export function getEntityTypeVariantFromBossID(
  bossID: BossID,
): readonly [EntityType, int] {
  return BOSS_ID_TO_ENTITY_TYPE_VARIANT[bossID];
}

/**
 * Helper function to check if a boss is only found on a Repentance floor such as Dross, Mines, and
 * so on.
 *
 * For example, The Pile is a boss that was added in Repentance, but since it can appear in
 * Necropolis, it is not considered a Repentance boss for the purposes of this function.
 */
export function isRepentanceBoss(bossID: BossID): boolean {
  return REPENTANCE_ONLY_BOSS_IDS_SET.has(bossID);
}

/** Helper function to check if the provided NPC is a Sin miniboss, such as Sloth or Lust. */
export function isSin(npc: EntityNPC): boolean {
  return SIN_ENTITY_TYPES_SET.has(npc.Type);
}

function getNumBossSegments(
  entityType: EntityType,
  variant: int,
  numSegments: int | undefined,
) {
  if (numSegments !== undefined) {
    return numSegments;
  }

  switch (entityType) {
    // 28
    case EntityType.CHUB: {
      // Chub is always composed of 3 segments.
      return 3;
    }

    // 69
    case EntityType.LOKI: {
      return variant === LokiVariant.LOKII ? 2 : 1;
    }

    // 237
    case EntityType.GURGLING: {
      // Gurglings & Turdlings are always encountered in groups of 2.
      return 2;
    }

    default: {
      return DEFAULT_BOSS_MULTI_SEGMENTS;
    }
  }
}

/**
 * Helper function to spawn a boss.
 *
 * Use this function instead of `spawnNPC` since it handles automatically spawning multiple segments
 * for multi-segment bosses.
 *
 * By default, this will spawn Chub (and his variants) with 3 segments, Lokii with 2 copies,
 * Gurglings/Turdlings with 2 copies, and other multi-segment bosses with 4 segments. You can
 * customize this via the "numSegments" argument.
 */
export function spawnBoss(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
  numSegments?: int,
): EntityNPC {
  const seed = isRNG(seedOrRNG) ? seedOrRNG.Next() : seedOrRNG;
  const npc = spawnNPC(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seed,
  );

  if (BOSSES_THAT_REQUIRE_MULTIPLE_SPAWNS.has(entityType)) {
    const numBossSegments = getNumBossSegments(
      entityType,
      variant,
      numSegments,
    );
    const remainingSegmentsToSpawn = numBossSegments - 1;
    repeat(remainingSegmentsToSpawn, () => {
      spawnNPC(
        entityType,
        variant,
        subType,
        positionOrGridIndex,
        velocity,
        spawner,
        seed,
      );
    });
  }

  return npc;
}

/**
 * Helper function to spawn a boss with a specific seed.
 *
 * For more information, see the documentation for the `spawnBoss` function.
 */
export function spawnBossWithSeed(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  numSegments?: int,
): EntityNPC {
  const seed = isRNG(seedOrRNG) ? seedOrRNG.Next() : seedOrRNG;
  return spawnBoss(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seed,
    numSegments,
  );
}

----
functions\cards.ts
import type { CardType } from "isaac-typescript-definitions";
import { ItemConfigCardType, UseFlag } from "isaac-typescript-definitions";
import { POCKET_ITEM_SLOT_VALUES } from "../cachedEnumValues";
import { itemConfig } from "../core/cachedClasses";
import { LAST_VANILLA_CARD_TYPE } from "../core/constantsFirstLast";
import {
  CARD_DESCRIPTIONS,
  DEFAULT_CARD_DESCRIPTION,
} from "../objects/cardDescriptions";
import { CARD_NAMES, DEFAULT_CARD_NAME } from "../objects/cardNames";
import { ITEM_CONFIG_CARD_TYPES_FOR_CARDS } from "../sets/itemConfigCardTypesForCards";
import { addFlag } from "./flag";
import { asCardType } from "./types";

/**
 * Helper function to get a card description from a `CardType` value. Returns "Unknown" if the
 * provided card type is not valid.
 *
 * This function works for both vanilla and modded trinkets.
 *
 * For example, `getCardDescription(CardType.FOOL)` would return "Where journey begins".
 */
export function getCardDescription(cardType: CardType): string {
  // "ItemConfigCard.Description" is bugged with vanilla cards on patch v1.7.6, so we use a
  // hard-coded map as a workaround.
  const cardDescription = CARD_DESCRIPTIONS[cardType];
  // Handle modded cards.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (cardDescription !== undefined) {
    return cardDescription;
  }

  const itemConfigCard = itemConfig.GetCard(cardType);
  if (itemConfigCard !== undefined) {
    return itemConfigCard.Description;
  }

  return DEFAULT_CARD_DESCRIPTION;
}

/**
 * Helper function to get the name of a card. Returns "Unknown" if the provided card type is not
 * valid.
 *
 * This function works for both vanilla and modded trinkets.
 *
 * For example, `getCardName(Card.FOOL)` would return "0 - The Fool".
 */
export function getCardName(cardType: CardType): string {
  // "ItemConfigCard.Name" is bugged with vanilla cards on patch v1.7.6, so we use a hard-coded map
  // as a workaround.
  const cardName = CARD_NAMES[cardType];
  // Handle modded cards.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (cardName !== undefined) {
    return cardName;
  }

  const itemConfigCard = itemConfig.GetCard(cardType);
  if (itemConfigCard !== undefined) {
    return itemConfigCard.Name;
  }

  return DEFAULT_CARD_NAME;
}

/**
 * Helper function to get the item config card type of a particular card, rune, or object. For
 * example, the item config card type of `CardType.FOOL` is equal to `ItemConfigCardType.TAROT`.
 *
 * Returns undefined if the provided card type was not valid.
 */
export function getItemConfigCardType(
  cardType: CardType,
): ItemConfigCardType | undefined {
  const itemConfigCard = itemConfig.GetCard(cardType);
  if (itemConfigCard === undefined) {
    return undefined;
  }

  return itemConfigCard.CardType;
}

/**
 * Helper function to check if a player is holding a specific card in one of their pocket item
 * slots.
 *
 * This function is variadic, meaning that you can pass as many cards as you want to check for. The
 * function will return true if the player has any of the cards.
 */
export function hasCard(
  player: EntityPlayer,
  ...cardTypes: readonly CardType[]
): boolean {
  const cardTypesSet = new Set(cardTypes);
  return POCKET_ITEM_SLOT_VALUES.some((pocketItemSlot) => {
    const cardType = player.GetCard(pocketItemSlot);
    return cardTypesSet.has(cardType);
  });
}

/**
 * Returns true for card types that have the following item config card type:
 *
 * - `ItemConfigCardType.TAROT` (0)
 * - `ItemConfigCardType.SUIT` (1)
 * - `ItemConfigCardType.SPECIAL` (3)
 * - `ItemConfigCardType.TAROT_REVERSE` (5)
 */
export function isCard(cardType: CardType): boolean {
  const itemConfigCardType = getItemConfigCardType(cardType);
  if (itemConfigCardType === undefined) {
    return false;
  }

  return ITEM_CONFIG_CARD_TYPES_FOR_CARDS.has(itemConfigCardType);
}

/** Returns whether the given card type matches the specified item config card type. */
export function isCardType(
  cardType: CardType,
  itemConfigCardType: ItemConfigCardType,
): boolean {
  return itemConfigCardType === getItemConfigCardType(cardType);
}

/** Returns true for any card type added by a mod. */
export function isModdedCardType(cardType: CardType): boolean {
  return !isVanillaCardType(cardType);
}

/** Returns true for card types that have `ItemConfigCardType.SPECIAL_OBJECT`. */
export function isPocketItemObject(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.SPECIAL_OBJECT);
}

/** Returns true for card types that have `ItemConfigCardType.TAROT_REVERSE`. */
export function isReverseTarotCard(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.TAROT_REVERSE);
}

/** Returns true for card types that have `ItemConfigCardType.RUNE`. */
export function isRune(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.RUNE);
}

/** Returns true for card types that have `ItemConfigCardType.SPECIAL`. */
export function isSpecialCard(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.SPECIAL);
}

/** Returns true for card types that have `ItemConfigCardType.SUIT`. */
export function isSuitCard(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.SUIT);
}

/** Returns true for card types that have `ItemConfigCardType.TAROT`. */
export function isTarotCard(cardType: CardType): boolean {
  return isCardType(cardType, ItemConfigCardType.TAROT);
}

export function isValidCardType(cardType: int): cardType is CardType {
  const potentialCardType = asCardType(cardType);
  const itemConfigCard = itemConfig.GetCard(potentialCardType);
  return itemConfigCard !== undefined;
}

export function isVanillaCardType(cardType: CardType): boolean {
  return cardType <= LAST_VANILLA_CARD_TYPE;
}

/**
 * Helper function to use a card without showing an animation and without the announcer voice
 * playing.
 */
export function useCardTemp(player: EntityPlayer, cardType: CardType): void {
  const useFlags = addFlag(UseFlag.NO_ANIMATION, UseFlag.NO_ANNOUNCER_VOICE);
  player.UseCard(cardType, useFlags);
}

----
functions\challenges.ts
import type {
  BossID,
  CollectibleType,
  PlayerType,
  TrinketType,
} from "isaac-typescript-definitions";
import { Challenge } from "isaac-typescript-definitions";
import {
  CHALLENGE_BOSSES,
  DEFAULT_CHALLENGE_BOSS_ID,
} from "../objects/challengeBosses";
import {
  CHALLENGE_CHARACTERS,
  DEFAULT_CHALLENGE_CHARACTER,
} from "../objects/challengeCharacters";
import { CHALLENGE_COLLECTIBLE_TYPES } from "../objects/challengeCollectibleTypes";
import {
  CHALLENGE_NAMES,
  DEFAULT_CHALLENGE_NAME,
} from "../objects/challengeNames";
import { CHALLENGE_TRINKET_TYPE } from "../objects/challengeTrinketType";
import { log } from "./log";

/**
 * Helper function to clear the current challenge, which will restart the run on a new random
 * non-challenge seed with the current character.
 *
 * If the player is not in a challenge already, this function will do nothing.
 *
 * Under the hood, this function executes the `challenge 0` console command.
 */
export function clearChallenge(): void {
  if (onAnyChallenge()) {
    const command = `challenge ${Challenge.NULL}`;
    log(
      `Restarting the run to clear the current challenge with a console command of: ${command}`,
    );
    Isaac.ExecuteCommand(command);
  }
}

/**
 * Get the final boss of a challenge. This will only work for vanilla challenges.
 *
 * For modded challenges, `BossID.MOM` (6) will be returned.
 *
 * Note that for `Challenge.BACKASSWARDS` (31), this function will return `BossID.MEGA_SATAN` (55),
 * but this is not actually the final boss. (There is no final boss for this challenge.)
 */
export function getChallengeBoss(challenge: Challenge): BossID {
  const challengeBossID = CHALLENGE_BOSSES[challenge];
  // Handle modded challenges.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return challengeBossID ?? DEFAULT_CHALLENGE_BOSS_ID;
}

/**
 * Get the starting character of a challenge. This will only work for vanilla challenges.
 *
 * For modded challenges, `PlayerType.ISAAC` (0) will be returned.
 */
export function getChallengeCharacter(challenge: Challenge): PlayerType {
  const challengeCharacter = CHALLENGE_CHARACTERS[challenge];
  // Handle modded challenges.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return challengeCharacter ?? DEFAULT_CHALLENGE_CHARACTER;
}

/**
 * Get the extra starting collectibles for a challenge. This will only work for vanilla challenges.
 *
 * For modded challenges, an empty array will be returned.
 */
export function getChallengeCollectibleTypes(
  challenge: Challenge,
): readonly CollectibleType[] {
  return CHALLENGE_COLLECTIBLE_TYPES[challenge];
}

/**
 * Get the proper name for a `Challenge` enum. This will only work for vanilla challenges.
 *
 * For modded challenges, "Unknown" will be returned.
 */
export function getChallengeName(challenge: Challenge): string {
  const challengeName = CHALLENGE_NAMES[challenge];
  // Handle modded challenges.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return challengeName ?? DEFAULT_CHALLENGE_NAME;
}

/**
 * Get the extra starting trinket for a challenge. This will only work for vanilla challenges.
 *
 * If a challenge does not grant a starting trinket, `undefined` will be returned.
 *
 * For modded challenges, `undefined` will be returned.
 */
export function getChallengeTrinketType(
  challenge: Challenge,
): TrinketType | undefined {
  return CHALLENGE_TRINKET_TYPE[challenge];
}

/** Helper function to see if the player is playing any challenge. */
export function onAnyChallenge(): boolean {
  const challenge = Isaac.GetChallenge();
  return challenge !== Challenge.NULL;
}

/**
 * Helper function to check to see if the player is playing a particular challenge.
 *
 * This function is variadic, meaning that you can specify as many challenges as you want to check
 * for.
 */
export function onChallenge(...challenges: readonly Challenge[]): boolean {
  const challenge = Isaac.GetChallenge();
  return challenges.includes(challenge);
}

/**
 * Helper function to restart the run on a particular challenge.
 *
 * If the player is already in the particular challenge, this function will do nothing.
 *
 * Under the hood, this function executes the `challenge 0` console command.
 */
export function setChallenge(challenge: Challenge): void {
  if (!onChallenge(challenge)) {
    const command = `challenge ${challenge}`;
    log(
      `Restarting the run to set a challenge with a console command of: ${command}`,
    );
    Isaac.ExecuteCommand(command);
  }
}

----
functions\characters.ts
import type {
  CollectibleType,
  TrinketType,
} from "isaac-typescript-definitions";
import { PlayerType } from "isaac-typescript-definitions";
import { FLYING_CHARACTERS, MAIN_CHARACTERS } from "../core/constants";
import { LAST_VANILLA_CHARACTER } from "../core/constantsFirstLast";
import { CHARACTER_DAMAGE_MULTIPLIERS } from "../objects/characterDamageMultipliers";
import { CHARACTER_NAMES } from "../objects/characterNames";
import { CHARACTER_SPRITE_PNG_FILE_NAMES } from "../objects/characterSpritePNGFileNames";
import { CHARACTER_STARTING_COLLECTIBLE_TYPES } from "../objects/characterStartingCollectibleTypes";
import { CHARACTER_STARTING_TRINKET_TYPE } from "../objects/characterStartingTrinketTypes";
import { CHARACTERS_THAT_START_WITH_AN_ACTIVE_ITEM_SET } from "../sets/charactersThatStartWithAnActiveItemSet";
import { CHARACTERS_WITH_BLACK_HEART_FROM_ETERNAL_HEART_SET } from "../sets/charactersWithBlackHeartFromEternalHeartSet";
import { CHARACTERS_WITH_FREE_DEVIL_DEALS_SET } from "../sets/charactersWithFreeDevilDealsSet";
import { CHARACTERS_WITH_NO_RED_HEARTS_SET } from "../sets/charactersWithNoRedHeartsSet";
import { CHARACTERS_WITH_NO_SOUL_HEARTS_SET } from "../sets/charactersWithNoSoulHeartsSet";
import { LOST_STYLE_CHARACTERS_SET } from "../sets/lostStyleCharactersSet";
import { ReadonlySet } from "../types/ReadonlySet";

type MainCharacter = (typeof MAIN_CHARACTERS)[number];

const FLYING_CHARACTERS_SET = new ReadonlySet<PlayerType>(FLYING_CHARACTERS);
const MAIN_CHARACTERS_SET = new ReadonlySet<PlayerType>(MAIN_CHARACTERS);

const PNG_PATH_PREFIX = "characters/costumes";

/**
 * Helper function to determine if the given character can have red heart containers. Returns true
 * for characters like Isaac, Magdalene, or Cain. Returns true for Keeper and Tainted Keeper, even
 * though coin containers are not technically the same as red heart containers. Returns false for
 * characters like Blue Baby. Returns false for The Lost and Tainted Lost.
 */
export function canCharacterHaveRedHearts(character: PlayerType): boolean {
  return !CHARACTERS_WITH_NO_RED_HEARTS_SET.has(character);
}

/**
 * Helper function to determine if the given character can have soul hearts. Returns true for
 * characters like Isaac, Magdalene, or Cain. Returns false for characters like Bethany. Returns
 * false for The Lost and Tainted Lost.
 */
export function canCharacterHaveSoulHearts(character: PlayerType): boolean {
  return !CHARACTERS_WITH_NO_SOUL_HEARTS_SET.has(character);
}

/**
 * Helper function for determining whether the given character can take free Devil Deals. (e.g. The
 * Lost, Tainted Lost, etc.)
 */
export function canCharacterTakeFreeDevilDeals(character: PlayerType): boolean {
  return CHARACTERS_WITH_FREE_DEVIL_DEALS_SET.has(character);
}

/**
 * Normally, characters get a red heart container upon reaching a new floor with an eternal heart,
 * but some characters grant a black heart instead. Returns true for Dark Judas and Tainted Judas.
 * Otherwise, returns false.
 */
export function doesCharacterGetBlackHeartFromEternalHeart(
  character: PlayerType,
): boolean {
  return CHARACTERS_WITH_BLACK_HEART_FROM_ETERNAL_HEART_SET.has(character);
}

/**
 * Helper function to determine if the specified character starts with an active item.
 *
 * For the purposes of this function, the save file is considered to be fully unlocked (e.g. Isaac
 * is considered to starts with the D6, but this is not the case on a brand new save file).
 */
export function doesCharacterStartWithActiveItem(
  character: PlayerType,
): boolean {
  return CHARACTERS_THAT_START_WITH_AN_ACTIVE_ITEM_SET.has(character);
}

/**
 * Helper function to get the numerical damage multiplier for a character.
 *
 * @param character The character to get.
 * @param hasWhoreOfBabylon Optional. Whether the character has the Whore of Babylon effect
 *                          currently active. Defaults to false. This is necessary because Eve's
 *                          damage multiplier changes from 0.75 to 1 when she has Whore of Babylon
 *                          active.
 */
export function getCharacterDamageMultiplier(
  character: PlayerType,
  hasWhoreOfBabylon = false,
): float {
  if (character === PlayerType.EVE && hasWhoreOfBabylon) {
    return 1;
  }

  return CHARACTER_DAMAGE_MULTIPLIERS[character];
}

/**
 * - Most characters have a 56 frame death animation (i.e. the "Death" animation).
 * - The Lost and Tainted Lost have a 38 frame death animation (i.e. the "LostDeath" animation).
 * - Tainted Forgotten have a 20 frame death animation (i.e. the "ForgottenDeath" animation).
 */
export function getCharacterDeathAnimationName(character: PlayerType): string {
  if (LOST_STYLE_CHARACTERS_SET.has(character)) {
    return "LostDeath";
  }

  if (character === PlayerType.FORGOTTEN_B) {
    return "ForgottenDeath";
  }

  return "Death";
}

/**
 * Returns the maximum heart containers that the provided character can have. Normally, this is 12,
 * but with Keeper it is 3, and with Tainted Keeper it is 2. This does not account for Birthright or
 * Mother's Kiss; use the `getPlayerMaxHeartContainers` helper function for that.
 */
export function getCharacterMaxHeartContainers(character: PlayerType): int {
  // 14
  if (character === PlayerType.KEEPER) {
    return 3;
  }

  // 16
  if (character === PlayerType.FORGOTTEN) {
    return 6;
  }

  // 17
  if (character === PlayerType.SOUL) {
    return 6;
  }

  // 33
  if (character === PlayerType.KEEPER_B) {
    return 2;
  }

  return 12;
}

/** Helper function to get the name of a character. Returns "Unknown" for modded characters. */
export function getCharacterName(character: PlayerType): string {
  if (isModdedCharacter(character)) {
    return "Unknown";
  }

  return CHARACTER_NAMES[character];
}

/**
 * Helper function to get the path to the sprite for a particular character.
 *
 * For example, the file path for `PlayerType.ISAAC` is
 * "characters/costumes/character_001_isaac.png".
 */
export function getCharacterSpritePNGFilePath(character: PlayerType): string {
  const fileName = CHARACTER_SPRITE_PNG_FILE_NAMES[character];
  return `${PNG_PATH_PREFIX}/${fileName}`;
}

/**
 * Helper function to get the collectibles that are granted to a particular character at the
 * beginning of a run.
 *
 * Note that this will return an empty array for Eden and Tainted Eden.
 */
export function getCharacterStartingCollectibleTypes(
  character: PlayerType,
): readonly CollectibleType[] {
  return CHARACTER_STARTING_COLLECTIBLE_TYPES[character];
}

/**
 * Helper function to get the trinket that is granted to a particular character at the beginning of
 * a run. Returns undefined if the character does not start with a trinket.
 *
 * Note that this will return undefined for Eden and Tainted Eden.
 */
export function getCharacterStartingTrinketType(
  character: PlayerType,
): TrinketType | undefined {
  return CHARACTER_STARTING_TRINKET_TYPE[character];
}

/**
 * Helper function to get the "main" version of the character. In other words, this is the character
 * that selectable from the main menu (and has achievements related to completing the various bosses
 * and so on).
 *
 * For example, the main character for `PlayerType.MAGDALENE` (1) is also `PlayerType.MAGDALENE`
 * (1), but the main character for `PlayerType.LAZARUS_2` (11) would be `PlayerType.LAZARUS` (8).
 *
 * For `PlayerType.POSSESSOR` (-1) and modded characters, the same character will be returned.
 */
export function getMainCharacter(character: PlayerType): PlayerType {
  if (isMainCharacter(character) || isModdedCharacter(character)) {
    return character;
  }

  switch (character) {
    // -1
    case PlayerType.POSSESSOR: {
      return PlayerType.POSSESSOR;
    }

    // 11
    case PlayerType.LAZARUS_2: {
      return PlayerType.LAZARUS;
    }

    // 12
    case PlayerType.DARK_JUDAS: {
      return PlayerType.JUDAS;
    }

    // 17
    case PlayerType.SOUL: {
      return PlayerType.FORGOTTEN;
    }

    // 20
    case PlayerType.ESAU: {
      return PlayerType.JACOB;
    }

    // 38
    case PlayerType.LAZARUS_2_B: {
      return PlayerType.LAZARUS_2;
    }

    // 39
    case PlayerType.JACOB_2_B: {
      return PlayerType.JACOB_B;
    }

    // 40
    case PlayerType.SOUL_B: {
      return PlayerType.FORGOTTEN_B;
    }
  }
}

export function isFlyingCharacter(character: PlayerType): boolean {
  return FLYING_CHARACTERS_SET.has(character);
}

/**
 * Helper function to check if the provided character is one of the characters that are selectable
 * from the main menu (and have achievements related to completing the various bosses and so on).
 */
export function isMainCharacter(
  character: PlayerType,
): character is MainCharacter {
  return MAIN_CHARACTERS_SET.has(character);
}

export function isModdedCharacter(character: PlayerType): boolean {
  return !isVanillaCharacter(character);
}

export function isVanillaCharacter(character: PlayerType): boolean {
  return character <= LAST_VANILLA_CHARACTER;
}

----
functions\charge.ts
import {
  ActiveSlot,
  CollectibleType,
  ItemConfigChargeType,
  SoundEffect,
  TrinketType,
} from "isaac-typescript-definitions";
import { game, sfxManager } from "../core/cachedClasses";
import {
  getCollectibleChargeType,
  getCollectibleMaxCharges,
} from "./collectibles";
import { getActiveItemSlots } from "./playerCollectibles";
import { getPlayers } from "./playerIndex";
import { getRoomShapeCharges } from "./roomShape";

/**
 * Helper function to add a charge to the player's active item. Will flash the HUD and play the
 * appropriate sound effect, depending on whether the charge is partially full or completely full.
 *
 * If the player's active item is already fully charged, then this function will return 0 and not
 * flash the HUD or play a sound effect.
 *
 * This function will take the following things into account:
 * - The Battery
 * - AAA Battery
 *
 * @param player The player to grant the charges to.
 * @param activeSlot Optional. The slot to grant the charges to. Default is `ActiveSlot.PRIMARY`.
 * @param numCharges Optional. The amount of charges to grant. Default is 1.
 * @param playSoundEffect Optional. Whether to play a charge-related sound effect. Default is true.
 * @returns The amount of charges that were actually granted. For example, if the active item was
 *          only one away from a full charge, but the `numCharges` provided to this function was 2,
 *          then this function would return 1.
 */
export function addCharge(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
  numCharges = 1,
  playSoundEffect = true,
): int {
  const hud = game.GetHUD();

  // Ensure that there is enough space on the active item to store these amount of charges. (If we
  // add too many charges, it will grant orange "battery" charges, even if the player does not have
  // The Battery.)
  const chargesAwayFromMax = getChargesAwayFromMax(player, activeSlot);
  const chargesToAdd =
    numCharges > chargesAwayFromMax ? chargesAwayFromMax : numCharges;

  // The AAA Battery trinket might grant an additional charge.
  const modifiedChargesToAdd = getChargesToAddWithAAAModifier(
    player,
    activeSlot,
    chargesToAdd,
  );

  const totalCharge = getTotalCharge(player, activeSlot);
  const newCharge = totalCharge + modifiedChargesToAdd;
  if (newCharge === totalCharge) {
    return 0;
  }

  player.SetActiveCharge(newCharge, activeSlot);
  hud.FlashChargeBar(player, activeSlot);

  if (playSoundEffect) {
    playChargeSoundEffect(player, activeSlot);
  }

  return modifiedChargesToAdd;
}

/**
 * Helper function to add a charge to a player's active item(s), emulating what happens when a room
 * is cleared.
 *
 * This function will take the following things into account:
 * - 2x2 rooms and L rooms granting a double charge
 * - The Battery
 * - AAA Battery
 * - Not charging active items with `chargetype="special"`
 *
 * @param player The player to grant the charges to.
 * @param bigRoomDoubleCharge Optional. If set to false, it will treat the current room as a 1x1
 *                            room for the purposes of calculating how much charge to grant. Default
 *                            is true.
 * @param playSoundEffect Optional. Whether to play a charge-related sound effect. Default is true.
 */
export function addRoomClearCharge(
  player: EntityPlayer,
  bigRoomDoubleCharge = true,
  playSoundEffect = true,
): void {
  for (const activeSlot of [
    ActiveSlot.PRIMARY,
    ActiveSlot.SECONDARY,
    ActiveSlot.POCKET,
  ]) {
    addRoomClearChargeToSlot(
      player,
      activeSlot,
      bigRoomDoubleCharge,
      playSoundEffect,
    );
  }
}

/**
 * Helper function to add a charge to one of a player's active items, emulating what happens when a
 * room is cleared.
 *
 * This function will take the following things into account:
 * - L rooms and 2x2 rooms granting a double charge
 * - The Battery
 * - AAA Battery
 * - Not charging active items with `chargetype="special"`
 *
 * @param player The player to grant the charges to.
 * @param activeSlot Optional. The active item slot to grant the charges to. Default is
 *                   `ActiveSlot.PRIMARY`.
 * @param bigRoomDoubleCharge Optional. If set to false, it will treat the current room as a 1x1
 *                            room for the purposes of calculating how much charge to grant. Default
 *                            is true.
 * @param playSoundEffect Optional. Whether to play a charge-related sound effect. Default is true.
 */
export function addRoomClearChargeToSlot(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
  bigRoomDoubleCharge = true,
  playSoundEffect = true,
): void {
  const activeItem = player.GetActiveItem(activeSlot);
  if (activeItem === CollectibleType.NULL) {
    return;
  }

  // Certain collectibles have special charge mechanisms and are not charged upon a room being
  // cleared.
  const chargeType = getCollectibleChargeType(activeItem);
  if (chargeType === ItemConfigChargeType.SPECIAL) {
    return;
  }

  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();

  // Big rooms grant two charges and normal rooms grant one charge.
  let numCharges = bigRoomDoubleCharge ? getRoomShapeCharges(roomShape) : 1;

  // Handle the special case of a timed item. When clearing a room with a timed item, it should
  // become fully charged.
  if (chargeType === ItemConfigChargeType.TIMED) {
    // The charges will become clamped to the proper amount in the `addCharge` function. (If the
    // item is at 50% charge and the player has The Battery, it should go to 150% charged.)
    numCharges = getCollectibleMaxCharges(activeItem);
  }

  addCharge(player, activeSlot, numCharges, playSoundEffect);
}

/**
 * The AAA Battery should grant an extra charge when the active item is one away from being fully
 * charged.
 */
function getChargesToAddWithAAAModifier(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
  chargesToAdd: int,
) {
  const hasAAABattery = player.HasTrinket(TrinketType.AAA_BATTERY);
  if (!hasAAABattery) {
    return chargesToAdd;
  }

  const chargesAwayFromMax = getChargesAwayFromMax(player, activeSlot);
  const AAABatteryShouldApply = chargesToAdd === chargesAwayFromMax - 1;
  return AAABatteryShouldApply ? chargesToAdd + 1 : chargesToAdd;
}

/**
 * Helper function to add a charge to every player's active item, emulating what happens when a room
 * is cleared.
 *
 * This function will take the following things into account:
 * - L rooms and 2x2 rooms granting a double charge
 * - The Battery
 * - AAA Battery
 *
 * @param bigRoomDoubleCharge Optional. If set to false, it will treat the current room as a 1x1
 *                            room for the purposes of calculating how much charge to grant. Default
 *                            is true.
 */
export function addRoomClearCharges(bigRoomDoubleCharge = true): void {
  for (const player of getPlayers()) {
    addRoomClearCharge(player, bigRoomDoubleCharge);
  }
}

/**
 * Helper function to get the amount of charges away from the maximum charge that a particular
 * player is.
 *
 * This function accounts for The Battery. For example, if the player has 2/6 charges on a D6, this
 * function will return 10 (because there are 4 charges remaining on the base charge and 6 charges
 * remaining on The Battery charge).
 *
 * @param player The player to get the charges from.
 * @param activeSlot Optional. The slot to get the charges from. Default is `ActiveSlot.PRIMARY`.
 */
export function getChargesAwayFromMax(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
): int {
  const totalCharge = getTotalCharge(player, activeSlot);
  const activeItem = player.GetActiveItem(activeSlot);
  const hasBattery = player.HasCollectible(CollectibleType.BATTERY);
  const maxCharges = getCollectibleMaxCharges(activeItem);
  const effectiveMaxCharges = hasBattery ? maxCharges * 2 : maxCharges;

  return effectiveMaxCharges - totalCharge;
}

/**
 * Helper function to get the combined normal charge and the battery charge for the player's active
 * item. This is useful because you have to add these two values together when setting the active
 * charge.
 *
 * @param player The player to get the charges from.
 * @param activeSlot Optional. The slot to get the charges from. Default is `ActiveSlot.PRIMARY`.
 */
export function getTotalCharge(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
): int {
  const activeCharge = player.GetActiveCharge(activeSlot);
  const batteryCharge = player.GetBatteryCharge(activeSlot);

  return activeCharge + batteryCharge;
}

/**
 * Helper function to find the active slots that the player has the corresponding collectible type
 * in and have enough charge to be used. Returns an empty array if the player does not have the
 * collectible in any active slot or does not have enough charges.
 */
export function getUsableActiveItemSlots(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): readonly ActiveSlot[] {
  const maxCharges = getCollectibleMaxCharges(collectibleType);
  const activeSlots = getActiveItemSlots(player, collectibleType);
  return activeSlots.filter((activeSlot) => {
    const totalCharge = getTotalCharge(player, activeSlot);
    return totalCharge >= maxCharges;
  });
}

/**
 * Helper function to check if a player's active item is "double charged", meaning that it has both
 * a full normal charge and a full charge from The Battery.
 *
 * @param player The player to check.
 * @param activeSlot Optional. The slot to check. Default is `ActiveSlot.PRIMARY`.
 */
export function isActiveSlotDoubleCharged(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
): boolean {
  const collectibleType = player.GetActiveItem(activeSlot);
  const batteryCharge = player.GetBatteryCharge(activeSlot);
  const maxCharges = getCollectibleMaxCharges(collectibleType);

  return batteryCharge >= maxCharges;
}

/**
 * Helper function to play the appropriate sound effect for a player after getting one or more
 * charges on their active item. (There is a different sound depending on whether the item is fully
 * charged.)
 *
 * @param player The player to play the sound effect for.
 * @param activeSlot Optional. The slot that was just charged. Default is `ActiveSlot.PRIMARY`.
 */
export function playChargeSoundEffect(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
): void {
  for (const soundEffect of [
    SoundEffect.BATTERY_CHARGE, // 170
    SoundEffect.BEEP, // 171
  ]) {
    sfxManager.Stop(soundEffect);
  }

  const chargeSoundEffect = shouldPlayFullRechargeSound(player, activeSlot)
    ? SoundEffect.BATTERY_CHARGE
    : SoundEffect.BEEP;
  sfxManager.Play(chargeSoundEffect);
}

function shouldPlayFullRechargeSound(
  player: EntityPlayer,
  activeSlot: ActiveSlot,
) {
  const activeItem = player.GetActiveItem(activeSlot);
  const activeCharge = player.GetActiveCharge(activeSlot);
  const batteryCharge = player.GetBatteryCharge(activeSlot);
  const hasBattery = player.HasCollectible(CollectibleType.BATTERY);
  const maxCharges = getCollectibleMaxCharges(activeItem);

  // If we do not have The Battery, play the full recharge sound if we are now fully charged.
  if (!hasBattery) {
    // We cannot use the `EntityPlayer.NeedsCharge` method because it does not work properly for
    // items with `chargetype="special"`.
    return activeCharge === maxCharges;
  }

  // If we do have The Battery, play the full recharge sound if we are exactly double charged or
  // exactly single charged.
  return (
    batteryCharge === maxCharges ||
    (activeCharge === maxCharges && batteryCharge === 0)
  );
}

----
functions\chargeBar.ts
import type { ChargeBarSprites } from "../interfaces/ChargeBarSprites";

const CHARGE_BAR_ANM2 = "gfx/ui/ui_chargebar.anm2";

/**
 * Constructor for a `ChargeBarSprites` object. For more information, see the `renderChargeBar`
 * helper function.
 *
 * Note that this is for the vertical charge bar that represents the number of charges that an
 * active item has, not the circular charge bar that shows e.g. the charge rate of Brimstone.
 */
export function newChargeBarSprites(maxCharges: int): ChargeBarSprites {
  const back = Sprite();
  back.Load(CHARGE_BAR_ANM2, true);
  back.Play("BarEmpty", true);

  const meter = Sprite();
  meter.Load(CHARGE_BAR_ANM2, true);
  meter.Play("BarFull", true);

  const meterBattery = Sprite();
  meterBattery.Load(CHARGE_BAR_ANM2, true);
  meterBattery.Play("BarFull", true);

  const lines = Sprite();
  lines.Load(CHARGE_BAR_ANM2, true);
  lines.Play(`BarOverlay${maxCharges}`, true);

  return {
    back,
    meter,
    meterBattery,
    lines,
    maxCharges,
  };
}

/**
 * Helper function to render a charge bar on the screen. First, call the `newChargeBarSprites`
 * function to initialize the sprites, and then call this function on every render frame.
 *
 * Note that this is for the vertical charge bar that represents the number of charges that an
 * active item has, not the circular charge bar that shows e.g. the charge rate of Brimstone.
 */
export function renderChargeBar(
  sprites: ChargeBarSprites,
  position: Vector,
  normalCharges: int,
  batteryCharges: int,
): void {
  sprites.back.Render(position);

  const normalChargesClamp = getChargeBarClamp(
    normalCharges,
    sprites.maxCharges,
  );
  sprites.meter.Render(position, normalChargesClamp);

  const batteryChargesClamp = getChargeBarClamp(
    batteryCharges,
    sprites.maxCharges,
  );
  sprites.meterBattery.Render(position, batteryChargesClamp);

  sprites.lines.Render(position);
}

function getChargeBarClamp(charges: int, maxCharges: int) {
  const meterMultiplier = 24 / maxCharges;
  const meterClip = 26 - charges * meterMultiplier;
  return Vector(0, meterClip);
}

----
functions\collectibleTag.ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ItemConfigTag } from "isaac-typescript-definitions";
import { itemConfig } from "../core/cachedClasses";
import { isInteger } from "./types";

export function collectibleHasTag(
  collectibleOrCollectibleType: EntityPickupCollectible | CollectibleType,
  tag: ItemConfigTag,
): boolean {
  const collectibleType = isInteger(collectibleOrCollectibleType)
    ? collectibleOrCollectibleType
    : collectibleOrCollectibleType.SubType;

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return false;
  }

  return itemConfigItem.HasTags(tag);
}

export function isQuestCollectible(
  collectibleOrCollectibleType: EntityPickupCollectible | CollectibleType,
): boolean {
  const collectibleType = isInteger(collectibleOrCollectibleType)
    ? collectibleOrCollectibleType
    : collectibleOrCollectibleType.SubType;

  return collectibleHasTag(collectibleType, ItemConfigTag.QUEST);
}

----
functions\collectibles.ts
import type {
  CacheFlag,
  CollectiblePedestalType,
  ItemConfigTag,
} from "isaac-typescript-definitions";
import {
  CollectibleSpriteLayer,
  CollectibleType,
  EntityType,
  ItemConfigChargeType,
  ItemConfigTagZero,
  ItemType,
  PickupPrice,
  PickupVariant,
  RenderMode,
} from "isaac-typescript-definitions";
import { game, itemConfig } from "../core/cachedClasses";
import {
  BLIND_ITEM_PNG_PATH,
  DEFAULT_ITEM_POOL_TYPE,
  QUALITIES,
} from "../core/constants";
import { LAST_VANILLA_COLLECTIBLE_TYPE } from "../core/constantsFirstLast";
import { VANILLA_COLLECTIBLE_TYPES } from "../core/constantsVanilla";
import {
  COLLECTIBLE_DESCRIPTIONS,
  DEFAULT_COLLECTIBLE_DESCRIPTION,
} from "../objects/collectibleDescriptions";
import {
  COLLECTIBLE_NAMES,
  DEFAULT_COLLECTIBLE_NAME,
} from "../objects/collectibleNames";
import { SINGLE_USE_ACTIVE_COLLECTIBLE_TYPES_SET } from "../sets/singleUseActiveCollectibleTypesSet";
import { getEntityID } from "./entities";
import { hasFlag } from "./flag";
import { isCollectible } from "./pickupVariants";
import { clearSprite, spriteEquals } from "./sprites";
import { asCollectibleType, isInteger } from "./types";
import { assertDefined } from "./utils";

const COLLECTIBLE_ANM2_PATH = "gfx/005.100_collectible.anm2";

const DEFAULT_COLLECTIBLE_PRICE = 15;

/** Glitched items start at id 4294967295 (the final 32-bit integer) and increment backwards. */
const GLITCHED_ITEM_THRESHOLD = 4_000_000_000;

const QUALITY_TO_VANILLA_COLLECTIBLE_TYPES_MAP: ReadonlyMap<
  Quality,
  CollectibleType[]
> = (() => {
  const qualityToCollectibleTypesMap = new Map<Quality, CollectibleType[]>();

  for (const quality of QUALITIES) {
    const collectibleTypes: CollectibleType[] = [];

    for (const collectibleType of VANILLA_COLLECTIBLE_TYPES) {
      const collectibleTypeQuality = getCollectibleQuality(collectibleType);
      if (collectibleTypeQuality === quality) {
        collectibleTypes.push(collectibleType);
      }
    }

    qualityToCollectibleTypesMap.set(quality, collectibleTypes);
  }

  return qualityToCollectibleTypesMap;
})();

/** The `isBlindCollectible` function needs a reference sprite to work properly. */
const questionMarkSprite = (() => {
  const sprite = Sprite();
  sprite.Load("gfx/005.100_collectible.anm2", false);
  sprite.ReplaceSpritesheet(1, "gfx/items/collectibles/questionmark.png");
  sprite.LoadGraphics();

  return sprite;
})();

export function clearCollectibleSprite(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "clearCollectibleSprite" function was given a non-collectible: ${entityID}`,
    );
  }

  setCollectibleSprite(collectible, undefined);
}

/** Helper function to check in the item config if a given collectible has a given cache flag. */
export function collectibleHasCacheFlag(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
  cacheFlag: CacheFlag,
): boolean {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "collectibleHasCacheFlag",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return false;
  }

  return hasFlag(itemConfigItem.CacheFlags, cacheFlag);
}

/** Helper function to check if two collectible sprites have the same sprite sheet loaded. */
export function collectibleSpriteEquals(
  sprite1: Sprite,
  sprite2: Sprite,
): boolean {
  // We start at negative 40 texels upwards, as by default we assume a collectible that is sitting
  // on a pedestal. We finish at positive 10 texels downwards, in order to make comparing shop items
  // more accurate.
  const xStart = -1;
  const xFinish = 1;
  const xIncrement = 1;
  const yStart = -40;
  const yFinish = 10;
  const yIncrement = 3;

  return spriteEquals(
    sprite1,
    sprite2,
    CollectibleSpriteLayer.HEAD,
    xStart,
    xFinish,
    xIncrement,
    yStart,
    yFinish,
    yIncrement,
  );
}

/**
 * Helper function to get the charge type that a collectible has. Returns
 * `ItemConfigChargeType.NORMAL` if the provided collectible type was not valid.
 */
export function getCollectibleChargeType(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): ItemConfigChargeType {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleChargeType",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return ItemConfigChargeType.NORMAL;
  }

  return itemConfigItem.ChargeType;
}

/**
 * Helper function to get the in-game description for a collectible. Returns "Unknown" if the
 * provided collectible type was not valid.
 *
 * This function works for both vanilla and modded collectibles.
 */
export function getCollectibleDescription(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): string {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleDescription",
  );

  // "ItemConfigItem.Description" is bugged with vanilla items on patch v1.7.6, so we use a
  // hard-coded map as a workaround.
  const collectibleDescription = COLLECTIBLE_DESCRIPTIONS[collectibleType] as
    | string
    | undefined;
  if (collectibleDescription !== undefined) {
    return collectibleDescription;
  }

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem !== undefined) {
    return itemConfigItem.Description;
  }

  return DEFAULT_COLLECTIBLE_DESCRIPTION;
}

/**
 * Helper function to get the coin cost that a collectible item would be if it were being offered in
 * a Devil Room deal. Returns 0 if passed `CollectibleType.NULL`.
 */
export function getCollectibleDevilCoinPrice(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): int {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleDescription",
  );

  if (collectibleType === CollectibleType.NULL) {
    return 0;
  }

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return DEFAULT_COLLECTIBLE_PRICE;
  }

  return itemConfigItem.DevilPrice * DEFAULT_COLLECTIBLE_PRICE;
}

/**
 * Helper function to get the heart cost that a collectible item would be if it were being offered
 * in a Devil Room deal. Returns 0 if passed `CollectibleType.NULL`.
 */
export function getCollectibleDevilHeartPrice(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
  player: EntityPlayer,
): PickupPrice {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleDevilHeartPrice",
  );
  const maxHearts = player.GetMaxHearts();

  if (collectibleType === CollectibleType.NULL) {
    return 0;
  }

  if (maxHearts === 0) {
    return PickupPrice.THREE_SOUL_HEARTS;
  }

  const defaultCollectiblePrice = PickupPrice.ONE_HEART;
  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return defaultCollectiblePrice;
  }

  const twoHeartPrice =
    maxHearts === 2
      ? PickupPrice.ONE_HEART_AND_TWO_SOUL_HEARTS
      : PickupPrice.TWO_HEARTS;

  return itemConfigItem.DevilPrice === 2
    ? twoHeartPrice
    : PickupPrice.ONE_HEART;
}

/**
 * Helper function to get the path to a collectible PNG file. Returns the path to the question mark
 * sprite (i.e. from Curse of the Blind) if the provided collectible type was not valid.
 *
 * If you intentionally want the path to the question mark sprite, pass -1 as the collectible type.
 *
 * Note that this does not return the file name, but the full path to the collectible's PNG file.
 * The function is named "GfxFilename" to correspond to the associated `ItemConfigItem.GfxFileName`
 * field.
 */
export function getCollectibleGfxFilename(
  collectibleOrCollectibleType: EntityPickup | CollectibleType | -1,
): string {
  if (collectibleOrCollectibleType === -1) {
    return BLIND_ITEM_PNG_PATH;
  }

  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleGfxFilename",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return BLIND_ITEM_PNG_PATH;
  }

  return itemConfigItem.GfxFileName;
}

/**
 * Helper function to get the initial amount of charges that a collectible has. In most cases, when
 * picking up an active collectible for the first time, it will be fully charged, which corresponds
 * to an `InitCharge` value of -1. However, in some cases, this may be different. For example,
 * Eden's Soul starts without any charges, so it has an `InitCharge` value of 0.
 *
 * This function returns 0 if the provided collectible type was not valid. This function returns -1
 * if the provided collectible type was not an active collectible.
 */
export function getCollectibleInitCharge(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): int {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleInitCharge",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return 0;
  }

  return itemConfigItem.InitCharge;
}

/**
 * Helper function to get the `ItemType` of a collectible. Returns `ItemType.ITEM_NULL` if the
 * provided collectible type was not valid.
 */
export function getCollectibleItemType(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): ItemType {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleItemType",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return ItemType.NULL;
  }

  return itemConfigItem.Type;
}

/**
 * Helper function to get the maximum amount of charges that a collectible has. Returns 0 if the
 * provided collectible type was not valid.
 */
export function getCollectibleMaxCharges(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): int {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleMaxCharges",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return 0;
  }

  return itemConfigItem.MaxCharges;
}

/**
 * Helper function to get the name of a collectible. Returns "Unknown" if the provided collectible
 * type is not valid.
 *
 * This function works for both vanilla and modded collectibles.
 *
 * For example, `getCollectibleName(CollectibleType.SAD_ONION)` would return "Sad Onion".
 */
export function getCollectibleName(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): string {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleName",
  );

  // "ItemConfigItem.Name" is bugged with vanilla items on patch v1.7.6, so we use a hard-coded map
  // as a workaround.
  const collectibleName = COLLECTIBLE_NAMES[collectibleType] as
    | string
    | undefined;
  if (collectibleName !== undefined) {
    return collectibleName;
  }

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem !== undefined) {
    return itemConfigItem.Name;
  }

  return DEFAULT_COLLECTIBLE_NAME;
}

/**
 * Helper function to get the "pedestal type" of a collectible. For example, it might be sitting on
 * top of a broken Blood Donation Machine, or it might be sitting on top of an opened Spiked Chest.
 */
export function getCollectiblePedestalType(
  collectible: EntityPickup,
): CollectiblePedestalType {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "getCollectiblePedestalType" function was given a non-collectible: ${entityID}`,
    );
  }

  const sprite = collectible.GetSprite();
  return sprite.GetOverlayFrame();
}

/**
 * Helper function to get a collectible's quality, which ranges from 0 to 4 (inclusive). For
 * example, Mom's Knife has a quality of 4. Returns 0 if the provided collectible type was not
 * valid.
 */
export function getCollectibleQuality(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): Quality {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleQuality",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return 0;
  }

  return itemConfigItem.Quality;
}

/**
 * Helper function to get the tags of a collectible (which is the composition of zero or more
 * `ItemConfigTag`). Returns 0 if the provided collectible type is not valid.
 *
 * For example:
 *
 * ```ts
 * const collectibleType = CollectibleType.SAD_ONION;
 * const itemConfigTags = getCollectibleTags(collectibleType); // itemConfigTags is "18350080"
 * ```
 */
export function getCollectibleTags(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): BitFlags<ItemConfigTag> {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "getCollectibleTags",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  return itemConfigItem === undefined ? ItemConfigTagZero : itemConfigItem.Tags;
}

/**
 * Returns an array containing every vanilla collectible type with the given quality.
 *
 * Note that this function will only return vanilla collectible types. To handle modded collectible
 * types, use the `getCollectibleTypesOfQuality` helper function instead.
 */
export function getVanillaCollectibleTypesOfQuality(
  quality: Quality,
): readonly CollectibleType[] {
  const collectibleTypes =
    QUALITY_TO_VANILLA_COLLECTIBLE_TYPES_MAP.get(quality);
  assertDefined(
    collectibleTypes,
    `Failed to find the vanilla collectible types corresponding to quality: ${quality}`,
  );

  return collectibleTypes;
}

/** Returns true if the item type in the item config is equal to `ItemType.ACTIVE`. */
export function isActiveCollectible(collectibleType: CollectibleType): boolean {
  const itemType = getCollectibleItemType(collectibleType);
  return itemType === ItemType.ACTIVE;
}

/**
 * Returns true if the collectible has a red question mark sprite.
 *
 * Note that this function will not work properly in a render callback with the `RenderMode` set to
 * `RenderMode.WATER_REFLECT`. If this is detected, this function will throw a run-time error.
 */
export function isBlindCollectible(collectible: EntityPickup): boolean {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "isBlindCollectible" function was given a non-collectible: ${entityID}`,
    );
  }

  const room = game.GetRoom();
  const renderMode = room.GetRenderMode();
  if (renderMode === RenderMode.WATER_REFLECT) {
    error(
      'The "isBlindCollectible" function will not work properly in a render callback with the render mode equal to "RenderMode.WATER_REFLECT". Make sure that you properly account for this case if you are calling this function in a render callback.',
    );
  }

  const sprite = collectible.GetSprite();
  const animation = sprite.GetAnimation();
  const frame = sprite.GetFrame();

  questionMarkSprite.SetFrame(animation, frame);
  return collectibleSpriteEquals(sprite, questionMarkSprite);
}

/** Returns true if the item type in the item config is equal to `ItemType.FAMILIAR`. */
export function isFamiliarCollectible(
  collectibleType: CollectibleType,
): boolean {
  const itemType = getCollectibleItemType(collectibleType);
  return itemType === ItemType.FAMILIAR;
}

/**
 * Returns whether the given collectible is a "glitched" item. All items are replaced by glitched
 * items once a player has TMTRAINER. However, glitched items can also "naturally" appear in secret
 * rooms and I AM ERROR rooms if the "Corrupted Data" achievement is unlocked.
 *
 * Under the hood, this checks if the sub-type of the collectible is greater than 4,000,000,000.
 */
export function isGlitchedCollectible(collectible: EntityPickup): boolean {
  return (
    collectible.Variant === PickupVariant.COLLECTIBLE &&
    collectible.SubType > GLITCHED_ITEM_THRESHOLD
  );
}

/**
 * Returns true if the collectible has the "Hidden" attribute in the item config.
 *
 * Hidden collectibles will not show up in any pools and Eden will not start with them.
 */
export function isHiddenCollectible(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): boolean {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "isHiddenCollectible",
  );

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  return itemConfigItem !== undefined && itemConfigItem.Hidden;
}

export function isModdedCollectibleType(
  collectibleType: CollectibleType,
): boolean {
  return !isVanillaCollectibleType(collectibleType);
}

/**
 * Returns true if the item type in the item config is equal to `ItemType.ITEM_PASSIVE` or
 * `ItemType.ITEM_FAMILIAR`.
 */
export function isPassiveOrFamiliarCollectible(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
): boolean {
  const collectibleType = getCollectibleTypeFromArg(
    collectibleOrCollectibleType,
    "isPassiveCollectible",
  );

  const itemType = getCollectibleItemType(collectibleType);
  return itemType === ItemType.PASSIVE || itemType === ItemType.FAMILIAR;
}

/** Helper function to check if a collectible type is a particular quality. */
export function isQuality(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
  quality: int,
): boolean {
  const actualQuality = getCollectibleQuality(collectibleOrCollectibleType);
  return quality === actualQuality;
}

/**
 * Helper function to determine if a particular collectible will disappear from the player's
 * inventory upon use. Note that this will not work will modded collectibles, as there is no way to
 * dynamically know if a modded collectible will disappear.
 */
export function isSingleUseCollectible(
  collectibleType: CollectibleType,
): boolean {
  return SINGLE_USE_ACTIVE_COLLECTIBLE_TYPES_SET.has(collectibleType);
}

export function isValidCollectibleType(
  collectibleType: int,
): collectibleType is CollectibleType {
  const potentialCollectibleType = asCollectibleType(collectibleType);
  const itemConfigItem = itemConfig.GetCollectible(potentialCollectibleType);
  return itemConfigItem !== undefined;
}

export function isVanillaCollectibleType(
  collectibleType: CollectibleType,
): boolean {
  return collectibleType <= LAST_VANILLA_COLLECTIBLE_TYPE;
}

/**
 * Helper function to generate a new sprite based on a collectible. If the provided collectible type
 * is invalid, a sprite with a Curse of the Blind question mark will be returned.
 *
 * If you intentionally want a question mark sprite, pass -1 as the collectible type.
 */
export function newCollectibleSprite(
  collectibleType: CollectibleType | -1,
): Sprite {
  const sprite = Sprite();
  sprite.Load(COLLECTIBLE_ANM2_PATH, false);

  // We want to clear the pedestal layers so that the returned sprite only has the collectible
  // image. We can't use the `Sprite.Reset` method for this purpose because that would unload the
  // anm2 file.
  clearSprite(sprite);

  const gfxFileName = getCollectibleGfxFilename(collectibleType);
  sprite.ReplaceSpritesheet(CollectibleSpriteLayer.HEAD, gfxFileName);
  sprite.LoadGraphics();

  const defaultAnimation = sprite.GetDefaultAnimation();
  sprite.Play(defaultAnimation, true);

  return sprite;
}

/**
 * Helper function to remove the rotation behavior from a collectible. This will happen by default
 * when collectibles are spawned when playing as Tainted Isaac or when having Binge Eater.
 *
 * Under the hood, this is accomplished by morphing the collectible with the `ignoreModifiers`
 * argument set to true.
 */
export function preventCollectibleRotation(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "preventCollectibleRotation" function was given a non-collectible: ${entityID}`,
    );
  }

  collectible.Morph(
    collectible.Type,
    collectible.Variant,
    collectible.SubType,
    true,
    true,
    true,
  );
}

/**
 * Helper function to remove all pickup delay on a collectible. By default, collectibles have a 20
 * frame delay before they can be picked up by a player.
 */
export function removeCollectiblePickupDelay(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "removeCollectiblePickupDelay" function was given a non-collectible: ${entityID}`,
    );
  }

  collectible.Wait = 0;
}

/**
 * Helper function to set a collectible sprite to a question mark (i.e. how collectibles look when
 * the player has Curse of the Blind).
 */
export function setCollectibleBlind(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectibleBlind" function was given a non-collectible: ${entityID}`,
    );
  }

  setCollectibleSprite(collectible, BLIND_ITEM_PNG_PATH);
}

/**
 * Helper function to remove the collectible from a collectible pedestal and make it appear as if a
 * player has already taken the item. This is accomplished by changing the sub-type to
 * `CollectibleType.NULL` and then setting the sprite to an empty/missing PNG file.
 *
 * For more information, see the documentation for the "clearSprite" helper function.
 */
export function setCollectibleEmpty(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectibleEmpty" function was given a non-collectible: ${entityID}`,
    );
  }

  collectible.SubType = CollectibleType.NULL;
  clearCollectibleSprite(collectible);
}

/**
 * Helper function to change a collectible into a "glitched" item (like the ones that appear when
 * the player has TMTRAINER).
 */
export function setCollectibleGlitched(collectible: EntityPickup): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectibleGlitched" function was given a non-collectible: ${entityID}`,
    );
  }

  // We need to generate a new glitched item. Thus, we temporarily give the player TMTRAINER, if
  // necessary.
  const player = Isaac.GetPlayer();
  const hasTMTRAINER = player.HasCollectible(CollectibleType.TMTRAINER);
  if (!hasTMTRAINER) {
    player.AddCollectible(CollectibleType.TMTRAINER, 0, false);
  }

  const itemPool = game.GetItemPool();
  const collectibleType = itemPool.GetCollectible(DEFAULT_ITEM_POOL_TYPE);
  setCollectibleSubType(collectible, collectibleType);

  if (!hasTMTRAINER) {
    player.RemoveCollectible(CollectibleType.TMTRAINER);
  }
}

/**
 * Helper function to set the "pedestal type" of a collectible. For example, it might be sitting on
 * top of a broken Blood Donation Machine and you want to change it to be sitting on top of an
 * opened Spiked Chest.
 */
export function setCollectiblePedestalType(
  collectible: EntityPickup,
  collectiblePedestalType: CollectiblePedestalType,
): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectiblePedestalType" function was given a non-collectible: ${entityID}`,
    );
  }

  const sprite = collectible.GetSprite();
  const overlayAnimation = sprite.GetOverlayAnimation();
  sprite.SetOverlayFrame(overlayAnimation, collectiblePedestalType);
}

/**
 * Helper function to change the sprite of a collectible pedestal entity.
 *
 * For more information about removing the collectible sprite, see the documentation for the
 * "clearSprite" helper function.
 *
 * @param collectible The collectible whose sprite you want to modify.
 * @param pngPath Equal to either the spritesheet path to load (e.g.
 *                "gfx/items/collectibles/collectibles_001_thesadonion.png") or undefined. If
 *                undefined, the sprite will be removed, making it appear like the collectible has
 *                already been taken by the player.
 */
export function setCollectibleSprite(
  collectible: EntityPickup,
  pngPath: string | undefined,
): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectibleSprite" function was given a non-collectible: ${entityID}`,
    );
  }

  const sprite = collectible.GetSprite();
  if (pngPath === undefined) {
    // We want to remove the little circle that appears on top of the pedestal, which is why we also
    // clear `CollectibleSpriteLayer.ITEM_SHADOW`.
    clearSprite(
      sprite,
      CollectibleSpriteLayer.HEAD,
      CollectibleSpriteLayer.ITEM_SHADOW,
    );
  } else {
    sprite.ReplaceSpritesheet(CollectibleSpriteLayer.HEAD, pngPath);
    sprite.LoadGraphics();
  }
}

/**
 * Helper function to change the collectible on a pedestal. Simply updating the `SubType` field is
 * not sufficient because the sprite will not change.
 */
export function setCollectibleSubType(
  collectible: EntityPickup,
  newCollectibleType: CollectibleType,
): void {
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "setCollectibleSubType" function was given a non-collectible: ${entityID}`,
    );
  }

  // You cannot morph a pedestal to "CollectibleType.NULL"; it would instead create a new random
  // collectible item.
  if (newCollectibleType === CollectibleType.NULL) {
    setCollectibleEmpty(collectible);
    return;
  }

  // The naive way to change a collectible's sub-type is to set it directly. However, doing this
  // will not update the sprite. Manually updating the sprite works in most situations, but does not
  // work when the pedestal is empty. Instead, we can simply morph the collectible, which seems to
  // work in all situations.
  collectible.Morph(
    EntityType.PICKUP,
    PickupVariant.COLLECTIBLE,
    newCollectibleType,
    true,
    true,
    true,
  );
}

/**
 * Helper function to put a message in the log.txt file to let the Rebirth Item Tracker know that
 * the build has been rerolled.
 */
export function setCollectiblesRerolledForItemTracker(): void {
  // This cannot use the "log" function since the prefix will prevent the Rebirth Item Tracker from
  // recognizing the message. The number here does not matter since the tracker does not check for a
  // specific number.
  Isaac.DebugString("Added 3 Collectibles");
}

function getCollectibleTypeFromArg(
  collectibleOrCollectibleType: EntityPickup | CollectibleType,
  functionName: string,
): CollectibleType {
  if (isInteger(collectibleOrCollectibleType)) {
    return collectibleOrCollectibleType;
  }

  const collectible = collectibleOrCollectibleType;
  if (!isCollectible(collectible)) {
    const entityID = getEntityID(collectible);
    error(
      `The "${functionName}" function was given a non-collectible: ${entityID}`,
    );
  }

  return collectible.SubType;
}

----
functions\color.ts
import type { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { isaacAPIClassEquals, isIsaacAPIClassOfType } from "./isaacAPIClass";
import { getRandom } from "./random";
import { isRNG, newRNG } from "./rng";
import {
  copyUserdataValuesToTable,
  getNumbersFromTable,
  tableHasKeys,
} from "./table";
import { isTable } from "./types";
import { assertDefined } from "./utils";

export type SerializedColor = LuaMap<string, unknown> & {
  readonly __serializedColorBrand: symbol;
  readonly __kind: CopyableIsaacAPIClassType.COLOR;
};

const OBJECT_NAME = "Color";
const KEYS = ["R", "G", "B", "A", "RO", "GO", "BO"] as const;

export function colorEquals(color1: Color, color2: Color): boolean {
  return isaacAPIClassEquals(color1, color2, KEYS);
}

/** Helper function to copy a `Color` Isaac API class. */
export function copyColor(color: Color): Color {
  if (!isColor(color)) {
    error(
      `Failed to copy a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  return Color(
    color.R,
    color.G,
    color.B,
    color.A,
    color.RO,
    color.GO,
    color.BO,
  );
}

/**
 * Helper function to convert a `SerializedColor` object to a normal `Color` object. (This is used
 * by the save data manager when reading data from the "save#.dat" file.)
 */
export function deserializeColor(color: SerializedColor): Color {
  if (!isTable(color)) {
    error(
      `Failed to deserialize a ${OBJECT_NAME} object since the provided object was not a Lua table.`,
    );
  }

  const [r, g, b, a, ro, go, bo] = getNumbersFromTable(
    color,
    OBJECT_NAME,
    ...KEYS,
  );

  assertDefined(
    r,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: R`,
  );
  assertDefined(
    g,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: G`,
  );
  assertDefined(
    b,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: B`,
  );

  return Color(r, g, b, a, ro, go, bo);
}

/**
 * Helper function to get a random `Color` object.
 *
 * If you want to generate an unseeded object, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param alpha Optional. The alpha value to use. Default is 1.
 */
export function getRandomColor(
  seedOrRNG: Seed | RNG | undefined,
  alpha = 1,
): Readonly<Color> {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  const r = getRandom(rng);
  const g = getRandom(rng);
  const b = getRandom(rng);

  return Color(r, g, b, alpha);
}

/** Helper function to check if something is an instantiated `Color` object. */
export function isColor(object: unknown): object is Color {
  return isIsaacAPIClassOfType(object, OBJECT_NAME);
}

/**
 * Used to determine is the given table is a serialized `Color` object created by the `deepCopy`
 * function.
 */
export function isSerializedColor(object: unknown): object is SerializedColor {
  if (!isTable(object)) {
    return false;
  }

  return tableHasKeys(object, ...KEYS) && object.has(SerializationBrand.COLOR);
}

/**
 * Helper function to convert a `Color` object to a `SerializedColor` object. (This is used by the
 * save data manager when writing data from the "save#.dat" file.)
 */
export function serializeColor(color: Color): SerializedColor {
  if (!isColor(color)) {
    error(
      `Failed to serialize a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const colorTable = new LuaMap<string, unknown>();
  copyUserdataValuesToTable(color, KEYS, colorTable);
  colorTable.set(SerializationBrand.COLOR, "");
  return colorTable as SerializedColor;
}

----
functions\console.ts
import { CONSOLE_COMMANDS_SET } from "../sets/consoleCommandsSet";

/**
 * Helper function to see if a particular command is a vanilla console command. This is useful
 * because the `EXECUTE_CMD` callback will not fire for any vanilla commands.
 */
export function isVanillaConsoleCommand(commandName: string): boolean {
  return CONSOLE_COMMANDS_SET.has(commandName);
}

/** Helper function to print whether something was enabled or disabled to the in-game console. */
export function printEnabled(enabled: boolean, description: string): void {
  const enabledText = enabled ? "Enabled" : "Disabled";
  print(`${enabledText} ${description}.`);
}

----
functions\curses.ts
import type { LevelCurse } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { hasFlag } from "./flag";

/**
 * Helper function to get the actual bit flag for modded curses.
 *
 * Will throw a run-time error if the provided curse does not exist.
 *
 * Use this over the `Isaac.GetCurseIdByName` method because that will return an integer instead of
 * a bit flag.
 */
export function getCurseIDByName(name: string): LevelCurse {
  const curseID = Isaac.GetCurseIdByName(name);
  if (curseID === -1) {
    error(
      `Failed to get the curse ID corresponding to the curse name of "${curseID}". Does this name match what you put in the "content/curses.xml" file?`,
    );
  }

  // For example, the final vanilla curse is "Curse of the Giant", which has an ID of 8. This
  // corresponds to `LevelCurse.GIANT`, which has a value of `1 << 7`.
  return (1 << (curseID - 1)) as LevelCurse;
}

/**
 * Helper function to check if the current floor has a particular curse.
 *
 * This function is variadic, meaning that you can specify as many curses as you want. The function
 * will return true if the level has one or more of the curses.
 *
 * Under the hood, this function uses the `Level.GetCurses` method.
 */
export function hasCurse(...curses: readonly LevelCurse[]): boolean {
  const level = game.GetLevel();
  const levelCurses = level.GetCurses();

  return curses.some((curse) => hasFlag(levelCurses, curse));
}

----
functions\debugFunctions.ts
import { log } from "./log";

/**
 * Helper function to get the amount of elapsed time for benchmarking / profiling purposes.
 *
 * For more information, see the documentation for the `getTime` helper function.
 *
 * @param time The milliseconds (int) or fractional seconds (float).
 * @param useSocketIfAvailable Optional. Whether to use the `socket.gettime` method, if available.
 *                             Default is true. If set to false, the `Isaac.GetTime()` method will
 *                             always be used.
 */
export function getElapsedTimeSince(
  time: int | float,
  useSocketIfAvailable = true,
): int {
  return getTime(useSocketIfAvailable) - time;
}

/**
 * Helper function to get the current time for benchmarking / profiling purposes.
 *
 * The return value will either be in seconds or milliseconds, depending on if the "--luadebug" flag
 * is turned on.
 *
 * If the "--luadebug" flag is present, then this function will use the `socket.gettime` method,
 * which returns the epoch timestamp in seconds (e.g. "1640320492.5779"). This is preferable over
 * the more conventional `Isaac.GetTime` method, since it has one extra decimal point of precision.
 *
 * If the "--luadebug" flag is not present, then this function will use the `Isaac.GetTime` method,
 * which returns the number of milliseconds since the computer's operating system was started (e.g.
 * "739454963").
 *
 * @param useSocketIfAvailable Optional. Whether to use the `socket.gettime` method, if available.
 *                             Default is true. If set to false, the `Isaac.GetTime()` method will
 *                             always be used.
 */
export function getTime(useSocketIfAvailable = true): int | float {
  if (useSocketIfAvailable) {
    if (SandboxGetTime !== undefined) {
      return SandboxGetTime();
    }

    if (isLuaDebugEnabled()) {
      // eslint-disable-next-line unicorn/prefer-module
      const [ok, requiredSocket] = pcall(require, "socket");
      if (ok) {
        const socket = requiredSocket as Socket;
        return socket.gettime();
      }
    }
  }

  // We could divide the result by 1000 in order to unify the return type with `socket.gettime`.
  // However, this causes floating point inaccuracies in the number when subtracting, so it is
  // better to keep it as an integer.
  return Isaac.GetTime();
}

/**
 * Helper function to get a stack trace.
 *
 * This will only work if the `--luadebug` launch option is enabled. If it isn't, then a error
 * string will be returned.
 */
export function getTraceback(this: void): string {
  if (SandboxGetTraceback !== undefined) {
    return SandboxGetTraceback();
  }

  // "debug" will be equal to undefined if the "--luadebug" launch flag is not present.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (debug !== undefined) {
    // The --luadebug launch flag is enabled.
    return debug.traceback();
  }

  return 'stack traceback:\n(the "--luadebug" flag is not enabled)';
}

/**
 * Players can boot the game with an launch option called "--luadebug", which will enable additional
 * functionality that is considered to be unsafe. For more information about this flag, see the
 * wiki: https://bindingofisaacrebirth.fandom.com/wiki/Launch_Options
 *
 * When this flag is enabled, the global environment will be slightly different. The differences are
 * documented here: https://wofsauge.github.io/IsaacDocs/rep/Globals.html
 *
 * This function uses the `package` global variable as a proxy to determine if the "--luadebug" flag
 * is enabled.
 *
 * Note that this function will return false if the Racing+ sandbox is enabled, even if the
 * "--luadebug" flag is really turned on. If checking for this case is needed, check for the
 * presence of the `sandboxGetTraceback` function.
 */
export function isLuaDebugEnabled(): boolean {
  // "package" is not always defined like the Lua definitions imply.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return _G.package !== undefined;
}

/**
 * Helper function to log a stack trace to the "log.txt" file, similar to JavaScript's
 * `console.trace` function.
 *
 * This will only work if the `--luadebug` launch option is enabled. If it isn't, then a error
 * string will be logged.
 */
export function traceback(this: void): void {
  const tracebackOutput = getTraceback();
  log(tracebackOutput);
}

----
functions\decorators.ts
/**
 * If you decide to structure your mod as a set of feature classes, you can use decorators to
 * automatically register callbacks.
 *
 * Currently, there are two decorators:
 * - `@Callback`
 * - `@CallbackCustom`
 *
 * For example:
 *
 * ```ts
 * export class MyFeature extends ModFeature {
 *   @Callback(ModCallback.POST_GAME_STARTED)
 *   postGameStarted(isContinued: boolean): void {
 *     Isaac.DebugString(`Callback fired: POST_GAME_STARTED`);
 *   }
 * }
 * ```
 *
 * @module
 */

import type { ModCallback } from "isaac-typescript-definitions";
import { CallbackPriority } from "isaac-typescript-definitions";
import type { ModFeature } from "../classes/ModFeature";
import {
  MOD_FEATURE_CALLBACKS_KEY,
  MOD_FEATURE_CUSTOM_CALLBACKS_KEY,
} from "../classes/ModFeature";
import type { ModCallbackCustom } from "../enums/ModCallbackCustom";
import type { AddCallbackParametersCustom } from "../interfaces/private/AddCallbackParametersCustom";
import type { AllButFirst } from "../types/AllButFirst";
import { getTSTLClassName } from "./tstlClass";

/**
 * A decorator function that signifies that the decorated class method should be automatically
 * registered with `Mod.AddCallback`.
 *
 * @allowEmptyVariadic
 * @ignore
 */
// We tell TypeDoc to ignore this function because it generates a bunch of spam.
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function Callback<T extends ModCallback>(
  modCallback: T,
  ...optionalArgs: AllButFirst<AddCallbackParameters[T]>
) {
  return PriorityCallback(
    modCallback,
    CallbackPriority.DEFAULT,
    ...optionalArgs,
  );
}

/**
 * A decorator function that signifies that the decorated class method should be automatically
 * registered with `ModUpgraded.AddCallbackCustom`.
 *
 * @allowEmptyVariadic
 * @ignore
 */
// We tell TypeDoc to ignore this function because it generates a bunch of spam.
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function CallbackCustom<T extends ModCallbackCustom>(
  modCallbackCustom: T,
  ...optionalArgs: AllButFirst<AddCallbackParametersCustom[T]>
) {
  return PriorityCallbackCustom(
    modCallbackCustom,
    CallbackPriority.DEFAULT,
    ...optionalArgs,
  );
}

/**
 * A decorator function that signifies that the decorated class method should be automatically
 * registered with `Mod.AddPriorityCallback`.
 *
 * @allowEmptyVariadic
 * @ignore
 */
// We tell TypeDoc to ignore this function because it generates a bunch of spam.
export function PriorityCallback<T extends ModCallback>(
  modCallback: T,
  priority: CallbackPriority | int,
  ...optionalArgs: AllButFirst<AddCallbackParameters[T]>
) {
  return <Class extends ModFeature, Fn extends AddCallbackParameters[T][0]>(
    target: Class,
    propertyKey: string,
    _descriptor: TypedPropertyDescriptor<Fn>,
  ): void => {
    // First, prepare the arguments for the `Mod.AddPriorityCallback` method.
    const methodName = propertyKey as keyof Class;
    const method = target[methodName] as AddCallbackParameters[T][0];
    const callbackTuple = [modCallback, priority, method, optionalArgs];

    // Since the decorator runs prior to instantiation, we only have access to get and set static
    // properties, which are located on the "constructor" table. Thus, we store the callback
    // arguments for later.
    const constructor = target.constructor as unknown as
      | Record<string, unknown>
      | undefined;

    if (constructor === undefined) {
      const tstlClassName = getTSTLClassName(target) ?? "Unknown";
      error(
        `Failed to get the constructor for class "${tstlClassName}". Did you decorate a static method? You can only decorate non-static class methods, because the "Mod" object is not present before the class is instantiated.`,
      );
    }

    const key = MOD_FEATURE_CALLBACKS_KEY;
    let callbackTuples = constructor[key] as unknown[] | undefined;
    if (callbackTuples === undefined) {
      callbackTuples = [];
      constructor[key] = callbackTuples;
    }

    callbackTuples.push(callbackTuple);
  };
}

/**
 * A decorator function that signifies that the decorated class method should be automatically
 * registered with `ModUpgraded.AddCallbackCustom`.
 *
 * @allowEmptyVariadic
 * @ignore
 */
// We tell TypeDoc to ignore this function because it generates a bunch of spam.
export function PriorityCallbackCustom<T extends ModCallbackCustom>(
  modCallbackCustom: T,
  priority: CallbackPriority | int,
  ...optionalArgs: AllButFirst<AddCallbackParametersCustom[T]>
) {
  return <
    Class extends ModFeature,
    Fn extends AddCallbackParametersCustom[T][0],
  >(
    target: Class,
    propertyKey: string,
    _descriptor: TypedPropertyDescriptor<Fn>,
  ): void => {
    // First, prepare the arguments for the `Mod.AddCallbackCustom` method.
    const methodName = propertyKey as keyof Class;
    const method = target[methodName] as AddCallbackParametersCustom[T][0];
    const callbackTuple = [modCallbackCustom, priority, method, optionalArgs];

    // Since the decorator runs prior to instantiation, we only have access to get and set static
    // properties, which are located on the "constructor" table. Thus, we store the callback
    // arguments for later.
    const constructor = target.constructor as unknown as
      | Record<string, unknown>
      | undefined;

    if (constructor === undefined) {
      const tstlClassName = getTSTLClassName(target) ?? "Unknown";
      error(
        `Failed to get the constructor for class "${tstlClassName}". Did you decorate a static method? You can only decorate non-static class methods, because the "Mod" object is not present before the class is instantiated.`,
      );
    }

    const key = MOD_FEATURE_CUSTOM_CALLBACKS_KEY;
    let callbackTuples = constructor[key] as unknown[] | undefined;
    if (callbackTuples === undefined) {
      callbackTuples = [];
      constructor[key] = callbackTuples;
    }
    callbackTuples.push(callbackTuple);
  };
}

----
functions\deepCopy.ts
import { DefaultMap } from "../classes/DefaultMap";
import { SAVE_DATA_MANAGER_DEBUG } from "../classes/features/other/saveDataManager/constants";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { SerializationType } from "../enums/SerializationType";
import { isSerializationBrand } from "../serialization";
import type { AnyClass } from "../types/AnyClass";
import type { TSTLClass } from "../types/TSTLClass";
import { isArray } from "./array";
import { getIsaacAPIClassName } from "./isaacAPIClass";
import { log } from "./log";
import {
  copyIsaacAPIClass,
  deserializeIsaacAPIClass,
  isCopyableIsaacAPIClass,
  isSerializedIsaacAPIClass,
  serializeIsaacAPIClass,
} from "./serialization";
import { sortTwoDimensionalArray } from "./sort";
import {
  getTSTLClassName,
  isDefaultMap,
  isTSTLMap,
  isTSTLSet,
  newTSTLClass,
} from "./tstlClass";
import { asString, isNumber, isPrimitive } from "./types";
import { assertDefined, getTraversalDescription } from "./utils";

/**
 * `deepCopy` is a semi-generic deep cloner. It will recursively copy all of the values so that none
 * of the nested references remain.
 *
 * `deepCopy` is used by the IsaacScript save data manager to make a backup of your variables, so
 * that it can restore them to the default values at the beginning of a new room, floor, or run.
 *
 * `deepCopy` supports the following object types:
 *
 * - Primitives (i.e. strings, numbers, and booleans)
 * - Basic TSTL objects (which are the same thing as Lua tables)
 * - TSTL `Map`
 * - TSTL `Set`
 * - TSTL classes
 * - `DefaultMap`
 * - Isaac `BitSet128` objects
 * - Isaac `Color` objects
 * - Isaac `KColor` objects
 * - Isaac `RNG` objects
 * - Isaac `Vector` objects
 *
 * It does not support:
 * - objects with values of `null` (since that transpiles to `nil`)
 * - other Isaac API objects such as `EntityPtr` (that have a type of "userdata")
 *
 * @param value The primitive or object to copy.
 * @param serializationType Optional. Has 3 possible values. Can copy objects as-is, or can
 *                          serialize objects to Lua tables, or can deserialize Lua tables to
 *                          objects. Default is `SerializationType.NONE`.
 * @param traversalDescription Optional. Used to track the current key that we are operating on for
 *                             debugging purposes. Default is an empty string.
 * @param classConstructors Optional. A Lua table that maps the name of a user-defined TSTL class to
 *                          its corresponding constructor. If the `deepCopy` function finds any
 *                          user-defined TSTL classes when recursively iterating through the given
 *                          object, it will use this map to instantiate a new class. Default is an
 *                          empty Lua table.
 * @param insideMap Optional. Tracks whether the deep copy function is in the process of recursively
 *                  copying a TSTL Map. Default is false.
 */
export function deepCopy<T>(
  // An overload describing the trivial case of a normal copy. (T --> T)
  value: T,
  serializationType?: SerializationType.NONE,
  traversalDescription?: string,
  classConstructors?: LuaMap<string, AnyClass>,
  insideMap?: boolean,
): T;
export function deepCopy(
  // An overload describing the serialization/deserialization case.
  value: unknown,
  serializationType: SerializationType,
  traversalDescription?: string,
  classConstructors?: LuaMap<string, AnyClass>,
  insideMap?: boolean,
): unknown; // The return types for serialization/deserialization are non-trivial, so we do not annotate them.
export function deepCopy(
  value: unknown,
  serializationType = SerializationType.NONE,
  traversalDescription = "",
  classConstructors = new LuaMap<string, AnyClass>(),
  insideMap = false,
): unknown {
  if (SAVE_DATA_MANAGER_DEBUG) {
    let logString = `deepCopy is operating on: ${traversalDescription}`;
    if (serializationType === SerializationType.SERIALIZE) {
      logString += " (serializing)";
    } else if (serializationType === SerializationType.DESERIALIZE) {
      logString += " (deserializing)";
    }
    logString += `: ${value}`;
    log(logString);
  }

  const valueType = type(value);
  switch (valueType) {
    // First, handling the trivial case of primitives.
    case "nil":
    case "boolean":
    case "number":
    case "string": {
      return value;
    }

    // Second, handle values that cannot be serialized.
    case "function":
    case "thread": {
      if (serializationType === SerializationType.SERIALIZE) {
        error(
          `The deep copy function does not support serialization of "${traversalDescription}", since it is type: ${valueType}`,
        );
      }

      if (serializationType === SerializationType.DESERIALIZE) {
        error(
          `The deep copy function does not support deserialization of "${traversalDescription}", since it is type: ${valueType}`,
        );
      }

      // We cannot copy this, so simply return the reference.
      return value;
    }

    case "table": {
      const luaMap = value as LuaMap<AnyNotNil, unknown>;
      return deepCopyTable(
        luaMap,
        serializationType,
        traversalDescription,
        classConstructors,
        insideMap,
      );
    }

    case "userdata": {
      return deepCopyUserdata(value, serializationType, traversalDescription);
    }
  }
}

function deepCopyTable(
  luaMap: LuaMap<AnyNotNil, unknown>,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): unknown {
  // First, handle the cases of TSTL classes or serialized TSTL classes.
  if (isDefaultMap(luaMap) || luaMap.has(SerializationBrand.DEFAULT_MAP)) {
    return deepCopyDefaultMap(
      luaMap,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
  }

  if (isTSTLMap(luaMap) || luaMap.has(SerializationBrand.MAP)) {
    return deepCopyMap(
      luaMap,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
  }

  if (isTSTLSet(luaMap) || luaMap.has(SerializationBrand.SET)) {
    return deepCopySet(
      luaMap,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
  }

  const className = getTSTLClassName(luaMap);

  if (className === "WeakMap") {
    error(
      `The deep copy function does not support copying the "WeakMap" class for: ${traversalDescription}`,
    );
  }

  if (className === "WeakSet") {
    error(
      `The deep copy function does not support copying the "WeakSet" class for: ${traversalDescription}`,
    );
  }

  if (className !== undefined || luaMap.has(SerializationBrand.TSTL_CLASS)) {
    return deepCopyTSTLClass(
      luaMap as TSTLClass,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
  }

  // This is not a TSTL Map/Set/class. If it has a metatable, abort.
  checkMetatable(luaMap, traversalDescription);

  // Handle the special case of serialized Isaac API classes.
  if (
    isSerializedIsaacAPIClass(luaMap) &&
    serializationType === SerializationType.DESERIALIZE
  ) {
    return deserializeIsaacAPIClass(luaMap);
  }

  // Handle the special case of an array.
  if (isArray(luaMap)) {
    return deepCopyArray(
      luaMap,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
  }

  // Base case: copy a normal Lua table
  return deepCopyNormalLuaTable(
    luaMap,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );
}

function deepCopyDefaultMap(
  defaultMap: DefaultMap<AnyNotNil, unknown> | LuaMap<AnyNotNil, unknown>,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): ReadonlyMap<AnyNotNil, unknown> | Readonly<LuaMap<AnyNotNil, unknown>> {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying a DefaultMap.");
  }

  const constructorArg = isDefaultMap(defaultMap)
    ? defaultMap.getConstructorArg()
    : undefined; // The undefined case is handled explicitly in the "getNewDefaultMap" function.

  // First, handle the special case of serializing a DefaultMap instantiated with a factory
  // function. If this is the case, then we cannot serialize it (because there is no way to
  // serialize a function).
  if (
    serializationType === SerializationType.SERIALIZE &&
    !isPrimitive(constructorArg)
  ) {
    if (insideMap) {
      // The case of a DefaultMap within another map is complicated. Unlike a DefaultMap attached to
      // a "normal" object, the `merge` function will have no reference to the factory function that
      // was used to instantiate it. Thus, there is no way to copy this object. In this case, we
      // throw a run-time error to immediately alert the end-user that their data structure is
      // invalid.
      error(
        "Failed to deep copy a DefaultMap because it was instantiated with a factory function and was also inside of an array, map, or set. For more information, see: https://isaacscript.github.io/main/gotchas#failed-to-deep-copy-a-defaultmap",
      );
    } else {
      // In most cases, the DefaultMap will be attached to a normal table element. In this case, if
      // we serialize it as a normal `Map`, then everything will work out fine, because the `merge`
      // function only needs to copy the values (and not instantiate the object itself).
      return deepCopyMap(
        defaultMap,
        serializationType,
        traversalDescription,
        classConstructors,
        insideMap,
      );
    }
  }

  const newDefaultMap = getNewDefaultMap(
    defaultMap,
    serializationType,
    traversalDescription,
    constructorArg,
  );
  insideMap = true;

  const { entries, convertedNumberKeysToStrings } = getCopiedEntries(
    defaultMap,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );

  if (convertedNumberKeysToStrings) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isDefaultMap(newDefaultMap)) {
      newDefaultMap.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
    } else {
      newDefaultMap.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
    }
  }

  for (const [key, value] of entries) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isDefaultMap(newDefaultMap)) {
      newDefaultMap.set(key, value);
    } else {
      newDefaultMap.set(key, value);
    }
  }

  insideMap = false;

  return newDefaultMap;
}

/**
 * The new copied default map with either be a TSTL `DefaultMap` class or a Lua table, depending on
 * whether we are serializing.
 */
function getNewDefaultMap(
  defaultMap: DefaultMap<AnyNotNil, unknown> | LuaMap<AnyNotNil, unknown>,
  serializationType: SerializationType,
  traversalDescription: string,
  constructorArg: unknown,
): DefaultMap<AnyNotNil, unknown> | LuaMap<AnyNotNil, unknown> {
  switch (serializationType) {
    case SerializationType.NONE: {
      // eslint-disable-next-line isaacscript/no-invalid-default-map
      return new DefaultMap(constructorArg);
    }

    case SerializationType.SERIALIZE: {
      // Since we are serializing, the new object will be a Lua table. (At this point, we already
      // handled the special case of a DefaultMap instantiated with a factory function.)
      const newDefaultMap = new LuaMap<AnyNotNil, unknown>();
      newDefaultMap.set(SerializationBrand.DEFAULT_MAP, "");
      newDefaultMap.set(SerializationBrand.DEFAULT_MAP_VALUE, constructorArg);

      return newDefaultMap;
    }

    case SerializationType.DESERIALIZE: {
      if (isDefaultMap(defaultMap)) {
        error(
          `Failed to deserialize a default map of "${traversalDescription}", since it was not a Lua table.`,
        );
      }

      const defaultMapValue = defaultMap.get(
        SerializationBrand.DEFAULT_MAP_VALUE,
      );
      assertDefined(
        defaultMapValue,
        `Failed to deserialize a default map of "${traversalDescription}", since there was no serialization brand of: ${SerializationBrand.DEFAULT_MAP_VALUE}`,
      );

      // eslint-disable-next-line isaacscript/no-invalid-default-map
      return new DefaultMap(defaultMapValue);
    }
  }
}

function deepCopyMap(
  map: ReadonlyMap<AnyNotNil, unknown> | Readonly<LuaMap<AnyNotNil, unknown>>,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): ReadonlyMap<AnyNotNil, unknown> | Readonly<LuaMap<AnyNotNil, unknown>> {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying a Map.");
  }

  let newMap: Map<AnyNotNil, unknown> | LuaMap<AnyNotNil, unknown>;
  if (serializationType === SerializationType.SERIALIZE) {
    // Since we are serializing, the new object will be a Lua table.
    newMap = new LuaMap<AnyNotNil, unknown>();
    newMap.set(SerializationBrand.MAP, "");
  } else {
    newMap = new Map();
  }
  insideMap = true;

  const { entries, convertedNumberKeysToStrings } = getCopiedEntries(
    map,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );

  if (convertedNumberKeysToStrings) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isTSTLMap(newMap)) {
      newMap.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
    } else {
      newMap.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
    }
  }

  for (const [key, value] of entries) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isTSTLMap(newMap)) {
      newMap.set(key, value);
    } else {
      newMap.set(key, value);
    }
  }

  insideMap = false;

  return newMap;
}

function deepCopySet(
  set: ReadonlySet<AnyNotNil> | Readonly<LuaMap<AnyNotNil, unknown>>,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): ReadonlySet<AnyNotNil> | Readonly<LuaMap<AnyNotNil, string>> {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying a Set.");
  }

  let newSet: Set<AnyNotNil> | LuaMap<AnyNotNil, string>;
  if (serializationType === SerializationType.SERIALIZE) {
    // For serialization purposes, we represent a `Set` as a table with keys that match the
    // keys/values in the Set and values of an empty string.
    newSet = new LuaMap<AnyNotNil, string>();
    newSet.set(SerializationBrand.SET, "");
  } else {
    newSet = new Set();
  }

  const { entries, convertedNumberKeysToStrings } = getCopiedEntries(
    set,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );

  if (convertedNumberKeysToStrings) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isTSTLSet(newSet)) {
      // We should never be serializing an object of type `Set`.
      error(
        "The deep copy function cannot convert number keys to strings for a Set.",
      );
    } else {
      newSet.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
    }
  }

  for (const [key] of entries) {
    // Differentiating between the two types looks superfluous but is necessary for TSTL to produce
    // the proper set method call.
    if (isTSTLSet(newSet)) {
      newSet.add(key);
    } else {
      newSet.set(key, "");
    }
  }

  return newSet;
}

function deepCopyTSTLClass(
  tstlClass: TSTLClass,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
) {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying a TSTL class.");
  }

  let newClass: TSTLClass | LuaMap<AnyNotNil, unknown>;
  switch (serializationType) {
    case SerializationType.NONE: {
      // We can use the class constructor from the old class.
      newClass = newTSTLClass(tstlClass);
      break;
    }

    case SerializationType.SERIALIZE: {
      newClass = new LuaMap<AnyNotNil, unknown>();

      // We brand it with the name of the class so that we can run the corresponding constructor
      // during deserialization.
      const tstlClassName = getTSTLClassName(tstlClass);
      if (tstlClassName !== undefined) {
        newClass.set(SerializationBrand.TSTL_CLASS, tstlClassName);
      }

      break;
    }

    case SerializationType.DESERIALIZE: {
      const tstlClassName = tstlClass.get(SerializationBrand.TSTL_CLASS) as
        | string
        | undefined;
      assertDefined(
        tstlClassName,
        "Failed to deserialize a TSTL class since the brand did not contain the class name.",
      );

      const classConstructor = classConstructors.get(tstlClassName);
      assertDefined(
        classConstructor,
        `Failed to deserialize a TSTL class since there was no constructor registered for a class name of "${tstlClassName}". If this mod is using the save data manager, it must register the class constructor with the "saveDataManagerRegisterClass" method.`,
      );

      // eslint-disable-next-line new-cap
      newClass = new classConstructor() as TSTLClass;

      break;
    }
  }

  const { entries, convertedNumberKeysToStrings } = getCopiedEntries(
    tstlClass,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );

  if (convertedNumberKeysToStrings) {
    newClass.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
  }

  for (const [key, value] of entries) {
    newClass.set(key, value);
  }

  return newClass;
}

function deepCopyArray(
  array: readonly unknown[],
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): readonly unknown[] {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying an array.");
  }

  const newArray: unknown[] = [];

  for (const value of array) {
    const newValue = deepCopy(
      value,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );
    newArray.push(newValue);
  }

  return newArray;
}

function deepCopyNormalLuaTable(
  luaMap: LuaMap<AnyNotNil, unknown>,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
) {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log("deepCopy is copying a normal Lua table.");
  }

  const newTable = new LuaMap<AnyNotNil, unknown>();
  const { entries, convertedNumberKeysToStrings } = getCopiedEntries(
    luaMap,
    serializationType,
    traversalDescription,
    classConstructors,
    insideMap,
  );

  if (convertedNumberKeysToStrings) {
    newTable.set(SerializationBrand.OBJECT_WITH_NUMBER_KEYS, "");
  }

  for (const [key, value] of entries) {
    newTable.set(key, value);
  }

  return newTable;
}

/**
 * Recursively clones the object's entries, automatically converting number keys to strings, if
 * necessary.
 *
 * This should work on objects/tables, maps, sets, default maps, and classes.
 */
function getCopiedEntries(
  object: unknown,
  serializationType: SerializationType,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
  insideMap: boolean,
): {
  entries: Array<[key: AnyNotNil, value: unknown]>;
  convertedNumberKeysToStrings: boolean;
} {
  // First, shallow copy the entries. We cannot use "pairs" to iterate over a `Map` or `Set`. We
  // cannot use "[...pairs(object)]", as it results in a run-time error.
  const entries: Array<[key: AnyNotNil, value: unknown]> = [];
  if (isTSTLMap(object) || isTSTLSet(object) || isDefaultMap(object)) {
    for (const [key, value] of object.entries()) {
      entries.push([key, value]);
    }
  } else {
    for (const [key, value] of pairs(object)) {
      entries.push([key, value]);
    }
  }

  if (SAVE_DATA_MANAGER_DEBUG) {
    entries.sort(sortTwoDimensionalArray);
  }

  // During serialization, we brand some Lua tables with a special identifier to signify that it has
  // keys that should be deserialized to numbers.
  const convertStringKeysToNumbers =
    serializationType === SerializationType.DESERIALIZE &&
    entries.some(
      ([key]) => key === asString(SerializationBrand.OBJECT_WITH_NUMBER_KEYS),
    );

  const hasNumberKeys = entries.some(([key]) => isNumber(key));
  const convertNumberKeysToStrings =
    serializationType === SerializationType.SERIALIZE && hasNumberKeys;

  // Second, deep copy the entries.
  const copiedEntries: Array<[key: AnyNotNil, value: unknown]> = [];
  for (const [key, value] of entries) {
    // When deserializing, we do not need to copy the serialization brands that are used to denote
    // the object type.
    if (isSerializationBrand(key)) {
      continue;
    }

    traversalDescription = getTraversalDescription(key, traversalDescription);
    const newValue = deepCopy(
      value,
      serializationType,
      traversalDescription,
      classConstructors,
      insideMap,
    );

    let keyToUse = key;
    if (convertStringKeysToNumbers) {
      const numberKey = tonumber(key);
      if (numberKey !== undefined) {
        keyToUse = numberKey;
      }
    }
    if (convertNumberKeysToStrings) {
      keyToUse = tostring(key);
    }
    copiedEntries.push([keyToUse, newValue]);
  }

  return {
    entries: copiedEntries,
    convertedNumberKeysToStrings: convertNumberKeysToStrings,
  };
}

/**
 * Lua tables can have metatables, which make writing a generic deep cloner impossible. The deep
 * copy function will refuse to copy a table type that has a metatable, outside of specifically
 * supported TSTL objects.
 */
function checkMetatable(
  luaMap: LuaMap<AnyNotNil, unknown>,
  traversalDescription: string,
) {
  const metatable = getmetatable(luaMap);
  if (metatable === undefined) {
    return;
  }

  const tableDescription =
    traversalDescription === ""
      ? "the table to copy"
      : `"${traversalDescription}"`;

  error(
    `The deepCopy function detected that ${tableDescription} has a metatable. Copying tables with metatables is not supported, unless they are explicitly handled by the save data manager. (e.g. TypeScriptToLua Maps, TypeScriptToLua Sets, etc.)`,
  );
}

/** Isaac API classes are of type "userdata". End-user code cannot create userdata. */
function deepCopyUserdata(
  value: unknown,
  serializationType: SerializationType,
  traversalDescription: string,
) {
  if (!isCopyableIsaacAPIClass(value)) {
    const className = getIsaacAPIClassName(value) ?? "Unknown";
    error(
      `The deep copy function does not support serializing "${traversalDescription}", since it is an Isaac API class of type: ${className}`,
    );
  }

  switch (serializationType) {
    case SerializationType.NONE: {
      return copyIsaacAPIClass(value);
    }

    case SerializationType.SERIALIZE: {
      return serializeIsaacAPIClass(value);
    }

    case SerializationType.DESERIALIZE: {
      return error(
        `The deep copy function can not deserialize "${traversalDescription}", since it is userdata.`,
      );
    }
  }
}

----
functions\deepCopyTests.ts
import { DefaultMap } from "../classes/DefaultMap";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { SerializationType } from "../enums/SerializationType";
import { arrayEquals } from "./array";
import { deepCopy } from "./deepCopy";
import { log } from "./log";
import { isDefaultMap, isTSTLMap, isTSTLSet } from "./tstlClass";
import { isNumber, isString, isTable } from "./types";

/**
 * Run the suite of tests that prove that the "deepCopy" helper function works properly.
 *
 * This function is only useful if you are troubleshooting the "deepCopy" function.
 */
export function runDeepCopyTests(): void {
  copiedObjectIsTable();
  copiedObjectHasKeyAndValueString();
  copiedTableHasKeyAndValueNumber();
  copiedTableDoesNotCoerceTypes();
  copiedObjectHasNoReferencesForPrimitivesForward();
  copiedObjectHasNoReferencesForPrimitivesBackward();
  copiedObjectHasNoReferencesForArray();
  copiedObjectHasChildObject();

  copiedMapIsMap();
  copiedMapHasValue();

  copiedSetIsSet();
  copiedSetHasValue();

  copiedMapHasChildMap();
  copiedDefaultMapHasChildDefaultMap();
  copiedDefaultMapHasBrand();

  copiedSerializedMapHasStringKey();
  copiedSerializedMapHasNumberKey();

  copiedSerializedDefaultMapHasStringKey();
  copiedSerializedDefaultMapHasNumberKey();

  const successText = "All deep copy tests passed!";
  log(successText);
  print(successText);
}

function copiedObjectIsTable() {
  const oldObject = {
    abc: "def",
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectIsTable",
  );
  if (!isTable(newObject)) {
    error(`The copied object had a type of: ${typeof newObject}`);
  }
}

function copiedObjectHasKeyAndValueString() {
  const keyToLookFor = "abc";
  const valueToLookFor = "def";
  const oldObject = {
    abc: valueToLookFor,
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectHasKeyAndValueString",
  );

  const value = newObject[keyToLookFor] as string | undefined;
  if (value === undefined) {
    error(`The copied object did not have a key of: ${keyToLookFor}`);
  }

  if (!isString(value)) {
    error(`The copied object had a value type of: ${typeof value}`);
  }
  if (value !== valueToLookFor) {
    error(`The copied object had a value of: ${value}`);
  }
}

function copiedTableHasKeyAndValueNumber() {
  const keyToLookFor = 123;
  const valueToLookFor = 456;
  const oldTable = new LuaMap<AnyNotNil, unknown>();
  oldTable.set(keyToLookFor, valueToLookFor);

  const newTable = deepCopy(
    oldTable,
    SerializationType.NONE,
    "copiedTableHasKeyAndValueNumber",
  );

  const value = newTable.get(keyToLookFor) as number | undefined;
  if (value === undefined) {
    error(`The copied object did not have a key of: ${keyToLookFor}`);
  }

  if (!isNumber(value)) {
    error(`The copied object had a value type of: ${typeof value}`);
  }
  if (value !== valueToLookFor) {
    error(`The copied object had a value of: ${value}`);
  }
}

function copiedTableDoesNotCoerceTypes() {
  const keyToLookFor = 123;
  const valueToLookFor = 456;
  const oldTable = new LuaMap<AnyNotNil, unknown>();
  oldTable.set(keyToLookFor, valueToLookFor);

  const newTable = deepCopy(
    oldTable,
    SerializationType.NONE,
    "copiedTableDoesNotCoerceTypes",
  );

  const keyString = tostring(keyToLookFor);
  const valueString = tostring(valueToLookFor);

  const valueFromString = newTable.get(keyString);
  if (valueFromString !== undefined) {
    error(`The copied object had a string key of: ${keyString}`);
  }

  const value = newTable.get(keyToLookFor);
  if (value === valueString) {
    error(
      `The copied object had a value that incorrectly matched the string of: ${valueString}`,
    );
  }
}

/** In this context, a reference is a pointer. */
function copiedObjectHasNoReferencesForPrimitivesForward() {
  const originalStringValue = "abcdef";
  const originalNumberValue = 123;
  const oldObject = {
    abc: originalStringValue,
    def: originalNumberValue,
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectHasNoReferencesForPrimitivesForward",
  );

  oldObject.abc = "newValue";
  if (oldObject.abc === newObject.abc) {
    error("The copied object has a string reference going forward.");
  }

  oldObject.def = 456;
  if (oldObject.def === newObject.def) {
    error("The copied object has a number reference going forward.");
  }
}

function copiedObjectHasNoReferencesForPrimitivesBackward() {
  const originalStringValue = "abcdef";
  const originalNumberValue = 123;
  const oldObject = {
    abc: originalStringValue,
    def: originalNumberValue,
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectHasNoReferencesForPrimitivesBackward",
  );

  newObject.abc = "newValue";
  if (newObject.abc === oldObject.abc) {
    error("The copied object has a string reference going backward.");
  }

  newObject.def = 456;
  if (newObject.def === oldObject.def) {
    error("The copied object has a number reference going backward.");
  }
}

/** In this context, a reference is a pointer. */
function copiedObjectHasNoReferencesForArray() {
  const oldObject = {
    abc: [1, 2, 3],
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectHasNoReferencesForArray",
  );

  if (oldObject.abc === newObject.abc) {
    error("The copied object has the same point to the child array.");
  }

  if (!arrayEquals(oldObject.abc, newObject.abc)) {
    error("The copied object does not have an equal array.");
  }

  oldObject.abc[0]++;
  if (arrayEquals(oldObject.abc, newObject.abc)) {
    error(
      "The copied object has an equal array after a modification to the old array.",
    );
  }
  oldObject.abc[0]--;

  newObject.abc[0]++;
  if (arrayEquals(oldObject.abc, newObject.abc)) {
    error(
      "The copied object has an equal array after a modification to the new array.",
    );
  }
  newObject.abc[0]--;
}

function copiedObjectHasChildObject() {
  const childObjectIndex = "abc";
  const keyToLookFor = "def";
  const valueToLookFor = "ghi";
  const oldObject = {
    abc: {
      def: valueToLookFor,
    },
  };
  const newObject = deepCopy(
    oldObject,
    SerializationType.NONE,
    "copiedObjectHasChildObject",
  );

  const childObject = newObject[childObjectIndex] as
    | (typeof oldObject)["abc"]
    | undefined;
  if (childObject === undefined) {
    error(`Failed to find the child object at index: ${childObjectIndex}`);
  }

  if (!isTable(childObject)) {
    error(`The copied child object had a type of: ${typeof childObject}`);
  }

  const value = childObject[keyToLookFor] as string | undefined;
  if (value === undefined) {
    error(`The child object did not have a key of: ${keyToLookFor}`);
  }

  if (!isString(value)) {
    error(`The child object value had a type of: ${typeof value}`);
  }
  if (value !== valueToLookFor) {
    error(`The child object value was: ${valueToLookFor}`);
  }
}

function copiedMapIsMap() {
  const keyToLookFor = "abc";
  const valueToLookFor = "def";
  const oldMap = new Map<string, string>();
  oldMap.set(keyToLookFor, valueToLookFor);

  const newMap = deepCopy(oldMap, SerializationType.NONE, "copiedMapIsMap");

  if (!isTSTLMap(newMap)) {
    error(`The copied Map was not a Map and has a type of: ${typeof newMap}`);
  }
}

function copiedMapHasValue() {
  const keyToLookFor = "abc";
  const valueToLookFor = "def";
  const oldMap = new Map<string, string>();
  oldMap.set(keyToLookFor, valueToLookFor);

  const newMap = deepCopy(oldMap, SerializationType.NONE, "copiedMapHasValue");

  if (!isTSTLMap(newMap)) {
    error(`The copied Map was not a Map and has a type of: ${typeof newMap}`);
  }

  const value = newMap.get(keyToLookFor);
  if (value === undefined) {
    error(`The copied Map did not have a key of: ${keyToLookFor}`);
  }
  if (value !== valueToLookFor) {
    error(`The copied Map did not have a value of: ${valueToLookFor}`);
  }
}

function copiedSetIsSet() {
  const valueToLookFor = "abc";
  const oldSet = new Set<string>();
  oldSet.add(valueToLookFor);

  const newSet = deepCopy(oldSet, SerializationType.NONE, "copiedSetIsSet");

  if (!isTSTLSet(newSet)) {
    error(`The copied Set was not a Set and has a type of: ${typeof newSet}`);
  }
}

function copiedSetHasValue() {
  const valueToLookFor = "abc";
  const oldSet = new Set<string>();
  oldSet.add(valueToLookFor);

  const newSet = deepCopy(oldSet, SerializationType.NONE, "copiedSetHasValue");

  if (!isTSTLSet(newSet)) {
    error(`The copied Set was not a Set and has a type of: ${typeof newSet}`);
  }

  const hasValue = newSet.has(valueToLookFor);
  if (!hasValue) {
    error(`The copied Set did not have a value of: ${valueToLookFor}`);
  }
}

function copiedMapHasChildMap() {
  const childMapKey = 123;
  const childMapValue = 456;
  const oldChildMap = new Map<number, number>();
  oldChildMap.set(childMapKey, childMapValue);

  const keyToLookFor = "childMap";
  const oldMap = new Map<string, Map<number, number>>();
  oldMap.set(keyToLookFor, oldChildMap);

  const newMap = deepCopy(
    oldMap,
    SerializationType.NONE,
    "copiedMapHasChildMap",
  );

  if (!isTSTLMap(newMap)) {
    error(`The copied Map was not a Map and had a type of: ${typeof newMap}`);
  }

  const newChildMap = newMap.get(keyToLookFor);
  if (newChildMap === undefined) {
    error(`The copied Map did not have a child map at key: ${keyToLookFor}`);
  }

  if (!isTSTLMap(newChildMap)) {
    error(
      `The copied child Map was not a Map and had a type of: ${typeof newChildMap}`,
    );
  }

  const value = newChildMap.get(childMapKey);
  if (value === undefined) {
    error(`The copied child Map did not have a key of: ${childMapKey}`);
  }
  if (value !== childMapValue) {
    error(`The copied child Map did not have a value of: ${childMapValue}`);
  }
}

function copiedDefaultMapHasChildDefaultMap() {
  const parentMapKey = "abc";
  const childMapKey1 = 123;
  const childMapKey2 = 456;
  const childMapDefaultValue = 1;
  const childMapCustomValue = 2;
  const oldParentMap = new DefaultMap<string, DefaultMap<number, number>>(
    () => new DefaultMap(childMapDefaultValue),
  );
  const oldChildMap = oldParentMap.getAndSetDefault(parentMapKey);
  oldChildMap.getAndSetDefault(childMapKey1);
  oldChildMap.set(childMapKey2, childMapCustomValue);

  const newParentMap = deepCopy(
    oldParentMap,
    SerializationType.NONE,
    "copiedDefaultMapHasChildDefaultMap",
  );

  if (!isDefaultMap(newParentMap)) {
    error(
      `The copied parent DefaultMap was not a DefaultMap and had a type of: ${typeof newParentMap}`,
    );
  }

  const newChildMap = newParentMap.get(parentMapKey);
  if (newChildMap === undefined) {
    error(
      `The copied DefaultMap did not have a child map at key: ${parentMapKey}`,
    );
  }

  if (!isDefaultMap(newChildMap)) {
    error(
      `The copied child DefaultMap was not a DefaultMap and had a type of: ${typeof newChildMap}`,
    );
  }

  const newChildMapValue1 = newChildMap.get(childMapKey1);
  if (newChildMapValue1 === undefined) {
    error(`The copied child DefaultMap did not have a key of: ${childMapKey1}`);
  }
  if (newChildMapValue1 !== childMapDefaultValue) {
    error(
      `The copied child Map did not have a default value of: ${childMapDefaultValue}`,
    );
  }

  const newChildMapValue2 = newChildMap.get(childMapKey2);
  if (newChildMapValue2 === undefined) {
    error(`The copied child DefaultMap did not have a key of: ${childMapKey2}`);
  }
  if (newChildMapValue2 !== childMapCustomValue) {
    error(
      `The copied child Map did not have a custom value of: ${childMapCustomValue}`,
    );
  }
}

function copiedDefaultMapHasBrand() {
  const oldDefaultValue = "foo";
  const oldDefaultMap = new DefaultMap<string, string>(oldDefaultValue);
  const newTable = deepCopy(
    oldDefaultMap,
    SerializationType.SERIALIZE,
    "copiedDefaultMapHasBrand",
  ) as LuaMap<AnyNotNil, unknown>;

  if (!isTable(newTable)) {
    error(
      `The copied DefaultMap was not a table and had a type of: ${typeof newTable}`,
    );
  }

  if (!newTable.has(SerializationBrand.DEFAULT_MAP)) {
    error(
      `The copied DefaultMap does not have the brand: ${SerializationBrand.DEFAULT_MAP}`,
    );
  }
}

function copiedSerializedMapHasStringKey() {
  const mapKey = "123";
  const mapValue = 456;
  const oldMap = new Map<string, number>();
  oldMap.set(mapKey, mapValue);

  const serializedOldMap = deepCopy(
    oldMap,
    SerializationType.SERIALIZE,
    "copiedSerializedMapHasStringKey-serialize",
  );

  const newTable = deepCopy(
    serializedOldMap,
    SerializationType.DESERIALIZE,
    "copiedSerializedMapHasStringKey-deserialize",
  );

  const newMap = newTable as Map<string, number>;
  if (!newMap.has(mapKey)) {
    const keyType = type(mapKey);
    error(
      `The copied Map did not have a key of: ${mapKey} with type ${keyType}`,
    );
  }
}

function copiedSerializedMapHasNumberKey() {
  const mapKey = 123;
  const mapValue = 456;
  const oldMap = new Map<number, number>();
  oldMap.set(mapKey, mapValue);

  const serializedOldMap = deepCopy(
    oldMap,
    SerializationType.SERIALIZE,
    "copiedSerializedMapHasNumberKey-serialize",
  );

  const newTable = deepCopy(
    serializedOldMap,
    SerializationType.DESERIALIZE,
    "copiedSerializedMapHasNumberKey-deserialize",
  );

  const newMap = newTable as Map<number, number>;
  if (!newMap.has(mapKey)) {
    const keyType = type(mapKey);
    error(
      `The copied Map did not have a key of: ${mapKey} with type ${keyType}`,
    );
  }
}

function copiedSerializedDefaultMapHasStringKey() {
  const mapKey = "123";
  const oldDefaultMap = new DefaultMap<string, number>(456);
  oldDefaultMap.getAndSetDefault(mapKey);

  const serializedOldDefaultMap = deepCopy(
    oldDefaultMap,
    SerializationType.SERIALIZE,
    "copiedSerializedDefaultMapHasStringKey-serialize",
  );

  const newTable = deepCopy(
    serializedOldDefaultMap,
    SerializationType.DESERIALIZE,
    "copiedSerializedDefaultMapHasStringKey-deserialize",
  );

  const newDefaultMap = newTable as DefaultMap<string, number>;
  if (!newDefaultMap.has(mapKey)) {
    const keyType = type(mapKey);
    error(
      `The copied DefaultMap did not have a key of "${mapKey}" with type: ${keyType}`,
    );
  }
}

function copiedSerializedDefaultMapHasNumberKey() {
  const mapKey = 123;
  const oldDefaultMap = new DefaultMap<number, number>(456);
  oldDefaultMap.getAndSetDefault(mapKey);

  const serializedOldDefaultMap = deepCopy(
    oldDefaultMap,
    SerializationType.SERIALIZE,
    "copiedSerializedDefaultMapHasNumberKey-serialize",
  );

  const newTable = deepCopy(
    serializedOldDefaultMap,
    SerializationType.DESERIALIZE,
    "copiedSerializedDefaultMapHasNumberKey-deserialize",
  );

  const newDefaultMap = newTable as DefaultMap<number, number>;
  if (!newDefaultMap.has(mapKey)) {
    const keyType = type(mapKey);
    error(
      `The copied DefaultMap did not have a key of: ${mapKey} with type ${keyType}`,
    );
  }
}

----
functions\dimensions.ts
import { Dimension } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { DIMENSIONS } from "../core/constants";
import { getRoomGridIndex } from "./roomData";

/**
 * Helper function to get the current dimension. Most of the time, this will be `Dimension.MAIN`,
 * but it can change if e.g. the player is in the mirror world of Downpour/Dross.
 */
export function getDimension(): Dimension {
  const level = game.GetLevel();
  const roomGridIndex = getRoomGridIndex();
  const roomDescription = level.GetRoomByIdx(roomGridIndex, Dimension.CURRENT);
  const currentRoomHash = GetPtrHash(roomDescription);

  for (const dimension of DIMENSIONS) {
    const dimensionRoomDescription = level.GetRoomByIdx(
      roomGridIndex,
      dimension,
    );
    const dimensionRoomHash = GetPtrHash(dimensionRoomDescription);

    if (dimensionRoomHash === currentRoomHash) {
      return dimension;
    }
  }

  error("Failed to get the current dimension.");
}

export function inDimension(dimension: Dimension): boolean {
  return dimension === getDimension();
}

----
functions\direction.ts
import type { ButtonAction } from "isaac-typescript-definitions";
import { Direction } from "isaac-typescript-definitions";
import { DIRECTION_NAMES } from "../objects/directionNames";
import { DIRECTION_TO_DEGREES } from "../objects/directionToDegrees";
import { DIRECTION_TO_MOVE_ACTION } from "../objects/directionToMoveAction";
import { DIRECTION_TO_SHOOT_ACTION } from "../objects/directionToShootAction";
import { DIRECTION_TO_VECTOR } from "../objects/directionToVector";

/**
 * Helper function to convert the degrees of an angle to the `Direction` enum.
 *
 * Note that this function considers 0 degrees to be pointing to the right, which is unusual because
 * 0 normally corresponds to up. (This corresponds to how the `Vector.GetAngleDegrees` method
 * works.)
 */
export function angleToDirection(angleDegrees: int): Direction {
  let positiveDegrees = angleDegrees;
  while (positiveDegrees < 0) {
    positiveDegrees += 360;
  }
  const normalizedDegrees = positiveDegrees % 360;

  if (normalizedDegrees < 45) {
    return Direction.RIGHT;
  }

  if (normalizedDegrees < 135) {
    return Direction.DOWN;
  }

  if (normalizedDegrees < 225) {
    return Direction.LEFT;
  }

  if (normalizedDegrees < 315) {
    return Direction.UP;
  }

  return Direction.RIGHT;
}

/**
 * Helper function to convert a direction to degrees. For example, `Direction.LEFT` (0) would return
 * 180 and `Direction.RIGHT` (2) would return 0. (This corresponds to how the
 * `Vector.GetAngleDegrees` method works.)
 */
export function directionToDegrees(direction: Direction): int {
  return DIRECTION_TO_DEGREES[direction];
}

/**
 * Helper function to convert a direction to a shoot `ButtonAction`. For example, `Direction.LEFT`
 * (0) would return `ButtonAction.LEFT` (0).
 */
export function directionToMoveAction(
  direction: Direction,
): ButtonAction | undefined {
  return DIRECTION_TO_MOVE_ACTION[direction];
}

/**
 * Helper function to convert a direction to a shoot `ButtonAction`. For example, `Direction.LEFT`
 * (0) would return `ButtonAction.SHOOT_LEFT` (4).
 */
export function directionToShootAction(
  direction: Direction,
): ButtonAction | undefined {
  return DIRECTION_TO_SHOOT_ACTION[direction];
}

/**
 * Helper function to convert a direction to a `Vector`. For example, `Direction.LEFT` (0) would
 * convert to `Vector(-1, 0).
 */
export function directionToVector(direction: Direction): Readonly<Vector> {
  return DIRECTION_TO_VECTOR[direction];
}

/**
 * Helper function to get the lowercase name of a direction. For example, `Direction.LEFT` (0) would
 * return "left".
 */
export function getDirectionName(direction: Direction): string | undefined {
  return DIRECTION_NAMES[direction];
}

----
functions\doors.ts
import type {
  Direction,
  DoorSlotFlag,
  RoomShape,
} from "isaac-typescript-definitions";
import {
  DoorSlot,
  DoorState,
  DoorVariant,
  GridEntityType,
  GridRoom,
  RoomType,
} from "isaac-typescript-definitions";
import { DOOR_SLOT_FLAG_VALUES, DOOR_SLOT_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { DISTANCE_OF_GRID_TILE } from "../core/constants";
import {
  DEFAULT_DOOR_SLOT,
  DOOR_SLOT_FLAG_TO_DOOR_SLOT,
} from "../objects/doorSlotFlagToDoorSlot";
import { DOOR_SLOT_TO_DIRECTION } from "../objects/doorSlotToDirection";
import { DOOR_SLOT_TO_DOOR_SLOT_FLAG } from "../objects/doorSlotToDoorSlotFlag";
import { OPPOSITE_DOOR_SLOTS } from "../objects/oppositeDoorSlots";
import { ROOM_SHAPE_TO_DOOR_SLOT_COORDINATES } from "../objects/roomShapeToDoorSlotCoordinates";
import { ROOM_SHAPE_TO_DOOR_SLOTS } from "../objects/roomShapeToDoorSlots";
import { ReadonlySet } from "../types/ReadonlySet";
import { arrayToBitFlags } from "./bitwise";
import { directionToVector } from "./direction";
import { isEnumValue } from "./enums";
import { hasFlag } from "./flag";
import { isTSTLSet } from "./tstlClass";
import { parseIntSafe } from "./types";

export function closeAllDoors(): void {
  for (const door of getDoors()) {
    door.Close(true);
  }
}

/**
 * Use this instead of the `GridEntityDoor.Close` method if you want the door to immediately close
 * without an animation.
 */
export function closeDoorFast(door: GridEntityDoor): void {
  door.State = DoorState.CLOSED;

  const sprite = door.GetSprite();
  sprite.Play("Closed", true);
}

export function doorSlotFlagToDoorSlot(doorSlotFlag: DoorSlotFlag): DoorSlot {
  const doorSlot = DOOR_SLOT_FLAG_TO_DOOR_SLOT[doorSlotFlag];
  return doorSlot ?? DEFAULT_DOOR_SLOT;
}

export function doorSlotFlagsToDoorSlots(
  doorSlotFlags: BitFlags<DoorSlotFlag>,
): readonly DoorSlot[] {
  const doorSlots: DoorSlot[] = [];

  for (const doorSlotFlag of DOOR_SLOT_FLAG_VALUES) {
    if (hasFlag(doorSlotFlags, doorSlotFlag)) {
      const doorSlot = doorSlotFlagToDoorSlot(doorSlotFlag);
      doorSlots.push(doorSlot);
    }
  }

  return doorSlots;
}

export function doorSlotToDirection(doorSlot: DoorSlot): Direction {
  return DOOR_SLOT_TO_DIRECTION[doorSlot];
}

export function doorSlotToDoorSlotFlag(doorSlot: DoorSlot): DoorSlotFlag {
  return DOOR_SLOT_TO_DOOR_SLOT_FLAG[doorSlot];
}

/**
 * Helper function to convert an array of door slots or a set of door slots to the resulting bit
 * flag number.
 */
export function doorSlotsToDoorSlotFlags(
  doorSlots: readonly DoorSlot[] | ReadonlySet<DoorSlot>,
): BitFlags<DoorSlotFlag> {
  const doorSlotsMutable = doorSlots as DoorSlot[] | Set<DoorSlot>;

  const doorSlotArray: readonly DoorSlot[] = isTSTLSet(doorSlotsMutable)
    ? [...doorSlotsMutable.values()]
    : doorSlotsMutable;

  const doorSlotFlagArray = doorSlotArray.map((doorSlot) =>
    doorSlotToDoorSlotFlag(doorSlot),
  );

  return arrayToBitFlags(doorSlotFlagArray);
}

export function getAngelRoomDoor(): GridEntityDoor | undefined {
  const angelRoomDoors = getDoors(RoomType.ANGEL);
  return angelRoomDoors.length === 0 ? undefined : angelRoomDoors[0];
}

/**
 * Helper function to get the door that leads to the off-grid room that contains the hole to the
 * Blue Womb. (In vanilla, the door will only appear in the It Lives Boss Room.)
 *
 * Returns undefined if the room has no Blue Womb doors.
 */
export function getBlueWombDoor(): GridEntityDoor | undefined {
  const doors = getDoors();
  return doors.find((door) => isBlueWombDoor(door));
}

/**
 * Helper function to get the door that leads to the Boss Rush. (In vanilla, the door will only
 * appear in the Boss Room of the sixth floor.)
 *
 * Returns undefined if the room has no Boss Rush doors.
 */
export function getBossRushDoor(): GridEntityDoor | undefined {
  const doors = getDoors();
  return doors.find((door) => isBossRushDoor(door));
}

export function getDevilRoomDoor(): GridEntityDoor | undefined {
  const devilRoomDoors = getDoors(RoomType.DEVIL);
  return devilRoomDoors.length === 0 ? undefined : devilRoomDoors[0];
}

/**
 * If there is both a Devil Room and an Angel Room door, this function will return door with the
 * lowest slot number.
 */
export function getDevilRoomOrAngelRoomDoor(): GridEntityDoor | undefined {
  const devilRoomOrAngelRoomDoors = getDoors(RoomType.DEVIL, RoomType.ANGEL);
  return devilRoomOrAngelRoomDoors.length === 0
    ? undefined
    : devilRoomOrAngelRoomDoors[0];
}

/**
 * Helper function to get the position that a player will enter a room at corresponding to a door.
 *
 * When players enter a room, they do not appear exactly on the location of the door, because then
 * they would immediately collide with the loading zone. Instead, they appear on the grid tile next
 * to the door.
 */
export function getDoorEnterPosition(door: GridEntityDoor): Readonly<Vector> {
  const offset = getDoorSlotEnterPositionOffset(door.Slot);
  return door.Position.add(offset);
}

/**
 * Helper function to get the position that a player will enter a room at corresponding to a door
 * slot.
 *
 * When players enter a room, they do not appear exactly on the location of the door, because then
 * they would immediately collide with the loading zone. Instead, they appear on the grid tile next
 * to the door.
 */
export function getDoorSlotEnterPosition(doorSlot: DoorSlot): Readonly<Vector> {
  const room = game.GetRoom();
  const position = room.GetDoorSlotPosition(doorSlot);
  const offset = getDoorSlotEnterPositionOffset(doorSlot);
  return position.add(offset);
}

/**
 * Helper function to get the offset from a door position that a player will enter a room at.
 *
 * When players enter a room, they do not appear exactly on the location of the door, because then
 * they would immediately collide with the loading zone. Instead, they appear on the grid tile next
 * to the door.
 */
export function getDoorSlotEnterPositionOffset(
  doorSlot: DoorSlot,
): Readonly<Vector> {
  const direction = doorSlotToDirection(doorSlot);
  const vector = directionToVector(direction);

  // The player appears in the opposite direction of the way that the door is oriented in the room.
  const oppositeVector = vector.mul(-1);

  return oppositeVector.mul(DISTANCE_OF_GRID_TILE);
}

/** Helper function to get the possible door slots that can exist for a given room shape. */
export function getDoorSlotsForRoomShape(
  roomShape: RoomShape,
): ReadonlySet<DoorSlot> {
  return ROOM_SHAPE_TO_DOOR_SLOTS[roomShape];
}

/**
 * Helper function to get all of the doors in the room. By default, it will return every door.
 *
 * You can optionally specify one or more room types to return only the doors that match the
 * specified room types.
 *
 * @allowEmptyVariadic
 */
export function getDoors(
  ...roomTypes: readonly RoomType[]
): readonly GridEntityDoor[] {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();
  const roomTypesSet = new ReadonlySet(roomTypes);

  // We iterate over the possible door slots for this room shape instead of all door slots in order
  // to prevent crashes from accessing invalid memory.
  const possibleDoorSlots = getDoorSlotsForRoomShape(roomShape);

  const doors: GridEntityDoor[] = [];
  for (const doorSlot of possibleDoorSlots) {
    const door = room.GetDoor(doorSlot);
    if (door === undefined) {
      continue;
    }

    // In Repentance, sometimes doors won't be doors for some reason.
    const gridEntityType = door.GetType();
    if (gridEntityType !== GridEntityType.DOOR) {
      continue;
    }

    if (roomTypesSet.size === 0 || roomTypesSet.has(door.TargetRoomType)) {
      doors.push(door);
    }
  }

  return doors;
}

/**
 * Helper function to get all of the doors in the room that lead to the provided room index.
 *
 * This function is variadic, meaning that you can specify N arguments to return all of the doors
 * that match any of the N room grid indexes.
 */
export function getDoorsToRoomIndex(
  ...roomGridIndex: readonly int[]
): readonly GridEntityDoor[] {
  const roomGridIndexesSet = new ReadonlySet(roomGridIndex);
  const doors = getDoors();
  return doors.filter((door) => roomGridIndexesSet.has(door.TargetRoomIndex));
}

/**
 * Helper function to get the door that leads to the Mega Satan Boss Room. (In vanilla, the door
 * will only appear in the starting room of The Chest / Dark Room.)
 *
 * Returns undefined if the room has no Mega Satan doors.
 */
export function getMegaSatanDoor(): GridEntityDoor | undefined {
  const doors = getDoors();
  return doors.find((door) => isMegaSatanDoor(door));
}

export function getOppositeDoorSlot(doorSlot: DoorSlot): DoorSlot | undefined {
  return OPPOSITE_DOOR_SLOTS[doorSlot];
}

/**
 * Helper function to get the door that leads to the "secret exit" off-grid room that takes you to
 * the Repentance floor or to the version of Depths 2 that has Dad's Key.
 *
 * Returns undefined if the room has no Repentance doors.
 */
export function getRepentanceDoor(): GridEntityDoor | undefined {
  const doors = getDoors();
  return doors.find((door) => isRepentanceDoor(door));
}

/**
 * Helper function to get the corresponding door slot for a given room shape and grid coordinates.
 */
export function getRoomShapeDoorSlot(
  roomShape: RoomShape,
  x: int,
  y: int,
): DoorSlot | undefined {
  const doorSlotCoordinates = ROOM_SHAPE_TO_DOOR_SLOT_COORDINATES[
    roomShape
  ] as Record<DoorSlot, readonly [x: int, y: int]>;

  for (const [doorSlotString, coordinates] of Object.entries(
    doorSlotCoordinates,
  )) {
    const doorSlot = parseIntSafe(doorSlotString);
    if (doorSlot === undefined || !isEnumValue(doorSlot, DoorSlot)) {
      continue;
    }

    const [doorX, doorY] = coordinates;
    if (x === doorX && y === doorY) {
      return doorSlot;
    }
  }

  return undefined;
}

/**
 * Helper function to get the room grid coordinates for a specific room shape and door slot
 * combination.
 */
export function getRoomShapeDoorSlotCoordinates(
  roomShape: RoomShape,
  doorSlot: DoorSlot,
): readonly [x: int, y: int] | undefined {
  const doorSlotCoordinates = ROOM_SHAPE_TO_DOOR_SLOT_COORDINATES[
    roomShape
  ] as Record<DoorSlot, readonly [x: int, y: int]>;

  return doorSlotCoordinates[doorSlot];
}

/**
 * Helper function to find unused door slots in the current room that can be used to make custom
 * doors.
 */
export function getUnusedDoorSlots(): readonly DoorSlot[] {
  const room = game.GetRoom();

  return DOOR_SLOT_VALUES.filter(
    (doorSlot) =>
      // We need to filter out the -1 value to prevent crashes.
      doorSlot !== DoorSlot.NO_DOOR_SLOT &&
      room.IsDoorSlotAllowed(doorSlot) &&
      room.GetDoor(doorSlot) === undefined,
  );
}

/**
 * Helper function to get the door that leads to the off-grid room that contains the portal to The
 * Void. (In vanilla, the door will only appear in the Hush Boss Room.)
 *
 * Returns undefined if the room has no Void doors.
 */
export function getVoidDoor(): GridEntityDoor | undefined {
  const doors = getDoors();
  return doors.find((door) => isVoidDoor(door));
}

/**
 * Helper function to check if the current room has one or more doors that lead to the given room
 * type.
 *
 * This function is variadic, meaning that you can supply as many door types as you want to check
 * for. This function will return true if one or more room types match.
 */
export function hasDoorType(...roomTypes: readonly RoomType[]): boolean {
  const doors = getDoors();
  const doorsOfThisRoomType = doors.filter((door) =>
    roomTypes.some((roomType) => door.IsRoomType(roomType)),
  );
  return doorsOfThisRoomType.length > 0;
}

/**
 * Helper function to check if the current room has one or more open door slots that can be used to
 * make custom doors.
 */
export function hasUnusedDoorSlot(): boolean {
  const unusedDoorSlots = getUnusedDoorSlots();
  return unusedDoorSlots.length > 0;
}

export function isAngelRoomDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomType === RoomType.ANGEL;
}

/**
 * Helper function to check if the provided door is the one that leads to the off-grid room that
 * contains the hole to the Blue Womb. (In vanilla, the door will only appear in the It Lives Boss
 * Room.)
 */
export function isBlueWombDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomIndex === GridRoom.BLUE_WOMB;
}

/**
 * Helper function to check if the provided door is the one that leads to the Boss Rush room. (In
 * vanilla, the door will only appear in the Boss Room of the sixth floor.)
 */
export function isBossRushDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomIndex === GridRoom.BOSS_RUSH;
}

export function isDevilRoomDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomType === RoomType.DEVIL;
}

/** Helper function to see if a door slot could exist for a given room shape. */
export function isDoorSlotInRoomShape(
  doorSlot: DoorSlot,
  roomShape: RoomShape,
): boolean {
  const doorSlots = getDoorSlotsForRoomShape(roomShape);
  return doorSlots.has(doorSlot);
}

/**
 * This refers to the Repentance door that spawns in a boss room after defeating the boss. You have
 * to spend one key to open it. It has a sprite filename of "gfx/grid/door_downpour.anm2".
 */
export function isDoorToDownpour(door: GridEntityDoor): boolean {
  if (!isRepentanceDoor(door)) {
    return false;
  }

  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_Downpour.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_downpour.anm2";
}

/**
 * This refers to the Repentance door that spawns in a boss room after defeating the boss. You have
 * to spend two hearts to open it. It has a sprite filename of "gfx/grid/door_mausoleum.anm2".
 */
export function isDoorToMausoleum(door: GridEntityDoor): boolean {
  if (!isRepentanceDoor(door)) {
    return false;
  }

  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_Mausoleum.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_mausoleum.anm2";
}

/**
 * This refers to the "strange door" located on the first room of Depths 2. You open it with either
 * a Polaroid or a Negative. It has a sprite filename of "gfx/grid/door_mausoleum_alt.anm2".
 */
export function isDoorToMausoleumAscent(door: GridEntityDoor): boolean {
  if (!isRepentanceDoor(door)) {
    return false;
  }

  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_Mausoleum_Alt.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_mausoleum_alt.anm2";
}

/**
 * This refers to the Repentance door that spawns in a boss room after defeating the boss. You have
 * to spend two bombs to open it. It has a sprite filename of "gfx/grid/door_mines.anm2".
 */
export function isDoorToMines(door: GridEntityDoor): boolean {
  if (!isRepentanceDoor(door)) {
    return false;
  }

  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_Mines.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_mines.anm2";
}

/**
 * This refers to the Repentance door that spawns after defeating Mom. You open it with the
 * completed knife. It has a sprite filename of "gfx/grid/door_momsheart.anm2".
 */
export function isDoorToMomsHeart(door: GridEntityDoor): boolean {
  if (!isRepentanceDoor(door)) {
    return false;
  }

  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_MomsHeart.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_momsheart.anm2"; // cspell:ignore momsheart
}

export function isHiddenSecretRoomDoor(door: GridEntityDoor): boolean {
  const sprite = door.GetSprite();
  const animation = sprite.GetAnimation();

  return isSecretRoomDoor(door) && animation === "Hidden";
}

/**
 * Helper function to check if the provided door is the one that leads to the Mega Satan Boss Room.
 * (In vanilla, the door will only appear in the starting room of The Chest / Dark Room.)
 */
export function isMegaSatanDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomIndex === GridRoom.MEGA_SATAN;
}

/**
 * Helper function to check if the provided door leads to the "secret exit" off-grid room that takes
 * you to the Repentance floor.
 */
export function isRepentanceDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomIndex === GridRoom.SECRET_EXIT;
}

/**
 * This refers to the hole in the wall that appears after bombing the entrance to a secret room.
 * Note that the door still exists before it has been bombed open. It has a sprite filename of
 * "gfx/grid/door_08_holeinwall.anm2".
 *
 * Note that since Ultra Secret Rooms do not use holes, this function will not detect an Ultra
 * Secret Room door.
 */
export function isSecretRoomDoor(door: GridEntityDoor): boolean {
  const sprite = door.GetSprite();
  const fileName = sprite.GetFilename();

  // On Windows, this is: "gfx/grid/Door_08_HoleInWall.anm2"
  return fileName.toLowerCase() === "gfx/grid/door_08_holeinwall.anm2"; // cspell:ignore holeinwall
}

/**
 * Helper function to check if the provided door is the one that leads to the off-grid room that
 * contains the portal to The Void. (In vanilla, the door will only appear in the Hush Boss Room.)
 */
export function isVoidDoor(door: GridEntityDoor): boolean {
  return door.TargetRoomIndex === GridRoom.VOID;
}

/**
 * Helper function to reset an unlocked door back to a locked state. Doing this is non-trivial
 * because in addition to calling the `GridEntityDoor.SetLocked` method, you must also:
 *
 * - Set the `VisitedCount` of the room's `RoomDescription` to 0.
 * - Set the variant to `DoorVariant.DOOR_LOCKED`.
 * - Close the door.
 */
export function lockDoor(door: GridEntityDoor): void {
  const level = game.GetLevel();

  // We can't use the "getRoomDescriptor" function since it will cause a dependency cycle.
  const roomDescriptor = level.GetRoomByIdx(door.TargetRoomIndex);
  roomDescriptor.VisitedCount = 0;

  door.SetVariant(DoorVariant.LOCKED);
  door.SetLocked(true);
  door.Close(true);
}

/**
 * For the purposes of this function, doors to Secret Rooms or Super Secret Rooms that have not been
 * discovered yet will not be opened.
 */
export function openAllDoors(): void {
  for (const door of getDoors()) {
    // If we try to open a hidden Secret Room door (or Super Secret Room door), then nothing will
    // happen.
    door.Open();
  }
}

/**
 * Use this instead of the `GridEntityDoor.Open` method if you want the door to immediately open
 * without an animation.
 */
export function openDoorFast(door: GridEntityDoor): void {
  door.State = DoorState.OPEN;

  const sprite = door.GetSprite();
  sprite.Play("Opened", true);
}

/**
 * Helper function to remove all of the doors in the room. By default, it will remove every door.
 * You can optionally specify one or more room types to remove only the doors that match the
 * specified room types.
 *
 * @returns The number of doors removed.
 * @allowEmptyVariadic
 */
export function removeAllDoors(...roomTypes: readonly RoomType[]): int {
  const doors = getDoors(...roomTypes);
  removeDoors(...doors);

  return doors.length;
}

/** Helper function to remove a single door. */
export function removeDoor(door: GridEntityDoor): void {
  const room = game.GetRoom();
  room.RemoveDoor(door.Slot);
}

/**
 * Helper function to remove the doors provided.
 *
 * This function is variadic, meaning that you can specify as many doors as you want to remove.
 */
export function removeDoors(...doors: readonly GridEntityDoor[]): void {
  for (const door of doors) {
    removeDoor(door);
  }
}

----
functions\easing.ts
/* eslint-disable no-nested-ternary */
/* eslint-disable no-return-assign */
/* eslint-disable sort-exports/sort-exports */

/**
 * From: https://easings.net/#easeInSine
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInSine(time: number): number {
  return 1 - Math.cos((time * Math.PI) / 2);
}

/**
 * From: https://easings.net/#easeOutSine
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutSine(time: number): number {
  return Math.sin((time * Math.PI) / 2);
}

/**
 * From: https://easings.net/#easeInOutSine
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutSine(time: number): number {
  return -(Math.cos(Math.PI * time) - 1) / 2;
}

/**
 * From: https://easings.net/#easeInCubic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInCubic(time: number): number {
  return time * time * time;
}

/**
 * From: https://easings.net/#easeOutCubic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutCubic(time: number): number {
  return 1 - (1 - time) ** 3;
}

/**
 * From: https://easings.net/#easeInOutCubic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutCubic(time: number): number {
  return time < 0.5 ? 4 * time * time * time : 1 - (-2 * time + 2) ** 3 / 2;
}

/**
 * From: https://easings.net/#easeInQuint
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInQuint(time: number): number {
  return time * time * time * time * time;
}

/**
 * From: https://easings.net/#easeOutQuint
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutQuint(time: number): number {
  return 1 - (1 - time) ** 5;
}

/**
 * From: https://easings.net/#easeInOutQuint
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutQuint(time: number): number {
  return time < 0.5
    ? 16 * time * time * time * time * time
    : 1 - (-2 * time + 2) ** 5 / 2;
}

/**
 * From: https://easings.net/#easeInCirc
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInCirc(time: number): number {
  return 1 - Math.sqrt(1 - time ** 2);
}

/**
 * From: https://easings.net/#easeOutCirc
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutCirc(time: number): number {
  return Math.sqrt(1 - (time - 1) ** 2);
}

/**
 * From: https://easings.net/#easeInOutCirc
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutCirc(time: number): number {
  return time < 0.5
    ? (1 - Math.sqrt(1 - (2 * time) ** 2)) / 2
    : (Math.sqrt(1 - (-2 * time + 2) ** 2) + 1) / 2;
}

/**
 * From: https://easings.net/#easeInElastic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInElastic(time: number): number {
  const c4 = (2 * Math.PI) / 3;

  return time === 0
    ? 0
    : time === 1
      ? 1
      : -(2 ** (10 * time - 10)) * Math.sin((time * 10 - 10.75) * c4);
}

/**
 * From: https://easings.net/#easeOutElastic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutElastic(time: number): number {
  const c4 = (2 * Math.PI) / 3;

  return time === 0
    ? 0
    : time === 1
      ? 1
      : 2 ** (-10 * time) * Math.sin((time * 10 - 0.75) * c4) + 1;
}

/**
 * From: https://easings.net/#easeInOutElastic
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutElastic(time: number): number {
  const c5 = (2 * Math.PI) / 4.5;

  return time === 0
    ? 0
    : time === 1
      ? 1
      : time < 0.5
        ? -(2 ** (20 * time - 10) * Math.sin((20 * time - 11.125) * c5)) / 2
        : (2 ** (-20 * time + 10) * Math.sin((20 * time - 11.125) * c5)) / 2 +
          1;
}

/**
 * From: https://easings.net/#easeInQuad
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInQuad(time: number): number {
  return time * time;
}

/**
 * From: https://easings.net/#easeOutQuad
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutQuad(time: number): number {
  return 1 - (1 - time) * (1 - time);
}

/**
 * From: https://easings.net/#easeInOutQuad
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutQuad(time: number): number {
  return time < 0.5 ? 2 * time * time : 1 - (-2 * time + 2) ** 2 / 2;
}

/**
 * From: https://easings.net/#easeInQuart
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInQuart(time: number): number {
  return time * time * time * time;
}

/**
 * From: https://easings.net/#easeOutQuart
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutQuart(time: number): number {
  return 1 - (1 - time) ** 4;
}

/**
 * From: https://easings.net/#easeInOutQuart
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutQuart(time: number): number {
  return time < 0.5
    ? 8 * time * time * time * time
    : 1 - (-2 * time + 2) ** 4 / 2;
}

/**
 * From: https://easings.net/#easeInExpo
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInExpo(time: number): number {
  return time === 0 ? 0 : 2 ** (10 * time - 10);
}

/**
 * From: https://easings.net/#easeOutExpo
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutExpo(time: number): number {
  return time === 1 ? 1 : 1 - 2 ** (-10 * time);
}

/**
 * From: https://easings.net/#easeInOutExpo
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutExpo(time: number): number {
  return time === 0
    ? 0
    : time === 1
      ? 1
      : time < 0.5
        ? 2 ** (20 * time - 10) / 2
        : (2 - 2 ** (-20 * time + 10)) / 2;
}

/**
 * From: https://easings.net/#easeInBack
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInBack(time: number): number {
  const c1 = 1.701_58;
  const c3 = c1 + 1;

  return c3 * time * time * time - c1 * time * time;
}

/**
 * From: https://easings.net/#easeOutBack
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutBack(time: number): number {
  const c1 = 1.701_58;
  const c3 = c1 + 1;

  return 1 + c3 * (time - 1) ** 3 + c1 * (time - 1) ** 2;
}

/**
 * From: https://easings.net/#easeInOutBack
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutBack(time: number): number {
  const c1 = 1.701_58;
  const c2 = c1 * 1.525;

  return time < 0.5
    ? ((2 * time) ** 2 * ((c2 + 1) * 2 * time - c2)) / 2
    : ((2 * time - 2) ** 2 * ((c2 + 1) * (time * 2 - 2) + c2) + 2) / 2;
}

/**
 * From: https://easings.net/#easeInBounce
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInBounce(time: number): number {
  return 1 - easeOutBounce(1 - time);
}

/**
 * From: https://easings.net/#easeInOutSine
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeOutBounce(time: number): number {
  const n1 = 7.5625;
  const d1 = 2.75;

  if (time < 1 / d1) {
    return n1 * time * time;
  }

  if (time < 2 / d1) {
    return n1 * (time -= 1.5 / d1) * time + 0.75;
  }

  if (time < 2.5 / d1) {
    return n1 * (time -= 2.25 / d1) * time + 0.9375;
  }

  return n1 * (time -= 2.625 / d1) * time + 0.984_375;
}

/**
 * From: https://easings.net/#easeInOutBounce
 *
 * @param time A value between 0 and 1 that represents how far along you are in the transition.
 */
export function easeInOutBounce(time: number): number {
  return time < 0.5
    ? (1 - easeOutBounce(1 - 2 * time)) / 2
    : (1 + easeOutBounce(2 * time - 1)) / 2;
}

----
functions\effects.ts
import { inRectangle } from "./math";

/** For `EntityType.EFFECT` (1000), `EffectVariant.DICE_FLOOR` (76). */
export const DICE_FLOOR_TRIGGER_SQUARE_SIZE = 75;

/** Helper function to see if a player is close enough to activate a Dice Room floor. */
export function isCloseEnoughToTriggerDiceFloor(
  player: EntityPlayer,
  diceFloor: EntityEffect,
): boolean {
  // Unlike other entities, the dice floor has a rectangular hit box, not a circular one.
  const topLeft = diceFloor.Position.add(
    Vector(-DICE_FLOOR_TRIGGER_SQUARE_SIZE, -DICE_FLOOR_TRIGGER_SQUARE_SIZE),
  );
  const bottomRight = diceFloor.Position.add(
    Vector(DICE_FLOOR_TRIGGER_SQUARE_SIZE, DICE_FLOOR_TRIGGER_SQUARE_SIZE),
  );

  return inRectangle(player.Position, topLeft, bottomRight);
}

----
functions\emptyRoom.ts
import {
  EntityFlag,
  EntityType,
  GridEntityType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { ReadonlySet } from "../types/ReadonlySet";
import { getEntities } from "./entities";
import { getGridEntities, removeGridEntity } from "./gridEntities";
import { isVanillaWallGridIndex } from "./roomShapeWalls";
import { roomUpdateSafe } from "./rooms";

const EMPTY_ROOM_BLACKLIST_ENTITY_SET = new ReadonlySet<EntityType>([
  EntityType.PLAYER, // 1
  EntityType.TEAR, // 2
  EntityType.FAMILIAR, // 3
  EntityType.LASER, // 7
  EntityType.KNIFE, // 8
  EntityType.PROJECTILE, // 9
  EntityType.DARK_ESAU, // 866
]);

/**
 * Helper function to remove all naturally spawning entities and grid entities from a room. Notably,
 * this will not remove players (1), tears (2), familiars (3), lasers (7), knives (8), projectiles
 * (9), blacklisted NPCs such as Dark Esau, charmed NPCs, friendly NPCs, persistent NPCs, most
 * effects (1000), doors, and walls.
 */
export function emptyRoom(): void {
  emptyRoomEntities();
  emptyRoomGridEntities();
}

/**
 * We remove entities in the `POST_NEW_ROOM` callback instead of in the `PRE_ROOM_ENTITY_SPAWN`
 * callback so that they will not re-appear when we re-enter the room.
 */
function emptyRoomEntities() {
  const room = game.GetRoom();

  for (const entity of getEntities()) {
    if (EMPTY_ROOM_BLACKLIST_ENTITY_SET.has(entity.Type)) {
      continue;
    }

    if (
      entity.HasEntityFlags(EntityFlag.CHARM) ||
      entity.HasEntityFlags(EntityFlag.FRIENDLY) ||
      entity.HasEntityFlags(EntityFlag.PERSISTENT)
    ) {
      continue;
    }

    entity.ClearEntityFlags(EntityFlag.APPEAR);
    entity.Remove();

    // When fire places are removed, they will leave behind a "path" that will prevent future grid
    // entities from being spawned on the same tile. Thus, reset the path for this tile if this is a
    // fire place.
    if (entity.Type === EntityType.FIREPLACE) {
      const gridIndex = room.GetGridIndex(entity.Position);
      room.SetGridPath(gridIndex, 0);
    }
  }
}

/** Helper function to remove all grid entities from a room except for doors and walls. */
export function emptyRoomGridEntities(): void {
  let removedOneOrMoreGridEntities = false;
  for (const gridEntity of getGridEntities()) {
    const gridEntityType = gridEntity.GetType();
    const gridIndex = gridEntity.GetGridIndex();

    // We cannot simply check if the grid entity type is equal to a wall because other mods use
    // walls as a base for custom grid entities.
    if (
      gridEntityType === GridEntityType.WALL &&
      isVanillaWallGridIndex(gridIndex)
    ) {
      continue;
    }

    if (gridEntityType === GridEntityType.DOOR) {
      continue;
    }

    removeGridEntity(gridEntity, false);
    removedOneOrMoreGridEntities = true;
  }
  if (removedOneOrMoreGridEntities) {
    roomUpdateSafe();
  }
}

----
functions\entities.ts
import {
  EntityFlag,
  EntityType,
  MotherVariant,
  NPCState,
  UltraGreedState,
  UltraGreedVariant,
  UltraGreedierState,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { VectorZero } from "../core/constants";
import { ENTITIES_WITH_ARMOR_SET } from "../sets/entitiesWithArmorSet";
import type { AnyEntity } from "../types/AnyEntity";
import type { EntityID } from "../types/EntityID";
import { getIsaacAPIClassName } from "./isaacAPIClass";
import { getRandom } from "./random";
import { newReadonlyColor } from "./readOnly";
import { getRandomSeed, isRNG, newRNG } from "./rng";
import { setSpriteOpacity } from "./sprites";
import { isTSTLSet } from "./tstlClass";
import { asNPCState, isPrimitive, parseIntSafe } from "./types";
import { assertDefined } from "./utils";
import { doesVectorHaveLength, isVector, vectorToString } from "./vector";

/** From DeadInfinity. */
const DAMAGE_FLASH_COLOR = newReadonlyColor(
  0.5,
  0.5,
  0.5,
  1,
  200 / 255,
  0 / 255,
  0 / 255,
);

/**
 * Helper function to count the number of entities in room. Use this over the vanilla
 * `Isaac.CountEntities` method to avoid having to specify a spawner and to handle ignoring charmed
 * enemies.
 *
 * @param entityType Optional. Default is -1, which matches every entity type.
 * @param variant Optional. Default is -1, which matches every variant.
 * @param subType Optional. Default is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. Default is false. Will throw a runtime error if set to true and
 *                       the `entityType` is equal to -1.
 */
export function countEntities(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): int {
  if (entityType === -1) {
    // The `Isaac.CountEntities` method requires an argument of `EntityType`, so we must revert to
    // using the `Isaac.GetRoomEntities` method, which is slower.
    const entities = Isaac.GetRoomEntities();
    if (!ignoreFriendly) {
      return entities.length;
    }

    const nonFriendlyEntities = entities.filter(
      (entity) => !entity.HasEntityFlags(EntityFlag.FRIENDLY),
    );
    return nonFriendlyEntities.length;
  }

  if (!ignoreFriendly) {
    return Isaac.CountEntities(undefined, entityType, variant, subType);
  }

  const entities = Isaac.FindByType(
    entityType,
    variant,
    subType,
    false,
    ignoreFriendly,
  );

  return entities.length;
}

/**
 * Helper function to check if one or more matching entities exist in the current room. It uses the
 * `doesEntityExist` helper function to determine this.
 *
 * @param entityTypes An array or set of the entity types that you want to check for. Will return
 *                    true if any of the provided entity types exist.
 * @param ignoreFriendly Optional. Default is false.
 */
export function doesAnyEntityExist(
  entityTypes: readonly EntityType[] | ReadonlySet<EntityType>,
  ignoreFriendly = false,
): boolean {
  const entityTypesMutable = entityTypes as EntityType[] | Set<EntityType>;

  const entityTypesArray: readonly EntityType[] = isTSTLSet(entityTypesMutable)
    ? [...entityTypesMutable.values()]
    : entityTypesMutable;

  return entityTypesArray.some((entityType) =>
    doesEntityExist(entityType, -1, -1, ignoreFriendly),
  );
}

/**
 * Helper function to check if one or more of a specific kind of entity is present in the current
 * room. It uses the `countEntities` helper function to determine this.
 *
 * @param entityType Optional. Default is -1, which matches every entity type.
 * @param variant Optional. Default is -1, which matches every variant.
 * @param subType Optional. Default is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. Default is false.
 */
export function doesEntityExist(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): boolean {
  const count = countEntities(entityType, variant, subType, ignoreFriendly);
  return count > 0;
}

/**
 * Given an array of entities, this helper function returns the closest one to a provided reference
 * entity.
 *
 * For example:
 *
 * ```ts
 * const player = Isaac.GetPlayer();
 * const gapers = getEntities(EntityType.GAPER);
 * const closestGaper = getClosestEntityTo(player, gapers);
 * ```
 *
 * @param referenceEntity The entity that is close by.
 * @param entities The array of entities to look through.
 * @param filterFunc Optional. A function to filter for a specific type of entity, like e.g. an
 *                   enemy with a certain amount of HP left.
 */
export function getClosestEntityTo<T extends AnyEntity>(
  referenceEntity: Entity,
  entities: readonly T[],
  filterFunc?: (entity: T) => boolean,
): T | undefined {
  let closestEntity: T | undefined;
  let closestDistance = Number.POSITIVE_INFINITY;
  for (const entity of entities) {
    const distance = referenceEntity.Position.Distance(entity.Position);

    if (
      distance < closestDistance &&
      (filterFunc === undefined || filterFunc(entity))
    ) {
      closestEntity = entity;
      closestDistance = distance;
    }
  }

  return closestEntity;
}

/** Helper function to get the entity type, variant, and sub-type from an `EntityID`. */
export function getConstituentsFromEntityID(
  entityID: EntityID,
): [entityType: EntityType, variant: int, subType: int] {
  const parts = entityID.split(".");
  if (parts.length !== 3) {
    error(`Failed to get the constituents from entity ID: ${entityID}`);
  }

  const [entityTypeString, variantString, subTypeString] = parts;

  assertDefined(
    entityTypeString,
    `Failed to get the first constituent from an entity ID: ${entityID}`,
  );

  assertDefined(
    variantString,
    `Failed to get the second constituent from an entity ID: ${entityID}`,
  );

  assertDefined(
    subTypeString,
    `Failed to get the third constituent from an entity ID: ${entityID}`,
  );

  const entityType = parseIntSafe(entityTypeString);
  assertDefined(
    entityType,
    `Failed to convert the entity type to an integer: ${entityTypeString}`,
  );

  const variant = parseIntSafe(variantString);
  assertDefined(
    variant,
    `Failed to convert the entity variant to an integer: ${variantString}`,
  );

  const subType = parseIntSafe(subTypeString);
  assertDefined(
    subType,
    `Failed to convert the entity sub-type to an integer: ${subTypeString}`,
  );

  return [entityType, variant, subType];
}

/**
 * Helper function to get all of the entities in the room or all of the entities that match a
 * specific entity type / variant / sub-type.
 *
 * Due to bugs with `Isaac.FindInRadius`, this function uses `Isaac.GetRoomEntities`, which is more
 * expensive but also more robust. (If a matching entity type is provided, then `Isaac.FindByType`
 * will be used instead.)
 *
 * For example:
 *
 * ```ts
 * // Make all of the entities in the room invisible.
 * for (const entity of getEntities()) {
 *   entity.Visible = false;
 * }
 * ```
 *
 * @param entityType Optional. If specified, will only get the entities that match the type. Default
 *                   is -1, which matches every type.
 * @param variant Optional. If specified, will only get the entities that match the variant. Default
 *                is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the entities that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. If set to true, it will exclude friendly NPCs from being
 *                       returned. Default is false. Will only be taken into account if the
 *                       `entityType` is specified.
 */
export function getEntities(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): readonly Entity[] {
  if (entityType === -1) {
    return Isaac.GetRoomEntities();
  }

  return Isaac.FindByType(entityType, variant, subType, ignoreFriendly);
}

/**
 * Helper function to get all the fields on an entity. For example, this is useful for comparing it
 * to another entity later. (One option is to use the `logTableDifferences` function for this.)
 *
 * This function will only get fields that are equal to booleans, numbers, or strings, or Vectors,
 * as comparing other types is non-trivial.
 */
export function getEntityFields(
  entity: Entity,
): LuaMap<string, boolean | number | string> {
  const entityFields = new LuaMap<string, boolean | number | string>();

  const metatable = getmetatable(entity) as
    | LuaMap<AnyNotNil, unknown>
    | undefined;
  assertDefined(metatable, "Failed to get the metatable for an entity.");

  setPrimitiveEntityFields(entity, metatable, entityFields);

  // If this is a class that inherits from `Entity` (like `EntityPlayer`), the "__propget" table
  // will not contain the attributes for `Entity`. Thus, if this is not an `Entity`, we have
  // additional fields to add.
  const className = getIsaacAPIClassName(entity);
  if (className === "Entity") {
    return entityFields;
  }

  const parentTable = metatable.get("__parent") as
    | LuaMap<AnyNotNil, unknown>
    | undefined;
  assertDefined(
    parentTable,
    'Failed to get the "__parent" table for an entity.',
  );

  setPrimitiveEntityFields(entity, parentTable, entityFields);

  return entityFields;
}

function setPrimitiveEntityFields(
  entity: Entity,
  metatable: LuaMap<AnyNotNil, unknown>,
  entityFields: LuaMap<string, boolean | number | string>,
) {
  const propGetTable = metatable.get("__propget") as
    | LuaMap<AnyNotNil, unknown>
    | undefined;
  assertDefined(
    propGetTable,
    'Failed to get the "__propget" table for an entity.',
  );

  for (const [key] of propGetTable) {
    // The values of this table are functions. Thus, we use the key to index the original entity.
    const indexKey = key as keyof typeof entity;
    const value = entity[indexKey];
    if (isPrimitive(value)) {
      entityFields.set(indexKey as string, value);
    } else if (isVector(value)) {
      entityFields.set(indexKey as string, vectorToString(value));
    }
  }
}

/**
 * Helper function to get an entity from a `PtrHash`. Note that doing this is very expensive, so you
 * should only use this function when debugging. (Normally, if you need to work backwards from a
 * reference, you would use an `EntityPtr` instead of a `PtrHash`.
 */
export function getEntityFromPtrHash(ptrHash: PtrHash): Entity | undefined {
  const entities = getEntities();
  return entities.find((entity) => GetPtrHash(entity) === ptrHash);
}

/** Helper function to get a string containing the entity's type, variant, and sub-type. */
export function getEntityID(entity: Entity): EntityID {
  return `${entity.Type}.${entity.Variant}.${entity.SubType}` as EntityID;
}

/**
 * Helper function to get a formatted string in the format returned by the `getEntityID` function.
 */
export function getEntityIDFromConstituents(
  entityType: EntityType,
  variant: int,
  subType: int,
): EntityID {
  return `${entityType}.${variant}.${subType}` as EntityID;
}

/**
 * Helper function to compare two different arrays of entities. Returns the entities that are in the
 * second array but not in the first array.
 */
export function getFilteredNewEntities<T extends AnyEntity>(
  oldEntities: readonly T[],
  newEntities: readonly T[],
): readonly T[] {
  const oldEntitiesSet = new Set<PtrHash>();
  for (const entity of oldEntities) {
    const ptrHash = GetPtrHash(entity);
    oldEntitiesSet.add(ptrHash);
  }

  return newEntities.filter((entity) => {
    const ptrHash = GetPtrHash(entity);
    return !oldEntitiesSet.has(ptrHash);
  });
}

/**
 * Helper function to see if a particular entity has armor. In this context, armor refers to the
 * damage scaling mechanic. For example, Ultra Greed has armor, but a Gaper does not.
 *
 * For more on armor, see the wiki: https://bindingofisaacrebirth.fandom.com/wiki/Damage_Scaling
 */
export function hasArmor(entity: Entity): boolean {
  const typeVariantString = `${entity.Type}.${entity.Variant}`;
  return ENTITIES_WITH_ARMOR_SET.has(typeVariantString);
}

/**
 * Helper function to detect if a particular entity is an active enemy. Use this over the
 * `Entity.IsActiveEnemy` method since it is bugged with friendly enemies, Grimaces, Ultra Greed,
 * and Mother.
 */
export function isActiveEnemy(entity: Entity): boolean {
  if (entity.HasEntityFlags(EntityFlag.FRIENDLY)) {
    return false;
  }

  const room = game.GetRoom();
  const isClear = room.IsClear();

  // Some entities count as being "active" enemies, but they deactivate when the room is cleared.
  if (isClear) {
    switch (entity.Type) {
      // 42
      case EntityType.GRIMACE: {
        return false;
      }

      // 294
      case EntityType.ULTRA_DOOR: {
        return false;
      }

      // 406
      case EntityType.ULTRA_GREED: {
        const npc = entity.ToNPC();
        if (npc !== undefined) {
          const ultraGreedVariant = npc.Variant as UltraGreedVariant;

          switch (ultraGreedVariant) {
            case UltraGreedVariant.ULTRA_GREED: {
              if (npc.State === asNPCState(UltraGreedState.GOLD_STATUE)) {
                return false;
              }

              break;
            }

            case UltraGreedVariant.ULTRA_GREEDIER: {
              if (npc.State === asNPCState(UltraGreedierState.POST_EXPLOSION)) {
                return false;
              }

              break;
            }
          }
        }

        break;
      }

      // 912
      case EntityType.MOTHER: {
        if (entity.Variant === MotherVariant.MOTHER_1) {
          const npc = entity.ToNPC();
          if (npc !== undefined && npc.State === NPCState.SPECIAL) {
            return false;
          }
        }

        break;
      }

      default: {
        break;
      }
    }
  }

  // eslint-disable-next-line deprecation/deprecation
  return entity.IsActiveEnemy(false);
}

/**
 * Helper function to measure an entity's velocity to see if it is moving.
 *
 * Use this helper function over checking if the velocity length is equal to 0 because entities can
 * look like they are completely immobile but yet still have a non zero velocity. Thus, using a
 * threshold is needed.
 *
 * @param entity The entity whose velocity to measure.
 * @param threshold Optional. The threshold from 0 to consider to be moving. Default is 0.01.
 */
export function isEntityMoving(entity: Entity, threshold = 0.01): boolean {
  return doesVectorHaveLength(entity.Velocity, threshold);
}

/**
 * Helper function to parse a string that contains an entity type, a variant, and a sub-type,
 * separated by periods.
 *
 * For example, passing "45.0.1" would return an array of [45, 0, 1].
 *
 * Returns undefined if the string cannot be parsed.
 */
export function parseEntityID(
  entityID: string,
): [entityType: EntityType, variant: int, subType: int] | undefined {
  const entityIDArray = entityID.split(".");
  if (entityIDArray.length !== 3) {
    return undefined;
  }

  const [entityTypeString, variantString, subTypeString] = entityIDArray;

  if (
    entityTypeString === undefined ||
    variantString === undefined ||
    subTypeString === undefined
  ) {
    return undefined;
  }

  const entityType = parseIntSafe(entityTypeString);
  const variant = parseIntSafe(variantString);
  const subType = parseIntSafe(subTypeString);

  if (
    entityType === undefined ||
    variant === undefined ||
    subType === undefined
  ) {
    return undefined;
  }

  return [entityType, variant, subType];
}

/**
 * Helper function to parse a string that contains an entity type and a variant separated by a
 * period.
 *
 * For example, passing "45.0" would return an array of [45, 0].
 *
 * Returns undefined if the string cannot be parsed.
 */
export function parseEntityTypeVariantString(
  entityTypeVariantString: string,
): [entityType: EntityType, variant: int] | undefined {
  const entityTypeVariantArray = entityTypeVariantString.split(".");
  if (entityTypeVariantArray.length !== 2) {
    return undefined;
  }

  const [entityTypeString, variantString] = entityTypeVariantArray;

  if (entityTypeString === undefined || variantString === undefined) {
    return undefined;
  }

  const entityType = parseIntSafe(entityTypeString);
  const variant = parseIntSafe(variantString);

  if (entityType === undefined || variant === undefined) {
    return undefined;
  }

  return [entityType, variant];
}

/**
 * Helper function to remove all of the matching entities in the room.
 *
 * @param entityType The entity type to match.
 * @param entityVariant Optional. The variant to match. Default is -1, which matches every variant.
 * @param entitySubType Optional. The sub-type to match. Default is -1, which matches every
 *                      sub-type.
 * @param cap Optional. If specified, will only remove the given amount of collectibles.
 * @returns An array of the entities that were removed.
 */
export function removeAllMatchingEntities(
  entityType: EntityType,
  entityVariant = -1,
  entitySubType = -1,
  cap: int | undefined = undefined,
): readonly Entity[] {
  const entities = getEntities(entityType, entityVariant, entitySubType);
  return removeEntities(entities, cap);
}

/**
 * Helper function to remove all of the entities in the supplied array.
 *
 * @param entities The array of entities to remove.
 * @param cap Optional. If specified, will only remove the given amount of entities.
 * @returns An array of the entities that were removed.
 */
export function removeEntities<T extends AnyEntity>(
  entities: readonly T[],
  cap?: int,
): readonly T[] {
  if (entities.length === 0) {
    return [];
  }

  const entitiesRemoved: T[] = [];
  for (const entity of entities) {
    entity.Remove();

    entitiesRemoved.push(entity);
    if (cap !== undefined && entitiesRemoved.length >= cap) {
      break;
    }
  }

  return entitiesRemoved;
}

/**
 * Helper function to reroll an enemy. Use this instead of the vanilla "Game.RerollEnemy" function
 * if you want the rerolled enemy to be returned.
 *
 * @param entity The entity to reroll.
 * @returns If the game failed to reroll the enemy, returns undefined. Otherwise, returns the
 *          rerolled entity.
 */
export function rerollEnemy(entity: Entity): Entity | undefined {
  const oldEntities = getEntities();
  const wasRerolled = game.RerollEnemy(entity);
  if (!wasRerolled) {
    return undefined;
  }

  const newEntities = getEntities();
  const filteredNewEntities = getFilteredNewEntities(oldEntities, newEntities);
  if (filteredNewEntities.length === 0) {
    error(
      'Failed to find the new entity generated by the "Game.RerollEnemy" method.',
    );
  }

  return filteredNewEntities[0];
}

/**
 * Helper function to make an entity flash red like it is taking damage. This is useful when you
 * want to make it appear as if an entity is taking damage without actually dealing any damage to
 * it.
 */
export function setEntityDamageFlash(entity: Entity): void {
  entity.SetColor(DAMAGE_FLASH_COLOR, 2, 0);
}

/**
 * Helper function to keep an entity's color the same values as it already is but set the opacity to
 * a specific value.
 *
 * @param entity The entity to set.
 * @param alpha A value between 0 and 1 that represents the fade amount.
 */
export function setEntityOpacity(entity: Entity, alpha: float): void {
  const sprite = entity.GetSprite();
  setSpriteOpacity(sprite, alpha);
}

export function setEntityRandomColor(entity: Entity): void {
  const seed = entity.InitSeed === 0 ? getRandomSeed() : entity.InitSeed;
  const rng = newRNG(seed);

  const r = getRandom(rng);
  const g = getRandom(rng);
  const b = getRandom(rng);

  const color = Color(r, g, b);
  entity.SetColor(color, 100_000, 100_000, false, false);
}

/**
 * Helper function to spawn an entity. Use this instead of the `Isaac.Spawn` method if you do not
 * need to specify the velocity or spawner.
 *
 * Also see the `spawnWithSeed` helper function.
 *
 * @param entityType The `EntityType` of the entity to spawn.
 * @param variant The variant of the entity to spawn.
 * @param subType The sub-type of the entity to spawn.
 * @param positionOrGridIndex The position or grid index of the entity to spawn.
 * @param velocity Optional. The velocity of the entity to spawn. Default is `VectorZero`.
 * @param spawner Optional. The entity that will be the `SpawnerEntity`. Default is undefined.
 * @param seedOrRNG Optional. The seed or RNG object to use to generate the `InitSeed` of the
 *                  entity. Default is undefined, which will make the entity spawn with a random
 *                  seed using the `Isaac.Spawn` method.
 */
export function spawn(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): Entity {
  const room = game.GetRoom();

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (positionOrGridIndex === undefined) {
    const entityID = getEntityIDFromConstituents(entityType, variant, subType);
    error(
      `Failed to spawn entity ${entityID} since an undefined position was passed to the "spawn" function.`,
    );
  }

  const position = isVector(positionOrGridIndex)
    ? positionOrGridIndex
    : room.GetGridPosition(positionOrGridIndex);

  if (seedOrRNG === undefined) {
    return Isaac.Spawn(
      entityType,
      variant,
      subType,
      position,
      velocity,
      spawner,
    );
  }

  const seed = isRNG(seedOrRNG) ? seedOrRNG.Next() : seedOrRNG;
  return game.Spawn(
    entityType,
    variant,
    position,
    velocity,
    spawner,
    subType,
    seed,
  );
}

/**
 * Helper function to spawn the entity corresponding to an `EntityID`.
 *
 * @param entityID The `EntityID` of the entity to spawn.
 * @param positionOrGridIndex The position or grid index of the entity to spawn.
 * @param velocity Optional. The velocity of the entity to spawn. Default is `VectorZero`.
 * @param spawner Optional. The entity that will be the `SpawnerEntity`. Default is undefined.
 * @param seedOrRNG Optional. The seed or RNG object to use to generate the `InitSeed` of the
 *                  entity. Default is undefined, which will make the entity spawn with a random
 *                  seed using the `Isaac.Spawn` method.
 */
export function spawnEntityID(
  entityID: EntityID,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): Entity {
  const [entityType, variant, subType] = getConstituentsFromEntityID(entityID);
  return spawn(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Helper function to spawn an entity. Use this instead of the `Game.Spawn` method if you do not
 * need to specify the velocity or spawner.
 */
export function spawnWithSeed(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): Entity {
  return spawn(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

----
functions\entitiesSpecific.ts
import type {
  BombVariant,
  EffectVariant,
  FamiliarVariant,
  KnifeVariant,
  LaserVariant,
  PickupVariant,
  ProjectileVariant,
  SlotVariant,
  TearVariant,
} from "isaac-typescript-definitions";
import { EntityType } from "isaac-typescript-definitions";
import { VectorZero } from "../core/constants";
import { getEntities, removeEntities, spawn } from "./entities";
import { assertDefined } from "./utils";

/**
 * Helper function to get all of the bombs in the room. (Specifically, this refers to the
 * `EntityBomb` class, not bomb pickups.)
 *
 * For example:
 *
 * ```ts
 * // Make all of the bombs in the room invisible.
 * for (const bomb of getBombs()) {
 *   bomb.Visible = false;
 * }
 * ```
 *
 * @param bombVariant Optional. If specified, will only get the bombs that match the variant.
 *                    Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the bombs that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getBombs(
  bombVariant: BombVariant | -1 = -1,
  subType = -1,
): readonly EntityBomb[] {
  const entities = getEntities(EntityType.BOMB, bombVariant, subType);

  const bombs: EntityBomb[] = [];
  for (const entity of entities) {
    const bomb = entity.ToBomb();
    if (bomb !== undefined) {
      bombs.push(bomb);
    }
  }

  return bombs;
}

/**
 * Helper function to get all of the effects in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the effects in the room invisible.
 * for (const effect of getEffects()) {
 *   effect.Visible = false;
 * }
 * ```
 *
 * @param effectVariant Optional. If specified, will only get the effects that match the variant.
 *                      Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the effects that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getEffects(
  effectVariant: EffectVariant | -1 = -1,
  subType = -1,
): readonly EntityEffect[] {
  const entities = getEntities(EntityType.EFFECT, effectVariant, subType);

  const effects: EntityEffect[] = [];
  for (const entity of entities) {
    const effect = entity.ToEffect();
    if (effect !== undefined) {
      effects.push(effect);
    }
  }

  return effects;
}

/**
 * Helper function to get all of the familiars in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the familiars in the room invisible.
 * for (const familiar of getFamiliars()) {
 *   familiar.Visible = false;
 * }
 * ```
 *
 * @param familiarVariant Optional. If specified, will only get the familiars that match the
 *                        variant. Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the familiars that match the sub-type.
 *                Default is -1, which matches every sub-type.
 */
export function getFamiliars(
  familiarVariant: FamiliarVariant | -1 = -1,
  subType = -1,
): readonly EntityFamiliar[] {
  const entities = getEntities(EntityType.FAMILIAR, familiarVariant, subType);

  const familiars: EntityFamiliar[] = [];
  for (const entity of entities) {
    const familiar = entity.ToFamiliar();
    if (familiar !== undefined) {
      familiars.push(familiar);
    }
  }

  return familiars;
}

/**
 * Helper function to get all of the knives in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the knives in the room invisible.
 * for (const knife of getKnives()) {
 *   knife.Visible = false;
 * }
 * ```
 *
 * @param knifeVariant Optional. If specified, will only get the knives that match the variant.
 *                     Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the knives that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getKnives(
  knifeVariant: KnifeVariant | -1 = -1,
  subType = -1,
): readonly EntityKnife[] {
  const entities = getEntities(EntityType.KNIFE, knifeVariant, subType);

  const knives: EntityKnife[] = [];
  for (const entity of entities) {
    const knife = entity.ToKnife();
    if (knife !== undefined) {
      knives.push(knife);
    }
  }

  return knives;
}

/**
 * Helper function to get all of the lasers in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the lasers in the room invisible.
 * for (const laser of getLasers()) {
 *   laser.Visible = false;
 * }
 * ```
 *
 * @param laserVariant Optional. If specified, will only get the lasers that match the variant.
 *                     Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only get the lasers that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getLasers(
  laserVariant: LaserVariant | -1 = -1,
  subType = -1,
): readonly EntityLaser[] {
  const entities = getEntities(EntityType.LASER, laserVariant, subType);

  const lasers: EntityLaser[] = [];
  for (const entity of entities) {
    const laser = entity.ToLaser();
    if (laser !== undefined) {
      lasers.push(laser);
    }
  }

  return lasers;
}

/**
 * Helper function to get all of the NPCs in the room.
 *
 * @param entityType Optional. If specified, will only get the NPCs that match the type. Default is
 *                   -1, which matches every entity type.
 * @param variant Optional. If specified, will only get the NPCs that match the variant. Default is
 *                -1, which matches every entity type.
 * @param subType Optional. If specified, will only get the bombs that match the sub-type. Default
 *                is -1, which matches every sub-type.
 * @param ignoreFriendly Optional. If set to true, it will exclude friendly NPCs from being
 *                       returned. Default is false. Will only be taken into account if the
 *                       `entityType` is specified.
 */
export function getNPCs(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): readonly EntityNPC[] {
  const entities = getEntities(entityType, variant, subType, ignoreFriendly);

  const npcs: EntityNPC[] = [];
  for (const entity of entities) {
    const npc = entity.ToNPC();
    if (npc !== undefined) {
      npcs.push(npc);
    }
  }

  return npcs;
}

/**
 * Helper function to get all of the pickups in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the pickups in the room invisible.
 * for (const pickup of getPickups()) {
 *   pickup.Visible = false;
 * }
 * ```
 *
 * @param pickupVariant Optional. If specified, will only get the pickups that match the variant.
 *                      Default is -1, which matches every entity type.
 * @param subType Optional. If specified, will only get the pickups that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getPickups(
  pickupVariant: PickupVariant | -1 = -1,
  subType = -1,
): readonly EntityPickup[] {
  const entities = getEntities(EntityType.PICKUP, pickupVariant, subType);

  const pickups: EntityPickup[] = [];
  for (const entity of entities) {
    const pickup = entity.ToPickup();
    if (pickup !== undefined) {
      pickups.push(pickup);
    }
  }

  return pickups;
}

/**
 * Helper function to get all of the projectiles in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the projectiles in the room invisible.
 * for (const projectile of getProjectiles()) {
 *   projectile.Visible = false;
 * }
 * ```
 *
 * @param projectileVariant Optional. If specified, will only get the projectiles that match the
 *                          variant. Default is -1, which matches every entity type.
 * @param subType Optional. If specified, will only get the projectiles that match the sub-type.
 *                Default is -1, which matches every sub-type.
 */
export function getProjectiles(
  projectileVariant: ProjectileVariant | -1 = -1,
  subType = -1,
): readonly EntityProjectile[] {
  const entities = getEntities(
    EntityType.PROJECTILE,
    projectileVariant,
    subType,
  );

  const projectiles: EntityProjectile[] = [];
  for (const entity of entities) {
    const projectile = entity.ToProjectile();
    if (projectile !== undefined) {
      projectiles.push(projectile);
    }
  }

  return projectiles;
}

/**
 * Helper function to get all of the slots in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the slots in the room invisible.
 * for (const slot of getSlots()) {
 *   slot.Visible = false;
 * }
 * ```
 *
 * @param slotVariant Optional. If specified, will only get the slots that match the variant.
 *                    Default is -1, which matches every entity type.
 * @param subType Optional. If specified, will only get the slots that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getSlots(
  slotVariant: SlotVariant | -1 = -1,
  subType = -1,
): readonly EntitySlot[] {
  const slots = getEntities(EntityType.SLOT, slotVariant, subType);

  return slots as EntitySlot[];
}

/**
 * Helper function to get all of the tears in the room.
 *
 * For example:
 *
 * ```ts
 * // Make all of the tears in the room invisible.
 * for (const tear of getTears()) {
 *   tear.Visible = false;
 * }
 * ```
 *
 * @param tearVariant Optional. If specified, will only get the tears that match the variant.
 *                    Default is -1, which matches every entity type.
 * @param subType Optional. If specified, will only get the tears that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getTears(
  tearVariant: TearVariant | -1 = -1,
  subType = -1,
): readonly EntityTear[] {
  const entities = getEntities(EntityType.TEAR, tearVariant, subType);

  const tears: EntityTear[] = [];
  for (const entity of entities) {
    const tear = entity.ToTear();
    if (tear !== undefined) {
      tears.push(tear);
    }
  }

  return tears;
}

/**
 * Helper function to remove all of the bombs in the room. (Specifically, this refers to the
 * `EntityBomb` class, not bomb pickups.)
 *
 * @param bombVariant Optional. If specified, will only remove the bombs that match the variant.
 *                    Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the bombs that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of bombs.
 * @returns An array of the bombs that were removed.
 */
export function removeAllBombs(
  bombVariant: BombVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityBomb[] {
  const bombs = getBombs(bombVariant, subType);
  return removeEntities(bombs, cap);
}

/**
 * Helper function to remove all of the effects in the room.
 *
 * @param effectVariant Optional. If specified, will only remove the effects that match the variant.
 *                      Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the effects that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of effects.
 * @returns An array of the effects that were removed.
 */
export function removeAllEffects(
  effectVariant: EffectVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityEffect[] {
  const effects = getEffects(effectVariant, subType);
  return removeEntities(effects, cap);
}

/**
 * Helper function to remove all of the familiars in the room.
 *
 * @param familiarVariant Optional. If specified, will only remove the familiars that match the
 *                        variant. Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the familiars that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of familiars.
 * @returns An array of the familiars that were removed.
 */
export function removeAllFamiliars(
  familiarVariant: FamiliarVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityFamiliar[] {
  const familiars = getFamiliars(familiarVariant, subType);
  return removeEntities(familiars, cap);
}

/**
 * Helper function to remove all of the knives in the room.
 *
 * @param knifeVariant Optional. If specified, will only remove the knives that match the variant.
 *                     Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the knives that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of knives.
 * @returns An array of the knives that were removed.
 */
export function removeAllKnives(
  knifeVariant: KnifeVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityKnife[] {
  const knives = getKnives(knifeVariant, subType);
  return removeEntities(knives, cap);
}

/**
 * Helper function to remove all of the lasers in the room.
 *
 * @param laserVariant Optional. If specified, will only remove the lasers that match the variant.
 *                     Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the lasers that match the sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of lasers.
 * @returns An array of the lasers that were removed.
 */
export function removeAllLasers(
  laserVariant: LaserVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityLaser[] {
  const lasers = getLasers(laserVariant, subType);
  return removeEntities(lasers, cap);
}

/**
 * Helper function to remove all of the NPCs in the room.
 *
 * @param entityType Optional. If specified, will only remove the NPCs that match the type. Default
 *                   is -1, which matches every type.
 * @param variant Optional. If specified, will only remove the NPCs that match the variant. Default
 *                is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove the NPCs that match the sub-type. Default
 *                is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of NPCs.
 * @returns An array of the NPCs that were removed.
 */
export function removeAllNPCs(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  cap?: int,
): readonly EntityNPC[] {
  const npcs = getNPCs(entityType, variant, subType);
  return removeEntities(npcs, cap);
}

/**
 * Helper function to remove all of the pickups in the room.
 *
 * @param pickupVariant Optional. If specified, will only remove pickups that match this variant.
 *                      Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove pickups that match this sub-type. Default
 *                is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of pickups.
 * @returns An array of the pickups that were removed.
 */
export function removeAllPickups(
  pickupVariant: PickupVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityPickup[] {
  const pickups = getPickups(pickupVariant, subType);
  return removeEntities(pickups, cap);
}

/**
 * Helper function to remove all of the projectiles in the room.
 *
 * @param projectileVariant Optional. If specified, will only remove projectiles that match this
 *                          variant. Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove projectiles that match this sub-type.
 *                Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of projectiles.
 * @returns An array of the projectiles that were removed.
 */
export function removeAllProjectiles(
  projectileVariant: ProjectileVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityProjectile[] {
  const projectiles = getProjectiles(projectileVariant, subType);
  return removeEntities(projectiles, cap);
}

/**
 * Helper function to remove all of the slots in the room.
 *
 * @param slotVariant Optional. If specified, will only remove slots that match this variant.
 *                    Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove slots that match this sub-type. Default
 *                is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of slots.
 * @returns An array of the slots that were removed.
 */
export function removeAllSlots(
  slotVariant: SlotVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly Entity[] {
  const slots = getSlots(slotVariant, subType);
  return removeEntities(slots, cap);
}

/**
 * Helper function to remove all of the tears in the room.
 *
 * @param tearVariant Optional. If specified, will only remove tears that match this variant.
 *                    Default is -1, which matches every variant.
 * @param subType Optional. If specified, will only remove tears that match this sub-type. Default
 *                is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of tears.
 * @returns An array of the tears that were removed.
 */
export function removeAllTears(
  tearVariant: TearVariant | -1 = -1,
  subType = -1,
  cap?: int,
): readonly EntityTear[] {
  const tears = getTears(tearVariant, subType);
  return removeEntities(tears, cap);
}

/** Helper function to spawn a `EntityType.BOMB` (4). */
export function spawnBomb(
  bombVariant: BombVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityBomb {
  const entity = spawn(
    EntityType.BOMB,
    bombVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const bomb = entity.ToBomb();
  assertDefined(bomb, "Failed to spawn a bomb.");

  return bomb;
}

/** Helper function to spawn a `EntityType.BOMB` (4) with a specific seed. */
export function spawnBombWithSeed(
  bombVariant: BombVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityBomb {
  return spawnBomb(
    bombVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.EFFECT` (1000). */
export function spawnEffect(
  effectVariant: EffectVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityEffect {
  const entity = spawn(
    EntityType.EFFECT,
    effectVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const effect = entity.ToEffect();
  assertDefined(effect, "Failed to spawn an effect.");

  return effect;
}

/** Helper function to spawn a `EntityType.EFFECT` (1000) with a specific seed. */
export function spawnEffectWithSeed(
  effectVariant: EffectVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityEffect {
  return spawnEffect(
    effectVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Helper function to spawn a `EntityType.FAMILIAR` (3).
 *
 * If you are trying to implement a custom familiar, you probably want to use the
 * `checkFamiliarFromCollectibles` helper function instead.
 */
export function spawnFamiliar(
  familiarVariant: FamiliarVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityFamiliar {
  const entity = spawn(
    EntityType.FAMILIAR,
    familiarVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const familiar = entity.ToFamiliar();
  assertDefined(familiar, "Failed to spawn a familiar.");

  return familiar;
}

/** Helper function to spawn a `EntityType.FAMILIAR` (3) with a specific seed. */
export function spawnFamiliarWithSeed(
  familiarVariant: FamiliarVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityFamiliar {
  return spawnFamiliar(
    familiarVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.KNIFE` (8). */
export function spawnKnife(
  knifeVariant: KnifeVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityKnife {
  const entity = spawn(
    EntityType.KNIFE,
    knifeVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const knife = entity.ToKnife();
  assertDefined(knife, "Failed to spawn a knife.");

  return knife;
}

/** Helper function to spawn a `EntityType.KNIFE` (8) with a specific seed. */
export function spawnKnifeWithSeed(
  knifeVariant: KnifeVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityKnife {
  return spawnKnife(
    knifeVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.LASER` (7). */
export function spawnLaser(
  laserVariant: LaserVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityLaser {
  const entity = spawn(
    EntityType.LASER,
    laserVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const laser = entity.ToLaser();
  assertDefined(laser, "Failed to spawn a laser.");

  return laser;
}

/** Helper function to spawn a `EntityType.LASER` (7) with a specific seed. */
export function spawnLaserWithSeed(
  laserVariant: LaserVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityLaser {
  return spawnLaser(
    laserVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Helper function to spawn an NPC.
 *
 * Note that if you pass a non-NPC `EntityType` to this function, it will cause a run-time error,
 * since the `Entity.ToNPC` method will return undefined.
 */
export function spawnNPC(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityNPC {
  const entity = spawn(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const npc = entity.ToNPC();
  assertDefined(npc, "Failed to spawn an NPC.");

  return npc;
}

/**
 * Helper function to spawn an NPC with a specific seed.
 *
 * Note that if you pass a non-NPC `EntityType` to this function, it will cause a run-time error,
 * since the `Entity.ToNPC` method will return undefined.
 */
export function spawnNPCWithSeed(
  entityType: EntityType,
  variant: int,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityNPC {
  return spawnNPC(
    entityType,
    variant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5). */
export function spawnPickup(
  pickupVariant: PickupVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickup {
  const entity = spawn(
    EntityType.PICKUP,
    pickupVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const pickup = entity.ToPickup();
  assertDefined(pickup, "Failed to spawn a pickup.");

  return pickup;
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with a specific seed. */
export function spawnPickupWithSeed(
  pickupVariant: PickupVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickup {
  return spawnPickup(
    pickupVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PROJECTILE` (9). */
export function spawnProjectile(
  projectileVariant: ProjectileVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityProjectile {
  const entity = spawn(
    EntityType.PROJECTILE,
    projectileVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const projectile = entity.ToProjectile();
  assertDefined(projectile, "Failed to spawn a projectile.");

  return projectile;
}

/** Helper function to spawn a `EntityType.PROJECTILE` (9) with a specific seed. */
export function spawnProjectileWithSeed(
  projectileVariant: ProjectileVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityProjectile {
  return spawnProjectile(
    projectileVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.SLOT` (6). */
export function spawnSlot(
  slotVariant: SlotVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntitySlot {
  return spawn(
    EntityType.SLOT,
    slotVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntitySlot;
}

/** Helper function to spawn a `EntityType.SLOT` (6) with a specific seed. */
export function spawnSlotWithSeed(
  slotVariant: SlotVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntitySlot {
  return spawnSlot(
    slotVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.TEAR` (2). */
export function spawnTear(
  tearVariant: TearVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityTear {
  const entity = spawn(
    EntityType.TEAR,
    tearVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );

  const tear = entity.ToTear();
  assertDefined(tear, "Failed to spawn a tear.");

  return tear;
}

/** Helper function to spawn a `EntityType.EntityType` (2) with a specific seed. */
export function spawnTearWithSeed(
  tearVariant: TearVariant,
  subType: int,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityTear {
  return spawnTear(
    tearVariant,
    subType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

----
functions\entityTypes.ts
import { EntityType } from "isaac-typescript-definitions";

/** For `EntityType.SLOT` (6). */
export function isSlot(entity: Entity): entity is EntitySlot {
  return entity.Type === EntityType.SLOT;
}

----
functions\enums.ts
import { ReadonlySet } from "../types/ReadonlySet";
import { getRandomArrayElement } from "./array";
import { sortNormal } from "./sort";
import { isNumber, isString } from "./types";
import { assertDefined, iRange } from "./utils";

/**
 * In Lua, tables can have number keys, but since this is a type only being validated in TypeScript,
 * we can match the JavaScript definition, meaning that we can omit the number from the keys.
 */
export type TranspiledEnum = Record<
  string,
  string | number | BitFlag | BitFlag128
>;

/**
 * TypeScriptToLua will transpile TypeScript number enums to Lua tables that have a double mapping.
 * Thus, when you iterate over them, you will get both the names of the enums and the values of the
 * enums, in a random order. Use this helper function to get the entries of the enum with the
 * reverse mappings filtered out.
 *
 * This function will return the enum values in a sorted order, which may not necessarily be the
 * same order as which they were declared in. (It is impossible to get the declaration order at
 * run-time.)
 *
 * This function will work properly for both number enums and string enums. (Reverse mappings are
 * not created for string enums.)
 *
 * Also see the `getEnumKeys` and `getEnumValues` helper functions.
 *
 * For a more in depth explanation, see:
 * https://isaacscript.github.io/main/gotchas#iterating-over-enums
 */
export function getEnumEntries<T extends TranspiledEnum>(
  transpiledEnum: T,
): ReadonlyArray<[key: string, value: T[keyof T]]> {
  const entries = Object.entries(transpiledEnum);
  const numberEntries = entries.filter(
    ([_key, value]) => typeof value === "number",
  );

  // If there are no number values, then this must be a string enum, and no filtration is required.
  const entriesToReturn = numberEntries.length > 0 ? numberEntries : entries;

  // The enums will be in a random order (because of "pairs"), so sort them based on the values.
  // https://stackoverflow.com/questions/5199901/how-to-sort-an-associative-array-by-its-values-in-javascript
  entriesToReturn.sort(
    ([_key1, value1], [_key2, value2]) =>
      value1 < value2 ? -1 : value1 > value2 ? 1 : 0, // eslint-disable-line no-nested-ternary
  );

  return entriesToReturn as never;
}

/**
 * TypeScriptToLua will transpile TypeScript number enums to Lua tables that have a double mapping.
 * Thus, when you iterate over them, you will get both the names of the enums and the values of the
 * enums, in a random order. If all you need are the keys of an enum, use this helper function.
 *
 * This function will return the enum keys in a sorted order, which may not necessarily be the same
 * order as which they were declared in. (It is impossible to get the declaration order at
 * run-time.)
 *
 * This function will work properly for both number enums and string enums. (Reverse mappings are
 * not created for string enums.)
 *
 * Also see the `getEnumEntries` and `getEnumValues` helper functions.
 *
 * For a more in depth explanation, see:
 * https://isaacscript.github.io/main/gotchas#iterating-over-enums
 */
export function getEnumKeys(transpiledEnum: TranspiledEnum): readonly string[] {
  const enumEntries = getEnumEntries(transpiledEnum);
  return enumEntries.map(([key, _value]) => key);
}

/** Helper function to get the amount of entries inside of an enum. */
export function getEnumLength(transpiledEnum: TranspiledEnum): int {
  const enumEntries = getEnumEntries(transpiledEnum);
  return enumEntries.length;
}

/**
 * TypeScriptToLua will transpile TypeScript number enums to Lua tables that have a double mapping.
 * Thus, when you iterate over them, you will get both the names of the enums and the values of the
 * enums, in a random order. If all you need are the names of an enum from the reverse mapping, use
 * this helper function.
 *
 * This function will return the enum names in a sorted order, which may not necessarily be the same
 * order as which they were declared in. (It is impossible to get the declaration order at
 * run-time.)
 *
 * This function will work properly for both number enums and string enums. (Reverse mappings are
 * not created for string enums, so their names would be equivalent to what would be returned by the
 * `getEnumKeys` function.)
 *
 * For a more in depth explanation, see:
 * https://isaacscript.github.io/main/gotchas#iterating-over-enums
 */
export function getEnumNames(
  transpiledEnum: TranspiledEnum,
): readonly string[] {
  const enumNames: string[] = [];

  for (const [key, _value] of pairs(transpiledEnum)) {
    if (isString(key)) {
      enumNames.push(key);
    }
  }

  // The enum names will be in a random order (because of "pairs"), so sort them.
  enumNames.sort();

  return enumNames;
}

/**
 * TypeScriptToLua will transpile TypeScript number enums to Lua tables that have a double mapping.
 * Thus, when you iterate over them, you will get both the names of the enums and the values of the
 * enums, in a random order. If all you need are the values of an enum, use this helper function.
 *
 * This function will return the enum values in a sorted order, which may not necessarily be the
 * same order as which they were declared in. (It is impossible to get the declaration order at
 * run-time.)
 *
 * This function will work properly for both number enums and string enums. (Reverse mappings are
 * not created for string enums.)
 *
 * Also see the `getEnumEntries` and `getEnumKeys` helper functions.
 *
 * For a more in depth explanation, see:
 * https://isaacscript.github.io/main/gotchas#iterating-over-enums
 */
export function getEnumValues<T extends TranspiledEnum>(
  transpiledEnum: T,
): ReadonlyArray<T[keyof T]> {
  const enumEntries = getEnumEntries(transpiledEnum);
  return enumEntries.map(([_key, value]) => value);
}

/**
 * Helper function to get the enum value with the highest value.
 *
 * Note that this is not necessarily the enum value that is declared last in the code, since there
 * is no way to infer that at run-time.
 *
 * Throws an error if the provided enum is empty.
 */
export function getHighestEnumValue<T extends TranspiledEnum>(
  transpiledEnum: T,
): T[keyof T] {
  const enumValues = getEnumValues(transpiledEnum);
  const sortedValues = enumValues.toSorted(sortNormal);
  const lastElement = sortedValues.at(-1);
  assertDefined(
    lastElement,
    "Failed to get the highest value from an enum since the enum was empty.",
  );

  return lastElement;
}

/**
 * Helper function to get the enum value with the lowest value.
 *
 * Note that this is not necessarily the enum value that is declared first in the code, since there
 * is no way to infer that at run-time.
 *
 * Throws an error if the provided enum is empty.
 */
export function getLowestEnumValue<T extends TranspiledEnum>(
  transpiledEnum: T,
): T[keyof T] {
  const enumValues = getEnumValues(transpiledEnum);
  const sortedValues = enumValues.toSorted(sortNormal);
  const firstElement = sortedValues[0];
  assertDefined(
    firstElement,
    "Failed to get the lowest value from an enum since the enum was empty.",
  );

  return firstElement;
}

/**
 * Helper function to get a random value from the provided enum.
 *
 * If you want an unseeded value, you must explicitly pass `undefined` to the `seedOrRNG` parameter.
 *
 * @param transpiledEnum The enum to get the value from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of elements to skip over if selected.
 */
export function getRandomEnumValue<T extends TranspiledEnum>(
  transpiledEnum: T,
  seedOrRNG: Seed | RNG | undefined,
  exceptions: ReadonlyArray<T[keyof T]> = [],
): T[keyof T] {
  const enumValues = getEnumValues(transpiledEnum);
  return getRandomArrayElement(enumValues, seedOrRNG, exceptions);
}

/**
 * Helper function to validate that an interface contains all of the keys of an enum. You must
 * specify both generic parameters in order for this to work properly (i.e. the interface and then
 * the enum).
 *
 * For example:
 *
 * ```ts
 * enum MyEnum {
 *   Value1,
 *   Value2,
 *   Value3,
 * }
 *
 * interface MyEnumToType {
 *   [MyEnum.Value1]: boolean;
 *   [MyEnum.Value2]: number;
 *   [MyEnum.Value3]: string;
 * }
 *
 * interfaceSatisfiesEnum<MyEnumToType, MyEnum>();
 * ```
 *
 * This function is only meant to be used with interfaces (i.e. types that will not exist at
 * run-time). If you are generating an object that will contain all of the keys of an enum, use the
 * `satisfies` operator with the `Record` type instead.
 */
export function interfaceSatisfiesEnum<
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  T extends Record<Enum, unknown>,
  Enum extends string | number,
>(): void {} // eslint-disable-line @typescript-eslint/no-empty-function

/** Helper function to validate that a particular value exists inside of an enum. */
export function isEnumValue<T extends TranspiledEnum>(
  value: number | string | BitFlag | BitFlag128,
  transpiledEnum: T,
): value is T[keyof T] {
  const enumValues = getEnumValues(transpiledEnum);
  return enumValues.includes(value as T[keyof T]);
}

/**
 * Helper function to check every value of a custom enum for -1. Will throw an run-time error if any
 * -1 values are found. This is helpful because many methods of the Isaac class return -1 if they
 * fail.
 *
 * For example:
 *
 * ```ts
 * enum EntityTypeCustom {
 *   FOO = Isaac.GetEntityTypeByName("Foo"),
 * }
 *
 * validateCustomEnum("EntityTypeCustom", EntityTypeCustom);
 * ```
 */
export function validateCustomEnum(
  transpiledEnumName: string,
  transpiledEnum: TranspiledEnum,
): void {
  for (const [key, value] of getEnumEntries(transpiledEnum)) {
    if (value === -1) {
      error(
        `Failed to find the custom enum value: ${transpiledEnumName}.${key}`,
      );
    }
  }
}

/**
 * Helper function to validate if every value in a number enum is contiguous, starting at 0.
 *
 * This is useful to automate checking large enums for typos.
 */
export function validateEnumContiguous<T extends TranspiledEnum>(
  transpiledEnumName: string,
  transpiledEnum: T,
): void {
  const values = getEnumValues(transpiledEnum);
  const lastValue = values.at(-1);
  assertDefined(
    lastValue,
    "Failed to validate that an enum was contiguous, since the last value was undefined.",
  );

  if (!isNumber(lastValue)) {
    error(
      "Failed to validate that an enum was contiguous, since the last value was not a number.",
    );
  }

  const valuesSet = new ReadonlySet(values);
  for (const value of iRange(lastValue)) {
    if (!valuesSet.has(value as unknown as T[keyof T])) {
      error(
        `Failed to find a custom enum value of ${value} for: ${transpiledEnumName}`,
      );
    }
  }
}

----
functions\external.ts
/**
 * Helper functions that have to do with external programs.
 *
 * @module
 */

import type { CollectibleType } from "isaac-typescript-definitions";
import { getCollectibleName } from "./collectibles";

const REBIRTH_ITEM_TRACKER_REMOVE_COLLECTIBLE_COMMAND =
  "REBIRTH_ITEM_TRACKER_REMOVE_COLLECTIBLE";

const REBIRTH_ITEM_TRACKER_WRITE_TO_FILE_COMMAND =
  "REBIRTH_ITEM_TRACKER_WRITE_TO_FILE";

/**
 * Helper function to let the Rebirth Item Tracker know that it should remove a collectible from its
 * list.
 *
 * The "item tracker" in this function does not refer to the in-game item tracker, but rather to the
 * external Python program.
 *
 * This function is variadic, meaning that you can pass as many collectible types as you want to
 * remove.
 *
 * Note that calling this function is not normally necessary when removing collectibles from
 * players. For example, when you remove a collectible with the `EntityPlayer.RemoveCollectible`
 * method, a message is sent to the log file by the game and the item tracker will automatically
 * remove it. However, in some cases, manually removing collectibles can be useful:
 *
 * - We may be giving the player a "fake" collectible (e.g. 1-Up for the purposes of an extra life)
 *   and do not want the fake collectible to show up on the tracker.
 * - We may be removing a starting active item. Since active items are never removed from the
 *   tracker, we want to tell the item tracker that the player never had a particular active item to
 *   begin with.
 *
 * @see https://github.com/Rchardon/RebirthItemTracker
 */
export function rebirthItemTrackerRemoveCollectible(
  ...collectibleTypes: readonly CollectibleType[]
): void {
  for (const collectibleType of collectibleTypes) {
    // This cannot use the "log" function since the prefix will prevent the Rebirth Item Tracker
    // from recognizing the message.
    const collectibleName = getCollectibleName(collectibleType);
    Isaac.DebugString(
      `${REBIRTH_ITEM_TRACKER_REMOVE_COLLECTIBLE_COMMAND} Removing collectible ${collectibleType} (${collectibleName}) on player 0 (Player)`,
    );
  }
}

/**
 * Helper function to let the Rebirth Item Tracker know that it should write the submitted text
 * string to a file. This is useful for capturing text in programs like Open Broadcaster Software
 * (OBS).
 *
 * The "item tracker" in this function does not refer to the in-game item tracker, but rather to the
 * external Python program.
 *
 * @see https://github.com/Rchardon/RebirthItemTracker
 */
export function rebirthItemTrackerWriteToFile(msg: string): void {
  // This cannot use the "log" function since the prefix will prevent the Rebirth Item Tracker from
  // recognizing the message.
  Isaac.DebugString(`${REBIRTH_ITEM_TRACKER_WRITE_TO_FILE_COMMAND} ${msg}`);
}

----
functions\familiars.ts
import type {
  CollectibleType,
  FamiliarVariant,
} from "isaac-typescript-definitions";
import { EntityType } from "isaac-typescript-definitions";
import { itemConfig } from "../core/cachedClasses";
import { FAMILIARS_THAT_SHOOT_PLAYER_TEARS_SET } from "../sets/familiarsThatShootPlayerTearsSet";
import { getEntities } from "./entities";
import { getFamiliars } from "./entitiesSpecific";
import { newRNG } from "./rng";

/**
 * Instead of generating a new RNG object every time we need to spawn a new familiar, we instead
 * re-use the same RNG object. This makes it less likely that the `InitSeed` of the familiar will
 * overlap, since we are "nexting" instead of doing a fresh reroll.
 */
const familiarGenerationRNG = newRNG();

/**
 * Helper function to add and remove familiars based on a target amount that you specify.
 *
 * This is a convenience wrapper around the `EntityPlayer.CheckFamiliar` method. Use this helper
 * function instead so that you do not have to retrieve the `ItemConfigItem` and so that you do not
 * specify an incorrect RNG object. (The vanilla method is bugged in that it does not increment the
 * RNG object; see the documentation of the method for more details.)
 *
 * This function is meant to be called in the `EVALUATE_CACHE` callback (when the cache flag is
 * equal to `CacheFlag.FAMILIARS`).
 *
 * Note that this function is only meant to be used in special circumstances where the familiar
 * count is completely custom and does not correspond to the amount of collectibles. For the general
 * case, use the `checkFamiliarFromCollectibles` helper function instead.
 *
 * Note that this will spawn familiars with a completely random `InitSeed`. When calculating random
 * events for this familiar, you should use a data structure that maps familiar `InitSeed` to RNG
 * objects that are initialized based on the seed from
 * `EntityPlayer.GetCollectibleRNG(collectibleType)`.
 *
 * @param player The player that owns the familiars.
 * @param collectibleType The collectible type of the collectible associated with this familiar.
 * @param targetCount The number of familiars that should exist. This function will add or remove
 *                    familiars until it matches the target count.
 * @param familiarVariant The variant of the familiar to spawn or remove.
 * @param familiarSubType Optional. The sub-type of the familiar to spawn or remove. If not
 *                        specified, it will search for existing familiars of all sub-types, and
 *                        spawn new familiars with a sub-type of 0.
 */
export function checkFamiliar(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  targetCount: int,
  familiarVariant: FamiliarVariant,
  familiarSubType?: int,
): void {
  familiarGenerationRNG.Next();

  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  player.CheckFamiliar(
    familiarVariant,
    targetCount,
    familiarGenerationRNG,
    itemConfigItem,
    familiarSubType,
  );
}

/**
 * Helper function to add and remove familiars based on the amount of associated collectibles that a
 * player has.
 *
 * Use this helper function instead of invoking the `EntityPlayer.CheckFamiliar` method directly so
 * that the target count is handled automatically.
 *
 * This function is meant to be called in the `EVALUATE_CACHE` callback (when the cache flag is
 * equal to `CacheFlag.FAMILIARS`).
 *
 * Use this function when the amount of familiars should be equal to the amount of associated
 * collectibles that the player has (plus any extras from having used Box of Friends or Monster
 * Manual). If you instead need to have a custom amount of familiars, use the `checkFamiliars`
 * function instead.
 *
 * Note that this will spawn familiars with a completely random `InitSeed`. When calculating random
 * events for this familiar, you should use a data structure that maps familiar `InitSeed` to RNG
 * objects that are initialized based on the seed from
 * `EntityPlayer.GetCollectibleRNG(collectibleType)`.
 *
 * @param player The player that owns the familiars and collectibles.
 * @param collectibleType The collectible type of the collectible associated with this familiar.
 * @param familiarVariant The variant of the familiar to spawn or remove.
 * @param familiarSubType Optional. The sub-type of the familiar to spawn or remove. If not
 *                        specified, it will search for existing familiars of all sub-types, and
 *                        spawn new familiars with a sub-type of 0.
 */
export function checkFamiliarFromCollectibles(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  familiarVariant: FamiliarVariant,
  familiarSubType?: int,
): void {
  // We need to include non-real collectibles (like Lilith's Incubus), so we omit the second
  // argument.
  const numCollectibles = player.GetCollectibleNum(collectibleType);
  const effects = player.GetEffects();

  // Whenever Box of Friends or Monster Manual is used, it will automatically increment the number
  // of collectible effects for this familiar.
  const numCollectibleEffects =
    effects.GetCollectibleEffectNum(collectibleType);
  const targetCount = numCollectibles + numCollectibleEffects;

  checkFamiliar(
    player,
    collectibleType,
    targetCount,
    familiarVariant,
    familiarSubType,
  );
}

/** Helper function to get only the familiars that belong to a specific player. */
export function getPlayerFamiliars(
  player: EntityPlayer,
): readonly EntityFamiliar[] {
  const playerPtrHash = GetPtrHash(player);
  const familiars = getFamiliars();
  return familiars.filter((familiar) => {
    const familiarPlayerPtrHash = GetPtrHash(familiar.Player);
    return familiarPlayerPtrHash === playerPtrHash;
  });
}

/**
 * Helper function to get the corresponding "Siren Helper" entity for a stolen familiar.
 *
 * When The Siren boss "steals" your familiars, a hidden "Siren Helper" entity is spawned to control
 * each familiar stolen. (Checking for the presence of this entity seems to be the only way to
 * detect when the Siren steals a familiar.)
 *
 * @param familiar The familiar to be checked.
 * @returns Returns the hidden "Siren Helper" entity corresponding to the given familiar, if it
 *          exists. Returns undefined otherwise.
 */
export function getSirenHelper(familiar: EntityFamiliar): Entity | undefined {
  const familiarPtrHash = GetPtrHash(familiar);

  const sirenHelpers = getEntities(EntityType.SIREN_HELPER);
  return sirenHelpers.find(
    (sirenHelper) =>
      sirenHelper.Target !== undefined &&
      GetPtrHash(sirenHelper.Target) === familiarPtrHash,
  );
}

/**
 * Helper function to detect if the given familiar is "stolen" by The Siren boss.
 *
 * This function is useful because some familiars may need to behave differently when under The
 * Siren's control (e.g. if they auto-target enemies).
 */
export function isFamiliarStolenBySiren(familiar: EntityFamiliar): boolean {
  const sirenHelper = getSirenHelper(familiar);
  return sirenHelper !== undefined;
}

/**
 * Helper function to check if a familiar is the type that shoots tears that mimic the players
 * tears, like Incubus, Fate's Reward, Sprinkler, and so on.
 */
export function isFamiliarThatShootsPlayerTears(
  familiar: EntityFamiliar,
): boolean {
  return FAMILIARS_THAT_SHOOT_PLAYER_TEARS_SET.has(familiar.Variant);
}

----
functions\flag.ts
import { DamageFlag } from "isaac-typescript-definitions";
import type { ReadonlyRecord } from "../types/ReadonlyRecord";

/**
 * Helper function to add a bit flag to an existing set of bit flags.
 *
 * This is a variadic function, so pass as many flags as you want to add.
 *
 * Example 1:
 *
 * ```ts
 * // Give the player spectral tears
 * const player = Isaac.GetPlayer();
 * player.TearFlags = addFlag(player.TearFlags, TearFlags.TEAR_SPECTRAL);
 * ```
 *
 * Example 2:
 *
 * ```ts
 * // Give the player spectral and homing tears
 * const player = Isaac.GetPlayer();
 * player.TearFlags = addFlag(player.TearFlags, TearFlags.TEAR_SPECTRAL, TearFlags.TEAR_HOMING);
 * ```
 *
 * @param flags The existing set of bit flags.
 * @param flagsToAdd One or more bit flags to add, each as a separate argument.
 * @returns The combined bit flags.
 */
export function addFlag<T extends BitFlag | BitFlag128>(
  flags: T | BitFlags<T>,
  ...flagsToAdd: readonly T[]
): BitFlags<T> {
  let flagsAsInt = flags as int;

  for (const flagToAdd of flagsToAdd) {
    flagsAsInt |= flagToAdd as int;
  }

  return flagsAsInt as unknown as BitFlags<T>;
}

/**
 * Helper function for casting a flag enum value to a `BitFlags` object.
 *
 * This is useful because the compiler will prevent you from assigning a specific flag to a
 * `BitFlags` field. (It does this to ensure type safety, since `BitFlags` can represent a zero
 * value or a composition of N flags.)
 *
 * For example:
 *
 * ```ts
 * player.TearFlags = bitFlags(TearFlag.SPECTRAL);
 * ```
 */
export function bitFlags<T extends BitFlag | BitFlag128>(flag: T): BitFlags<T> {
  return flag as BitFlags<T>;
}

/**
 * Helper function to get the key associated with a particular flag.
 *
 * (Since bit flags are represented by custom objects instead of normal TypeScript enums, you cannot
 * use the reverse mapping to find the associated key of a given enum value. Use this helper
 * function instead of indexing the enum directly.)
 */
export function getFlagName<T extends BitFlag | BitFlag128>(
  flag: BitFlag,
  flagEnum: ReadonlyRecord<string, T>,
): string | undefined {
  for (const [key, value] of Object.entries(flagEnum)) {
    if (value === flag) {
      return key;
    }
  }

  return undefined;
}

/**
 * Helper function to determine if a particular bit flag is set to true.
 *
 * This is a variadic function, so pass as many flags as you want to check for. If passed multiple
 * flags, it will only return true if all of the flags are set.
 *
 * For example:
 *
 * ```ts
 * const player = Isaac.GetPlayer();
 * if (hasFlag(player.TearFlags, TearFlags.TEAR_SPECTRAL) {
 *   // The player currently has spectral tears
 * }
 * ```
 *
 * @param flags The existing set of bit flags.
 * @param flagsToCheck One or more bit flags to check for, each as a separate argument.
 */
export function hasFlag<T extends BitFlag | BitFlag128>(
  flags: T | BitFlags<T>,
  ...flagsToCheck: readonly T[]
): boolean {
  const flagsAsInt = flags as int;

  for (const flagToCheck of flagsToCheck) {
    if (!((flagsAsInt & (flagToCheck as int)) === flagToCheck)) {
      return false;
    }
  }

  return true;
}

/**
 * Helper function to check if every bit in the flag is turned off.
 *
 * (This is equivalent to checking if the flag is equal to 0, but this is not possible without
 * casting the flag to a number.)
 */
export function isEmptyFlag<T extends BitFlag | BitFlag128>(flag: T): boolean {
  return flag === 0;
}

/**
 * Helper function to determine whether damage to a player in the `ENTITY_TAKE_DMG` callback was
 * self-inflicted. For example, damage from a Curse Room door, a Razor, or a Blood Donation Machine
 * would count as self-inflicted damage.
 */
export function isSelfDamage(
  damageFlags: DamageFlag | BitFlags<DamageFlag>,
): boolean {
  return (
    // Exclude self-damage from e.g. Curse Room door spikes.
    hasFlag(damageFlags, DamageFlag.NO_PENALTIES) ||
    // Exclude self-damage from e.g. Razor.
    hasFlag(damageFlags, DamageFlag.RED_HEARTS)
  );
}

/**
 * Helper function to remove a bit flag from an existing set of bit flags.
 *
 * This is a variadic function, so pass as many flags as you want to remove.
 *
 * For example:
 *
 * ```ts
 * // Remove spectral tears from the player, if present
 * const player = Isaac.GetPlayer();
 * player.TearFlags = removeFlag(player.TearFlags, TearFlags.TEAR_SPECTRAL);
 * ```
 *
 * @param flags The existing set of bit flags.
 * @param flagsToRemove One or more bit flags to remove, each as a separate argument.
 * @returns The combined bit flags.
 */
export function removeFlag<T extends BitFlag | BitFlag128>(
  flags: T | BitFlags<T>,
  ...flagsToRemove: readonly T[]
): BitFlags<T> {
  let flagsAsInt = flags as int;

  for (const flagToRemove of flagsToRemove) {
    flagsAsInt &= ~flagToRemove;
  }

  return flagsAsInt as unknown as BitFlags<T>;
}

----
functions\frames.ts
import { game } from "../core/cachedClasses";

export function getElapsedGameFramesSince(gameFrameCount: int): int {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount - gameFrameCount;
}

export function getElapsedRenderFramesSince(renderFrameCount: int): int {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount - renderFrameCount;
}

export function getElapsedRoomFramesSince(roomFrameCount: int): int {
  const room = game.GetRoom();
  const thisRoomFrameCount = room.GetFrameCount();
  return thisRoomFrameCount - roomFrameCount;
}

/**
 * Helper function to check if the current game frame count is higher than a specific game frame
 * count.
 */
export function isAfterGameFrame(gameFrameCount: int): boolean {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount > gameFrameCount;
}

/**
 * Helper function to check if the current render frame count is higher than a specific render frame
 * count.
 */
export function isAfterRenderFrame(renderFrameCount: int): boolean {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount > renderFrameCount;
}

/**
 * Helper function to check if the current room frame count is higher than a specific room frame
 * count.
 */
export function isAfterRoomFrame(roomFrameCount: int): boolean {
  const room = game.GetRoom();

  const thisGameFrameCount = room.GetFrameCount();
  return thisGameFrameCount > roomFrameCount;
}

/**
 * Helper function to check if the current game frame count is lower than a specific game frame
 * count.
 */
export function isBeforeGameFrame(gameFrameCount: int): boolean {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount < gameFrameCount;
}

/**
 * Helper function to check if the current render frame count is lower than a specific render frame
 * count.
 */
export function isBeforeRenderFrame(renderFrameCount: int): boolean {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount < renderFrameCount;
}

/**
 * Helper function to check if the current room frame count is lower than a specific room frame
 * count.
 */
export function isBeforeRoomFrame(roomFrameCount: int): boolean {
  const room = game.GetRoom();

  const thisGameFrameCount = room.GetFrameCount();
  return thisGameFrameCount < roomFrameCount;
}

/**
 * Helper function to check if the current game frame count is exactly equal to a specific game
 * frame count.
 *
 * This returns false if the submitted render frame count is null or undefined.
 */
export function onGameFrame(gameFrameCount: int | null | undefined): boolean {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount === gameFrameCount;
}

/**
 * Helper function to check if the current game frame count is equal to or higher than a specific
 * game frame count.
 */
export function onOrAfterGameFrame(gameFrameCount: int): boolean {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount >= gameFrameCount;
}

/**
 * Helper function to check if the current render frame count is equal to or higher than a specific
 * render frame count.
 */
export function onOrAfterRenderFrame(renderFrameCount: int): boolean {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount >= renderFrameCount;
}

/**
 * Helper function to check if the current room frame count is equal to or higher than a specific
 * room frame count.
 */
export function onOrAfterRoomFrame(roomFrameCount: int): boolean {
  const room = game.GetRoom();

  const thisGameFrameCount = room.GetFrameCount();
  return thisGameFrameCount >= roomFrameCount;
}

/**
 * Helper function to check if the current game frame count is equal to or lower than a specific
 * game frame count.
 */
export function onOrBeforeGameFrame(gameFrameCount: int): boolean {
  const thisGameFrameCount = game.GetFrameCount();
  return thisGameFrameCount <= gameFrameCount;
}

/**
 * Helper function to check if the current render frame count is equal to or lower than a specific
 * render frame count.
 */
export function onOrBeforeRenderFrame(renderFrameCount: int): boolean {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount <= renderFrameCount;
}

/**
 * Helper function to check if the current room frame count is equal to or lower than a specific
 * room frame count.
 */
export function onOrBeforeRoomFrame(roomFrameCount: int): boolean {
  const room = game.GetRoom();

  const thisGameFrameCount = room.GetFrameCount();
  return thisGameFrameCount <= roomFrameCount;
}

/**
 * Helper function to check if the current render frame count is exactly equal to a specific render
 * frame count.
 *
 * This returns false if the submitted render frame count is null or undefined.
 */
export function onRenderFrame(
  renderFrameCount: int | null | undefined,
): boolean {
  const thisRenderFrameCount = Isaac.GetFrameCount();
  return thisRenderFrameCount === renderFrameCount;
}

/**
 * Helper function to check if the current room frame count is exactly equal to a specific room
 * frame count.
 *
 * This returns false if the submitted room frame count is null or undefined.
 */
export function onRoomFrame(roomFrameCount: int | null | undefined): boolean {
  const room = game.GetRoom();

  const thisGameFrameCount = room.GetFrameCount();
  return thisGameFrameCount === roomFrameCount;
}

----
functions\globals.ts
import { ReadonlySet } from "../types/ReadonlySet";
import { getTraceback, isLuaDebugEnabled, traceback } from "./debugFunctions";
import * as logExports from "./log";
import { log } from "./log";
import * as logEntitiesExports from "./logEntities";
import * as logMiscExports from "./logMisc";
import { addSetsToSet, copySet } from "./set";
import { sortTwoDimensionalArray } from "./sort";

const DEFAULT_GLOBALS = new ReadonlySet<string>([
  "ActionTriggers",
  "ActiveSlot",
  "BabySubType",
  "BackdropType",
  "BatterySubType",
  "BedSubType",
  "BitSet128",
  "BombSubType",
  "BombVariant",
  "ButtonAction",
  "CacheFlag",
  "Card",
  "Challenge",
  "ChampionColor",
  "ChestSubType",
  "CoinSubType",
  "CollectibleType",
  "Color",
  "CppContainer",
  "DamageFlag",
  "Difficulty",
  "Direction",
  "DoorSlot",
  "DoorState",
  "DoorVariant",
  "EffectVariant",
  "Entity",
  "EntityBomb",
  "EntityCollisionClass",
  "EntityEffect",
  "EntityFamiliar",
  "EntityFlag",
  "EntityGridCollisionClass",
  "EntityKnife",
  "EntityLaser",
  "EntityNPC",
  "EntityPartition",
  "EntityPickup",
  "EntityPlayer",
  "EntityProjectile",
  "EntityPtr",
  "EntityRef",
  "EntityTear",
  "EntityType",
  "FamiliarVariant",
  "Font",
  "Game",
  "GameStateFlag",
  "GetPtrHash",
  "GridCollisionClass",
  "GridEntity",
  "GridEntityDesc",
  "GridEntityDoor",
  "GridEntityPit",
  "GridEntityPoop",
  "GridEntityPressurePlate",
  "GridEntityRock",
  "GridEntitySpikes",
  "GridEntityTNT",
  "GridEntityType",
  "GridRooms",
  "HUD",
  "HeartSubType",
  "Input",
  "InputHook",
  "Isaac",
  "ItemConfig",
  "ItemPool",
  "ItemPoolType",
  "ItemType",
  "KColor",
  "KeySubType",
  "Keyboard",
  "LaserOffset",
  "LaserSubType",
  "Level",
  "LevelCurse",
  "LevelStage",
  "LevelStateFlag",
  "LocustSubtypes",
  "ModCallbacks",
  "Mouse",
  "Music",
  "MusicManager",
  "NpcState",
  "NullItemID",
  "Options",
  "PathFinder",
  "PickupPrice",
  "PickupVariant",
  "PillColor",
  "PillEffect",
  "PlayerForm",
  "PlayerSpriteLayer",
  "PlayerType",
  "PlayerTypes",
  "PoopPickupSubType",
  "PoopSpellType",
  "ProjectileFlags",
  "ProjectileParams",
  "ProjectileVariant",
  "QueueItemData",
  "REPENTANCE",
  "RNG",
  "Random",
  "RandomVector",
  "RegisterMod",
  "RenderMode",
  "Room",
  "RoomConfig",
  "RoomDescriptor",
  "RoomShape",
  "RoomTransitionAnim",
  "RoomType",
  "SFXManager",
  "SackSubType",
  "SeedEffect",
  "Seeds",
  "SkinColor",
  "SortingLayer",
  "SoundEffect",
  "Sprite",
  "StageType",
  "StartDebug",
  "TearFlags",
  "TearParams",
  "TearVariant",
  "TemporaryEffect",
  "TemporaryEffects",
  "TrinketType",
  "UseFlag",
  "Vector",
  "WeaponType",
  "_G",
  "_VERSION",
  "assert",
  "collectgarbage",
  "coroutine",
  "error",
  "getmetatable",
  "include",
  "ipairs",
  "load",
  "math",
  "next",
  "pairs",
  "pcall",
  "print",
  "rawequal",
  "rawget",
  "rawlen",
  "rawset",
  "require",
  "select",
  "setmetatable",
  "string",
  "table",
  "tonumber",
  "tostring",
  "type",
  "utf8",
  "xpcall",
]);

const LUA_DEBUG_ADDED_GLOBALS = new ReadonlySet<string>([
  "debug",
  "dofile",
  "loadfile",
  "io",
  "os",
  "package",
]);

const RACING_PLUS_SANDBOX_ADDED_GLOBALS = new ReadonlySet<string>([
  "sandboxTraceback",
  "sandboxGetTraceback",
  "getParentFunctionDescription",
]);

/**
 * Helper function to get a set containing all of the global variable names that are contained
 * within the Isaac environment by default.
 *
 * Returns a slightly different set depending on whether the "--luadebug" flag is enabled.
 */
export function getDefaultGlobals(): ReadonlySet<string> {
  const defaultGlobals = copySet(DEFAULT_GLOBALS);

  if (isLuaDebugEnabled()) {
    addSetsToSet(defaultGlobals, LUA_DEBUG_ADDED_GLOBALS);
  }

  if (isRacingPlusSandboxEnabled()) {
    addSetsToSet(defaultGlobals, RACING_PLUS_SANDBOX_ADDED_GLOBALS);
  }

  return defaultGlobals;
}

function isRacingPlusSandboxEnabled() {
  return SandboxGetParentFunctionDescription !== undefined;
}

/**
 * Helper function to get an array of any added global variables in the Isaac Lua environment.
 * Returns a sorted array of key/value tuples.
 */
export function getNewGlobals(): ReadonlyArray<[AnyNotNil, unknown]> {
  const defaultGlobals = getDefaultGlobals();
  const newGlobals: Array<[AnyNotNil, unknown]> = [];
  for (const [key, value] of pairs(_G)) {
    if (!defaultGlobals.has(key)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const keyValueTuple: [AnyNotNil, unknown] = [key, value as any];
      newGlobals.push(keyValueTuple);
    }
  }

  newGlobals.sort(sortTwoDimensionalArray);

  return newGlobals;
}

/** Helper function to log any added global variables in the Isaac Lua environment. */
export function logNewGlobals(): void {
  const newGlobals = getNewGlobals();

  log("List of added global variables in the Isaac environment:");
  if (newGlobals.length === 0) {
    log("- n/a (no extra global variables found)");
  } else {
    for (const [i, tuple] of newGlobals.entries()) {
      const [key, value] = tuple;
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      log(`${i + 1}) ${key} - ${value}`);
    }
  }
}

/**
 * Converts every `isaacscript-common` function that begins with "log" to a global function.
 *
 * This is useful when printing out variables from the in-game debug console.
 */
export function setLogFunctionsGlobal(): void {
  const globals = _G as Record<string, unknown>;

  for (const exports of [logExports, logMiscExports, logEntitiesExports]) {
    // eslint-disable-next-line isaacscript/no-object-any
    for (const [logFuncName, logFunc] of Object.entries(exports)) {
      globals[logFuncName] = logFunc;
    }
  }
}

/**
 * Sets the `traceback` and `getTraceback` functions to be global functions.
 *
 * This is useful when editing Lua files when troubleshooting.
 */
export function setTracebackFunctionsGlobal(): void {
  const globals = _G as Record<string, unknown>;

  globals["getTraceback"] = getTraceback;
  globals["traceback"] = traceback;
}

----
functions\gridEntities.ts
import type { GridEntityXMLType } from "isaac-typescript-definitions";
import {
  BackdropType,
  EffectVariant,
  GridCollisionClass,
  GridEntityType,
  PoopGridEntityVariant,
  StatueVariant,
  TrapdoorVariant,
} from "isaac-typescript-definitions";
import { GRID_ENTITY_XML_TYPE_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { DISTANCE_OF_GRID_TILE, VectorOne } from "../core/constants";
import { GRID_ENTITY_TYPE_TO_BROKEN_STATE_MAP } from "../maps/gridEntityTypeToBrokenStateMap";
import { GRID_ENTITY_XML_MAP } from "../maps/gridEntityXMLMap";
import {
  DEFAULT_TOP_LEFT_WALL_GRID_INDEX,
  ROOM_SHAPE_TO_TOP_LEFT_WALL_GRID_INDEX_MAP,
} from "../maps/roomShapeToTopLeftWallGridIndexMap";
import { GRID_ENTITY_TYPE_TO_ANM2_NAME } from "../objects/gridEntityTypeToANM2Name";
import { POOP_GRID_ENTITY_XML_TYPES_SET } from "../sets/poopGridEntityXMLTypesSet";
import type { AnyGridEntity } from "../types/AnyGridEntity";
import type { GridEntityID } from "../types/GridEntityID";
import { ReadonlySet } from "../types/ReadonlySet";
import { removeEntities } from "./entities";
import { getEffects } from "./entitiesSpecific";
import { isCircleIntersectingRectangle } from "./math";
import { roomUpdateSafe } from "./rooms";
import { isInteger, parseIntSafe } from "./types";
import { assertDefined, eRange, iRange } from "./utils";
import { isVector, vectorEquals } from "./vector";

/**
 * For some specific grid entities, the variant defined in the XML is what is used by the actual
 * game (which is not the case for e.g. poops).
 */
const GRID_ENTITY_TYPES_THAT_KEEP_GRID_ENTITY_XML_VARIANT = new ReadonlySet([
  GridEntityType.SPIKES_ON_OFF, // 9
  GridEntityType.PRESSURE_PLATE, // 20
  GridEntityType.TELEPORTER, // 23
]);

const BREAKABLE_GRID_ENTITY_TYPES_BY_EXPLOSIONS =
  new ReadonlySet<GridEntityType>([
    GridEntityType.ROCK, // 2
    GridEntityType.ROCK_TINTED, // 4
    GridEntityType.ROCK_BOMB, // 5
    GridEntityType.ROCK_ALT, // 6
    GridEntityType.SPIDER_WEB, // 10
    GridEntityType.TNT, // 12
    // GridEntityType.FIREPLACE (13) does not count since it is turned into a non-grid entity upon
    // spawning.
    GridEntityType.POOP, // 14
    GridEntityType.ROCK_SUPER_SPECIAL, // 22
    GridEntityType.ROCK_SPIKED, // 25
    GridEntityType.ROCK_ALT_2, // 26
    GridEntityType.ROCK_GOLD, // 27
  ]);

const BREAKABLE_GRID_ENTITY_TYPES_VARIANTS_BY_EXPLOSIONS =
  new ReadonlySet<string>([`${GridEntityType.STATUE}.${StatueVariant.ANGEL}`]);

const GRID_ENTITY_XML_TYPES_SET = new ReadonlySet(GRID_ENTITY_XML_TYPE_VALUES);

/**
 * Helper function to convert the grid entity type found in a room XML file to the corresponding
 * grid entity type and variant normally used by the game. For example, `GridEntityXMLType.ROCK` is
 * 1000 (in a room XML file), but `GridEntityType.ROCK` is equal to 2 (in-game).
 */
export function convertXMLGridEntityType(
  gridEntityXMLType: GridEntityXMLType,
  gridEntityXMLVariant: int,
): [GridEntityType, int] | undefined {
  const gridEntityArray = GRID_ENTITY_XML_MAP.get(gridEntityXMLType);
  assertDefined(
    gridEntityArray,
    `Failed to find an entry in the grid entity map for XML entity type: ${gridEntityXMLType}`,
  );

  const gridEntityType = gridEntityArray[0];
  const variant = GRID_ENTITY_TYPES_THAT_KEEP_GRID_ENTITY_XML_VARIANT.has(
    gridEntityType,
  )
    ? gridEntityXMLVariant
    : gridEntityArray[1];

  return [gridEntityType, variant];
}

/**
 * Helper function to check if one or more of a specific kind of grid entity is present in the
 * current room.
 *
 * @param gridEntityType The grid entity type to match.
 * @param variant Optional. Default is -1, which matches every variant.
 */
export function doesGridEntityExist(
  gridEntityType: GridEntityType,
  variant = -1,
): boolean {
  const room = game.GetRoom();
  const gridIndexes = getAllGridIndexes();

  return gridIndexes.some((gridIndex) => {
    const gridEntity = room.GetGridEntity(gridIndex);
    if (gridEntity === undefined) {
      return false;
    }

    const thisGridEntityType = gridEntity.GetType();
    const thisVariant = gridEntity.GetVariant();
    return (
      gridEntityType === thisGridEntityType &&
      (variant === -1 || variant === thisVariant)
    );
  });
}

/**
 * Helper function to get every legal grid index for the current room.
 *
 * Under the hood, this uses the `Room.GetGridSize` method.
 */
export function getAllGridIndexes(): readonly int[] {
  const room = game.GetRoom();
  const gridSize = room.GetGridSize();

  return eRange(gridSize);
}

/**
 * Gets the entities that have a hitbox that overlaps with any part of the square that the grid
 * entity is on.
 *
 * This function is useful because the vanilla collision callbacks do not work with grid entities.
 * This is used by `POST_GRID_ENTITY_COLLISION` custom callback.
 *
 * Note that this function will not work properly in the `POST_NEW_ROOM` callback since entities do
 * not have collision yet in that callback.
 */
export function getCollidingEntitiesWithGridEntity(
  gridEntity: GridEntity,
): readonly Entity[] {
  const { topLeft, bottomRight } = getGridEntityCollisionPoints(gridEntity);

  const closeEntities = Isaac.FindInRadius(
    gridEntity.Position,
    DISTANCE_OF_GRID_TILE * 2,
  );

  return closeEntities.filter(
    (entity) =>
      entity.CollidesWithGrid() &&
      isCircleIntersectingRectangle(
        entity.Position,
        // We arbitrarily add 0.1 to account for entities that are already pushed back by the time
        // the `POST_UPDATE` callback fires.
        entity.Size + 0.1,
        topLeft,
        bottomRight,
      ),
  );
}

/** Helper function to get the grid entity type and variant from a `GridEntityID`. */
export function getConstituentsFromGridEntityID(
  gridEntityID: GridEntityID,
): [gridEntityType: GridEntityType, variant: int] {
  const parts = gridEntityID.split(".");
  if (parts.length !== 2) {
    error(
      `Failed to get the constituents from a grid entity ID: ${gridEntityID}`,
    );
  }

  const [gridEntityTypeString, variantString] = parts;

  assertDefined(
    gridEntityTypeString,
    `Failed to get the first constituent from a grid entity ID: ${gridEntityID}`,
  );

  assertDefined(
    variantString,
    `Failed to get the second constituent from a grid entity ID: ${gridEntityID}`,
  );

  const gridEntityType = parseIntSafe(gridEntityTypeString);
  assertDefined(
    gridEntityType,
    `Failed to convert the grid entity type to a number: ${gridEntityTypeString}`,
  );

  const variant = parseIntSafe(variantString);
  assertDefined(
    variant,
    `Failed to convert the grid entity variant to an integer: ${variantString}`,
  );

  return [gridEntityType, variant];
}

/**
 * Helper function to get every grid entity in the current room.
 *
 * Use this function with no arguments to get every grid entity, or specify a variadic amount of
 * arguments to match specific grid entity types.
 *
 * For example:
 *
 * ```ts
 * for (const gridEntity of getGridEntities()) {
 *   print(gridEntity.GetType())
 * }
 * ```
 *
 * For example:
 *
 * ```ts
 * const rocks = getGridEntities(
 *   GridEntityType.ROCK,
 *   GridEntityType.BLOCK,
 *   GridEntityType.ROCK_TINTED,
 * );
 * ```
 *
 * @allowEmptyVariadic
 */
export function getGridEntities(
  ...gridEntityTypes: readonly GridEntityType[]
): readonly GridEntity[] {
  const gridEntities = getAllGridEntities();

  if (gridEntityTypes.length === 0) {
    return gridEntities;
  }

  const gridEntityTypesSet = new ReadonlySet(gridEntityTypes);
  return gridEntities.filter((gridEntity) => {
    const gridEntityType = gridEntity.GetType();
    return gridEntityTypesSet.has(gridEntityType);
  });
}

/**
 * Helper function to get every grid entity in the current room except for certain specific types.
 *
 * This function is variadic, meaning that you can specify as many grid entity types as you want to
 * exclude.
 */
export function getGridEntitiesExcept(
  ...gridEntityTypes: readonly GridEntityType[]
): readonly GridEntity[] {
  const gridEntities = getAllGridEntities();

  if (gridEntityTypes.length === 0) {
    return gridEntities;
  }

  const gridEntityTypesSet = new ReadonlySet(gridEntityTypes);
  return gridEntities.filter((gridEntity) => {
    const gridEntityType = gridEntity.GetType();
    return !gridEntityTypesSet.has(gridEntityType);
  });
}

function getAllGridEntities(): readonly GridEntity[] {
  const room = game.GetRoom();

  const gridEntities: GridEntity[] = [];
  for (const gridIndex of getAllGridIndexes()) {
    const gridEntity = room.GetGridEntity(gridIndex);
    if (gridEntity !== undefined) {
      gridEntities.push(gridEntity);
    }
  }

  return gridEntities;
}

/** Helper function to get all grid entities in a given radius around a given point. */
export function getGridEntitiesInRadius(
  targetPosition: Vector,
  radius: number,
): readonly GridEntity[] {
  radius = Math.abs(radius);
  const topLeftOffset = VectorOne.mul(-radius);
  const mostTopLeftPosition = targetPosition.add(topLeftOffset);
  const room = game.GetRoom();

  const diameter = radius * 2;
  const iterations = Math.ceil(diameter / DISTANCE_OF_GRID_TILE);
  const separation = diameter / iterations;

  const gridEntities: GridEntity[] = [];
  const registeredGridIndexes = new Set<number>();
  for (const x of iRange(iterations)) {
    for (const y of iRange(iterations)) {
      const position = mostTopLeftPosition.add(
        Vector(x * separation, y * separation),
      );

      const gridIndex = room.GetGridIndex(position);
      const gridEntity = room.GetGridEntityFromPos(position);
      if (gridEntity === undefined || registeredGridIndexes.has(gridIndex)) {
        continue;
      }

      registeredGridIndexes.add(gridIndex);
      const { topLeft, bottomRight } = getGridEntityCollisionPoints(gridEntity);

      if (
        isCircleIntersectingRectangle(
          targetPosition,
          radius,
          topLeft,
          bottomRight,
        )
      ) {
        gridEntities.push(gridEntity);
      }
    }
  }

  return gridEntities;
}

/**
 * Helper function to get a map of every grid entity in the current room. The indexes of the map are
 * equal to the grid index. The values of the map are equal to the grid entities.
 *
 * Use this function with no arguments to get every grid entity, or specify a variadic amount of
 * arguments to match specific grid entity types.
 *
 * @allowEmptyVariadic
 */
export function getGridEntitiesMap(
  ...gridEntityTypes: readonly GridEntityType[]
): ReadonlyMap<int, GridEntity> {
  const gridEntities = getGridEntities(...gridEntityTypes);

  const gridEntityMap = new Map<int, GridEntity>();
  for (const gridEntity of gridEntities) {
    const gridIndex = gridEntity.GetGridIndex();
    gridEntityMap.set(gridIndex, gridEntity);
  }

  return gridEntityMap;
}

/** Helper function to get the ANM2 path for a grid entity type. */
export function getGridEntityANM2Path(
  gridEntityType: GridEntityType,
): string | undefined {
  const gridEntityANM2Name = getGridEntityANM2Name(gridEntityType);
  return `gfx/grid/${gridEntityANM2Name}`;
}

function getGridEntityANM2Name(
  gridEntityType: GridEntityType,
): string | undefined {
  switch (gridEntityType) {
    // 1
    case GridEntityType.DECORATION: {
      return getGridEntityANM2NameDecoration();
    }

    default: {
      return GRID_ENTITY_TYPE_TO_ANM2_NAME[gridEntityType];
    }
  }
}

/**
 * Helper function to get the ANM2 path for a decoration. This depends on the current room's
 * backdrop. The values are taken from the "backdrops.xml" file.
 */
function getGridEntityANM2NameDecoration(): string {
  const room = game.GetRoom();
  const backdropType = room.GetBackdropType();

  switch (backdropType) {
    // 1, 2, 3, 36, 49, 52
    case BackdropType.BASEMENT:
    case BackdropType.CELLAR:
    case BackdropType.BURNING_BASEMENT:
    case BackdropType.DOWNPOUR_ENTRANCE:
    case BackdropType.ISAACS_BEDROOM:
    case BackdropType.CLOSET: {
      return "Props_01_Basement.anm2";
    }

    // 4, 5, 6, 37
    case BackdropType.CAVES:
    case BackdropType.CATACOMBS:
    case BackdropType.FLOODED_CAVES:
    case BackdropType.MINES_ENTRANCE: {
      return "Props_03_Caves.anm2";
    }

    // 7, 8, 9, 30, 33, 38, 39, 40, 41, 42, 53, 60
    case BackdropType.DEPTHS:
    case BackdropType.NECROPOLIS:
    case BackdropType.DANK_DEPTHS:
    case BackdropType.SACRIFICE:
    case BackdropType.MAUSOLEUM:
    case BackdropType.MAUSOLEUM_ENTRANCE:
    case BackdropType.CORPSE_ENTRANCE:
    case BackdropType.MAUSOLEUM_2:
    case BackdropType.MAUSOLEUM_3:
    case BackdropType.MAUSOLEUM_4:
    case BackdropType.CLOSET_B:
    case BackdropType.DARK_CLOSET: {
      return "Props_05_Depths.anm2";
    }

    // 10, 12
    case BackdropType.WOMB:
    case BackdropType.SCARRED_WOMB: {
      return "Props_07_The Womb.anm2";
    }

    // 11
    case BackdropType.UTERO: {
      return "Props_07_Utero.anm2";
    }

    // 13, 27
    case BackdropType.BLUE_WOMB:
    case BackdropType.BLUE_WOMB_PASS: {
      return "Props_07_The Womb_blue.anm2";
    }

    // 14, 47
    case BackdropType.SHEOL:
    case BackdropType.GEHENNA: {
      return "Props_09_Sheol.anm2";
    }

    // 15
    case BackdropType.CATHEDRAL: {
      return "Props_10_Cathedral.anm2";
    }

    // 17
    case BackdropType.CHEST: {
      return "Props_11_The Chest.anm2";
    }

    // 28
    case BackdropType.GREED_SHOP: {
      return "Props_12_Greed.anm2";
    }

    // 31
    case BackdropType.DOWNPOUR: {
      return "props_01x_downpour.anm2";
    }

    // 32, 46, 58, 59
    case BackdropType.MINES:
    case BackdropType.ASHPIT:
    case BackdropType.MINES_SHAFT:
    case BackdropType.ASHPIT_SHAFT: {
      return "props_03x_mines.anm2";
    }

    // 34, 43, 44, 48
    case BackdropType.CORPSE:
    case BackdropType.CORPSE_2:
    case BackdropType.CORPSE_3:
    case BackdropType.MORTIS: {
      return "props_07_the corpse.anm2";
    }

    // 45
    case BackdropType.DROSS: {
      return "props_02x_dross.anm2";
    }

    default: {
      return "Props_01_Basement.anm2";
    }
  }
}

/** Helper function to get the top left and bottom right corners of a given grid entity. */
export function getGridEntityCollisionPoints(gridEntity: GridEntity): {
  topLeft: Vector;
  bottomRight: Vector;
} {
  const topLeft = Vector(
    gridEntity.Position.X - DISTANCE_OF_GRID_TILE / 2,
    gridEntity.Position.Y - DISTANCE_OF_GRID_TILE / 2,
  );
  const bottomRight = Vector(
    gridEntity.Position.X + DISTANCE_OF_GRID_TILE / 2,
    gridEntity.Position.Y + DISTANCE_OF_GRID_TILE / 2,
  );

  return { topLeft, bottomRight };
}

/** Helper function to get a string containing the grid entity's type and variant. */
export function getGridEntityID(gridEntity: GridEntity): GridEntityID {
  const gridEntityType = gridEntity.GetType();
  const variant = gridEntity.GetVariant();
  return `${gridEntityType}.${variant}` as GridEntityID;
}

/**
 * Helper function to get a formatted string in the format returned by the `getGridEntityID`
 * function.
 */
export function getGridEntityIDFromConstituents(
  gridEntityType: GridEntityType,
  variant: int,
): GridEntityID {
  return `${gridEntityType}.${variant}` as GridEntityID;
}

/**
 * Helper function to get all of the grid entities in the room that specifically match the type and
 * variant provided.
 *
 * If you want to match every variant, use the `getGridEntities` function instead.
 */
export function getMatchingGridEntities(
  gridEntityType: GridEntityType,
  variant: int,
): readonly GridEntity[] {
  const gridEntities = getGridEntities(gridEntityType);
  return gridEntities.filter(
    (gridEntity) => gridEntity.GetVariant() === variant,
  );
}

/**
 * Helper function to get the PNG path for a rock. This depends on the current room's backdrop. The
 * values are taken from the "backdrops.xml" file.
 *
 * All of the rock PNGs are in the "gfx/grid" directory.
 */
export function getRockPNGPath(): string {
  const rockPNGName = getRockPNGName();
  return `gfx/grid/${rockPNGName}`;
}

function getRockPNGName(): string {
  const room = game.GetRoom();
  const backdropType = room.GetBackdropType();

  switch (backdropType) {
    // 1, 17
    case BackdropType.BASEMENT:
    case BackdropType.CHEST: {
      return "rocks_basement.png";
    }

    // 2
    case BackdropType.CELLAR: {
      return "rocks_cellar.png";
    }

    // 3
    case BackdropType.BURNING_BASEMENT: {
      return "rocks_burningbasement.png"; // cspell:ignore burningbasement
    }

    // 4
    case BackdropType.CAVES: {
      return "rocks_caves.png";
    }

    // 5
    case BackdropType.CATACOMBS: {
      return "rocks_catacombs.png";
    }

    // 6
    case BackdropType.FLOODED_CAVES: {
      return "rocks_drownedcaves.png"; // cspell:ignore drownedcaves
    }

    // 7, 8, 9, 30, 60
    case BackdropType.DEPTHS:
    case BackdropType.NECROPOLIS:
    case BackdropType.DANK_DEPTHS:
    case BackdropType.SACRIFICE:
    case BackdropType.DARK_CLOSET: {
      return "rocks_depths.png";
    }

    // 10
    case BackdropType.WOMB: {
      return "rocks_womb.png";
    }

    // 11
    case BackdropType.UTERO: {
      return "rocks_utero.png";
    }

    // 12
    case BackdropType.SCARRED_WOMB: {
      return "rocks_scarredwomb.png"; // cspell:ignore scarredwomb
    }

    // 13, 27
    case BackdropType.BLUE_WOMB:
    case BackdropType.BLUE_WOMB_PASS: {
      return "rocks_bluewomb.png"; // cspell:ignore bluewomb
    }

    // 14, 16
    case BackdropType.SHEOL:
    case BackdropType.DARK_ROOM: {
      return "rocks_sheol.png";
    }

    // 15, 35
    case BackdropType.CATHEDRAL:
    case BackdropType.PLANETARIUM: {
      return "rocks_cathedral.png";
    }

    // 23, 32, 37, 58
    case BackdropType.SECRET:
    case BackdropType.MINES:
    case BackdropType.MINES_ENTRANCE:
    case BackdropType.MINES_SHAFT: {
      return "rocks_secretroom.png"; // cspell:ignore secretroom
    }

    // 31, 36
    case BackdropType.DOWNPOUR:
    case BackdropType.DOWNPOUR_ENTRANCE: {
      return "rocks_downpour.png";
    }

    // 33, 38, 40, 41, 42
    case BackdropType.MAUSOLEUM:
    case BackdropType.MAUSOLEUM_ENTRANCE:
    case BackdropType.MAUSOLEUM_2:
    case BackdropType.MAUSOLEUM_3:
    case BackdropType.MAUSOLEUM_4: {
      return "rocks_mausoleum.png";
    }

    // 34, 48
    case BackdropType.CORPSE:
    case BackdropType.MORTIS: {
      return "rocks_corpse.png";
    }

    // 39
    case BackdropType.CORPSE_ENTRANCE: {
      return "rocks_corpseentrance.png"; // cspell:ignore corpseentrance
    }

    // 43
    case BackdropType.CORPSE_2: {
      return "rocks_corpse2.png";
    }

    // 44
    case BackdropType.CORPSE_3: {
      return "rocks_corpse3.png";
    }

    // 45
    case BackdropType.DROSS: {
      return "rocks_dross.png";
    }

    // 46, 59
    case BackdropType.ASHPIT:
    case BackdropType.ASHPIT_SHAFT: {
      return "rocks_ashpit.png";
    }

    // 47
    case BackdropType.GEHENNA: {
      return "rocks_gehenna.png";
    }

    default: {
      return "rocks_basement.png";
    }
  }
}

/**
 * Helper function to get the grid entities on the surrounding tiles from the provided grid entity.
 *
 * For example, if a rock was surrounded by rocks on all sides, this would return an array of 8
 * rocks (e.g. top-left + top + top-right + left + right + bottom-left + bottom + right).
 */
export function getSurroundingGridEntities(
  gridEntity: GridEntity,
): readonly GridEntity[] {
  const room = game.GetRoom();
  const gridIndex = gridEntity.GetGridIndex();

  const surroundingGridIndexes = getSurroundingGridIndexes(gridIndex);

  const surroundingGridEntities: GridEntity[] = [];
  for (const surroundingGridIndex of surroundingGridIndexes) {
    const surroundingGridEntity = room.GetGridEntity(surroundingGridIndex);
    if (surroundingGridEntity !== undefined) {
      surroundingGridEntities.push(surroundingGridEntity);
    }
  }

  return surroundingGridEntities;
}

/**
 * Helper function to get the grid indexes on the surrounding tiles from the provided grid index.
 *
 * There are always 8 grid indexes returned (e.g. top-left + top + top-right + left + right +
 * bottom-left + bottom + right), even if the computed values would be negative or otherwise
 * invalid.
 */
export function getSurroundingGridIndexes(
  gridIndex: int,
): [
  topLeft: int,
  top: int,
  topRight: int,
  left: int,
  right: int,
  bottomLeft: int,
  bottom: int,
  bottomRight: int,
] {
  const room = game.GetRoom();
  const gridWidth = room.GetGridWidth();

  return [
    gridIndex - gridWidth - 1, // Top-left
    gridIndex - gridWidth, // Top
    gridIndex - gridWidth + 1, // Top-right

    gridIndex - 1, // Left
    gridIndex + 1, // Right

    gridIndex + gridWidth - 1, // Bottom-left
    gridIndex + gridWidth, // Bottom
    gridIndex + gridWidth + 1, // Bottom-right
  ];
}

/**
 * Helper function to get the top left wall in the current room.
 *
 * This function can be useful in certain situations to determine if the room is currently loaded.
 */
export function getTopLeftWall(): GridEntity | undefined {
  const room = game.GetRoom();
  const topLeftWallGridIndex = getTopLeftWallGridIndex();
  return room.GetGridEntity(topLeftWallGridIndex);
}

/**
 * Helper function to get the grid index of the top left wall. (This will depend on what the current
 * room shape is.)
 *
 * This function can be useful in certain situations to determine if the room is currently loaded.
 */
export function getTopLeftWallGridIndex(): int {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();

  const topLeftWallGridIndex =
    ROOM_SHAPE_TO_TOP_LEFT_WALL_GRID_INDEX_MAP.get(roomShape);
  return topLeftWallGridIndex ?? DEFAULT_TOP_LEFT_WALL_GRID_INDEX;
}

/**
 * Helper function to detect if a particular grid entity would "break" if it was touched by an
 * explosion.
 *
 * For example, rocks and pots are breakable by explosions, but blocks are not.
 */
export function isGridEntityBreakableByExplosion(
  gridEntity: GridEntity,
): boolean {
  const gridEntityType = gridEntity.GetType();
  const variant = gridEntity.GetVariant();
  const gridEntityTypeVariant = `${gridEntityType}.${variant}`;

  return (
    BREAKABLE_GRID_ENTITY_TYPES_BY_EXPLOSIONS.has(gridEntityType) ||
    BREAKABLE_GRID_ENTITY_TYPES_VARIANTS_BY_EXPLOSIONS.has(
      gridEntityTypeVariant,
    )
  );
}

/**
 * Helper function to see if the provided grid entity is in its respective broken state. See the
 * `GRID_ENTITY_TYPE_TO_BROKEN_STATE_MAP` constant for more details.
 *
 * Note that in the case of `GridEntityType.LOCK` (11), the state will turn to being broken before
 * the actual collision for the entity is removed.
 */
export function isGridEntityBroken(gridEntity: GridEntity): boolean {
  const gridEntityType = gridEntity.GetType();
  const brokenState = GRID_ENTITY_TYPE_TO_BROKEN_STATE_MAP.get(gridEntityType);
  return gridEntity.State === brokenState;
}

/**
 * Helper function to see if an arbitrary number is a valid `GridEntityXMLType`. This is useful in
 * the `PRE_ROOM_ENTITY_SPAWN` callback for narrowing the type of the first argument.
 */
export function isGridEntityXMLType(num: number): num is GridEntityXMLType {
  return GRID_ENTITY_XML_TYPES_SET.has(num); // eslint-disable-line isaacscript/strict-enums
}

/**
 * Helper function to check if the provided grid index has a door on it or if the surrounding 8 grid
 * indexes have a door on it.
 */
export function isGridIndexAdjacentToDoor(gridIndex: int): boolean {
  const room = game.GetRoom();
  const surroundingGridIndexes = getSurroundingGridIndexes(gridIndex);
  const gridIndexes = [gridIndex, ...surroundingGridIndexes];

  for (const gridIndexToInspect of gridIndexes) {
    const gridEntity = room.GetGridEntity(gridIndexToInspect);
    if (gridEntity !== undefined) {
      const door = gridEntity.ToDoor();
      if (door !== undefined) {
        return true;
      }
    }
  }

  return false;
}

/** Helper function to see if a `GridEntityXMLType` is some kind of poop. */
export function isPoopGridEntityXMLType(
  gridEntityXMLType: GridEntityXMLType,
): boolean {
  return POOP_GRID_ENTITY_XML_TYPES_SET.has(gridEntityXMLType);
}

/**
 * Helper function to detect whether a given Void Portal is one that randomly spawns after a boss is
 * defeated or is one that naturally spawns in the room after Hush.
 *
 * Under the hood, this is determined by looking at the `VarData` of the entity:
 * - The `VarData` of Void Portals that are spawned after bosses will be equal to 1.
 * - The `VarData` of the Void Portal in the room after Hush is equal to 0.
 */
export function isPostBossVoidPortal(gridEntity: GridEntity): boolean {
  const saveState = gridEntity.GetSaveState();

  return (
    saveState.Type === GridEntityType.TRAPDOOR &&
    saveState.Variant === TrapdoorVariant.VOID_PORTAL &&
    saveState.VarData === 1
  );
}

/**
 * Helper function to all grid entities in the room except for ones matching the grid entity types
 * provided.
 *
 * Note that this function will automatically update the room. (This means that you can spawn new
 * grid entities on the same tile on the same frame, if needed.)
 *
 * For example:
 *
 * ```ts
 * removeAllGridEntitiesExcept(
 *   GridEntityType.WALL,
 *   GridEntityType.DOOR,
 * );
 * ```
 *
 * @returns The grid entities that were removed.
 */
export function removeAllGridEntitiesExcept(
  ...gridEntityTypes: readonly GridEntityType[]
): readonly GridEntity[] {
  const gridEntityTypeExceptions = new ReadonlySet(gridEntityTypes);
  const gridEntities = getGridEntities();
  const removedGridEntities: GridEntity[] = [];
  for (const gridEntity of gridEntities) {
    const gridEntityType = gridEntity.GetType();
    if (!gridEntityTypeExceptions.has(gridEntityType)) {
      removeGridEntity(gridEntity, false);
      removedGridEntities.push(gridEntity);
    }
  }

  if (removedGridEntities.length > 0) {
    roomUpdateSafe();
  }

  return removedGridEntities;
}

/**
 * Helper function to remove all of the grid entities in the room that match the grid entity types
 * provided.
 *
 * Note that this function will automatically update the room. (This means that you can spawn new
 * grid entities on the same tile on the same frame, if needed.)
 *
 * For example:
 *
 * ```ts
 * removeAllMatchingGridEntities(
 *   GridEntityType.ROCK,
 *   GridEntityType.BLOCK,
 *   GridEntityType.ROCK_TINTED,
 * );
 * ```
 *
 * @returns An array of the grid entities removed.
 */
export function removeAllMatchingGridEntities(
  ...gridEntityType: readonly GridEntityType[]
): readonly GridEntity[] {
  const gridEntities = getGridEntities(...gridEntityType);
  if (gridEntities.length === 0) {
    return [];
  }

  for (const gridEntity of gridEntities) {
    removeGridEntity(gridEntity, false);
  }

  roomUpdateSafe();
  return gridEntities;
}

/**
 * Helper function to remove all entities that just spawned from a grid entity breaking.
 * Specifically, this is any entities that overlap with the position of a grid entity and are on
 * frame 0.
 *
 * You must specify an array of entities to look through.
 */
export function removeEntitiesSpawnedFromGridEntity(
  entities: readonly Entity[],
  gridEntity: GridEntity,
): void {
  const entitiesFromGridEntity = entities.filter(
    (entity) =>
      entity.FrameCount === 0 &&
      vectorEquals(entity.Position, gridEntity.Position),
  );
  removeEntities(entitiesFromGridEntity);
}

/**
 * Helper function to remove all of the grid entities in the supplied array.
 *
 * @param gridEntities The array of grid entities to remove.
 * @param updateRoom Whether to update the room after the grid entities are removed. This is
 *                   generally a good idea because if the room is not updated, you will be unable to
 *                   spawn another grid entity on the same tile until a frame has passed. However,
 *                   doing this is expensive, since it involves a call to `Isaac.GetRoomEntities`,
 *                   so set this to false if you need to run this function multiple times.
 * @param cap Optional. If specified, will only remove the given amount of entities.
 * @returns An array of the entities that were removed.
 */
export function removeGridEntities<T extends AnyGridEntity>(
  gridEntities: readonly T[],
  updateRoom: boolean,
  cap?: int,
): readonly T[] {
  if (gridEntities.length === 0) {
    return [];
  }

  const gridEntitiesRemoved: T[] = [];
  for (const gridEntity of gridEntities) {
    removeGridEntity(gridEntity, false);

    gridEntitiesRemoved.push(gridEntity);
    if (cap !== undefined && gridEntitiesRemoved.length >= cap) {
      break;
    }
  }

  if (updateRoom) {
    roomUpdateSafe();
  }

  return gridEntitiesRemoved;
}

/**
 * Helper function to remove a grid entity by providing the grid entity object or the grid index
 * inside of the room.
 *
 * If removing a Devil Statue or an Angel Statue, this will also remove the associated effect
 * (`EffectVariant.DEVIL` (6) or `EffectVariant.ANGEL` (9), respectively.)
 *
 * @param gridEntityOrGridIndex The grid entity or grid index to remove.
 * @param updateRoom Whether to update the room after the grid entity is removed. This is generally
 *                   a good idea because if the room is not updated, you will be unable to spawn
 *                   another grid entity on the same tile until a frame has passed. However, doing
 *                   this is expensive, since it involves a call to `Isaac.GetRoomEntities`, so set
 *                   this to false if you need to run this function multiple times.
 */
export function removeGridEntity(
  gridEntityOrGridIndex: GridEntity | int,
  updateRoom: boolean,
): void {
  const room = game.GetRoom();

  const gridEntity = isInteger(gridEntityOrGridIndex)
    ? room.GetGridEntity(gridEntityOrGridIndex)
    : gridEntityOrGridIndex;
  if (gridEntity === undefined) {
    // There is no grid entity to remove.
    return;
  }

  const gridEntityType = gridEntity.GetType();
  const variant = gridEntity.GetVariant();
  const position = gridEntity.Position;

  const gridIndex = isInteger(gridEntityOrGridIndex)
    ? gridEntityOrGridIndex
    : gridEntityOrGridIndex.GetGridIndex();
  room.RemoveGridEntity(gridIndex, 0, false);

  if (updateRoom) {
    roomUpdateSafe();
  }

  // In the special case of removing a Devil Statue or Angel Statue, we also need to delete the
  // corresponding effect.
  if (gridEntityType === GridEntityType.STATUE) {
    const effectVariant =
      variant === StatueVariant.DEVIL
        ? EffectVariant.DEVIL
        : EffectVariant.ANGEL;
    const effects = getEffects(effectVariant);
    const effectsOnTile = effects.filter((effect) =>
      vectorEquals(effect.Position, position),
    );
    removeEntities(effectsOnTile);
  }
}

/**
 * Helper function to make a grid entity invisible. This is accomplished by resetting the sprite.
 *
 * Note that this function is destructive such that once you make a grid entity invisible, it can no
 * longer become visible. (This is because the information about the sprite is lost when it is
 * reset.)
 */
export function setGridEntityInvisible(gridEntity: GridEntity): void {
  const sprite = gridEntity.GetSprite();
  sprite.Reset();
}

/**
 * Helper function to change the type of a grid entity to another type. Use this instead of the
 * `GridEntity.SetType` method since that does not properly handle updating the sprite of the grid
 * entity after the type is changed.
 *
 * Setting the new type to `GridEntityType.NULL` (0) will have no effect.
 */
export function setGridEntityType(
  gridEntity: GridEntity,
  gridEntityType: GridEntityType,
): void {
  gridEntity.SetType(gridEntityType);

  const sprite = gridEntity.GetSprite();
  const anm2Path = getGridEntityANM2Path(gridEntityType);
  if (anm2Path === undefined) {
    return;
  }

  sprite.Load(anm2Path, false);

  if (gridEntityType === GridEntityType.ROCK) {
    const pngPath = getRockPNGPath();
    sprite.ReplaceSpritesheet(0, pngPath);
  }

  sprite.LoadGraphics();
  const defaultAnimation = sprite.GetDefaultAnimation();
  sprite.Play(defaultAnimation, true);
}

/**
 * Helper function to spawn a giant poop. This is performed by spawning each of the four quadrant
 * grid entities in the appropriate positions.
 *
 * @returns Whether spawning the four quadrants was successful.
 */
export function spawnGiantPoop(topLeftGridIndex: int): boolean {
  const room = game.GetRoom();
  const gridWidth = room.GetGridWidth();

  const topRightGridIndex = topLeftGridIndex + 1;
  const bottomLeftGridIndex = topLeftGridIndex + gridWidth;
  const bottomRightGridIndex = bottomLeftGridIndex + 1;

  // First, check to see if all of the tiles are open.
  for (const gridIndex of [
    topLeftGridIndex,
    topRightGridIndex,
    bottomLeftGridIndex,
    bottomRightGridIndex,
  ]) {
    const gridEntity = room.GetGridEntity(gridIndex);
    if (gridEntity !== undefined) {
      return false;
    }
  }

  const topLeft = spawnGridEntityWithVariant(
    GridEntityType.POOP,
    PoopGridEntityVariant.GIANT_TOP_LEFT,
    topLeftGridIndex,
  );
  const topRight = spawnGridEntityWithVariant(
    GridEntityType.POOP,
    PoopGridEntityVariant.GIANT_TOP_RIGHT,
    topRightGridIndex,
  );
  const bottomLeft = spawnGridEntityWithVariant(
    GridEntityType.POOP,
    PoopGridEntityVariant.GIANT_BOTTOM_LEFT,
    bottomLeftGridIndex,
  );
  const bottomRight = spawnGridEntityWithVariant(
    GridEntityType.POOP,
    PoopGridEntityVariant.GIANT_BOTTOM_RIGHT,
    bottomRightGridIndex,
  );

  return (
    topLeft !== undefined &&
    topLeft.GetType() === GridEntityType.POOP &&
    topLeft.GetVariant() === PoopGridEntityVariant.GIANT_TOP_LEFT &&
    topRight !== undefined &&
    topRight.GetType() === GridEntityType.POOP &&
    topRight.GetVariant() === PoopGridEntityVariant.GIANT_TOP_RIGHT &&
    bottomLeft !== undefined &&
    bottomLeft.GetType() === GridEntityType.POOP &&
    bottomLeft.GetVariant() === PoopGridEntityVariant.GIANT_BOTTOM_LEFT &&
    bottomRight !== undefined &&
    bottomRight.GetType() === GridEntityType.POOP &&
    bottomRight.GetVariant() === PoopGridEntityVariant.GIANT_BOTTOM_RIGHT
  );
}

/**
 * Helper function to spawn a grid entity with a specific type.
 *
 * This function assumes you want to give the grid entity a variant of 0. If you want to specify a
 * variant, use the `spawnGridEntityWithVariant` helper function instead.
 *
 * Use this instead of the `Isaac.GridSpawn` method since it:
 * - handles giving pits collision
 * - removes existing grid entities on the same tile, if any
 * - allows you to specify either the grid index or the position
 *
 * @param gridEntityType The `GridEntityType` to use.
 * @param gridIndexOrPosition The grid index or position in the room that you want to spawn the grid
 *                            entity at. If a position is specified, the closest grid index will be
 *                            used.
 * @param removeExistingGridEntity Optional. Whether to remove the existing grid entity on the same
 *                                 tile, if it exists. Defaults to true. If false, this function
 *                                 will do nothing, since spawning a grid entity on top of another
 *                                 grid entity will not replace it.
 */
export function spawnGridEntity(
  gridEntityType: GridEntityType,
  gridIndexOrPosition: int | Vector,
  removeExistingGridEntity = true,
): GridEntity | undefined {
  return spawnGridEntityWithVariant(
    gridEntityType,
    0,
    gridIndexOrPosition,
    removeExistingGridEntity,
  );
}

/**
 * Helper function to spawn a grid entity with a specific variant.
 *
 * Use this instead of the `Isaac.GridSpawn` method since it:
 * - handles giving pits collision
 * - removes existing grid entities on the same tile, if any
 * - allows you to specify the grid index or the position
 *
 * @param gridEntityType The `GridEntityType` to use.
 * @param variant The variant to use.
 * @param gridIndexOrPosition The grid index or position in the room that you want to spawn the grid
 *                            entity at. If a position is specified, the closest grid index will be
 *                            used.
 * @param removeExistingGridEntity Optional. Whether to remove the existing grid entity on the same
 *                                 tile, if it exists. Defaults to true. If false, this function
 *                                 will do nothing, since spawning a grid entity on top of another
 *                                 grid entity will not replace it.
 */
export function spawnGridEntityWithVariant(
  gridEntityType: GridEntityType,
  variant: int,
  gridIndexOrPosition: int | Vector,
  removeExistingGridEntity = true,
): GridEntity | undefined {
  const room = game.GetRoom();

  const existingGridEntity = isVector(gridIndexOrPosition)
    ? room.GetGridEntityFromPos(gridIndexOrPosition)
    : room.GetGridEntity(gridIndexOrPosition);
  if (existingGridEntity !== undefined) {
    if (removeExistingGridEntity) {
      removeGridEntity(existingGridEntity, true);
    } else {
      return undefined;
    }
  }

  const position = isVector(gridIndexOrPosition)
    ? gridIndexOrPosition
    : room.GetGridPosition(gridIndexOrPosition);
  const gridEntity = Isaac.GridSpawn(gridEntityType, variant, position);
  if (gridEntity === undefined) {
    return gridEntity;
  }

  if (gridEntityType === GridEntityType.PIT) {
    // For some reason, spawned pits start with a collision class of `NONE`, so we have to manually
    // set it.
    const pit = gridEntity.ToPit();
    if (pit !== undefined) {
      pit.UpdateCollision();
    }
  } else if (gridEntityType === GridEntityType.WALL) {
    // For some reason, spawned walls start with a collision class of `NONE`, so we have to manually
    // set it.
    gridEntity.CollisionClass = GridCollisionClass.WALL;
  }

  return gridEntity;
}

/**
 * Helper function to spawn a Void Portal. This is more complicated than simply spawning a trapdoor
 * with the appropriate variant, as the game does not give it the correct sprite automatically.
 */
export function spawnVoidPortal(gridIndex: int): GridEntity | undefined {
  const voidPortal = spawnGridEntityWithVariant(
    GridEntityType.TRAPDOOR,
    TrapdoorVariant.VOID_PORTAL,
    gridIndex,
  );
  if (voidPortal === undefined) {
    return voidPortal;
  }

  // If Void Portals are not given a VarData of 1, they will send the player to the next floor
  // instead of The Void.
  voidPortal.VarData = 1;

  const sprite = voidPortal.GetSprite();
  sprite.Load("gfx/grid/voidtrapdoor.anm2", true);

  return voidPortal;
}

----
functions\gridEntitiesSpecific.ts
import type { TrapdoorVariant } from "isaac-typescript-definitions";
import {
  CrawlSpaceVariant,
  DoorVariant,
  GridEntityType,
  PitVariant,
  PoopGridEntityVariant,
  PressurePlateVariant,
  RockVariant,
} from "isaac-typescript-definitions";
import {
  getGridEntities,
  getMatchingGridEntities,
  removeGridEntities,
  spawnGridEntityWithVariant,
} from "./gridEntities";
import { assertDefined } from "./utils";

/**
 * Helper function to get all of the grid entities of type `GridEntityType.CRAWL_SPACE` (18) in the
 * room.
 *
 * @param crawlSpaceVariant Optional. If specified, will only get the crawl spaces that match the
 *                          variant. Default is -1, which matches every variant.
 */
export function getCrawlSpaces(
  crawlSpaceVariant: CrawlSpaceVariant | -1 = -1,
): readonly GridEntity[] {
  if (crawlSpaceVariant === -1) {
    return getGridEntities(GridEntityType.CRAWL_SPACE);
  }

  return getMatchingGridEntities(GridEntityType.CRAWL_SPACE, crawlSpaceVariant);
}

// The `getDoors` function is not located here because doors are collected via the `Room.GetDoor`
// method instead, which is faster.

/**
 * Helper function to get all of the `GridEntityPit` in the room.
 *
 * @param pitVariant Optional. If specified, will only get the pits that match the variant. Default
 *                   is -1, which matches every variant.
 */
export function getPits(
  pitVariant: PitVariant | -1 = -1,
): readonly GridEntityPit[] {
  const pits: GridEntityPit[] = [];
  for (const gridEntity of getGridEntities()) {
    const pit = gridEntity.ToPit();
    if (pit !== undefined) {
      const thisPitVariant = pit.GetVariant();
      if (pitVariant === -1 || pitVariant === thisPitVariant) {
        pits.push(pit);
      }
    }
  }

  return pits;
}

/**
 * Helper function to get all of the `GridEntityPoop` in the room.
 *
 * @param poopVariant Optional. If specified, will only get the poops that match the variant.
 *                    Default is -1, which matches every variant.
 */
export function getPoops(
  poopVariant: PoopGridEntityVariant | -1 = -1,
): readonly GridEntityPoop[] {
  const poops: GridEntityPoop[] = [];
  for (const gridEntity of getGridEntities()) {
    const poop = gridEntity.ToPoop();
    if (poop !== undefined) {
      const thisPoopVariant = poop.GetVariant();
      if (poopVariant === -1 || poopVariant === thisPoopVariant) {
        poops.push(poop);
      }
    }
  }

  return poops;
}

/**
 * Helper function to get all of the `GridEntityPressurePlate` in the room.
 *
 * @param pressurePlateVariant Optional. If specified, will only get the pressure plates that match
 *                             the variant. Default is -1, which matches every variant.
 */
export function getPressurePlates(
  pressurePlateVariant: PressurePlateVariant | -1 = -1,
): readonly GridEntityPressurePlate[] {
  const pressurePlates: GridEntityPressurePlate[] = [];
  for (const gridEntity of getGridEntities()) {
    const pressurePlate = gridEntity.ToPressurePlate();
    if (pressurePlate !== undefined) {
      const thisPressurePlateVariant = pressurePlate.GetVariant();
      if (
        pressurePlateVariant === -1 ||
        pressurePlateVariant === thisPressurePlateVariant
      ) {
        pressurePlates.push(pressurePlate);
      }
    }
  }

  return pressurePlates;
}

/**
 * Helper function to get all of the `GridEntityRock` in the room.
 *
 * @param variant Optional. If specified, will only get the rocks that match the variant. Default is
 *                -1, which matches every variant. Note that this is not the same thing as the
 *                `RockVariant` enum, since that only applies to `GridEntityType.ROCK`, and other
 *                types of grid entities can be the `GridEntityRock` class.
 */
export function getRocks(variant = -1): readonly GridEntityRock[] {
  const rocks: GridEntityRock[] = [];
  for (const gridEntity of getGridEntities()) {
    const rock = gridEntity.ToRock();
    if (rock !== undefined) {
      const thisVariant = rock.GetVariant();
      if (variant === -1 || variant === thisVariant) {
        rocks.push(rock);
      }
    }
  }

  return rocks;
}

/** Helper function to get all of the `GridEntitySpikes` in the room. */
export function getSpikes(variant = -1): readonly GridEntitySpikes[] {
  const spikes: GridEntitySpikes[] = [];
  for (const gridEntity of getGridEntities()) {
    const spike = gridEntity.ToSpikes();
    if (spike !== undefined) {
      const thisVariant = spike.GetVariant();
      if (variant === -1 || variant === thisVariant) {
        spikes.push(spike);
      }
    }
  }

  return spikes;
}

/** Helper function to get all of the `GridEntityTNT` in the room. */
export function getTNT(variant = -1): readonly GridEntityTNT[] {
  const tntArray: GridEntityTNT[] = [];
  for (const gridEntity of getGridEntities()) {
    const tnt = gridEntity.ToTNT();
    if (tnt !== undefined) {
      const thisVariant = tnt.GetVariant();
      if (variant === -1 || variant === thisVariant) {
        tntArray.push(tnt);
      }
    }
  }

  return tntArray;
}

/**
 * Helper function to get all of the grid entities of type `GridEntityType.TELEPORTER` (23) in the
 * room.
 *
 * @param variant Optional. If specified, will only get the teleporters that match the variant.
 *                Default is -1, which matches every variant.
 */
export function getTeleporters(variant = -1): readonly GridEntity[] {
  if (variant === -1) {
    return getGridEntities(GridEntityType.TELEPORTER);
  }

  return getMatchingGridEntities(GridEntityType.TELEPORTER, variant);
}

/**
 * Helper function to get all of the grid entities of type `GridEntityType.TRAPDOOR` (17) in the
 * room. Specify a specific trapdoor variant to select only trapdoors of that variant.
 *
 * @param trapdoorVariant Optional. If specified, will only get the trapdoors that match the
 *                        variant. Default is -1, which matches every variant.
 */
export function getTrapdoors(
  trapdoorVariant: TrapdoorVariant | -1 = -1,
): readonly GridEntity[] {
  if (trapdoorVariant === -1) {
    return getGridEntities(GridEntityType.TRAPDOOR);
  }

  return getMatchingGridEntities(GridEntityType.TRAPDOOR, trapdoorVariant);
}

/**
 * Helper function to remove all of the `GridEntityType.CRAWL_SPACE` (18) in the room.
 *
 * @param crawlSpaceVariant Optional. If specified, will only remove the crawl spaces that match
 *                          this variant. Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the crawl spaces are removed.
 *                   Default is false. For more information, see the description of the
 *                   `removeGridEntities` helper function.
 * @param cap Optional. If specified, will only remove the given amount of crawl spaces.
 * @returns The crawl spaces that were removed.
 */
export function removeAllCrawlSpaces(
  crawlSpaceVariant: CrawlSpaceVariant | -1 = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntity[] {
  const crawlSpaces = getCrawlSpaces(crawlSpaceVariant);
  return removeGridEntities(crawlSpaces, updateRoom, cap);
}

// The `removeAllDoors` function is not located here because doors are removed via the
// `Room.RemoveDoor` method instead.

/**
 * Helper function to remove all of the `GridEntityPit` in the room.
 *
 * @param pitVariant Optional. If specified, will only remove the pits that match this variant.
 *                   Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the pits are removed. Default is
 *                   false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of pits.
 * @returns The pits that were removed.
 */
export function removeAllPits(
  pitVariant: PitVariant | -1 = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntityPit[] {
  const pits = getPits(pitVariant);
  return removeGridEntities(pits, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityPoop` in the room.
 *
 * Note that poops can either be an entity or a grid entity, depending on the situation. This
 * function will only remove the grid entity poops.
 *
 * @param poopVariant Optional. If specified, will only remove the poops that match this variant.
 *                    Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the poops are removed. Default is
 *                   false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of poops.
 * @returns The poops that were removed.
 */
export function removeAllPoops(
  poopVariant: PoopGridEntityVariant | -1 = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntityPoop[] {
  const poops = getPoops(poopVariant);
  return removeGridEntities(poops, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityPressurePlate` in the room.
 *
 * @param pressurePlateVariant Optional. If specified, will only remove the pressure plates that
 *                             match this variant. Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the pressure plates are removed.
 *                   Default is false. For more information, see the description of the
 *                   `removeGridEntities` helper function.
 * @param cap Optional. If specified, will only remove the given amount of pressure plates.
 * @returns The pressure plates that were removed.
 */
export function removeAllPressurePlates(
  pressurePlateVariant: PressurePlateVariant | -1 = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntityPressurePlate[] {
  const pressurePlates = getPressurePlates(pressurePlateVariant);
  return removeGridEntities(pressurePlates, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityRock` in the room.
 *
 * @param variant Optional. If specified, will only remove the rocks that match this variant.
 *                Default is -1, which matches every variant. Note that this is not the same thing
 *                as the `RockVariant` enum, since that only applies to `GridEntityType.ROCK`, and
 *                other types of grid entities can be the `GridEntityRock` class.
 * @param updateRoom Optional. Whether to update the room after the rocks are removed. Default is
 *                   false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of rocks.
 * @returns The rocks that were removed.
 */
export function removeAllRocks(
  variant = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntityRock[] {
  const rocks = getRocks(variant);
  return removeGridEntities(rocks, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntitySpikes` in the room.
 *
 * @param variant Optional. If specified, will only remove the spikes that match this variant.
 *                Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the spikes are removed. Default is
 *                   false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of spikes.
 * @returns The spikes that were removed.
 */
export function removeAllSpikes(
  variant = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntitySpikes[] {
  const spikes = getSpikes(variant);
  return removeGridEntities(spikes, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityTNT` in the room.
 *
 * @param variant Optional. If specified, will only remove the TNTs that match this variant. Default
 *                is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the TNTs are removed. Default is
 *                   false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of TNTs.
 * @returns The TNTs that were removed.
 */
export function removeAllTNT(
  variant = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntityTNT[] {
  const tnt = getTNT(variant);
  return removeGridEntities(tnt, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityType.TELEPORTER` (23) in the room.
 *
 * @param variant Optional. If specified, will only remove the teleporters that match this variant.
 *                Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the teleporters are removed. Default
 *                   is false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of teleporters.
 * @returns The teleporters that were removed.
 */
export function removeAllTeleporters(
  variant = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntity[] {
  const teleporters = getTeleporters(variant);
  return removeGridEntities(teleporters, updateRoom, cap);
}

/**
 * Helper function to remove all of the `GridEntityType.TRAPDOOR` (17) in the room.
 *
 * @param trapdoorVariant Optional. If specified, will only remove the trapdoors that match this
 *                        variant. Default is -1, which matches every variant.
 * @param updateRoom Optional. Whether to update the room after the trapdoors are removed. Default
 *                   is false. For more information, see the description of the `removeGridEntities`
 *                   helper function.
 * @param cap Optional. If specified, will only remove the given amount of trapdoors.
 * @returns The trapdoors that were removed.
 */
export function removeAllTrapdoors(
  trapdoorVariant: TrapdoorVariant | -1 = -1,
  updateRoom = false,
  cap?: int,
): readonly GridEntity[] {
  const trapdoors = getTrapdoors(trapdoorVariant);
  return removeGridEntities(trapdoors, updateRoom, cap);
}

/** Helper function to spawn a `GridEntityType.CRAWL_SPACE` (18). */
export function spawnCrawlSpace(
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnCrawlSpaceWithVariant(
    CrawlSpaceVariant.NORMAL,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.CRAWL_SPACE` (18) with a specific variant. */
export function spawnCrawlSpaceWithVariant(
  crawlSpaceVariant: CrawlSpaceVariant,
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnGridEntityWithVariant(
    GridEntityType.CRAWL_SPACE,
    crawlSpaceVariant,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.PIT` (7) with a specific variant. */
export function spawnDoor(
  gridIndexOrPosition: int | Vector,
): GridEntityDoor | undefined {
  return spawnDoorWithVariant(DoorVariant.UNSPECIFIED, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.DOOR` (16). */
export function spawnDoorWithVariant(
  doorVariant: DoorVariant,
  gridIndexOrPosition: int | Vector,
): GridEntityDoor | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.DOOR,
    doorVariant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const door = gridEntity.ToDoor();
  assertDefined(door, "Failed to spawn a door.");

  return door;
}

/** Helper function to spawn a `GridEntityType.DOOR` (16) with a specific variant. */
export function spawnPit(
  gridIndexOrPosition: int | Vector,
): GridEntityPit | undefined {
  return spawnPitWithVariant(PitVariant.NORMAL, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.PIT` (7) with a specific variant. */
export function spawnPitWithVariant(
  pitVariant: PitVariant,
  gridIndexOrPosition: int | Vector,
): GridEntityPit | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.PIT,
    pitVariant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const pit = gridEntity.ToPit();
  assertDefined(pit, "Failed to spawn a pit.");

  return pit;
}

/** Helper function to spawn a `GridEntityType.POOP` (14). */
export function spawnPoop(
  gridIndexOrPosition: int | Vector,
): GridEntityPoop | undefined {
  return spawnPoopWithVariant(
    PoopGridEntityVariant.NORMAL,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.POOP` (14) with a specific variant. */
export function spawnPoopWithVariant(
  poopVariant: PoopGridEntityVariant,
  gridIndexOrPosition: int | Vector,
): GridEntityPoop | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.POOP,
    poopVariant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const poop = gridEntity.ToPoop();
  assertDefined(poop, "Failed to spawn a poop.");

  return poop;
}

/** Helper function to spawn a `GridEntityType.PRESSURE_PLATE` (20). */
export function spawnPressurePlate(
  gridIndexOrPosition: int | Vector,
): GridEntityPressurePlate | undefined {
  return spawnPressurePlateWithVariant(
    PressurePlateVariant.PRESSURE_PLATE,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.PRESSURE_PLATE` (20) with a specific variant. */
export function spawnPressurePlateWithVariant(
  pressurePlateVariant: PressurePlateVariant,
  gridIndexOrPosition: int | Vector,
): GridEntityPressurePlate | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.PRESSURE_PLATE,
    pressurePlateVariant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const pressurePlate = gridEntity.ToPressurePlate();
  assertDefined(pressurePlate, "Failed to spawn a pressure plate.");

  return pressurePlate;
}

/** Helper function to spawn a `GridEntityType.ROCK` (2). */
export function spawnRock(
  gridIndexOrPosition: int | Vector,
): GridEntityRock | undefined {
  return spawnRockWithVariant(RockVariant.NORMAL, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.ROCK` (2) with a specific variant. */
export function spawnRockWithVariant(
  rockVariant: RockVariant,
  gridIndexOrPosition: int | Vector,
): GridEntityRock | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.ROCK,
    rockVariant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const rock = gridEntity.ToRock();
  assertDefined(rock, "Failed to spawn a rock.");

  return rock;
}

/** Helper function to spawn a `GridEntityType.SPIKES` (8). */
export function spawnSpikes(
  gridIndexOrPosition: int | Vector,
): GridEntitySpikes | undefined {
  return spawnSpikesWithVariant(0, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.SPIKES` (8) with a specific variant. */
export function spawnSpikesWithVariant(
  variant: int,
  gridIndexOrPosition: int | Vector,
): GridEntitySpikes | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.SPIKES,
    variant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const spikes = gridEntity.ToSpikes();
  assertDefined(spikes, "Failed to spawn spikes.");

  return spikes;
}

/** Helper function to spawn a `GridEntityType.TNT` (12). */
export function spawnTNT(
  gridIndexOrPosition: int | Vector,
): GridEntityTNT | undefined {
  return spawnTNTWithVariant(0, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.TNT` (12) with a specific variant. */
export function spawnTNTWithVariant(
  variant: int,
  gridIndexOrPosition: int | Vector,
): GridEntityTNT | undefined {
  const gridEntity = spawnGridEntityWithVariant(
    GridEntityType.TNT,
    variant,
    gridIndexOrPosition,
  );
  if (gridEntity === undefined) {
    return undefined;
  }

  const tnt = gridEntity.ToTNT();
  assertDefined(tnt, "Failed to spawn TNT.");

  return tnt;
}

/** Helper function to spawn a `GridEntityType.TELEPORTER` (23). */
export function spawnTeleporter(
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnTeleporterWithVariant(0, gridIndexOrPosition);
}

/** Helper function to spawn a `GridEntityType.TELEPORTER` (23) with a specific variant. */
export function spawnTeleporterWithVariant(
  variant: int,
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnGridEntityWithVariant(
    GridEntityType.TELEPORTER,
    variant,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.TRAPDOOR` (17). */
export function spawnTrapdoor(
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnCrawlSpaceWithVariant(
    CrawlSpaceVariant.NORMAL,
    gridIndexOrPosition,
  );
}

/** Helper function to spawn a `GridEntityType.TRAPDOOR` (17) with a specific variant. */
export function spawnTrapdoorWithVariant(
  trapdoorVariant: TrapdoorVariant,
  gridIndexOrPosition: int | Vector,
): GridEntity | undefined {
  return spawnGridEntityWithVariant(
    GridEntityType.TRAPDOOR,
    trapdoorVariant,
    gridIndexOrPosition,
  );
}

----
functions\gridIndex.ts
import { RoomShape } from "isaac-typescript-definitions";
import { getRoomShapeWidth } from "./roomShape";
import { iRange } from "./utils";

/**
 * Helper function to get all of the grid indexes between two grid indexes on either a horizontal or
 * vertical line, inclusive on both ends.
 *
 * If the first grid index is greater than the second grid index, the two will be swapped.
 *
 * This function will throw a run-time error if the two provided grid indexes are not on the same
 * horizontal or vertical line.
 */
export function getGridIndexesBetween(
  gridIndex1: int,
  gridIndex2: int,
  roomShape: RoomShape,
): readonly int[] {
  if (gridIndex1 > gridIndex2) {
    const oldGridIndex1 = gridIndex1;
    const oldGridIndex2 = gridIndex2;
    gridIndex1 = oldGridIndex2;
    gridIndex2 = oldGridIndex1;
  }

  const delta = gridIndex2 - gridIndex1;
  const gridWidth = getRoomShapeWidth(roomShape);

  const isOnHorizontalLine = delta <= gridWidth;
  if (isOnHorizontalLine) {
    return iRange(gridIndex1, gridIndex2);
  }

  const isOnVerticalLine = delta % gridWidth === 0;
  if (isOnVerticalLine) {
    return iRange(gridIndex1, gridIndex2, gridWidth);
  }

  error(
    `Failed to get the grid indexes between ${gridIndex1} and ${gridIndex2} for RoomShape.${RoomShape[roomShape]} (${roomShape}) since they are not on the same horizontal or vertical line.`,
  );
}

----
functions\hash.ts
const CRC32 = [
  0x00_00_00_00, 0x77_07_30_96, 0xee_0e_61_2c, 0x99_09_51_ba, 0x07_6d_c4_19,
  0x70_6a_f4_8f, 0xe9_63_a5_35, 0x9e_64_95_a3, 0x0e_db_88_32, 0x79_dc_b8_a4,
  0xe0_d5_e9_1e, 0x97_d2_d9_88, 0x09_b6_4c_2b, 0x7e_b1_7c_bd, 0xe7_b8_2d_07,
  0x90_bf_1d_91, 0x1d_b7_10_64, 0x6a_b0_20_f2, 0xf3_b9_71_48, 0x84_be_41_de,
  0x1a_da_d4_7d, 0x6d_dd_e4_eb, 0xf4_d4_b5_51, 0x83_d3_85_c7, 0x13_6c_98_56,
  0x64_6b_a8_c0, 0xfd_62_f9_7a, 0x8a_65_c9_ec, 0x14_01_5c_4f, 0x63_06_6c_d9,
  0xfa_0f_3d_63, 0x8d_08_0d_f5, 0x3b_6e_20_c8, 0x4c_69_10_5e, 0xd5_60_41_e4,
  0xa2_67_71_72, 0x3c_03_e4_d1, 0x4b_04_d4_47, 0xd2_0d_85_fd, 0xa5_0a_b5_6b,
  0x35_b5_a8_fa, 0x42_b2_98_6c, 0xdb_bb_c9_d6, 0xac_bc_f9_40, 0x32_d8_6c_e3,
  0x45_df_5c_75, 0xdc_d6_0d_cf, 0xab_d1_3d_59, 0x26_d9_30_ac, 0x51_de_00_3a,
  0xc8_d7_51_80, 0xbf_d0_61_16, 0x21_b4_f4_b5, 0x56_b3_c4_23, 0xcf_ba_95_99,
  0xb8_bd_a5_0f, 0x28_02_b8_9e, 0x5f_05_88_08, 0xc6_0c_d9_b2, 0xb1_0b_e9_24,
  0x2f_6f_7c_87, 0x58_68_4c_11, 0xc1_61_1d_ab, 0xb6_66_2d_3d, 0x76_dc_41_90,
  0x01_db_71_06, 0x98_d2_20_bc, 0xef_d5_10_2a, 0x71_b1_85_89, 0x06_b6_b5_1f,
  0x9f_bf_e4_a5, 0xe8_b8_d4_33, 0x78_07_c9_a2, 0x0f_00_f9_34, 0x96_09_a8_8e,
  0xe1_0e_98_18, 0x7f_6a_0d_bb, 0x08_6d_3d_2d, 0x91_64_6c_97, 0xe6_63_5c_01,
  0x6b_6b_51_f4, 0x1c_6c_61_62, 0x85_65_30_d8, 0xf2_62_00_4e, 0x6c_06_95_ed,
  0x1b_01_a5_7b, 0x82_08_f4_c1, 0xf5_0f_c4_57, 0x65_b0_d9_c6, 0x12_b7_e9_50,
  0x8b_be_b8_ea, 0xfc_b9_88_7c, 0x62_dd_1d_df, 0x15_da_2d_49, 0x8c_d3_7c_f3,
  0xfb_d4_4c_65, 0x4d_b2_61_58, 0x3a_b5_51_ce, 0xa3_bc_00_74, 0xd4_bb_30_e2,
  0x4a_df_a5_41, 0x3d_d8_95_d7, 0xa4_d1_c4_6d, 0xd3_d6_f4_fb, 0x43_69_e9_6a,
  0x34_6e_d9_fc, 0xad_67_88_46, 0xda_60_b8_d0, 0x44_04_2d_73, 0x33_03_1d_e5,
  0xaa_0a_4c_5f, 0xdd_0d_7c_c9, 0x50_05_71_3c, 0x27_02_41_aa, 0xbe_0b_10_10,
  0xc9_0c_20_86, 0x57_68_b5_25, 0x20_6f_85_b3, 0xb9_66_d4_09, 0xce_61_e4_9f,
  0x5e_de_f9_0e, 0x29_d9_c9_98, 0xb0_d0_98_22, 0xc7_d7_a8_b4, 0x59_b3_3d_17,
  0x2e_b4_0d_81, 0xb7_bd_5c_3b, 0xc0_ba_6c_ad, 0xed_b8_83_20, 0x9a_bf_b3_b6,
  0x03_b6_e2_0c, 0x74_b1_d2_9a, 0xea_d5_47_39, 0x9d_d2_77_af, 0x04_db_26_15,
  0x73_dc_16_83, 0xe3_63_0b_12, 0x94_64_3b_84, 0x0d_6d_6a_3e, 0x7a_6a_5a_a8,
  0xe4_0e_cf_0b, 0x93_09_ff_9d, 0x0a_00_ae_27, 0x7d_07_9e_b1, 0xf0_0f_93_44,
  0x87_08_a3_d2, 0x1e_01_f2_68, 0x69_06_c2_fe, 0xf7_62_57_5d, 0x80_65_67_cb,
  0x19_6c_36_71, 0x6e_6b_06_e7, 0xfe_d4_1b_76, 0x89_d3_2b_e0, 0x10_da_7a_5a,
  0x67_dd_4a_cc, 0xf9_b9_df_6f, 0x8e_be_ef_f9, 0x17_b7_be_43, 0x60_b0_8e_d5,
  0xd6_d6_a3_e8, 0xa1_d1_93_7e, 0x38_d8_c2_c4, 0x4f_df_f2_52, 0xd1_bb_67_f1,
  0xa6_bc_57_67, 0x3f_b5_06_dd, 0x48_b2_36_4b, 0xd8_0d_2b_da, 0xaf_0a_1b_4c,
  0x36_03_4a_f6, 0x41_04_7a_60, 0xdf_60_ef_c3, 0xa8_67_df_55, 0x31_6e_8e_ef,
  0x46_69_be_79, 0xcb_61_b3_8c, 0xbc_66_83_1a, 0x25_6f_d2_a0, 0x52_68_e2_36,
  0xcc_0c_77_95, 0xbb_0b_47_03, 0x22_02_16_b9, 0x55_05_26_2f, 0xc5_ba_3b_be,
  0xb2_bd_0b_28, 0x2b_b4_5a_92, 0x5c_b3_6a_04, 0xc2_d7_ff_a7, 0xb5_d0_cf_31,
  0x2c_d9_9e_8b, 0x5b_de_ae_1d, 0x9b_64_c2_b0, 0xec_63_f2_26, 0x75_6a_a3_9c,
  0x02_6d_93_0a, 0x9c_09_06_a9, 0xeb_0e_36_3f, 0x72_07_67_85, 0x05_00_57_13,
  0x95_bf_4a_82, 0xe2_b8_7a_14, 0x7b_b1_2b_ae, 0x0c_b6_1b_38, 0x92_d2_8e_9b,
  0xe5_d5_be_0d, 0x7c_dc_ef_b7, 0x0b_db_df_21, 0x86_d3_d2_d4, 0xf1_d4_e2_42,
  0x68_dd_b3_f8, 0x1f_da_83_6e, 0x81_be_16_cd, 0xf6_b9_26_5b, 0x6f_b0_77_e1,
  0x18_b7_47_77, 0x88_08_5a_e6, 0xff_0f_6a_70, 0x66_06_3b_ca, 0x11_01_0b_5c,
  0x8f_65_9e_ff, 0xf8_62_ae_69, 0x61_6b_ff_d3, 0x16_6c_cf_45, 0xa0_0a_e2_78,
  0xd7_0d_d2_ee, 0x4e_04_83_54, 0x39_03_b3_c2, 0xa7_67_26_61, 0xd0_60_16_f7,
  0x49_69_47_4d, 0x3e_6e_77_db, 0xae_d1_6a_4a, 0xd9_d6_5a_dc, 0x40_df_0b_66,
  0x37_d8_3b_f0, 0xa9_bc_ae_53, 0xde_bb_9e_c5, 0x47_b2_cf_7f, 0x30_b5_ff_e9,
  0xbd_bd_f2_1c, 0xca_ba_c2_8a, 0x53_b3_93_30, 0x24_b4_a3_a6, 0xba_d0_36_05,
  0xcd_d7_06_93, 0x54_de_57_29, 0x23_d9_67_bf, 0xb3_66_7a_2e, 0xc4_61_4a_b8,
  0x5d_68_1b_02, 0x2a_6f_2b_94, 0xb4_0b_be_37, 0xc3_0c_8e_a1, 0x5a_05_df_1b,
  0x2d_02_ef_8d,
] as const;

/** From: https://github.com/lancelijade/qqwry.lua/blob/master/crc32.lua */
export function crc32(str: string): number {
  let count = str.length;
  let crc = 0xff_ff_ff_ff;
  let i = 1;

  while (count > 0) {
    const byte = string.byte(str, i);
    const left = crc >>> 8;
    const crcIndex = ((crc & 0xff) ^ byte) + 1;
    const right = CRC32[crcIndex] ?? 0;
    crc = left ^ right;
    i++;
    count--;
  }
  crc ^= 0xff_ff_ff_ff;

  return crc;
}

----
functions\hex.ts
import { logError } from "./log";

const HEX_STRING_LENGTH = 6;

/**
 * Converts a hex string like "#33aa33" to a KColor object.
 *
 * @param hexString A hex string like "#ffffff" or "ffffff". (The "#" character is optional.)
 * @param alpha Optional. Range is from 0 to 1. Default is 1. (The same as the `Color` constructor.)
 */
export function hexToColor(hexString: string, alpha = 1): Readonly<Color> {
  const { r, g, b } = hexToRGB(hexString);

  // Color values should be between 0 and 1.
  const base = 255;
  return Color(r / base, g / base, b / base, alpha);
}

/**
 * Converts a hex string like "#33aa33" to a Color object.
 *
 * @param hexString A hex string like "#ffffff" or "ffffff". (The "#" character is optional.)
 * @param alpha Range is from 0 to 1. Default is 1.
 */
export function hexToKColor(hexString: string, alpha = 1): Readonly<KColor> {
  const { r, g, b } = hexToRGB(hexString);

  // KColor values should be between 0 and 1.
  const base = 255;
  return KColor(r / base, g / base, b / base, alpha);
}

function hexToRGB(hexString: string): { r: float; g: float; b: float } {
  hexString = hexString.replace("#", "");
  if (hexString.length !== HEX_STRING_LENGTH) {
    logError(`Hex strings must be of length: ${HEX_STRING_LENGTH}`);
    return { r: 0, g: 0, b: 0 };
  }

  const rString = hexString.slice(0, 2);
  const r = tonumber(`0x${rString}`);
  if (r === undefined) {
    logError(`Failed to convert \`0x${rString}\` to a number.`);
    return { r: 0, g: 0, b: 0 };
  }

  const gString = hexString.slice(2, 4);
  const g = tonumber(`0x${gString}`);
  if (g === undefined) {
    logError(`Failed to convert \`0x${gString}\` to a number.`);
    return { r: 0, g: 0, b: 0 };
  }

  const bString = hexString.slice(4, 6);
  const b = tonumber(`0x${bString}`);
  if (b === undefined) {
    logError(`Failed to convert \`0x${bString}\` to a number.`);
    return { r: 0, g: 0, b: 0 };
  }

  return { r, g, b };
}

----
functions\input.ts
import {
  ButtonAction,
  Controller,
  ControllerIndex,
  Keyboard,
} from "isaac-typescript-definitions";
import { CONTROLLER_INDEX_VALUES } from "../cachedEnumValues";
import { KEYBOARD_TO_STRING_MAP } from "../maps/keyboardToStringMap";
import { ReadonlySet } from "../types/ReadonlySet";
import { trimPrefix } from "./string";

export const MODIFIER_KEYS = [
  Keyboard.LEFT_SHIFT, // 340
  Keyboard.LEFT_CONTROL, // 341
  Keyboard.LEFT_ALT, // 342
  Keyboard.LEFT_SUPER, // 343
  Keyboard.RIGHT_SHIFT, // 344
  Keyboard.RIGHT_CONTROL, // 345
  Keyboard.RIGHT_ALT, // 346
  Keyboard.RIGHT_SUPER, // 347
] as const;

export const MOVEMENT_BUTTON_ACTIONS = [
  ButtonAction.LEFT, // 0
  ButtonAction.RIGHT, // 1
  ButtonAction.UP, // 2
  ButtonAction.DOWN, // 3
] as const;

export const MOVEMENT_BUTTON_ACTIONS_SET = new ReadonlySet<ButtonAction>(
  MOVEMENT_BUTTON_ACTIONS,
);

export const SHOOTING_BUTTON_ACTIONS = [
  ButtonAction.SHOOT_LEFT, // 4
  ButtonAction.SHOOT_RIGHT, // 5
  ButtonAction.SHOOT_UP, // 6
  ButtonAction.SHOOT_DOWN, // 7
] as const;

export const SHOOTING_BUTTON_ACTIONS_SET = new ReadonlySet<ButtonAction>(
  SHOOTING_BUTTON_ACTIONS,
);

/**
 * Helper function to get the enum name for the specified `Controller` value. Note that this will
 * trim off the "BUTTON_" prefix.
 *
 * Returns undefined if the submitted controller value was not valid.
 */
export function controllerToString(controller: Controller): string | undefined {
  const key = Controller[controller];
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (key === undefined) {
    return undefined;
  }

  return trimPrefix(key, "BUTTON_");
}

/**
 * Helper function to get the movement actions that the specified `ControllerIndex` is currently
 * pressing down. This returns an array because a player can be holding down more than one movement
 * key at a time.
 */
export function getMoveButtonActions(
  controllerIndex: ControllerIndex,
): readonly ButtonAction[] {
  return MOVEMENT_BUTTON_ACTIONS.filter((buttonAction) =>
    Input.IsActionPressed(buttonAction, controllerIndex),
  );
}

/**
 * Helper function to get the shooting actions that the specified `ControllerIndex` is currently
 * pressing down. This returns an array because a player can be holding down more than one shooting
 * key at a time.
 */
export function getShootButtonActions(
  controllerIndex: ControllerIndex,
): readonly ButtonAction[] {
  return SHOOTING_BUTTON_ACTIONS.filter((buttonAction) =>
    Input.IsActionPressed(buttonAction, controllerIndex),
  );
}

/**
 * Helper function to check if a player is pressing a specific button (i.e. holding it down).
 *
 * This is a variadic version of `Input.IsActionPressed`, meaning that you can pass as many buttons
 * as you want to check for. This function will return true if any of the buttons are pressed.
 */
export function isActionPressed(
  controllerIndex: ControllerIndex,
  ...buttonActions: readonly ButtonAction[]
): boolean {
  return buttonActions.some((buttonAction) =>
    Input.IsActionPressed(buttonAction, controllerIndex),
  );
}

/**
 * Helper function to iterate over all inputs to determine if a specific button is pressed (i.e.
 * being held down).
 *
 * This function is variadic, meaning you can pass as many buttons as you want to check for. This
 * function will return true if any of the buttons are pressed.
 */
export function isActionPressedOnAnyInput(
  ...buttonActions: readonly ButtonAction[]
): boolean {
  return CONTROLLER_INDEX_VALUES.some((controllerIndex) =>
    isActionPressed(controllerIndex, ...buttonActions),
  );
}

/**
 * Helper function to check if a player is triggering a specific button (i.e. pressing and releasing
 * it).
 *
 * This is a variadic version of `Input.IsActionTriggered`, meaning that you can pass as many
 * buttons as you want to check for. This function will return true if any of the buttons are
 * triggered.
 */
export function isActionTriggered(
  controllerIndex: ControllerIndex,
  ...buttonActions: readonly ButtonAction[]
): boolean {
  return buttonActions.some((buttonAction) =>
    Input.IsActionTriggered(buttonAction, controllerIndex),
  );
}

/**
 * Iterates over all inputs to determine if a specific button is triggered (i.e. held down and then
 * released).
 *
 * This function is variadic, meaning you can pass as many buttons as you want to check for. This
 * function will return true if any of the buttons are pressed.
 */
export function isActionTriggeredOnAnyInput(
  ...buttonActions: readonly ButtonAction[]
): boolean {
  return CONTROLLER_INDEX_VALUES.some((controllerIndex) =>
    isActionTriggered(controllerIndex, ...buttonActions),
  );
}

/**
 * Helper function to see if a specific keyboard key is being held down by the player.
 *
 * This function is variadic, meaning you can pass as many keyboard values as you want to check for.
 * This function will return true if any of the values are pressed.
 */
export function isKeyboardPressed(...keys: readonly Keyboard[]): boolean {
  return keys.some((key) =>
    Input.IsButtonPressed(key, ControllerIndex.KEYBOARD),
  );
}

/**
 * Helper function to check if one or more modifier keys are being pressed down on the keyboard.
 *
 * A modifier key is defined as shift, control, alt, or Windows.
 */
export function isModifierKeyPressed(): boolean {
  return isKeyboardPressed(...MODIFIER_KEYS);
}

export function isMoveAction(buttonAction: ButtonAction): boolean {
  return MOVEMENT_BUTTON_ACTIONS_SET.has(buttonAction);
}

export function isMoveActionPressed(controllerIndex: ControllerIndex): boolean {
  return isActionPressed(controllerIndex, ...MOVEMENT_BUTTON_ACTIONS);
}

export function isMoveActionPressedOnAnyInput(): boolean {
  return MOVEMENT_BUTTON_ACTIONS.some((moveAction) =>
    isActionPressedOnAnyInput(moveAction),
  );
}

export function isMoveActionTriggered(
  controllerIndex: ControllerIndex,
): boolean {
  return isActionTriggered(controllerIndex, ...MOVEMENT_BUTTON_ACTIONS);
}

export function isMoveActionTriggeredOnAnyInput(): boolean {
  return MOVEMENT_BUTTON_ACTIONS.some((moveAction) =>
    isActionTriggeredOnAnyInput(moveAction),
  );
}

export function isShootAction(buttonAction: ButtonAction): boolean {
  return SHOOTING_BUTTON_ACTIONS_SET.has(buttonAction);
}

export function isShootActionPressed(
  controllerIndex: ControllerIndex,
): boolean {
  return isActionPressed(controllerIndex, ...SHOOTING_BUTTON_ACTIONS);
}

export function isShootActionPressedOnAnyInput(): boolean {
  return SHOOTING_BUTTON_ACTIONS.some((shootAction) =>
    isActionPressedOnAnyInput(shootAction),
  );
}

export function isShootActionTriggered(
  controllerIndex: ControllerIndex,
): boolean {
  return isActionTriggered(controllerIndex, ...SHOOTING_BUTTON_ACTIONS);
}

export function isShootActionTriggeredOnAnyInput(): boolean {
  return SHOOTING_BUTTON_ACTIONS.some((shootAction) =>
    isActionTriggeredOnAnyInput(shootAction),
  );
}

/**
 * Helper function to get the string that would be typed if someone pressed the corresponding key.
 * This is useful for creating in-game chat.
 *
 * Note that this function will only work for the keyboard values that are printable. Thus, it will
 * return undefined for e.g. `Keyboard.LEFT_SHIFT` (340). If all you want is the corresponding name
 * of the key, then simply use the enum reverse mapping (e.g. `Keyboard[keyboard]`).
 */
export function keyboardToString(
  keyboard: Keyboard,
  uppercase: boolean,
): string | undefined {
  const tuple = KEYBOARD_TO_STRING_MAP.get(keyboard);
  if (tuple === undefined) {
    return undefined;
  }

  const [lowercaseCharacter, uppercaseCharacter] = tuple;
  return uppercase ? uppercaseCharacter : lowercaseCharacter;
}

----
functions\isaacAPIClass.ts
import { trimPrefix } from "./string";
import { isString, isUserdata } from "./types";

/**
 * Helper function to get the name of a class from the Isaac API. This is contained within the
 * "__type" metatable key.
 *
 * For example, a `Vector` class is has a name of "Vector".
 *
 * Returns undefined if the object is not of type `userdata` or if the "__type" metatable key does
 * not exist.
 *
 * In some cases, Isaac classes can be a read-only. If this is the case, the "__type" field will be
 * prepended with "const ". This function will always strip this prefix, if it exists. For example,
 * the class name returned for "const Vector" will be "Vector".
 */
export function getIsaacAPIClassName(object: unknown): string | undefined {
  if (!isUserdata(object)) {
    return undefined;
  }

  const metatable = getmetatable(object) as
    | LuaMap<AnyNotNil, unknown>
    | undefined;
  if (metatable === undefined) {
    return undefined;
  }

  const classType = metatable.get("__type");
  if (!isString(classType)) {
    return undefined;
  }

  return trimPrefix(classType, "const ");
}

/** Helper function to detect if a variable is of type `EntityBomb`. */
export function isBomb(variable: unknown): variable is EntityBomb {
  return getIsaacAPIClassName(variable) === "EntityBomb";
}

/** Helper function to detect if a variable is of type `GridEntityDoor`. */
export function isDoor(variable: unknown): variable is GridEntityDoor {
  return getIsaacAPIClassName(variable) === "GridEntityDoor";
}

/** Helper function to detect if a variable is of type `EntityEffect`. */
export function isEffect(variable: unknown): variable is EntityEffect {
  return getIsaacAPIClassName(variable) === "EntityEffect";
}

/**
 * Helper function to detect if a variable is of type `Entity`. This will return false for child
 * classes such as `EntityPlayer` or `EntityTear`.
 */
export function isEntity(variable: unknown): variable is Entity {
  return getIsaacAPIClassName(variable) === "Entity";
}

/** Helper function to detect if a variable is of type `EntityFamiliar`. */
export function isFamiliar(variable: unknown): variable is EntityFamiliar {
  return getIsaacAPIClassName(variable) === "EntityEffect";
}

/** Helper function to detect if a variable is of type `GridEntity`. */
export function isGridEntity(variable: unknown): variable is GridEntity {
  return getIsaacAPIClassName(variable) === "GridEntity";
}

/**
 * Helper function to check if something is an instantiated class from the Isaac API. (All classes
 * from the Isaac API have a type of "userdata" in Lua with a metatable key of "__type" equal to the
 * name of the class.)
 */
export function isIsaacAPIClass(object: unknown): object is IsaacAPIClass {
  const isaacAPIClassType = getIsaacAPIClassName(object);
  return isaacAPIClassType !== undefined;
}

export function isIsaacAPIClassOfType(
  object: unknown,
  classType: string,
): boolean {
  const isaacAPIClassType = getIsaacAPIClassName(object);
  return (
    isaacAPIClassType === classType ||
    isaacAPIClassType === `const ${classType}`
  );
}

/** Helper function to detect if a variable is of type `EntityKnife`. */
export function isKnife(variable: unknown): variable is EntityKnife {
  return getIsaacAPIClassName(variable) === "EntityKnife";
}

/** Helper function to detect if a variable is of type `EntityLaser`. */
export function isLaser(variable: unknown): variable is EntityLaser {
  return getIsaacAPIClassName(variable) === "EntityLaser";
}

/** Helper function to detect if a variable is of type `EntityNPC`. */
export function isNPC(variable: unknown): variable is EntityNPC {
  return getIsaacAPIClassName(variable) === "EntityNPC";
}

/** Helper function to detect if a variable is of type `EntityPickup`. */
export function isPickup(variable: unknown): variable is EntityPickup {
  return getIsaacAPIClassName(variable) === "EntityPickup";
}

/** Helper function to detect if a variable is of type `GridEntityPit`. */
export function isPit(variable: unknown): variable is GridEntityPit {
  return getIsaacAPIClassName(variable) === "GridEntityPit";
}

/** Helper function to detect if a variable is of type `EntityPlayer`. */
export function isPlayer(variable: unknown): variable is EntityPlayer {
  return getIsaacAPIClassName(variable) === "EntityPlayer";
}

/** Helper function to detect if a variable is of type `GridEntityPoop`. */
export function isPoop(variable: unknown): variable is GridEntityPoop {
  return getIsaacAPIClassName(variable) === "GridEntityPoop";
}

/** Helper function to detect if a variable is of type `GridEntityPressurePlate`. */
export function isPressurePlate(
  variable: unknown,
): variable is GridEntityPressurePlate {
  return getIsaacAPIClassName(variable) === "GridEntityPressurePlate";
}

/** Helper function to detect if a variable is of type `EntityProjectile`. */
export function isProjectile(variable: unknown): variable is EntityProjectile {
  return getIsaacAPIClassName(variable) === "EntityProjectile";
}

/** Helper function to detect if a variable is of type `GridEntityRock`. */
export function isRock(variable: unknown): variable is GridEntityRock {
  return getIsaacAPIClassName(variable) === "GridEntityRock";
}

/** Helper function to detect if a variable is of type `GridEntitySpikes`. */
export function isSpikes(variable: unknown): variable is GridEntitySpikes {
  return getIsaacAPIClassName(variable) === "GridEntitySpikes";
}

/** Helper function to detect if a variable is of type `GridEntityTNT`. */
export function isTNT(variable: unknown): variable is GridEntityTNT {
  return getIsaacAPIClassName(variable) === "GridEntityTNT";
}

/** Helper function to detect if a variable is of type `EntityTear`. */
export function isTear(variable: unknown): variable is EntityTear {
  return getIsaacAPIClassName(variable) === "EntityTear";
}

/**
 * Helper function to check if an instantiated Isaac API class is equal to another one of the same
 * type. You must provide the list of keys to check for.
 */
export function isaacAPIClassEquals(
  object1: unknown,
  object2: unknown,
  keys: readonly string[],
): boolean {
  const table1 = object1 as LuaMap<AnyNotNil, unknown>;
  const table2 = object2 as LuaMap<AnyNotNil, unknown>;

  return keys.every((key) => table1.get(key) === table2.get(key));
}

----
functions\itemPool.ts
import type {
  CollectibleType,
  TrinketType,
} from "isaac-typescript-definitions";
import { ItemPoolType } from "isaac-typescript-definitions";
import { ITEM_POOL_TYPE_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { ITEM_POOL_TYPE_TO_ITEM_POOL_NAME } from "../maps/itemPoolTypeToItemPoolName";
import { ITEM_POOL_TYPE_TO_COLLECTIBLE_TYPES_SET } from "../objects/itemPoolTypeToCollectibleTypesSet";
import { arrayRemove, getRandomArrayElement } from "./array";

const NORMAL_MODE_ONLY_ITEM_POOL_TYPES = [
  ItemPoolType.TREASURE, // 0
  ItemPoolType.BOSS, // 2
  ItemPoolType.SHOP, // 1
  ItemPoolType.DEVIL, // 3
  ItemPoolType.ANGEL, // 4
  ItemPoolType.CURSE, // 12
  ItemPoolType.SECRET, // 5
] as const;

const GREED_MODE_ONLY_ITEM_POOL_TYPES = [
  ItemPoolType.GREED_TREASURE, // 16
  ItemPoolType.GREED_BOSS, // 17
  ItemPoolType.GREED_SHOP, // 18
  ItemPoolType.GREED_DEVIL, // 19
  ItemPoolType.GREED_ANGEL, // 20
  ItemPoolType.GREED_CURSE, // 21
  ItemPoolType.GREED_SECRET, // 22
] as const;

const FAKE_ITEM_POOL_TYPES = [ItemPoolType.SHELL_GAME] as const;

const NORMAL_MODE_ITEM_POOL_TYPES: readonly ItemPoolType[] = arrayRemove(
  ITEM_POOL_TYPE_VALUES,
  ...GREED_MODE_ONLY_ITEM_POOL_TYPES,
  ...FAKE_ITEM_POOL_TYPES,
);

const GREED_MODE_ITEM_POOL_TYPES: readonly ItemPoolType[] = arrayRemove(
  ITEM_POOL_TYPE_VALUES,
  ...NORMAL_MODE_ONLY_ITEM_POOL_TYPES,
  ...FAKE_ITEM_POOL_TYPES,
);

/**
 * Helper function to get the collectibles that are in a particular item pool at the beginning of a
 * vanilla run.
 */
export function getDefaultCollectibleTypesInItemPool(
  itemPoolType: ItemPoolType,
): ReadonlySet<CollectibleType> {
  return ITEM_POOL_TYPE_TO_COLLECTIBLE_TYPES_SET[itemPoolType];
}

/**
 * Helper function to get the item pools that a particular collectible starts in at the beginning of
 * a vanilla run.
 *
 * This function will automatically account for Greed Mode. In other words, it will not return the
 * "normal" item pools when playing in Greed Mode.
 */
export function getDefaultItemPoolsForCollectibleType(
  collectibleType: CollectibleType,
): readonly ItemPoolType[] {
  const collectibleItemPoolTypes: ItemPoolType[] = [];

  const itemPoolTypes = game.IsGreedMode()
    ? GREED_MODE_ITEM_POOL_TYPES
    : NORMAL_MODE_ITEM_POOL_TYPES;

  for (const itemPoolType of itemPoolTypes) {
    const collectibleTypesSet =
      ITEM_POOL_TYPE_TO_COLLECTIBLE_TYPES_SET[itemPoolType];
    if (collectibleTypesSet.has(collectibleType)) {
      collectibleItemPoolTypes.push(itemPoolType);
    }
  }

  return collectibleItemPoolTypes;
}

/**
 * Helper function to get the name for an item pool type as it appears in the "itempools.xml" file.
 */
export function getItemPoolName(itemPoolType: ItemPoolType): string {
  return ITEM_POOL_TYPE_TO_ITEM_POOL_NAME[itemPoolType];
}

/**
 * Helper function to get a random item pool. This is not as simple as getting a random value from
 * the `ItemPoolType` enum, since `ItemPoolType.SHELL_GAME` (7) is not a real item pool and the
 * Greed Mode item pools should be excluded if not playing in Greed Mode.
 *
 * If you want to get an unseeded item pool, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandomItemPool(
  seedOrRNG: Seed | RNG | undefined,
): ItemPoolType {
  const itemPoolTypes = game.IsGreedMode()
    ? GREED_MODE_ITEM_POOL_TYPES
    : NORMAL_MODE_ITEM_POOL_TYPES;

  return getRandomArrayElement(itemPoolTypes, seedOrRNG);
}

/**
 * Helper function to check if a particular collectibles is in a particular item pool at the
 * beginning of a vanilla run.
 */
export function isCollectibleTypeInDefaultItemPool(
  collectibleType: CollectibleType,
  itemPoolType: ItemPoolType,
): boolean {
  const collectibleTypesSet =
    ITEM_POOL_TYPE_TO_COLLECTIBLE_TYPES_SET[itemPoolType];
  return collectibleTypesSet.has(collectibleType);
}

/**
 * Helper function to remove one or more collectibles from all item pools.
 *
 * This function is variadic, meaning you can pass as many collectible types as you want to remove.
 */
export function removeCollectibleFromPools(
  ...collectibleTypes: readonly CollectibleType[]
): void {
  const itemPool = game.GetItemPool();

  for (const collectibleType of collectibleTypes) {
    itemPool.RemoveCollectible(collectibleType);
  }
}

/**
 * Helper function to remove one or more trinkets from all item pools.
 *
 * This function is variadic, meaning you can pass as many trinket types as you want to remove.
 */
export function removeTrinketFromPools(
  ...trinketTypes: readonly TrinketType[]
): void {
  const itemPool = game.GetItemPool();

  for (const trinketType of trinketTypes) {
    itemPool.RemoveTrinket(trinketType);
  }
}

----
functions\jsonHelpers.ts
import * as jsonLua from "../lib/jsonLua";
import { logError } from "./log";

function tryDecode(this: void, jsonString: string) {
  return jsonLua.decode(jsonString) as LuaMap<AnyNotNil, unknown>;
}

function tryEncode(this: void, luaTable: unknown) {
  return jsonLua.encode(luaTable);
}

/**
 * Converts a JSON string to a Lua table.
 *
 * In most cases, this function will be used for reading data from a "save#.dat" file. If decoding
 * fails, it will return a blank Lua table instead of throwing an error. (This allows execution to
 * continue in cases where users have no current save data or have manually removed their existing
 * save data.)
 *
 * Under the hood, this uses a custom JSON parser that was measured to be 11.8 times faster than the
 * vanilla JSON parser.
 */
export function jsonDecode(jsonString: string): LuaMap<AnyNotNil, unknown> {
  const [ok, luaTableOrErrMsg] = pcall(tryDecode, jsonString);
  if (!ok) {
    // Instead of throwing an error, continue execution of the callback.
    logError(`Failed to convert the JSON string to a Lua table: ${jsonString}`);
    return new LuaMap();
  }

  return luaTableOrErrMsg;
}

/**
 * Converts a Lua table to a JSON string.
 *
 * In most cases, this function will be used for writing data to a "save#.dat" file. If encoding
 * fails, it will throw an error to prevent writing a blank string or corrupted data to a user's
 * "save#.dat" file.
 *
 * Under the hood, this uses a custom JSON parser that was measured to be 11.8 times faster than the
 * vanilla JSON parser.
 */
export function jsonEncode(luaTable: unknown): string {
  const [ok, jsonStringOrErrMsg] = pcall(tryEncode, luaTable);
  if (!ok) {
    error(`Failed to convert the Lua table to JSON: ${jsonStringOrErrMsg}`);
  }

  return jsonStringOrErrMsg;
}

----
functions\jsonRoom.ts
import type { DoorSlotFlag } from "isaac-typescript-definitions";
import { DoorSlotFlagZero, RoomShape } from "isaac-typescript-definitions";
import type { JSONEntity, JSONRoom } from "../interfaces/JSONRoomsFile";
import { sumArray } from "./array";
import { doorSlotToDoorSlotFlag, getRoomShapeDoorSlot } from "./doors";
import { isEnumValue } from "./enums";
import { addFlag } from "./flag";
import { log } from "./log";
import { getRandomFloat } from "./random";
import { parseIntSafe } from "./types";
import { assertDefined } from "./utils";

/** This represents either a `JSONRoom` or a `JSONEntity`. */
interface JSONObject {
  $: { weight: string | undefined };
}

/**
 * Helper function to calculate what the resulting `BitFlags<DoorSlotFlag>` value would be for a
 * given JSON room.
 *
 * (A JSON room is an XML file converted to JSON so that it can be directly imported into your mod.)
 */
export function getJSONRoomDoorSlotFlags(
  jsonRoom: JSONRoom,
): BitFlags<DoorSlotFlag> {
  const roomShapeString = jsonRoom.$.shape;
  const roomShape = parseIntSafe(roomShapeString);
  assertDefined(
    roomShape,
    `Failed to parse the "shape" field of a JSON room: ${roomShapeString}`,
  );

  if (!isEnumValue(roomShape, RoomShape)) {
    error(
      `Failed to parse the "shape" field of a JSON room since it was an invalid number: ${roomShape}`,
    );
  }

  let doorSlotFlags = DoorSlotFlagZero;

  for (const door of jsonRoom.door) {
    const existsString = door.$.exists;
    if (existsString !== "True" && existsString !== "False") {
      error(
        `Failed to parse the "exists" field of a JSON room door: ${existsString}`,
      );
    }

    if (existsString === "False") {
      continue;
    }

    const xString = door.$.x;
    const x = parseIntSafe(xString);
    assertDefined(
      x,
      `Failed to parse the "x" field of a JSON room door: ${xString}`,
    );

    const yString = door.$.y;
    const y = parseIntSafe(yString);
    assertDefined(
      y,
      `Failed to parse the "y" field of a JSON room door: ${yString}`,
    );

    const doorSlot = getRoomShapeDoorSlot(roomShape, x, y);
    assertDefined(
      doorSlot,
      `Failed to retrieve the door slot for a JSON room door at coordinates: [${x}, ${y}]`,
    );

    const doorSlotFlag = doorSlotToDoorSlotFlag(doorSlot);
    doorSlotFlags = addFlag(doorSlotFlags, doorSlotFlag);
  }

  return doorSlotFlags;
}

/**
 * Helper function to find a specific room from an array of JSON rooms.
 *
 * (A JSON room is an XML file converted to JSON so that it can be directly imported into your mod.)
 *
 * @param jsonRooms The array of rooms to search through.
 * @param variant The room variant to select. (The room variant can be thought of as the ID of the
 *                room.)
 */
export function getJSONRoomOfVariant(
  jsonRooms: readonly JSONRoom[],
  variant: int,
): JSONRoom | undefined {
  const jsonRoomsOfVariant = jsonRooms.filter((jsonRoom) => {
    const roomVariantString = jsonRoom.$.variant;
    const roomVariant = parseIntSafe(roomVariantString);
    if (roomVariant === undefined) {
      error(
        `Failed to convert a JSON room variant to an integer: ${roomVariantString}`,
      );
    }

    return roomVariant === variant;
  });

  // The room variant acts as an ID for the room. We assume that there should only be a single room
  // per variant.
  if (jsonRoomsOfVariant.length === 0) {
    return undefined;
  }

  if (jsonRoomsOfVariant.length === 1) {
    return jsonRoomsOfVariant[0];
  }

  error(
    `Found ${jsonRoomsOfVariant.length} JSON rooms with a variant of ${variant}, when there should only be 1.`,
  );
}

/**
 * Helper function to find all of the JSON rooms that match the sub-type provided.
 *
 * (A JSON room is an XML file converted to JSON so that it can be directly imported into your mod.)
 *
 * @param jsonRooms The array of rooms to search through.
 * @param subType The sub-type to match.
 */
export function getJSONRoomsOfSubType(
  jsonRooms: readonly JSONRoom[],
  subType: int,
): readonly JSONRoom[] {
  return jsonRooms.filter((jsonRoom) => {
    const roomSubTypeString = jsonRoom.$.subtype;
    const roomSubType = parseIntSafe(roomSubTypeString);
    if (roomSubType === undefined) {
      error(
        `Failed to convert a JSON room sub-type to an integer: ${roomSubTypeString}`,
      );
    }

    return roomSubType === subType;
  });
}

/**
 * Helper function to get a random JSON entity from an array of JSON entities.
 *
 * (A JSON entity is an entity inside of a JSON room. A JSON room is an XML file converted to JSON
 * so that it can be directly imported into your mod.)
 *
 * Note that this function does not simply choose a random element in the provided array; it will
 * properly account for each room weight using the algorithm from:
 * https://stackoverflow.com/questions/1761626/weighted-random-numbers
 *
 * If you want an unseeded entity, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param jsonEntities The array of entities to randomly choose between.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param verbose Optional. If specified, will write entries to the "log.txt" file that describe
 *                what the function is doing. Default is false.
 */
export function getRandomJSONEntity(
  jsonEntities: readonly JSONEntity[],
  seedOrRNG: Seed | RNG | undefined,
  verbose = false,
): JSONEntity {
  const totalWeight = getTotalWeightOfJSONObject(jsonEntities);
  if (verbose) {
    log(`Total weight of the JSON entities provided: ${totalWeight}`);
  }

  const chosenWeight = getRandomFloat(0, totalWeight, seedOrRNG);
  if (verbose) {
    log(`Randomly chose weight for JSON entity: ${chosenWeight}`);
  }

  const randomJSONEntity = getJSONObjectWithChosenWeight(
    jsonEntities,
    chosenWeight,
  );
  assertDefined(
    randomJSONEntity,
    `Failed to get a JSON entity with chosen weight: ${chosenWeight}`,
  );

  return randomJSONEntity;
}

/**
 * Helper function to get a random JSON room from an array of JSON rooms.
 *
 * (A JSON room is an XML file converted to JSON so that it can be directly imported into your mod.)
 *
 * Note that this function does not simply choose a random element in the provided array; it will
 * properly account for each room weight using the algorithm from:
 * https://stackoverflow.com/questions/1761626/weighted-random-numbers
 *
 * If you want an unseeded room, you must explicitly pass `undefined` to the `seedOrRNG` parameter.
 *
 * @param jsonRooms The array of rooms to randomly choose between.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param verbose Optional. If specified, will write entries to the "log.txt" file that describe
 *                what the function is doing. Default is false.
 */
export function getRandomJSONRoom(
  jsonRooms: readonly JSONRoom[],
  seedOrRNG: Seed | RNG | undefined,
  verbose = false,
): JSONRoom {
  const totalWeight = getTotalWeightOfJSONObject(jsonRooms);
  if (verbose) {
    log(`Total weight of the JSON rooms provided: ${totalWeight}`);
  }

  const chosenWeight = getRandomFloat(0, totalWeight, seedOrRNG);
  if (verbose) {
    log(`Randomly chose weight for JSON room: ${chosenWeight}`);
  }

  const randomJSONRoom = getJSONObjectWithChosenWeight(jsonRooms, chosenWeight);
  assertDefined(
    randomJSONRoom,
    `Failed to get a JSON room with chosen weight: ${chosenWeight}`,
  );

  return randomJSONRoom;
}

function getTotalWeightOfJSONObject(
  jsonOjectArray: readonly JSONObject[],
): float {
  const weights = jsonOjectArray.map((jsonObject) => {
    const weightString = jsonObject.$.weight;
    const weight = tonumber(weightString);
    assertDefined(
      weight,
      `Failed to parse the weight of a JSON object: ${weightString}.`,
    );

    return weight;
  });

  return sumArray(weights);
}

function getJSONObjectWithChosenWeight<T extends JSONObject>(
  jsonOjectArray: readonly T[],
  chosenWeight: float,
): T | undefined {
  let weightAccumulator = 0;

  for (const jsonObject of jsonOjectArray) {
    const weightString = jsonObject.$.weight;
    const weight = tonumber(weightString);
    assertDefined(
      weight,
      `Failed to parse the weight of a JSON object: ${weightString}`,
    );

    weightAccumulator += weight;
    if (weightAccumulator >= chosenWeight) {
      return jsonObject;
    }
  }

  return undefined;
}

----
functions\kColor.ts
import type { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { isaacAPIClassEquals, isIsaacAPIClassOfType } from "./isaacAPIClass";
import { getRandom } from "./random";
import { isRNG, newRNG } from "./rng";
import {
  copyUserdataValuesToTable,
  getNumbersFromTable,
  tableHasKeys,
} from "./table";
import { isTable } from "./types";
import { assertDefined } from "./utils";

export type SerializedKColor = LuaMap<string, unknown> & {
  readonly __serializedKColorBrand: symbol;
  readonly __kind: CopyableIsaacAPIClassType.K_COLOR;
};

const OBJECT_NAME = "KColor";
const KEYS = ["Red", "Green", "Blue", "Alpha"] as const;

/** Helper function to copy a `KColor` Isaac API class. */
export function copyKColor(kColor: KColor): KColor {
  if (!isKColor(kColor)) {
    error(
      `Failed to copy a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  return KColor(kColor.Red, kColor.Green, kColor.Blue, kColor.Alpha);
}

/**
 * Helper function to convert a `SerializedKColor` object to a normal `KColor` object. (This is used
 * by the save data manager when reading data from the "save#.dat" file.)
 */
export function deserializeKColor(kColor: SerializedKColor): KColor {
  if (!isTable(kColor)) {
    error(
      `Failed to deserialize a ${OBJECT_NAME} object since the provided object was not a Lua table.`,
    );
  }

  const [r, g, b, a] = getNumbersFromTable(kColor, OBJECT_NAME, ...KEYS);

  assertDefined(
    r,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: Red`,
  );
  assertDefined(
    g,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: Green`,
  );
  assertDefined(
    b,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: Blue`,
  );
  assertDefined(
    a,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: Alpha`,
  );

  return KColor(r, g, b, a);
}

/**
 * Helper function to get a random `KColor` object (for use in fonts).
 *
 * If you want to generate an unseeded object, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param alpha Optional. The alpha value to use. Default is 1.
 */
export function getRandomKColor(
  seedOrRNG: Seed | RNG | undefined,
  alpha = 1,
): Readonly<KColor> {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  const r = getRandom(rng);
  const g = getRandom(rng);
  const b = getRandom(rng);

  return KColor(r, g, b, alpha);
}

/** Helper function to check if something is an instantiated `KColor` object. */
export function isKColor(object: unknown): object is KColor {
  return isIsaacAPIClassOfType(object, OBJECT_NAME);
}

/**
 * Used to determine is the given table is a serialized `KColor` object created by the `deepCopy`
 * function.
 */
export function isSerializedKColor(
  object: unknown,
): object is SerializedKColor {
  if (!isTable(object)) {
    return false;
  }

  return (
    tableHasKeys(object, ...KEYS) && object.has(SerializationBrand.K_COLOR)
  );
}

export function kColorEquals(kColor1: KColor, kColor2: KColor): boolean {
  return isaacAPIClassEquals(kColor1, kColor2, KEYS);
}

/**
 * Helper function to convert a `KColor` object to a `SerializedKColor` object. (This is used by the
 * save data manager when writing data from the "save#.dat" file.)
 */
export function serializeKColor(kColor: KColor): SerializedKColor {
  if (!isKColor(kColor)) {
    error(
      `Failed to serialize a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const kColorTable = new LuaMap<string, unknown>();
  copyUserdataValuesToTable(kColor, KEYS, kColorTable);
  kColorTable.set(SerializationBrand.K_COLOR, "");
  return kColorTable as SerializedKColor;
}

----
functions\language.ts
import { LANGUAGE_NAMES } from "../objects/languageNames";

/**
 * Helper function to convert the language abbreviation from `Options.Language` to the "full"
 * language name.
 *
 * For example, if the current language is set to Korean, `Options.Language` will be set to "kr",
 * and this function will return "Korean".
 */
export function getLanguageName(): string {
  const languageAbbreviation = Options.Language;
  return LANGUAGE_NAMES[languageAbbreviation];
}

----
functions\level.ts
import type { BossID } from "isaac-typescript-definitions";
import { RoomType, StageID } from "isaac-typescript-definitions";
import { DOOR_SLOT_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { filterMap } from "./array";
import {
  getRoomDescriptorsForType,
  isDoorSlotValidAtGridIndexForRedRoom,
} from "./levelGrid";
import { getNumRooms, getRoomsInsideGrid } from "./rooms";

/** Helper function to fill every possible level grid square with a red room. */
export function fillLevelWithRedRooms(): void {
  const level = game.GetLevel();

  let numRoomsInGrid: int;
  do {
    const roomsInGrid = getRoomsInsideGrid();
    numRoomsInGrid = roomsInGrid.length;

    for (const roomDescriptor of roomsInGrid) {
      for (const doorSlot of DOOR_SLOT_VALUES) {
        if (
          isDoorSlotValidAtGridIndexForRedRoom(
            doorSlot,
            roomDescriptor.GridIndex,
          )
        ) {
          level.MakeRedRoomDoor(roomDescriptor.GridIndex, doorSlot);
        }
      }
    }
  } while (numRoomsInGrid !== getNumRooms());
}

/**
 * Helper function to get the boss IDs of all of the Boss Rooms on this floor. (This is equivalent
 * to the sub-type of the room data.)
 *
 * Note that this will only look at Boss Rooms inside of the grid, so e.g. Reverse Emperor card
 * rooms will not count.
 */
export function getLevelBossIDs(): readonly BossID[] {
  const roomsInsideGrid = getRoomsInsideGrid();

  return filterMap(roomsInsideGrid, (roomDescriptor) =>
    roomDescriptor.Data !== undefined &&
    roomDescriptor.Data.Type === RoomType.BOSS &&
    roomDescriptor.Data.StageID === StageID.SPECIAL_ROOMS
      ? roomDescriptor.Data.Subtype
      : undefined,
  );
}

/**
 * Helper function to check if the current floor has a Boss Room that matches the boss ID provided.
 *
 * This function is variadic, meaning that you can pass as many boss IDs as you want to check for.
 * It will return true if one or more of the boss IDs are matched.
 */
export function levelHasBossID(...bossIDs: readonly BossID[]): boolean {
  const levelBossIDs = getLevelBossIDs();
  const levelBossIDsSet = new Set(levelBossIDs);

  return bossIDs.some((bossID) => levelBossIDsSet.has(bossID));
}

/**
 * Helper function to check to see if the current floor has one or more of a specific room type in
 * it.
 *
 * This function is variadic, meaning that you can pass as many room types as you want to check for.
 * This function will return true if any of the room types are found.
 */
export function levelHasRoomType(...roomTypes: readonly RoomType[]): boolean {
  const roomDescriptors = getRoomDescriptorsForType(...roomTypes);
  return roomDescriptors.length > 0;
}

----
functions\levelGrid.ts
/**
 * These functions have to do with the room grid index for the level (i.e. the position that the
 * room is on the grid that represents the map for the level).
 *
 * For functions having to do with the grid index inside of the room, see the "Room Grid" functions.
 *
 * @module
 */

import type { DoorSlot, RoomShape } from "isaac-typescript-definitions";
import {
  DisplayFlag,
  LevelStateFlag,
  RoomDescriptorFlag,
  RoomType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import {
  ALL_DISPLAY_FLAGS,
  LEVEL_GRID_ROW_WIDTH,
  MAX_LEVEL_GRID_INDEX,
} from "../core/constants";
import { ROOM_SHAPE_TO_DOOR_SLOTS_TO_GRID_INDEX_DELTA } from "../objects/roomShapeToDoorSlotsToGridIndexDelta";
import { getRandomArrayElement } from "./array";
import { doorSlotToDoorSlotFlag } from "./doors";
import { addFlag, hasFlag, removeFlag } from "./flag";
import { copyMap } from "./map";
import { isRNG, newRNG } from "./rng";
import {
  getRoomAllowedDoors,
  getRoomData,
  getRoomDescriptor,
  getRoomGridIndex,
  getRoomShape,
} from "./roomData";
import { getGridIndexDelta } from "./roomShape";
import {
  getRooms,
  getRoomsInsideGrid,
  isMineShaft,
  isMirrorRoom,
  isSecretRoomType,
} from "./rooms";

const LEFT = -1;
const UP = -LEVEL_GRID_ROW_WIDTH;
const RIGHT = 1;
const DOWN = LEVEL_GRID_ROW_WIDTH;

const ADJACENT_ROOM_GRID_INDEX_DELTAS = [LEFT, UP, RIGHT, DOWN] as const;

/**
 * Helper function to get only the adjacent room grid indexes that exist (i.e. have room data).
 *
 * This is just a filtering of the results of the `getAdjacentExistingRoomGridIndexes` function. See
 * that function for more information.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function getAdjacentExistingRoomGridIndexes(
  roomGridIndex?: int,
): readonly int[] {
  const adjacentRoomGridIndexes = getAdjacentRoomGridIndexes(roomGridIndex);
  return adjacentRoomGridIndexes.filter(
    (adjacentRoomGridIndex) => getRoomData(adjacentRoomGridIndex) !== undefined,
  );
}

/**
 * Helper function to get only the adjacent room grid indexes that do not exist (i.e. do not have
 * room data).
 *
 * This is just a filtering of the results of the `getAdjacentExistingRoomGridIndexes` function. See
 * that function for more information.
 */
export function getAdjacentNonExistingRoomGridIndexes(
  roomGridIndex?: int,
): readonly int[] {
  const adjacentRoomGridIndexes = getAdjacentRoomGridIndexes(roomGridIndex);
  return adjacentRoomGridIndexes.filter(
    (adjacentRoomGridIndex) => getRoomData(adjacentRoomGridIndex) === undefined,
  );
}

/**
 * Helper function to get all of the room grid indexes that are adjacent to a given room grid index
 * (even if those room grid indexes do not have any rooms in them).
 *
 * Adjacent room grid indexes that are outside of the grid will not be included in the returned
 * array.
 *
 * If a room grid index is provided that is outside of the grid, then an empty array will be
 * returned.
 *
 * Note that this function does not take the shape of the room into account; it only looks at a
 * single room grid index.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function getAdjacentRoomGridIndexes(
  roomGridIndex?: int,
): readonly int[] {
  const roomGridIndexToUse = roomGridIndex ?? getRoomGridIndex();

  if (!isRoomInsideGrid(roomGridIndexToUse)) {
    return [];
  }

  const adjacentRoomGridIndexes = ADJACENT_ROOM_GRID_INDEX_DELTAS.map(
    (delta) => roomGridIndexToUse + delta,
  );

  return adjacentRoomGridIndexes.filter((adjacentRoomGridIndex) =>
    isRoomInsideGrid(adjacentRoomGridIndex),
  );
}

/**
 * Helper function to get the room safe grid index for every room on the entire floor. This includes
 * off-grid rooms, such as the Devil Room.
 *
 * Rooms without any data are assumed to be non-existent and are not included.
 */
export function getAllRoomGridIndexes(): readonly int[] {
  const rooms = getRooms();
  return rooms.map((roomDescriptor) => roomDescriptor.SafeGridIndex);
}

/**
 * Helper function to pick a random valid spot on the floor to insert a brand new room. Note that
 * some floors will not have any valid spots. If this is the case, this function will return
 * undefined.
 *
 * If you want to get an unseeded room, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param ensureDeadEnd Optional. Whether to pick a valid dead end attached to a normal room. If
 *                      false, the function will randomly pick from any valid location that would
 *                      have a red door.
 * @returns Either a tuple of adjacent room grid index, `DoorSlot`, and new room grid index, or
 *          undefined.
 */
export function getNewRoomCandidate(
  seedOrRNG: Seed | RNG | undefined,
  ensureDeadEnd = true,
):
  | {
      readonly adjacentRoomGridIndex: int;
      readonly doorSlot: DoorSlot;
      readonly newRoomGridIndex: int;
    }
  | undefined {
  const newRoomCandidatesForLevel = getNewRoomCandidatesForLevel(ensureDeadEnd);
  if (newRoomCandidatesForLevel.length === 0) {
    return undefined;
  }

  return getRandomArrayElement(newRoomCandidatesForLevel, seedOrRNG);
}

/**
 * Helper function to iterate through the possible doors for a room and see if any of them would be
 * a valid spot to insert a brand new room on the floor.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @param ensureDeadEnd Optional. Whether to only include doors that lead to a valid dead end
 *                      attached to a normal room. If false, the function will include all doors
 *                      that would have a red door.
 * @returns A array of tuples of `DoorSlot` and room grid index.
 */
export function getNewRoomCandidatesBesideRoom(
  roomGridIndex?: int,
  ensureDeadEnd = true,
): ReadonlyArray<{ readonly doorSlot: DoorSlot; readonly roomGridIndex: int }> {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);

  // First, handle the case of rooms outside of the grid, which obviously cannot have any possible
  // adjacent new room candidates.
  if (!isRoomInsideGrid(roomDescriptor.SafeGridIndex)) {
    return [];
  }

  // Rooms without data are non-existent, so they obviously cannot have any possible adjacent new
  // room candidates.
  const roomData = roomDescriptor.Data;
  if (roomData === undefined) {
    return [];
  }

  const doorSlotToRoomGridIndexes = getRoomShapeAdjacentNonExistingGridIndexes(
    roomDescriptor.SafeGridIndex,
    roomData.Shape,
  );

  const roomCandidates: Array<{
    readonly doorSlot: DoorSlot;
    readonly roomGridIndex: int;
  }> = [];

  for (const [doorSlot, adjacentRoomGridIndex] of doorSlotToRoomGridIndexes) {
    // The "getRoomShapeAdjacentNonExistingGridIndexes" returns grid indexes for every possible
    // door, but the real room we are examining will only have a subset of these doors. Thus, we
    // have to exclude adjacent grid indexes where it would not be possible to place a door.
    const doorSlotFlag = doorSlotToDoorSlotFlag(doorSlot);
    if (!hasFlag(roomData.Doors, doorSlotFlag)) {
      continue;
    }

    // Check to see if hypothetically creating a room at the given room grid index would be a dead
    // end. In other words, if we created the room, we would only want it to connect to one other
    // room (this one).
    if (ensureDeadEnd && !isDeadEnd(adjacentRoomGridIndex)) {
      continue;
    }

    roomCandidates.push({
      doorSlot,
      roomGridIndex: adjacentRoomGridIndex,
    });
  }

  return roomCandidates;
}

/**
 * Helper function to get all of the spots on the floor to insert a brand new room.
 *
 * @param ensureDeadEnd Optional. Whether to only include spots that are a valid dead end attached
 *                      to a normal room. If false, the function will include all valid spots that
 *                      have a red door.
 * @returns A array of tuples containing the adjacent room grid index, the `DoorSlot`, and the new
 *          room grid index.
 */
export function getNewRoomCandidatesForLevel(
  ensureDeadEnd = true,
): ReadonlyArray<{
  readonly adjacentRoomGridIndex: int;
  readonly doorSlot: DoorSlot;
  readonly newRoomGridIndex: int;
}> {
  // We want to iterate over every room on the floor and search for potential new room spots.
  const roomsInsideGrid = getRoomsInsideGrid();

  // However, we want to filter out special rooms because they are supposed to be dead ends.
  const normalRooms = roomsInsideGrid.filter(
    (room) =>
      room.Data !== undefined &&
      room.Data.Type === RoomType.DEFAULT &&
      !isMirrorRoom(room.Data) && // Mirror rooms do not count as special rooms.
      !isMineShaft(room.Data), // Mineshaft rooms do not count as special rooms.
  );

  const roomsToLookThrough = ensureDeadEnd ? normalRooms : roomsInsideGrid;

  const newRoomCandidates: Array<{
    readonly adjacentRoomGridIndex: int;
    readonly doorSlot: DoorSlot;
    readonly newRoomGridIndex: int;
  }> = [];

  for (const room of roomsToLookThrough) {
    const newRoomCandidatesBesideRoom = getNewRoomCandidatesBesideRoom(
      room.SafeGridIndex,
      ensureDeadEnd,
    );
    for (const { doorSlot, roomGridIndex } of newRoomCandidatesBesideRoom) {
      newRoomCandidates.push({
        adjacentRoomGridIndex: room.SafeGridIndex,
        doorSlot,
        newRoomGridIndex: roomGridIndex,
      });
    }
  }

  return newRoomCandidates;
}

/**
 * Helper function to get the grid indexes of all the rooms connected to the given room index,
 * taking the shape of the room into account. (This will only include rooms with valid data.)
 *
 * Returns an empty map if the provided room grid index is out of bounds or has no associated room
 * data.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns A map of `DoorSlot` to the corresponding room grid index.
 */
export function getRoomAdjacentGridIndexes(
  roomGridIndex?: int,
): ReadonlyMap<DoorSlot, int> {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);

  if (!isRoomInsideGrid(roomDescriptor.SafeGridIndex)) {
    return new Map();
  }

  const roomData = roomDescriptor.Data;
  if (roomData === undefined) {
    return new Map();
  }

  return getRoomShapeAdjacentExistingGridIndexes(
    roomDescriptor.SafeGridIndex,
    roomData.Shape,
  );
}

/**
 * Helper function to get an array of all of the room descriptors for rooms that match the specified
 * room type.
 *
 * This function only searches through rooms in the current dimension and rooms inside the grid.
 *
 * This function is variadic, meaning that you can specify N arguments to get the combined room
 * descriptors for N room types.
 */
export function getRoomDescriptorsForType(
  ...roomTypes: readonly RoomType[]
): readonly RoomDescriptor[] {
  const roomTypesSet = new Set<RoomType>(roomTypes);

  const roomsInsideGrid = getRoomsInsideGrid();
  return roomsInsideGrid.filter(
    (roomDescriptor) =>
      roomDescriptor.Data !== undefined &&
      roomTypesSet.has(roomDescriptor.Data.Type),
  );
}

/**
 * Helper function to get an array of all of the safe grid indexes for rooms that match the
 * specified room type.
 *
 * This function only searches through rooms in the current dimension.
 *
 * This function is variadic, meaning that you can specify N arguments to get the combined grid
 * indexes for N room types.
 */
export function getRoomGridIndexesForType(
  ...roomTypes: readonly RoomType[]
): readonly int[] {
  const roomDescriptors = getRoomDescriptorsForType(...roomTypes);
  return roomDescriptors.map((roomDescriptor) => roomDescriptor.SafeGridIndex);
}

/**
 * Helper function to get only the adjacent room grid indexes for a room shape that exist (i.e. have
 * room data).
 *
 * This is just a filtering of the results of the `getRoomShapeAdjacentGridIndexes` function. See
 * that function for more information.
 */
export function getRoomShapeAdjacentExistingGridIndexes(
  safeRoomGridIndex: int,
  roomShape: RoomShape,
): ReadonlyMap<DoorSlot, int> {
  const roomShapeAdjacentGridIndexes = copyMap(
    getRoomShapeAdjacentGridIndexes(safeRoomGridIndex, roomShape),
  );

  for (const [doorSlot, roomGridIndex] of roomShapeAdjacentGridIndexes) {
    const roomData = getRoomData(roomGridIndex);
    if (roomData === undefined) {
      roomShapeAdjacentGridIndexes.delete(doorSlot);
    }
  }

  return roomShapeAdjacentGridIndexes;
}

/**
 * Helper function to get the room grid index delta that each hypothetical door in a given room
 * shape would go to.
 *
 * This is used by the `getRoomShapeAdjacentGridIndexes` function.
 *
 * @returns A map of `DoorSlot` to the corresponding room grid index delta.
 */
export function getRoomShapeAdjacentGridIndexDeltas(
  roomShape: RoomShape,
): ReadonlyMap<DoorSlot, int> {
  return ROOM_SHAPE_TO_DOOR_SLOTS_TO_GRID_INDEX_DELTA[roomShape];
}

/**
 * Helper function to get the room grid index that each hypothetical door in a given room shape
 * would go to. (This will not include room grid indexes that are outside of the grid.)
 *
 * @param safeRoomGridIndex This must be the room safe grid index (i.e. the top-left room grid index
 *                          for the respective room).
 * @param roomShape The shape of the hypothetical room.
 * @returns A map of `DoorSlot` to the corresponding room grid index.
 */
export function getRoomShapeAdjacentGridIndexes(
  safeRoomGridIndex: int,
  roomShape: RoomShape,
): ReadonlyMap<DoorSlot, int> {
  const roomShapeAdjacentGridIndexDeltas =
    getRoomShapeAdjacentGridIndexDeltas(roomShape);

  const adjacentGridIndexes = new Map<DoorSlot, int>();
  for (const [doorSlot, delta] of roomShapeAdjacentGridIndexDeltas) {
    const roomGridIndex = safeRoomGridIndex + delta;
    if (isRoomInsideGrid(roomGridIndex)) {
      adjacentGridIndexes.set(doorSlot, roomGridIndex);
    }
  }

  return adjacentGridIndexes;
}

/**
 * Helper function to get only the adjacent room grid indexes for a room shape that do not exist
 * (i.e. do not have room data).
 *
 * This is just a filtering of the results of the `getRoomShapeAdjacentGridIndexes` function. See
 * that function for more information.
 */
export function getRoomShapeAdjacentNonExistingGridIndexes(
  safeRoomGridIndex: int,
  roomShape: RoomShape,
): ReadonlyMap<DoorSlot, int> {
  const roomShapeAdjacentGridIndexes = copyMap(
    getRoomShapeAdjacentGridIndexes(safeRoomGridIndex, roomShape),
  );

  for (const [doorSlot, roomGridIndex] of roomShapeAdjacentGridIndexes) {
    const roomData = getRoomData(roomGridIndex);
    if (roomData !== undefined) {
      roomShapeAdjacentGridIndexes.delete(doorSlot);
    }
  }

  return roomShapeAdjacentGridIndexes;
}

/**
 * Helper function to determine if the current room grid index is inside of the normal 13x13 level
 * grid.
 *
 * For example, Devil Rooms and the Mega Satan room are not considered to be inside the grid.
 */
export function inGrid(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isRoomInsideGrid(roomGridIndex);
}

/**
 * Helper function to detect if the current room was created by the Red Key item.
 *
 * Under the hood, this checks for the `RoomDescriptorFlag.FLAG_RED_ROOM` flag.
 */
export function inRedKeyRoom(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isRedKeyRoom(roomGridIndex);
}

/**
 * Helper function to check if the given room grid index is a dead end. Specifically, this is
 * defined as having only one adjacent room that exists.
 *
 * Note that this function does not take the shape of the room into account; it only looks at a
 * single room grid index.
 *
 * This function does not care if the given room grid index actually exists, so you can use it to
 * check if a hypothetical room would be a dead end.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function isDeadEnd(roomGridIndex?: int): boolean {
  const adjacentExistingRoomGridIndexes =
    getAdjacentExistingRoomGridIndexes(roomGridIndex);

  return adjacentExistingRoomGridIndexes.length === 1;
}

export function isDoorSlotValidAtGridIndex(
  doorSlot: DoorSlot,
  roomGridIndex: int,
): boolean {
  const allowedDoors = getRoomAllowedDoors(roomGridIndex);
  return allowedDoors.has(doorSlot);
}

export function isDoorSlotValidAtGridIndexForRedRoom(
  doorSlot: DoorSlot,
  roomGridIndex: int,
): boolean {
  const doorSlotValidAtGridIndex = isDoorSlotValidAtGridIndex(
    doorSlot,
    roomGridIndex,
  );
  if (!doorSlotValidAtGridIndex) {
    return false;
  }

  const roomShape = getRoomShape(roomGridIndex);
  if (roomShape === undefined) {
    return false;
  }

  const delta = getGridIndexDelta(roomShape, doorSlot);
  if (delta === undefined) {
    return false;
  }

  const redRoomGridIndex = roomGridIndex + delta;
  return !roomExists(redRoomGridIndex) && isRoomInsideGrid(redRoomGridIndex);
}

/**
 * Helper function to detect if the provided room was created by the Red Key item.
 *
 * Under the hood, this checks for the `RoomDescriptorFlag.FLAG_RED_ROOM` flag.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function isRedKeyRoom(roomGridIndex: int): boolean {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);
  return hasFlag(roomDescriptor.Flags, RoomDescriptorFlag.RED_ROOM);
}

/**
 * Helper function to determine if a given room grid index is inside of the normal 13x13 level grid.
 *
 * For example, Devil Rooms and the Mega Satan room are not considered to be inside the grid.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function isRoomInsideGrid(roomGridIndex?: int): boolean {
  if (roomGridIndex === undefined) {
    roomGridIndex = getRoomGridIndex();
  }

  return roomGridIndex >= 0 && roomGridIndex <= MAX_LEVEL_GRID_INDEX;
}

/**
 * Helper function to generate a new room on the floor.
 *
 * If you want to generate an unseeded room, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * Under the hood, this function uses the `Level.MakeRedRoomDoor` method to create the room.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. Default is `Level.GetDungeonPlacementSeed`.
 *                  Note that the RNG is only used to select the random location to put the room on
 *                  the floor; it does not influence the randomly chosen room contents. (That is
 *                  performed by the game and can not be manipulated prior to its generation.)
 * @param ensureDeadEnd Optional. Whether to place the room at a valid dead end attached to a normal
 *                      room. If false, it will randomly appear at any valid location that would
 *                      have a red door.
 * @param customRoomData Optional. By default, the newly created room will have data corresponding
 *                       to the game's randomly generated red room. If you provide this function
 *                       with room data, it will be used to override the vanilla data.
 * @returns The room grid index of the new room or undefined if the floor had no valid dead ends to
 *          place a room.
 */
export function newRoom(
  seedOrRNG: Seed | RNG | undefined,
  ensureDeadEnd = true,
  customRoomData?: RoomConfig,
): int | undefined {
  const level = game.GetLevel();

  if (seedOrRNG === undefined) {
    seedOrRNG = level.GetDungeonPlacementSeed();
  }
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  const newRoomCandidate = getNewRoomCandidate(rng, ensureDeadEnd);
  if (newRoomCandidate === undefined) {
    return undefined;
  }
  const { adjacentRoomGridIndex, doorSlot, newRoomGridIndex } =
    newRoomCandidate;

  level.MakeRedRoomDoor(adjacentRoomGridIndex, doorSlot);

  // By default, the room will be a "red room" and have a red graphical tint, so we want to make it
  // a normal room.
  const roomDescriptor = getRoomDescriptor(newRoomGridIndex);
  roomDescriptor.Flags = removeFlag(
    roomDescriptor.Flags,
    RoomDescriptorFlag.RED_ROOM,
  );

  if (customRoomData !== undefined) {
    roomDescriptor.Data = customRoomData;
  }

  // By default, the new room will not appear on the map, even if the player has The Mind. Thus, we
  // must manually alter the `DisplayFlags` of the room descriptor.
  const roomData = roomDescriptor.Data;
  if (roomData !== undefined) {
    const hasFullMap = level.GetStateFlag(LevelStateFlag.FULL_MAP_EFFECT);
    const hasCompass = level.GetStateFlag(LevelStateFlag.COMPASS_EFFECT);
    const hasBlueMap = level.GetStateFlag(LevelStateFlag.BLUE_MAP_EFFECT);
    const roomType = roomData.Type;
    const isSecretRoom = isSecretRoomType(roomType);

    if (hasFullMap) {
      roomDescriptor.DisplayFlags = ALL_DISPLAY_FLAGS;
    } else if (!isSecretRoom && hasCompass) {
      roomDescriptor.DisplayFlags = addFlag(
        DisplayFlag.VISIBLE,
        DisplayFlag.SHOW_ICON,
      );
    } else if (isSecretRoom && hasBlueMap) {
      roomDescriptor.DisplayFlags = addFlag(
        DisplayFlag.VISIBLE,
        DisplayFlag.SHOW_ICON,
      );
    }
  }

  return newRoomGridIndex;
}

/**
 * Helper function to check if a room exists at the given room grid index. (A room will exist if it
 * has non-undefined data in the room descriptor.)
 */
export function roomExists(roomGridIndex: int): boolean {
  const roomData = getRoomData(roomGridIndex);
  return roomData !== undefined;
}

/**
 * Helper function to get the coordinates of a given room grid index. The floor is represented by a
 * 13x13 grid.
 *
 * - Since the starting room is in the center, the starting room grid index of 84 is equal to
 *   coordinates of (6, 6).
 * - The top-left grid index of 0 is equal to coordinates of: (12, 0)
 * - The top-right grid index of 12 is equal to coordinates of: (0, 0)
 * - The bottom-left grid index of 156 is equal to coordinates of: (0, 12)
 * - The bottom-right grid index of 168 is equal to coordinates of: (12, 12)
 */
export function roomGridIndexToVector(roomGridIndex: int): Readonly<Vector> {
  const x = roomGridIndex % LEVEL_GRID_ROW_WIDTH;
  const y = Math.floor(roomGridIndex / LEVEL_GRID_ROW_WIDTH);

  return Vector(x, y);
}

/**
 * Helper function to convert a room grid index expressed as a vector back into an integer.
 *
 * Also see the `roomGridIndexToVector` helper function.
 */
export function vectorToRoomGridIndex(roomVector: Vector): int {
  return roomVector.Y * LEVEL_GRID_ROW_WIDTH + roomVector.X;
}

----
functions\log.ts
import { isNumber } from "./types";

/**
 * Helper function to get the name and the line number of the current calling function.
 *
 * For this function to work properly, the "--luadebug" flag must be enabled. Otherwise, it will
 * always return undefined.
 *
 * @param levels Optional. The amount of levels to look backwards in the call stack. Default is 3
 *               (because the first level is this function, the second level is the calling
 *               function, and the third level is the parent of the calling function).
 */
export function getParentFunctionDescription(
  this: void,
  // We use 3 as a default because:
  // - The first level is this function.
  // - The second level is the calling function.
  // - The third level is the parent of the calling function.
  levels = 3,
): string | undefined {
  // "debug" is not always defined like the Lua definitions imply.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (debug !== undefined) {
    // The "--luadebug" launch flag is enabled.
    const debugTable = debug.getinfo(levels);
    if (debugTable !== undefined) {
      return `${debugTable.name}:${debugTable.linedefined}`;
    }
  }

  if (SandboxGetParentFunctionDescription !== undefined) {
    // The Racing+ sandbox is enabled.
    return SandboxGetParentFunctionDescription(levels);
  }

  return undefined;
}

/**
 * Helper function to avoid typing out `Isaac.DebugString()`.
 *
 * If you have the "--luadebug" launch flag turned on, then this function will also prepend the
 * function name and the line number before the string, like this:
 *
 * ```text
 * [INFO] - Lua Debug: saveToDisk:42494 - The save data manager wrote data to the "save#.dat" file.
 * ```
 *
 * Subsequently, it is recommended that you turn on the "--luadebug" launch flag when developing
 * your mod so that debugging becomes a little bit easier.
 *
 * @param msg The message to log.
 * @param includeParentFunction Optional. Whether to prefix the message with the function name and
 *                              line number, as shown in the above example. Default is true.
 */
export function log(
  this: void,
  msg: string | number,
  includeParentFunction = true,
): void {
  if (isNumber(msg)) {
    msg = msg.toString();
  }

  const parentFunctionDescription = includeParentFunction
    ? getParentFunctionDescription()
    : undefined;
  const debugMsg =
    parentFunctionDescription === undefined
      ? msg
      : `${parentFunctionDescription} - ${msg}`;
  Isaac.DebugString(debugMsg);
}

/**
 * Helper function to log a message to the "log.txt" file and to print it to the screen at the same
 * time.
 */
export function logAndPrint(msg: string): void {
  log(msg);
  print(msg);
}

/**
 * Helper function to log an error message and also print it to the console for better visibility.
 *
 * This is useful in situations where using the `error` function would be dangerous (since it
 * prevents all of the subsequent code in the callback from running).
 */
export function logError(this: void, msg: string): void {
  const errorMsg = `Error: ${msg}`;
  logAndPrint(errorMsg);
}

----
functions\logEntities.ts
import {
  BombVariant,
  EffectVariant,
  EntityType,
  FamiliarVariant,
  GridEntityType,
  KnifeVariant,
  LaserVariant,
  PickupVariant,
  PlayerVariant,
  ProjectileVariant,
  TearVariant,
} from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";
import { getEntities, getEntityFromPtrHash, getEntityID } from "./entities";
import { getGridEntities, getGridEntityID } from "./gridEntities";
import { log } from "./log";

const IGNORE_EFFECT_VARIANTS = new ReadonlySet<EffectVariant>([
  EffectVariant.BLOOD_EXPLOSION, // 2
  EffectVariant.BLOOD_PARTICLE, // 5
  EffectVariant.TINY_BUG, // 21
  EffectVariant.TINY_FLY, // 33
  EffectVariant.WATER_DROPLET, // 41
  EffectVariant.WORM, // 63
  EffectVariant.WALL_BUG, // 68
  EffectVariant.FALLING_EMBER, // 87
  EffectVariant.LIGHT, // 121
  EffectVariant.MIST, // 138
  EffectVariant.BACKDROP_DECORATION, // 140
  EffectVariant.TADPOLE, // 158
]);

/** Helper function for printing out every entity (or filtered entity) in the current room. */
export function logAllEntities(
  this: void,
  includeBackgroundEffects: boolean,
  entityTypeFilter?: EntityType,
): void {
  let msg = "Entities in the room";
  if (entityTypeFilter !== undefined) {
    msg += ` (filtered to entity type ${entityTypeFilter})`;
  } else if (!includeBackgroundEffects) {
    msg += " (not including background effects)";
  }
  msg += ":\n";

  const entities = getEntities();
  let numMatchedEntities = 0;

  for (const [i, entity] of entities.entries()) {
    // If a filter was specified, exclude all entities outside of the filter.
    if (entityTypeFilter !== undefined && entity.Type !== entityTypeFilter) {
      continue;
    }

    const effect = entity.ToEffect();
    if (
      !includeBackgroundEffects &&
      effect !== undefined &&
      IGNORE_EFFECT_VARIANTS.has(effect.Variant)
    ) {
      continue;
    }

    msg += getEntityLogLine(entity, i + 1);
    numMatchedEntities++;
  }

  const zeroText = "(no entities matched)";
  const oneOrMoreText = `(${numMatchedEntities} total ${
    numMatchedEntities === 1 ? "entity" : "entities"
  })`;
  const text = numMatchedEntities === 0 ? zeroText : oneOrMoreText;

  msg += `${text}\n`;

  // We must log each line because otherwise the message can get truncated.
  for (const line of msg.trim().split("\n")) {
    log(line);
  }
}

/**
 * Helper function for printing out every grid entity (or filtered grid entity) in the current room.
 *
 * @param includeWalls Optional. Whether oto log the walls. Default is false.
 * @param gridEntityTypeFilter Optional. If specified, will only log the given `GridEntityType`.
 *                             Default is undefined.
 */
export function logAllGridEntities(
  this: void,
  includeWalls = false,
  gridEntityTypeFilter?: GridEntityType,
): void {
  let msg = "Grid entities in the room";
  if (gridEntityTypeFilter !== undefined) {
    msg += ` (filtered to grid entity type ${gridEntityTypeFilter})`;
  } else if (!includeWalls) {
    msg += " (not including walls)";
  }
  msg += ":\n";

  const gridEntities = getGridEntities();
  let numMatchedEntities = 0;
  for (const gridEntity of gridEntities) {
    const gridEntityIndex = gridEntity.GetGridIndex();
    const gridEntityType = gridEntity.GetType();

    // If a filter was specified, exclude all entities outside of the filter.
    if (
      gridEntityTypeFilter !== undefined &&
      gridEntityType !== gridEntityTypeFilter
    ) {
      continue;
    }

    if (
      !includeWalls &&
      gridEntityType === GridEntityType.WALL &&
      gridEntityTypeFilter !== GridEntityType.WALL
    ) {
      continue;
    }

    msg += getGridEntityLogLine(gridEntity, gridEntityIndex);

    numMatchedEntities++;
  }

  msg +=
    numMatchedEntities === 0
      ? "(no grid entities matched)\n"
      : `(${numMatchedEntities} total grid ${
          numMatchedEntities === 1 ? "entity" : "entities"
        })\n`;

  // We must log each line because otherwise the message can get truncated.
  for (const line of msg.trim().split("\n")) {
    log(line);
  }
}

/** Helper function for logging an array of specific entities. */
export function logEntities(this: void, entities: readonly Entity[]): void {
  for (const entity of entities) {
    logEntity(entity);
  }
}

/** Helper function to log information about a specific entity. */
export function logEntity(this: void, entity: Entity): void {
  const msg = getEntityLogLine(entity);
  log(msg);
}

function getEntityLogLine(this: void, entity: Entity, num?: int): string {
  let msg = num === undefined ? "" : `${num}) `;

  msg += getEntityID(entity);

  const bomb = entity.ToBomb();
  if (bomb !== undefined) {
    msg += ` (bomb - ${getBombVariantName(bomb)})`;
  }

  const effect = entity.ToEffect();
  if (effect !== undefined) {
    msg += ` (effect - ${getEffectVariantName(effect)}) (State: ${
      effect.State
    })`;
  }

  const familiar = entity.ToFamiliar();
  if (familiar !== undefined) {
    msg += ` (familiar - ${getFamiliarVariantName(familiar)}) (State: ${
      familiar.State
    })`;
  }

  const knife = entity.ToKnife();
  if (knife !== undefined) {
    msg += ` (knife - ${getKnifeVariantName(knife)})`;
  }

  const laser = entity.ToLaser();
  if (laser !== undefined) {
    msg += ` (laser - ${getLaserVariantName(laser)})`;
  }

  const npc = entity.ToNPC();
  if (npc !== undefined) {
    msg += ` (NPC - ${getEntityTypeName(npc)}) (State: ${npc.State})`;
  }

  const pickup = entity.ToPickup();
  if (pickup !== undefined) {
    msg += ` (pickup - ${getPickupVariantName(pickup)}) (State: ${
      pickup.State
    })`;
  }

  const player = entity.ToPlayer();
  if (player !== undefined) {
    msg += ` (player - ${getPlayerVariantName(player)})`;
  }

  const projectile = entity.ToProjectile();
  if (projectile !== undefined) {
    msg += ` (projectile - ${getProjectileVariantName(projectile)})`;
  }

  const tear = entity.ToTear();
  if (tear !== undefined) {
    msg += ` (tear - ${getTearVariantName(tear)})`;
  }

  msg += "\n";
  msg += `  - Index: ${entity.Index}\n`;
  msg += `  - InitSeed: ${entity.InitSeed}\n`;
  msg += `  - DropSeed: ${entity.DropSeed}\n`;
  msg += `  - Position: (${entity.Position.X}, ${entity.Position.Y})\n`;
  msg += `  - Velocity: (${entity.Velocity.X}, ${entity.Velocity.Y})\n`;
  msg += `  - HP: ${entity.HitPoints} / ${entity.MaxHitPoints}\n`;
  msg += `  - Parent: ${entity.Parent}\n`;
  msg += `  - Child: ${entity.Child}\n`;
  msg += `  - SpawnerEntity: ${entity.SpawnerEntity}\n`;
  msg += `  - SpawnerType / SpawnerVariant: ${entity.SpawnerType}.${entity.SpawnerVariant}\n`;
  msg += `  - FrameCount: ${entity.FrameCount}\n`;
  if (npc !== undefined) {
    msg += `  - CanShutDoors: ${npc.CanShutDoors}\n`;
  }

  return msg;
}

function getBombVariantName(bomb: EntityBomb) {
  // Handle modded entities.
  const enumName = BombVariant[bomb.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `BombVariant.${enumName}`;
}

function getEffectVariantName(effect: EntityEffect) {
  // Handle modded entities.
  const enumName = EffectVariant[effect.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `EffectVariant.${enumName}`;
}

function getFamiliarVariantName(familiar: EntityFamiliar) {
  // Handle modded entities.
  const enumName = FamiliarVariant[familiar.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `FamiliarVariant.${enumName}`;
}

function getKnifeVariantName(knife: EntityKnife) {
  // Handle modded entities.
  const enumName = KnifeVariant[knife.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `KnifeVariant.${enumName}`;
}

function getLaserVariantName(laser: EntityLaser) {
  // Handle modded entities.
  const enumName = LaserVariant[laser.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `LaserVariant.${enumName}`;
}

function getEntityTypeName(npc: EntityNPC) {
  // Handle modded entities.
  const enumName = EntityType[npc.Type] as string | undefined;
  return enumName === undefined ? "unknown" : `EntityType.${enumName}`;
}

function getPickupVariantName(pickup: EntityPickup) {
  // Handle modded entities.
  const enumName = PickupVariant[pickup.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `PickupVariant.${enumName}`;
}

function getPlayerVariantName(player: EntityPlayer) {
  // Handle modded entities.
  const enumName = PlayerVariant[player.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `PlayerVariant.${enumName}`;
}

function getProjectileVariantName(projectile: EntityProjectile) {
  // Handle modded entities.
  const enumName = ProjectileVariant[projectile.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `ProjectileVariant.${enumName}`;
}

function getTearVariantName(tear: EntityTear) {
  // Handle modded entities.
  const enumName = TearVariant[tear.Variant] as string | undefined;
  return enumName === undefined ? "unknown" : `TearVariant.${enumName}`;
}

/** Helper function for logging an array of specific grid entities. */
export function logGridEntities(
  this: void,
  gridEntities: readonly GridEntity[],
): void {
  for (const gridEntity of gridEntities) {
    logGridEntity(gridEntity);
  }
}

/** Helper function for log information about a specific grid entity. */
export function logGridEntity(this: void, gridEntity: GridEntity): void {
  const msg = getGridEntityLogLine(gridEntity);
  log(msg);
}

function getGridEntityLogLine(
  this: void,
  gridEntity: GridEntity,
  num?: int,
): string {
  const gridEntityDesc = gridEntity.GetSaveState();

  let msg = num === undefined ? "" : `${num}) `;

  msg += getGridEntityID(gridEntity);

  const door = gridEntity.ToDoor();
  if (door !== undefined) {
    msg += " (door)";
  }

  const pit = gridEntity.ToPit();
  if (pit !== undefined) {
    msg += " (pit)";
  }

  const poop = gridEntity.ToPoop();
  if (poop !== undefined) {
    msg += " (poop)";
  }

  const pressurePlate = gridEntity.ToPressurePlate();
  if (pressurePlate !== undefined) {
    msg += " (pressurePlate)";
  }

  const rock = gridEntity.ToRock();
  if (rock !== undefined) {
    msg += " (rock)";
  }

  const spikes = gridEntity.ToSpikes();
  if (spikes !== undefined) {
    msg += " (spikes)";
  }

  const tnt = gridEntity.ToTNT();
  if (tnt !== undefined) {
    msg += " (TNT)";
  }

  msg += `  - State: ${gridEntity.State}\n`;
  msg += `  - VarData: ${gridEntity.VarData}\n`;
  msg += `  - Position: (${gridEntity.Position.X}, ${gridEntity.Position.Y})\n`;
  msg += `  - SpawnSeed: ${gridEntityDesc.SpawnSeed}\n`;
  msg += `  - VariableSeed: ${gridEntityDesc.VariableSeed})\n`;
  if (door !== undefined) {
    msg += `  - Slot: ${door.Slot}\n`;
    msg += `  - Direction: ${door.Direction}\n`;
    msg += `  - TargetRoomIndex: ${door.TargetRoomIndex}\n`;
    msg += `  - TargetRoomType: ${door.TargetRoomType}\n`;
  }

  return msg;
}

/**
 * Helper function to log information about the entity that corresponding to a pointer hash. (Only
 * use this when debugging, since retrieving the corresponding entity is expensive.)
 */
export function logPtrHash(this: void, ptrHash: PtrHash): void {
  log(`PtrHash: ${ptrHash}`);
  const entity = getEntityFromPtrHash(ptrHash);
  if (entity === undefined) {
    log("No corresponding entity found.");
  } else {
    logEntity(entity);
  }
}

/**
 * Helper function to log information about the entity that corresponding to one or more pointer
 * hashes. (Only use this when debugging, since retrieving the corresponding entity is expensive.)
 */
export function logPtrHashes(this: void, ptrHashes: readonly PtrHash[]): void {
  for (const ptrHash of ptrHashes) {
    logPtrHash(ptrHash);
  }
}

----
functions\logMisc.ts
import type {
  CollectibleType,
  ItemPoolType,
} from "isaac-typescript-definitions";
import {
  BossID,
  DamageFlag,
  DisplayFlag,
  EntityFlag,
  GameStateFlag,
  GridRoom,
  HeartSubType,
  LevelStateFlag,
  Music,
  ProjectileFlag,
  RoomType,
  SeedEffect,
  SoundEffect,
  StageID,
  TearFlag,
  UseFlag,
} from "isaac-typescript-definitions";
import { game, musicManager, sfxManager } from "../core/cachedClasses";
import type { ReadonlyMap } from "../types/ReadonlyMap";
import type { ReadonlyRecord } from "../types/ReadonlyRecord";
import { ReadonlySet } from "../types/ReadonlySet";
import { arrayToString, isArray } from "./array";
import { getBossID } from "./bosses";
import { getCollectibleName } from "./collectibles";
import { getEntityID } from "./entities";
import { getEnumEntries } from "./enums";
import { hasFlag } from "./flag";
import { getIsaacAPIClassName } from "./isaacAPIClass";
import { getItemPoolName } from "./itemPool";
import { log } from "./log";
import { getEffectsList } from "./playerEffects";
import { getPlayerHealth } from "./playerHealth";
import { getPlayerName } from "./players";
import { getRoomData, getRoomGridIndex, getRoomListIndex } from "./roomData";
import { combineSets, getSortedSetValues } from "./set";
import { sortNormal } from "./sort";
import { iterateTableInOrder } from "./table";
import { getTrinketName } from "./trinkets";
import { isDefaultMap, isTSTLMap, isTSTLSet } from "./tstlClass";
import { isTable, isUserdata } from "./types";
import { vectorToString } from "./vector";

/**
 * Helper function to log all of the values in an array.
 *
 * @param array The array to log.
 * @param name Optional. The name of the array, which will be logged before the elements.
 */
export function logArray<T>(
  this: void,
  array: readonly T[],
  name?: string,
): void {
  // We do not assume the given array has contiguous values in order to be more permissive about the
  // kinds of arrays that will successfully log without a run-time error.
  if (!isArray(array, false)) {
    log("Tried to log an array, but the given object was not an array.");
    return;
  }

  const arrayString = arrayToString(array);
  if (name === undefined) {
    name = "array";
  }
  log(`Logging ${name}: ${arrayString}`);
}

/**
 * Helper function to log the names of a collectible type array.
 *
 * @param collectibleTypes The collectible types to log.
 * @param name Optional. The name of the array, which will be logged before the elements.
 */
export function logCollectibleTypes(
  this: void,
  collectibleTypes: readonly CollectibleType[],
  name?: string,
): void {
  if (name === undefined) {
    name = "collectibles";
  }

  log(`Logging ${name}:`);

  let i = 1;
  for (const collectibleType of collectibleTypes) {
    const collectibleName = getCollectibleName(collectibleType);
    log(`${i}) ${collectibleName} (${collectibleType})`);
    i++;
  }
}

/**
 * Helper function to log a `Color` object.
 *
 * @param color The `Color` object to log.
 * @param name Optional. The name of the object, which will be logged before the properties.
 */
export function logColor(this: void, color: Color, name?: string): void {
  if (name === undefined) {
    name = "color";
  }

  log(
    `Logging ${name}: R${color.R}, G${color.G}, B${color.B}, A${color.A}, RO${color.RO}, BO${color.BO}, GO${color.GO}`,
  );
}

/** Helper function to log every damage flag that is turned on. Useful when debugging. */
export function logDamageFlags(
  this: void,
  damageFlags: DamageFlag | BitFlags<DamageFlag>,
): void {
  logFlags(damageFlags, DamageFlag, "damage");
}

/** Helper function to log every display flag that is turned on. Useful when debugging. */
export function logDisplayFlags(
  this: void,
  displayFlags: DisplayFlag | BitFlags<DisplayFlag>,
): void {
  logFlags(displayFlags, DisplayFlag, "display");
}

/** Helper function to log every entity flag that is turned on. Useful when debugging. */
export function logEntityFlags(
  this: void,
  entityFlags: EntityFlag | BitFlags<EntityFlag>,
): void {
  logFlags(entityFlags, EntityFlag, "entity");
}

export function logEntityID(this: void, entity: Entity): void {
  const entityID = getEntityID(entity);
  log(`Logging entity: ${entityID}`);
}

/** Helper function for logging every flag that is turned on. Useful when debugging. */
export function logFlags<T extends BitFlag | BitFlag128>(
  this: void,
  flags: T | BitFlags<T>,
  flagEnum: ReadonlyRecord<string, T>,
  description = "",
): void {
  if (description !== "") {
    description = "flag";
  }

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  log(`Logging ${description} values for: ${flags}`);
  let hasNoFlags = true;
  const entries = getEnumEntries(flagEnum);
  for (const [key, value] of entries) {
    if (hasFlag(flags, value)) {
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      log(`  Has flag: ${key} (${value})`);
      hasNoFlags = false;
    }
  }

  if (hasNoFlags) {
    log("  n/a (no flags)");
  }
}

/** Helper function for logging every game state flag that is turned on. Useful when debugging. */
export function logGameStateFlags(this: void): void {
  log("Logging game state flags:");

  const gameStateFlagEntries = getEnumEntries(GameStateFlag);

  let hasNoFlags = true;
  for (const [key, gameStateFlag] of gameStateFlagEntries) {
    const flagValue = game.GetStateFlag(gameStateFlag);
    if (flagValue) {
      log(`  Has flag: ${key} (${gameStateFlag})`);
      hasNoFlags = false;
    }
  }

  if (hasNoFlags) {
    log("  n/a (no flags)");
  }
}

/**
 * Helper function to log the names of a item pool type array.
 *
 * @param itemPoolTypes The item pool types to log.
 * @param name Optional. The name of the array, which will be logged before the elements.
 */
export function logItemPoolTypes(
  this: void,
  itemPoolTypes: readonly ItemPoolType[],
  name?: string,
): void {
  if (name === undefined) {
    name = "item pool types";
  }

  log(`Logging ${name}:`);

  let i = 1;
  for (const itemPoolType of itemPoolTypes) {
    const itemPoolName = getItemPoolName(itemPoolType);
    log(`${i}) ${itemPoolName} (${itemPoolType})`);
    i++;
  }
}

/**
 * Helper function to log a `KColor` object.
 *
 * @param kColor The `KColor` object to log.
 * @param name Optional. The name of the object, which will be logged before the properties.
 */
export function logKColor(this: void, kColor: KColor, name?: string): void {
  if (name === undefined) {
    name = "KColor";
  }

  log(
    `Logging ${name}: R${kColor.Red}, G${kColor.Green}, B${kColor.Blue}, A${kColor.Alpha}`,
  );
}

/** Helper function for logging every level state flag that is turned on. Useful when debugging. */
export function logLevelStateFlags(this: void): void {
  const level = game.GetLevel();

  const levelStateFlagEntries = getEnumEntries(LevelStateFlag);

  log("Logging level state flags:");
  let hasNoFlags = true;
  for (const [key, levelStateFlag] of levelStateFlagEntries) {
    const flagValue = level.GetStateFlag(levelStateFlag);
    if (flagValue) {
      log(`  Has flag: ${key} (${levelStateFlag})`);
      hasNoFlags = false;
    }
  }

  if (hasNoFlags) {
    log("  n/a (no flags)");
  }
}

/**
 * Helper function to log a TSTL `Map`.
 *
 * @param map The TSTL `Map` to log.
 * @param name Optional. The name of the map, which will be logged before the elements.
 */
export function logMap(
  this: void,
  map: ReadonlyMap<number | string, unknown>,
  name?: string,
): void {
  if (!isTSTLMap(map) && !isDefaultMap(map)) {
    log("Tried to log a TSTL map, but the given object was not a TSTL map.");
    return;
  }

  const suffix = name === undefined ? "" : ` "${name}"`;
  log(`Logging a TSTL map${suffix}:`);

  const mapKeys = [...map.keys()];
  mapKeys.sort(sortNormal);

  for (const key of mapKeys) {
    const value = map.get(key);
    log(`  ${key} --> ${value}`);
  }

  log(`  The size of the map was: ${map.size}`);
}

export function logMusic(this: void): void {
  const currentMusic = musicManager.GetCurrentMusicID();
  log(
    `Currently playing music track: ${Music[currentMusic]} (${currentMusic})`,
  );
}

export function logPlayerEffects(this: void, player: EntityPlayer): void {
  const effects = getEffectsList(player);

  log("Logging player effects:");

  if (effects.length === 0) {
    log("  n/a (no effects)");
    return;
  }

  for (const [i, effect] of effects.entries()) {
    let effectDescription: string;
    if (effect.Item.IsCollectible()) {
      const collectibleName = getCollectibleName(effect.Item.ID);
      effectDescription = `Collectible: ${collectibleName}`;
    } else if (effect.Item.IsTrinket()) {
      const trinketName = getTrinketName(effect.Item.ID);
      effectDescription = `Trinket: ${trinketName}`;
    } else if (effect.Item.IsNull()) {
      effectDescription = `Null item: ${effect.Item.ID}`;
    } else {
      effectDescription = `Unknown type of effect: ${effect.Item.ID}`;
    }

    log(`  ${i + 1}) ${effectDescription} (x${effect.Count})`);
  }
}

export function logPlayerHealth(this: void, player: EntityPlayer): void {
  const playerName = getPlayerName(player);
  const playerHealth = getPlayerHealth(player);

  log(`Player health for ${playerName}:`);
  log(`  Max hearts: ${playerHealth.maxHearts}`);
  log(`  Hearts: ${playerHealth.hearts}`);
  log(`  Eternal hearts: ${playerHealth.eternalHearts}`);
  log(`  Soul hearts: ${playerHealth.soulHearts}`);
  log(`  Bone hearts: ${playerHealth.boneHearts}`);
  log(`  Golden hearts: ${playerHealth.goldenHearts}`);
  log(`  Rotten hearts: ${playerHealth.rottenHearts}`);
  log(`  Broken hearts: ${playerHealth.brokenHearts}`);
  log(`  Soul charges: ${playerHealth.soulCharges}`);
  log(`  Blood charges: ${playerHealth.bloodCharges}`);
  log("  Soul heart types: [");
  for (const soulHeartType of playerHealth.soulHeartTypes) {
    log(`    HeartSubType.${HeartSubType[soulHeartType]}`);
  }
  log("  ]");
}

/** Helper function for logging every projectile flag that is turned on. Useful when debugging. */
export function logProjectileFlags(
  this: void,
  projectileFlags: ProjectileFlag | BitFlags<ProjectileFlag>,
): void {
  logFlags(projectileFlags, ProjectileFlag, "projectile");
}

/** Helper function for logging information about the current room. */
export function logRoom(this: void): void {
  const bossID = getBossID();
  const roomGridIndex = getRoomGridIndex();
  const roomListIndex = getRoomListIndex();
  const roomData = getRoomData();

  log("Logging room information:");
  log(`- Room stage ID: ${StageID[roomData.StageID]} (roomData.StageID)`);
  log(`- Room type: ${RoomType[roomData.Type]} (${roomData.Type})`);
  log(`- Variant: ${roomData.Variant}`);
  log(`- Sub-type: ${roomData.Subtype}`);
  log(`- Name: ${roomData.Name}`);

  const roomGridIndexName = GridRoom[roomGridIndex];
  if (roomGridIndexName === undefined) {
    log(`- Grid index: ${roomGridIndex}`);
  } else {
    log(`- Grid index: ${roomGridIndexName} (${roomGridIndex})`);
  }

  log(`- List index: ${roomListIndex}`);
  if (bossID === undefined) {
    log("- Boss ID: undefined");
  } else {
    log(`- Boss ID: ${BossID[bossID]} (${bossID})`);
  }
}

/**
 * Helper function for logging every seed effect (i.e. Easter Egg) that is turned on for the
 * particular run.
 */
export function logSeedEffects(this: void): void {
  const seeds = game.GetSeeds();

  const seedEffectEntries = getEnumEntries(SeedEffect);

  log("Logging seed effects:");
  let hasNoSeedEffects = true;
  for (const [key, seedEffect] of seedEffectEntries) {
    if (seeds.HasSeedEffect(seedEffect)) {
      log(`  ${key} (${seedEffect})`);
      hasNoSeedEffects = false;
    }
  }

  if (hasNoSeedEffects) {
    log("  n/a (no seed effects)");
  }
}

/**
 * Helper function to log a TSTL `Set`.
 *
 * @param set The TSTL `Set` to log.
 * @param name Optional. The name of the set, which will be logged before the elements.
 */
export function logSet(
  this: void,
  set: ReadonlySet<number | string>,
  name?: string,
): void {
  if (!isTSTLSet(set)) {
    log("Tried to log a TSTL set, but the given object was not a TSTL set.");
    return;
  }

  const suffix = name === undefined ? "" : ` "${name}"`;
  log(`Logging a TSTL set${suffix}:`);

  const setValues = getSortedSetValues(set);
  for (const value of setValues) {
    log(`  Value: ${value}`);
  }

  log(`  The size of the set was: ${set.size}`);
}

/** Helper function for logging every sound effect that is currently playing. */
export function logSounds(this: void): void {
  const soundEffects = getEnumEntries(SoundEffect);

  for (const [key, soundEffect] of soundEffects) {
    if (sfxManager.IsPlaying(soundEffect)) {
      log(`Currently playing sound effect: ${key} (${soundEffect})`);
    }
  }
}

/**
 * Helper function for logging every key and value of a Lua table. This is a deep log; the function
 * will recursively call itself if it encounters a table within a table.
 *
 * This function will only work on tables that have string keys (because it logs the keys in order,
 * instead of randomly). It will throw a run-time error if it encounters a non-string key.
 *
 * In order to prevent infinite recursion, this function will not log a sub-table when there are 10
 * or more parent tables.
 */
export function logTable(
  this: void,
  luaTable: unknown,
  parentTables = 0,
): void {
  if (parentTables === 0) {
    log("Logging a Lua table:", false);
  } else if (parentTables > 10) {
    return;
  }

  const numSpaces = (parentTables + 1) * 2; // 2, 4, 6, etc.
  const indentation = " ".repeat(numSpaces);

  if (!isTable(luaTable)) {
    log(
      `${indentation}n/a (encountered a variable of type "${typeof luaTable}" instead of a table)`,
      false,
    );

    return;
  }

  let numElements = 0;
  iterateTableInOrder(luaTable, (key, value) => {
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    log(`${indentation}${key} --> ${value}`, false);

    if (isTable(value)) {
      if (key === "__class") {
        log(
          `${indentation}  (skipping enumerating this key to avoid infinite recursion)`,
          false,
        );
      } else {
        logTable(value, parentTables + 1);
      }
    }

    numElements++;
  });

  log(`${indentation}The size of the table was: ${numElements}`, false);
}

/**
 * Helper function to log the differences between the entries of two tables. Note that this will
 * only do a shallow comparison.
 */
export function logTableDifferences<K extends AnyNotNil, V>(
  this: void,
  table1: LuaMap<K, V>,
  table2: LuaMap<K, V>,
): void {
  log("Comparing two Lua tables:");

  const table1Keys = Object.keys(table1);
  const table1KeysSet = new ReadonlySet(table1Keys);

  const table2Keys = Object.keys(table2);
  const table2KeysSet = new ReadonlySet(table2Keys);

  const keysSet = combineSets(table1KeysSet, table2KeysSet);
  const keys = [...keysSet.values()];
  keys.sort(); // eslint-disable-line @typescript-eslint/require-array-sort-compare

  for (const key of keys) {
    const value1 = table1.get(key);
    const value2 = table2.get(key);

    if (value1 === undefined) {
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      log(`  Table 1 is missing key: ${key}`);
    }

    if (value2 === undefined) {
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      log(`  Table 2 is missing key: ${key}`);
    }

    if (value1 !== value2) {
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      log(`  ${key} --> "${value1}" versus "${value2}"`);
    }
  }
}

/**
 * Helper function to log the keys of a Lua table. This is not a deep log; only the keys of the
 * top-most table will be logged.
 *
 * This function is useful for tables that have recursive references.
 */
export function logTableKeys(this: void, luaTable: unknown): void {
  log("Logging the keys of a Lua table:");

  if (!isTable(luaTable)) {
    log(
      `  n/a (encountered a variable of type "${typeof luaTable}" instead of a table)`,
    );
    return;
  }

  let numElements = 0;
  iterateTableInOrder(luaTable, (key) => {
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    log(`${key}`);
    numElements++;
  });

  log(`  The size of the table was: ${numElements}`);
}

/**
 * Helper function to log every table key and value. This is a shallow log; the function will not
 * recursively traverse sub-tables.
 *
 * This function will only work on tables that have string keys (because it logs the keys in order,
 * instead of randomly). It will throw a run-time error if it encounters a non-string key.
 */
export function logTableShallow<K extends AnyNotNil, V>(
  this: void,
  luaTable: LuaMap<K, V>,
): void {
  log("Logging a Lua table (shallow):", false);

  if (!isTable(luaTable)) {
    log(
      `n/a (encountered a variable of type "${typeof luaTable}" instead of a table)`,
      false,
    );

    return;
  }

  let numElements = 0;
  const indentation = "  ";
  iterateTableInOrder(luaTable, (key, value) => {
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    log(`${indentation}${key} --> ${value}`, false);
    numElements++;
  });

  log(`${indentation}The size of the table was: ${numElements}`, false);
}

/** Helper function for log every tear flag that is turned on. Useful when debugging. */
export function logTearFlags(
  this: void,
  tearFlags: TearFlag | BitFlags<TearFlag>,
): void {
  logFlags(tearFlags, TearFlag, "tear");
}

/** Helper function for printing out every use flag that is turned on. Useful when debugging. */
export function logUseFlags(
  this: void,
  useFlags: UseFlag | BitFlags<UseFlag>,
): void {
  logFlags(useFlags, UseFlag, "use");
}

/**
 * Helper function to enumerate all of the properties of a "userdata" object (i.e. an object from
 * the Isaac API).
 */
export function logUserdata(this: void, userdata: unknown): void {
  if (!isUserdata(userdata)) {
    log("Userdata: [not userdata]");
    return;
  }

  const metatable = getmetatable(userdata);
  if (metatable === undefined) {
    log("Userdata: [no metatable]");
    return;
  }

  const classType = getIsaacAPIClassName(userdata);
  if (classType === undefined) {
    log("Userdata: [no class type]");
  } else {
    log(`Userdata: ${classType}`);
  }

  logTable(metatable);
}

/**
 * Helper function to log a `Vector` object.
 *
 * @param vector The `Vector` object to log.
 * @param name Optional. The name of the object, which will be logged before the properties.
 * @param round Optional. If true, will round the vector values to the nearest integer. Default is
 *              false.
 */
export function logVector(
  this: void,
  vector: Vector,
  name?: string,
  round = false,
): void {
  if (name === undefined) {
    name = "vector";
  }

  const vectorString = vectorToString(vector, round);
  log(`Logging ${name}: ${vectorString}`);
}

----
functions\map.ts
import type { DefaultMap } from "../classes/DefaultMap";
import { sumArray } from "./array";

/** Helper function to copy a map. (You can also use a Map constructor to accomplish this task.) */
// eslint-disable-next-line isaacscript/no-mutable-return
export function copyMap<K, V>(oldMap: ReadonlyMap<K, V>): Map<K, V> {
  const newMap = new Map<K, V>();
  for (const [key, value] of oldMap) {
    newMap.set(key, value);
  }

  return newMap;
}

/**
 * Helper function to get the value from a `DefaultMap` that corresponds to an entity, assuming that
 * the map uses `PtrHash` as an index.
 */
export function defaultMapGetHash<V, A extends unknown[]>(
  map: DefaultMap<PtrHash, V, A>,
  entity: Entity,
  ...extraArgs: A
): V {
  const ptrHash = GetPtrHash(entity);
  return map.getAndSetDefault(ptrHash, ...extraArgs);
}

/**
 * Helper function to set a value for a `DefaultMap` that corresponds to an entity, assuming that
 * the map uses `PtrHash` as an index.
 *
 * Since `Map` and `DefaultMap` set values in the same way, this function is simply an alias for the
 * `mapSetHash` helper function.
 */
export function defaultMapSetHash<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PtrHash, V>,
  entity: Entity,
  value: V,
): void {
  mapSetHash(map, entity, value);
}

/**
 * Helper function to get a copy of a map with the keys and the values reversed.
 *
 * For example:
 *
 * ```ts
 * new Map<string, number>([
 *   ["foo", 1],
 *   ["bar", 2],
 * ]);
 * ```
 *
 * Would be reversed to:
 *
 * ```ts
 * new Map<number, string>([
 *   [1, "foo"],
 *   [2, "bar"],
 * ]);
 * ```
 */
export function getReversedMap<K, V>(
  map: ReadonlyMap<K, V>,
): ReadonlyMap<V, K> {
  const reverseMap = new Map<V, K>();

  for (const [key, value] of map) {
    reverseMap.set(value, key);
  }

  return reverseMap;
}

/**
 * Helper function to set a value for a `DefaultMap` that corresponds to an entity, assuming that
 * the map uses `PtrHash` as an index.
 */
export function mapSetHash<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PtrHash, V>,
  entity: Entity,
  value: V,
): void {
  const hash = GetPtrHash(entity);
  map.set(hash, value);
}

/**
 * Helper function to convert an object to a map.
 *
 * This is useful when you need to construct a type safe object with the `satisfies` operator, but
 * then later on you need to query it in a way where you expect the return value to be T or
 * undefined. In this situation, by converting the object to a map, you can avoid unsafe type
 * assertions.
 *
 * Note that the map values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectToReadonlyMap` function.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function objectToMap<K extends string | number | symbol, V>(
  object: Record<K, V>,
): Map<K, V> {
  const map = new Map<K, V>();

  for (const [key, value] of Object.entries(object)) {
    map.set(key as K, value as V);
  }

  return map;
}

/**
 * Helper function to convert an object to a read-only map.
 *
 * This is useful when you need to construct a type safe object with the `satisfies` operator, but
 * then later on you need to query it in a way where you expect the return value to be T or
 * undefined. In this situation, by converting the object to a map, you can avoid unsafe type
 * assertions.
 *
 * Note that the map values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectToMap` function.
 */
export function objectToReadonlyMap<K extends string | number | symbol, V>(
  object: Record<K, V>,
): ReadonlyMap<K, V> {
  return objectToMap(object);
}

/** Helper function to sum every value in a map together. */
export function sumMap(map: ReadonlyMap<unknown, number>): number {
  const values = [...map.values()];
  return sumArray(values);
}

----
functions\math.ts
import { Direction } from "isaac-typescript-definitions";
import { directionToVector } from "./direction";

/**
 * Helper function to normalize a number, ensuring that it is within a certain range.
 *
 * - If `num` is less than `min`, then it will be clamped to `min`.
 * - If `num` is greater than `max`, then it will be clamped to `max`.
 */
export function clamp(num: number, min: number, max: number): number {
  return Math.max(min, Math.min(num, max));
}

export function getAngleDifference(angle1: float, angle2: float): float {
  const subtractedAngle = angle1 - angle2;
  return ((subtractedAngle + 180) % 360) - 180;
}

/**
 * Helper function to get an array of equidistant points on the circumference around a circle.
 * Useful for equally distributing things in a circle pattern.
 *
 * @param centerPos A position that represents the center of the center to get the points from.
 * @param radius The radius of the circle.
 * @param numPoints The number of points on the circumference of the circle to get.
 * @param xMultiplier An optional multiplier to get the points around an oval. Default is 1.
 * @param yMultiplier An optional multiplier to get the points around an oval. Default is 1.
 * @param initialDirection By default, the first point on the circle will be on the top center, but
 *                         this can be optionally changed by specifying this argument.
 */
export function getCircleDiscretizedPoints(
  centerPos: Vector,
  radius: float,
  numPoints: int,
  xMultiplier = 1,
  yMultiplier = 1,
  initialDirection = Direction.UP,
): ReadonlyArray<Readonly<Vector>> {
  const vector = directionToVector(initialDirection);
  const initialPosition = vector.mul(radius);
  const positions: Vector[] = [];
  for (let i = 0; i < numPoints; i++) {
    const rotatedPosition = initialPosition.Rotated((i * 360) / numPoints);
    rotatedPosition.X *= xMultiplier;
    rotatedPosition.Y *= yMultiplier;
    const positionFromCenter = centerPos.add(rotatedPosition);
    positions.push(positionFromCenter);
  }

  return positions;
}

/**
 * Helper function to check if a given position is within a given rectangle.
 *
 * This is an inclusive check, meaning that it will return true if the position is on the border of
 * the rectangle.
 */
export function inRectangle(
  position: Vector,
  topLeft: Vector,
  bottomRight: Vector,
): boolean {
  return (
    position.X >= topLeft.X &&
    position.X <= bottomRight.X &&
    position.Y >= topLeft.Y &&
    position.Y <= bottomRight.Y
  );
}

/**
 * From: https://www.geeksforgeeks.org/check-if-any-point-overlaps-the-given-circle-and-rectangle/
 */
export function isCircleIntersectingRectangle(
  circleCenter: Vector,
  circleRadius: float,
  rectangleTopLeft: Vector,
  rectangleBottomRight: Vector,
): boolean {
  const nearestX = Math.max(
    rectangleTopLeft.X,
    Math.min(circleCenter.X, rectangleBottomRight.X),
  );

  const nearestY = Math.max(
    rectangleTopLeft.Y,
    Math.min(circleCenter.Y, rectangleBottomRight.Y),
  );

  const nearestPointToCircleOnRectangle = Vector(nearestX, nearestY);
  const distanceToCenterOfCircle =
    nearestPointToCircleOnRectangle.Distance(circleCenter);

  return distanceToCenterOfCircle <= circleRadius;
}

export function isEven(num: int): boolean {
  // This is benchmarked to be faster than using the modulus operator by 3%.
  return (num & 1) === 0;
}

export function isOdd(num: int): boolean {
  // This is benchmarked to be faster than using the modulus operator by 3%.
  return (num & 1) === 1;
}

export function lerp(a: number, b: number, pos: float): number {
  return a + (b - a) * pos;
}

export function lerpAngleDegrees(
  aStart: number,
  aEnd: number,
  percent: float,
): number {
  return aStart + getAngleDifference(aStart, aEnd) * percent;
}

/**
 * If rounding fails, this function returns 0.
 *
 * From: http://lua-users.org/wiki/SimpleRound
 *
 * @param num The number to round.
 * @param numDecimalPlaces Optional. Default is 0.
 */
export function round(num: float, numDecimalPlaces = 0): float {
  const roundedString = string.format(`%.${numDecimalPlaces}f`, num);
  const roundedNum = tonumber(roundedString);
  return roundedNum ?? 0;
}

/** @returns 1 if n is positive, -1 if n is negative, or 0 if n is 0. */
export function sign(n: number): int {
  if (n > 0) {
    return 1;
  }

  if (n < 0) {
    return -1;
  }

  return 0;
}

/**
 * Breaks a number into chunks of a given size. This is similar to the `String.split` method, but
 * for a number instead of a string.
 *
 * For example, `splitNumber(90, 25)` would return an array with four elements:
 *
 * - [1, 25]
 * - [26, 50]
 * - [51, 75]
 * - [76, 90]
 *
 * @param num The number to split into chunks. This must be a positive integer.
 * @param size The size of each chunk. This must be a positive integer.
 * @param startAtZero Whether to start at 0. Defaults to false. If true, the chunks will start at 0
 *                    instead of 1.
 */
export function splitNumber(
  num: int,
  size: int,
  startAtZero = false,
): ReadonlyArray<readonly [min: int, max: int]> {
  if (num <= 0) {
    error(
      `The number to split needs to be a positive number and is instead: ${num}`,
    );
  }

  if (size <= 0) {
    error(
      `The size to split needs to be a positive number and is instead: ${num}`,
    );
  }

  const chunks: Array<[number, number]> = [];
  let start = startAtZero ? 0 : 1;

  while (start <= num) {
    const end = Math.min(start + size - 1, num);
    chunks.push([start, end]);
    start += size;
  }

  return chunks;
}

export function tanh(x: number): number {
  return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
}

----
functions\merge.ts
import { SAVE_DATA_MANAGER_DEBUG } from "../classes/features/other/saveDataManager/constants";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { SerializationType } from "../enums/SerializationType";
import { isSerializationBrand } from "../serialization";
import type { AnyClass } from "../types/AnyClass";
import { isArray } from "./array";
import { deepCopy } from "./deepCopy";
import { log } from "./log";
import {
  deserializeIsaacAPIClass,
  isSerializedIsaacAPIClass,
} from "./serialization";
import { clearTable, iterateTableInOrder } from "./table";
import { isDefaultMap, isTSTLMap, isTSTLSet } from "./tstlClass";
import { isTable } from "./types";
import { getTraversalDescription } from "./utils";

/**
 * `merge` takes the values from a new table and recursively merges them into an old object (while
 * performing appropriate deserialization).
 *
 * This function is used to merge incoming data from the "save#.dat" file into a mod's variables.
 * Merging is useful instead of blowing away a table entirely because mod code often relies on the
 * local table/object references.
 *
 * This function always assumes that the new table is serialized data and will attempt to perform
 * deserialization on the objects within. In other words, unlike the `deepCopy` function, the
 * `merge` function will always operates in the mode of `SerializationType.DESERIALIZE`. For the
 * types of objects that will be deserialized, see the documentation for the `deepCopy` function.
 *
 * This function does not iterate over the old object, like you would naively expect. This is
 * because it is common for a variable to have a type of `something | null`. If this is the case,
 * the key would not appear when iterating over the old object (because a value of null transpiles
 * to nil, which means the table key does not exist). Thus, we must instead iterate over the new
 * object and copy the values backwards. The consequence of this is that `merge` can copy over old
 * variables that are no longer used in the code, or copy over old variables of a different type,
 * which can cause run-time errors. In such cases, users will have to manually delete their save
 * data.
 *
 * @param oldObject The old object to merge the values into. This can be either a Lua table, a TSTL
 *                  map, or a TSTL set.
 * @param newTable The new table to merge the values from. This must be a Lua table that represents
 *                 serialized data. In other words, it should be created with the `deepCopy`
 *                 function using `SerializationType.SERIALIZE`.
 * @param traversalDescription Used to track the current key that we are operating on for debugging
 *                             purposes. Use a name that corresponds to the name of the merging
 *                             table.
 * @param classConstructors Optional. A Lua table that maps the name of a user-defined TSTL class to
 *                          its corresponding constructor. If the `deepCopy` function finds any
 *                          user-defined TSTL classes when recursively iterating through the given
 *                          object, it will use this map to instantiate a new class. Default is an
 *                          empty Lua table.
 */
export function merge(
  oldObject:
    | Readonly<LuaMap<AnyNotNil, unknown>>
    | ReadonlyMap<AnyNotNil, unknown>
    | ReadonlySet<AnyNotNil>,
  newTable: LuaMap<AnyNotNil, unknown>,
  traversalDescription: string,
  classConstructors = new LuaMap<string, AnyClass>(),
): void {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log(`merge is traversing: ${traversalDescription}`);
  }

  if (!isTable(oldObject)) {
    error("The first argument given to the merge function is not a table.");
  }

  if (!isTable(newTable)) {
    error("The second argument given to the merge function is not a table.");
  }

  // First, handle the special case of an array with a shallow copy.
  if (isArray(oldObject) && isArray(newTable)) {
    mergeSerializedArray(
      oldObject,
      newTable,
      traversalDescription,
      classConstructors,
    );
    return;
  }

  // Depending on whether we are working on a Lua table or a TypeScriptToLua object, we need to
  // iterate in a specific way.
  if (isTSTLMap(oldObject) || isTSTLSet(oldObject) || isDefaultMap(oldObject)) {
    mergeSerializedTSTLObject(
      oldObject,
      newTable,
      traversalDescription,
      classConstructors,
    );
  } else {
    mergeSerializedTable(
      oldObject,
      newTable,
      traversalDescription,
      classConstructors,
    );
  }
}

function mergeSerializedArray(
  oldArray: LuaMap<AnyNotNil, unknown>,
  newArray: LuaMap<AnyNotNil, unknown>,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
) {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log(`merge encountered an array: ${traversalDescription}`);
  }

  // Assume that we should blow away all array values with whatever is present in the incoming
  // array.
  clearTable(oldArray);
  iterateTableInOrder(
    newArray,
    (key, value) => {
      const deserializedValue = deepCopy(
        value,
        SerializationType.DESERIALIZE,
        traversalDescription,
        classConstructors,
      );
      oldArray.set(key, deserializedValue);
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

function mergeSerializedTSTLObject(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  oldObject: Map<AnyNotNil, unknown> | Set<AnyNotNil>,
  newTable: LuaMap<AnyNotNil, unknown>,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
) {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log(`merge encountered a TSTL object: ${traversalDescription}`);
  }

  // We blow away the old object and recursively copy over all of the incoming values.
  oldObject.clear();

  // During serialization, we brand some Lua tables with a special identifier to signify that it has
  // keys that should be deserialized to numbers.
  const convertStringKeysToNumbers = newTable.has(
    SerializationBrand.OBJECT_WITH_NUMBER_KEYS,
  );

  iterateTableInOrder(
    newTable,
    (key, value) => {
      if (isSerializationBrand(key)) {
        return;
      }

      let keyToUse = key;
      if (convertStringKeysToNumbers) {
        const numberKey = tonumber(key);
        if (numberKey === undefined) {
          return;
        }
        keyToUse = numberKey;
      }

      if (isTSTLMap(oldObject) || isDefaultMap(oldObject)) {
        const deserializedValue = deepCopy(
          value,
          SerializationType.DESERIALIZE,
          traversalDescription,
          classConstructors,
        );
        oldObject.set(keyToUse, deserializedValue);
      } else if (isTSTLSet(oldObject)) {
        oldObject.add(keyToUse);
      }
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

function mergeSerializedTable(
  oldTable: LuaMap<AnyNotNil, unknown>,
  newTable: LuaMap<AnyNotNil, unknown>,
  traversalDescription: string,
  classConstructors: LuaMap<string, AnyClass>,
) {
  if (SAVE_DATA_MANAGER_DEBUG) {
    log(`merge encountered a Lua table: ${traversalDescription}`);
  }

  iterateTableInOrder(
    newTable,
    (key, value) => {
      if (SAVE_DATA_MANAGER_DEBUG) {
        const valueToPrint = value === "" ? "(empty string)" : `${value}`;
        log(`merge is merging: ${traversalDescription} --> ${valueToPrint}`);
      }

      if (isSerializationBrand(key)) {
        return;
      }

      // Handle the special case of serialized Isaac API classes.
      if (isSerializedIsaacAPIClass(value)) {
        if (SAVE_DATA_MANAGER_DEBUG) {
          log("merge found a serialized Isaac API class.");
        }

        const deserializedObject = deserializeIsaacAPIClass(value);
        oldTable.set(key, deserializedObject);
        return;
      }

      if (isTable(value)) {
        let oldValue = oldTable.get(key) as LuaMap<AnyNotNil, unknown>;
        if (!isTable(oldValue)) {
          // The child table does not exist on the old table. However, we still need to copy over
          // the new table, because we need to handle data types like `Foo | null`. Thus, set up a
          // blank sub-table on the old table, and continue to recursively merge.
          oldValue = new LuaMap();
          oldTable.set(key, oldValue);
        }

        traversalDescription = getTraversalDescription(
          key,
          traversalDescription,
        );
        merge(oldValue, value, traversalDescription, classConstructors);
      } else {
        // Base case: copy the value
        oldTable.set(key, value);
      }
    },
    SAVE_DATA_MANAGER_DEBUG,
  );
}

----
functions\mergeTests.ts
import { DefaultMap } from "../classes/DefaultMap";
import { SerializationType } from "../enums/SerializationType";
import { deepCopy } from "./deepCopy";
import { logAndPrint } from "./log";
import { merge } from "./merge";
import { isRNG, newRNG } from "./rng";
import { isSerializedIsaacAPIClass } from "./serialization";
import { isVector, serializeVector } from "./vector";

/**
 * Run the suite of tests that prove that the "merge" function works properly.
 *
 * This function is only useful if you are troubleshooting the save data manager.
 */
export function runMergeTests(): void {
  oldTableHasUpdatedValue();
  newTableHasSameValue();
  oldTableHasUpdatedValueFromNull();
  oldTableHasSerializedIsaacAPIClass();

  oldTableHasFilledChildTable();
  oldTableHasFilledMap();
  oldTableHasFilledDefaultMap();

  oldTableHasVector();
  oldTableHasVectorSerialized();
  oldTableHasRNG();
  oldTableHasRNGSerialized();

  const successText = "All merge tests passed!";
  logAndPrint(successText);
}

function oldTableHasUpdatedValue() {
  const key = "foo";
  const oldValue = "bar";
  const newValue = "baz";
  const oldTable = {
    foo: oldValue,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const newTable = {
    foo: newValue,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "oldTableHasUpdatedValue");

  const oldTableValue = oldTable.get(key) as string;
  if (oldTableValue !== newValue) {
    error(`The old table does not have a value of: ${newValue}`);
  }
}

function newTableHasSameValue() {
  const key = "foo";
  const oldValue = "bar";
  const newValue = "baz";
  const oldTable = {
    foo: oldValue,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const newTable = {
    foo: newValue,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "newTableHasSameValue");

  const newTableValue = newTable.get(key) as string;
  if (newTableValue !== newValue) {
    error(`The new table does not have a value of: ${newValue}`);
  }
}

function oldTableHasUpdatedValueFromNull() {
  const key = "foo";
  const newValue = "baz";
  const oldTable = {
    foo: null as string | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const newTable = {
    foo: newValue,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "oldTableHasUpdatedValueFromNull");

  const oldTableValue = oldTable.get(key) as string;
  if (oldTableValue !== newValue) {
    error(`The old table does not have a value of: ${newValue}`);
  }
}

function oldTableHasSerializedIsaacAPIClass() {
  const x = 50;
  const y = 60;
  const vector = Vector(x, y);

  const vectorSerialized = serializeVector(vector);
  if (!isSerializedIsaacAPIClass(vectorSerialized)) {
    error(
      'The "isSerializedIsaacAPIClass" function says that a serialized vector is not serialized.',
    );
  }
}

function oldTableHasFilledChildTable() {
  interface Foo {
    bar: string;
  }

  const key = "foo";
  const newValue = "baz";
  const oldTable = {
    foo: null as Foo | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const foo: Foo = {
    bar: newValue,
  };
  const newTable = {
    foo,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "oldTableHasFilledChildTable");

  const oldTableValue = oldTable.get(key) as Foo | undefined;
  if (oldTableValue === undefined) {
    error(`The old table's key of "${key}" was not filled.`);
  }

  if (oldTableValue.bar !== newValue) {
    error('The old table\'s key of "bar" was not filled.');
  }
}

function oldTableHasFilledMap() {
  const fakeV = {
    run: {
      myMap: new Map<string, string>(),
    },
  };

  const saveData = {
    run: {
      myMap: new Map<string, string>([
        ["foo1", "bar1"],
        ["foo2", "bar2"],
        ["foo3", "bar3"],
      ]),
    },
  };
  const serializedSaveData = deepCopy(saveData, SerializationType.SERIALIZE);

  merge(
    fakeV as unknown as LuaMap,
    serializedSaveData as LuaMap,
    "oldTableHasFilledMap",
  );

  const expectedSize = 3;
  if (fakeV.run.myMap.size !== expectedSize) {
    error(
      `The size of the merged map was equal to ${fakeV.run.myMap.size}, but it should be equal to: ${expectedSize}`,
    );
  }

  {
    const key = "foo1";
    const expectedValue = "bar1";

    const value = fakeV.run.myMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }

  {
    const key = "foo2";
    const expectedValue = "bar2";

    const value = fakeV.run.myMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }

  {
    const key = "foo3";
    const expectedValue = "bar3";

    const value = fakeV.run.myMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }
}

function oldTableHasFilledDefaultMap() {
  const fakeV = {
    run: {
      myDefaultMap: new DefaultMap<string, string>("default"),
    },
  };

  const saveData = {
    run: {
      myDefaultMap: new DefaultMap<string, string>("default", [
        ["foo1", "bar1"],
        ["foo2", "bar2"],
        ["foo3", "bar3"],
      ]),
    },
  };
  const serializedSaveData = deepCopy(saveData, SerializationType.SERIALIZE);

  merge(
    fakeV as unknown as LuaMap,
    serializedSaveData as LuaMap,
    "oldTableHasFilledDefaultMap",
  );

  const expectedSize = 3;
  if (fakeV.run.myDefaultMap.size !== expectedSize) {
    error(
      `The size of the merged default map was equal to ${fakeV.run.myDefaultMap.size}, but it should be equal to: ${expectedSize}`,
    );
  }

  {
    const key = "foo1";
    const expectedValue = "bar1";

    const value = fakeV.run.myDefaultMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's default map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }

  {
    const key = "foo2";
    const expectedValue = "bar2";

    const value = fakeV.run.myDefaultMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's default map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }

  {
    const key = "foo3";
    const expectedValue = "bar3";

    const value = fakeV.run.myDefaultMap.get(key);
    if (value !== expectedValue) {
      error(
        `The old table's default map key of "${key}" was not equal to "${expectedValue}" and was instead equal to: ${value}`,
      );
    }
  }
}

function oldTableHasVector() {
  interface Foo {
    bar: Vector;
  }

  const key = "foo";
  const x = 50;
  const y = 60;
  const newValue = Vector(x, y);
  const oldTable = {
    foo: null as Foo | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const foo: Foo = {
    bar: newValue,
  };
  const newTable = {
    foo,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "oldTableHasVector");

  const oldTableValue = oldTable.get(key) as Foo | undefined;
  if (oldTableValue === undefined) {
    error(`The old table's key of "${key}" was not filled.`);
  }

  if (oldTableValue.bar.X !== x) {
    error(`The old table's value for "x" does not match: ${x}`);
  }

  if (oldTableValue.bar.Y !== y) {
    error(`The old table's value for "y" does not match: ${y}`);
  }

  if (!isVector(oldTableValue.bar)) {
    error("The old table's value is not a Vector object.");
  }
}

function oldTableHasVectorSerialized() {
  interface Foo {
    bar: Vector;
  }

  const key = "foo";
  const x = 50;
  const y = 60;
  const newValue = Vector(x, y);
  const oldTable = {
    foo: null as Foo | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const foo: Foo = {
    bar: newValue,
  };
  const newTable = {
    foo,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const newTableSerialized = deepCopy(
    newTable,
    SerializationType.SERIALIZE,
    "oldTableHasVectorSerialized",
  ) as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTableSerialized, "oldTableHasVectorSerialized");

  const oldTableValue = oldTable.get(key) as Foo | undefined;
  if (oldTableValue === undefined) {
    error(`The old table's key of "${key}" was not filled.`);
  }

  if (oldTableValue.bar.X !== x) {
    error(`The old table's value for "x" does not match: ${x}`);
  }

  if (oldTableValue.bar.Y !== y) {
    error(`The old table's value for "y" does not match: ${y}`);
  }

  if (!isVector(oldTableValue.bar)) {
    error(
      "The old table's value is not a Vector object (during the serialized test).",
    );
  }
}

function oldTableHasRNG() {
  interface Foo {
    bar: RNG;
  }

  const key = "foo";
  const seed = 50 as Seed;
  const newValue = newRNG(seed);
  const oldTable = {
    foo: null as Foo | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const foo: Foo = {
    bar: newValue,
  };
  const newTable = {
    foo,
  } as unknown as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTable, "oldTableHasRNG");

  const oldTableValue = oldTable.get(key) as Foo | undefined;
  if (oldTableValue === undefined) {
    error(`The old table's key of "${key}" was not filled.`);
  }

  if (!isRNG(oldTableValue.bar)) {
    error("The old table's value is not an RNG object.");
  }

  const newSeed = oldTableValue.bar.GetSeed();
  if (newSeed !== seed) {
    error(`The old table's seed not match: ${seed}`);
  }
}

function oldTableHasRNGSerialized() {
  interface Foo {
    bar: RNG;
  }

  const key = "foo";
  const seed = 50 as Seed;
  const newValue = newRNG(seed);
  const oldTable = {
    foo: null as Foo | null,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const foo: Foo = {
    bar: newValue,
  };
  const newTable = {
    foo,
  } as unknown as LuaMap<AnyNotNil, unknown>;
  const newTableSerialized = deepCopy(
    newTable,
    SerializationType.SERIALIZE,
    "oldTableHasRNGSerialized",
  ) as LuaMap<AnyNotNil, unknown>;

  merge(oldTable, newTableSerialized, "oldTableHasRNGSerialized");

  const oldTableValue = oldTable.get(key) as Foo | undefined;
  if (oldTableValue === undefined) {
    error(`The old table's key of "${key}" was not filled.`);
  }

  if (!isRNG(oldTableValue.bar)) {
    error(
      "The old table's value is not an RNG object (during the serialized test).",
    );
  }

  const newSeed = oldTableValue.bar.GetSeed();
  if (newSeed !== seed) {
    error(`The old table's seed not match: ${seed}`);
  }
}

----
functions\minimap.ts
import type { DisplayFlag } from "isaac-typescript-definitions";
import { DisplayFlagZero } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { addFlag } from "./flag";
import { getRoomDescriptor, getRoomGridIndex } from "./roomData";
import { getRoomsInsideGrid } from "./rooms";
import { isInteger } from "./types";
import { assertDefined } from "./utils";

/**
 * Helper function to add a `DisplayFlag` to a particular room's minimap display flags (e.g. whether
 * it is visible and so on).
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * @param roomGridIndex Set to undefined to use the current room index.
 * @param displayFlag The `DisplayFlag` to set. (See the `DisplayFlag` enum.)
 * @param updateVisibility Optional. Whether to call the `Level.UpdateVisibility` method in order to
 *                         make the changes immediately visible. Default is true.
 */
export function addRoomDisplayFlag(
  roomGridIndex: int | undefined,
  displayFlag: DisplayFlag,
  updateVisibility = true,
): void {
  const oldDisplayFlags = getRoomDisplayFlags(roomGridIndex);
  const newDisplayFlags = addFlag(oldDisplayFlags, displayFlag);
  setRoomDisplayFlags(roomGridIndex, newDisplayFlags, updateVisibility);
}

/**
 * Helper function to set the value of `DisplayFlag` for every room on the floor to 0.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * This function automatically calls the `Level.UpdateVisibility` after setting the flags so that
 * the changes will be immediately visible.
 */
export function clearFloorDisplayFlags(): void {
  setAllDisplayFlags(DisplayFlagZero);
}

/**
 * Helper function to set the value of `DisplayFlag` for a room 0.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * This function automatically calls the `Level.UpdateVisibility` after setting the flags so that
 * the changes will be immediately visible.
 *
 * Note that if you clear the display flags of a room but then the player travels to the room (or an
 * adjacent room), the room will appear on the minimap again. If you want to permanently hide the
 * room even in this circumstance, use the `hideRoomOnMinimap` helper function instead.
 */
export function clearRoomDisplayFlags(roomGridIndex: int): void {
  setRoomDisplayFlags(roomGridIndex, DisplayFlagZero);
}

/**
 * Helper function to get the minimap `DisplayFlag` value for every room on the floor. Returns a map
 * that is indexed by the room's safe grid index.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * @param minimapAPI Optional. If MinimapAPI should be used, if present. Default is true.
 */
export function getFloorDisplayFlags(
  minimapAPI = true,
): ReadonlyMap<int, BitFlags<DisplayFlag>> {
  const displayFlagsMap = new Map<int, BitFlags<DisplayFlag>>();

  for (const roomDescriptor of getRoomsInsideGrid()) {
    const roomGridIndex = roomDescriptor.SafeGridIndex;
    const displayFlags = getRoomDisplayFlags(roomGridIndex, minimapAPI);
    displayFlagsMap.set(roomGridIndex, displayFlags);
  }

  return displayFlagsMap;
}

/**
 * Helper function to get a particular room's minimap display flags (e.g. whether it is visible and
 * so on).
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @param minimapAPI Optional. If MinimapAPI should be used, if present. Default is true.
 */
export function getRoomDisplayFlags(
  roomGridIndex?: int,
  minimapAPI = true,
): BitFlags<DisplayFlag> {
  if (roomGridIndex === undefined) {
    roomGridIndex = getRoomGridIndex();
  }

  if (MinimapAPI === undefined || !minimapAPI) {
    const roomDescriptor = getRoomDescriptor(roomGridIndex);
    return roomDescriptor.DisplayFlags;
  }

  const minimapAPIRoomDescriptor = MinimapAPI.GetRoomByIdx(roomGridIndex);
  assertDefined(
    minimapAPIRoomDescriptor,
    `Failed to get the MinimapAPI room descriptor for the room at grid index: ${roomGridIndex}`,
  );

  return minimapAPIRoomDescriptor.GetDisplayFlags();
}

/**
 * Helper function to hide a specific room on the minimap.
 *
 * If you want the room to be permanently hidden, you must to call this function on every new room.
 * This is because if the player enters into the room or walks into an adjacent room, the room will
 * reappear on the minimap.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 */
export function hideRoomOnMinimap(roomGridIndex: int): void {
  clearRoomDisplayFlags(roomGridIndex);

  // In vanilla, the map only updates at the beginning of every room. In MinimapAPI, it constant
  // updates, so we must specifically tell MinimapAPI that the room should be hidden using the
  // `Hidden` property.
  if (MinimapAPI !== undefined) {
    const minimapAPIRoomDescriptor = MinimapAPI.GetRoomByIdx(roomGridIndex);
    assertDefined(
      minimapAPIRoomDescriptor,
      `Failed to get the MinimapAPI room descriptor for the room at grid index: ${roomGridIndex}`,
    );

    minimapAPIRoomDescriptor.Hidden = true;
  }
}

/**
 * Helper function to check if a given room is visible on the minimap.
 *
 * @param roomGridIndexOrRoomDescriptor The room to check.
 * @param minimapAPI Optional. Whether MinimapAPI should be used, if present. Default is true.
 */
export function isRoomVisible(
  roomGridIndexOrRoomDescriptor: int | RoomDescriptor,
  minimapAPI = true,
): boolean {
  const roomGridIndex = isInteger(roomGridIndexOrRoomDescriptor)
    ? roomGridIndexOrRoomDescriptor
    : roomGridIndexOrRoomDescriptor.SafeGridIndex;
  const roomDisplayFlags = getRoomDisplayFlags(roomGridIndex, minimapAPI);

  return roomDisplayFlags !== DisplayFlagZero;
}

/**
 * Helper function to set the minimap `DisplayFlag` value for every room on the floor at once.
 *
 * This function automatically calls the `Level.UpdateVisibility` after setting the flags so that
 * the changes will be immediately visible.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 */
export function setAllDisplayFlags(displayFlags: BitFlags<DisplayFlag>): void {
  for (const room of getRoomsInsideGrid()) {
    // We pass false to the `updateVisibility` argument as a small optimization.
    setRoomDisplayFlags(room.SafeGridIndex, displayFlags, false);
  }

  // In vanilla, we must call the "Level.UpdateVisibility" method for the changes to be visible.
  if (MinimapAPI === undefined) {
    const level = game.GetLevel();
    level.UpdateVisibility();
  }
}

/**
 * Helper function to set the minimap `DisplayFlag` value for multiple rooms at once.
 *
 * This function automatically calls the `Level.UpdateVisibility` after setting the flags so that
 * the changes will be immediately visible.
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * @param displayFlagsMap A map of the display flags that is indexed by the room's safe grid index.
 */
export function setFloorDisplayFlags(
  displayFlagsMap: ReadonlyMap<int, BitFlags<DisplayFlag>>,
): void {
  for (const [roomGridIndex, displayFlags] of displayFlagsMap) {
    // We pass false to the `updateVisibility` argument as a small optimization.
    setRoomDisplayFlags(roomGridIndex, displayFlags, false);
  }

  // In vanilla, we must call the "Level.UpdateVisibility" method for the changes to be visible.
  if (MinimapAPI === undefined) {
    const level = game.GetLevel();
    level.UpdateVisibility();
  }
}

/**
 * Helper function to set a particular room's minimap display flags (e.g. whether it is visible and
 * so on).
 *
 * This function automatically accounts for if MinimapAPI is being used.
 *
 * @param roomGridIndex Set to undefined to use the current room index.
 * @param displayFlags The bit flags value to set. (See the `DisplayFlag` enum.)
 * @param updateVisibility Optional. Whether to call the `Level.UpdateVisibility` method in order to
 *                         make the changes immediately visible. Default is true. Set this to false
 *                         if you are doing a bunch of display flag setting and then manually call
 *                         the `Level.UpdateVisibility` method after you are done.
 */
export function setRoomDisplayFlags(
  roomGridIndex: int | undefined,
  displayFlags: BitFlags<DisplayFlag>,
  updateVisibility = true,
): void {
  if (roomGridIndex === undefined) {
    roomGridIndex = getRoomGridIndex();
  }

  if (MinimapAPI === undefined) {
    const roomDescriptor = getRoomDescriptor(roomGridIndex);
    roomDescriptor.DisplayFlags = displayFlags;

    if (updateVisibility) {
      const level = game.GetLevel();
      level.UpdateVisibility();
    }
  } else {
    const minimapAPIRoomDescriptor = MinimapAPI.GetRoomByIdx(roomGridIndex);
    assertDefined(
      minimapAPIRoomDescriptor,
      `Failed to get the MinimapAPI room descriptor for the room at grid index: ${roomGridIndex}`,
    );

    minimapAPIRoomDescriptor.SetDisplayFlags(displayFlags);
  }
}

----
functions\modFeatures.ts
import type { ModFeature } from "../classes/ModFeature";
import type { ModUpgraded } from "../classes/ModUpgraded";

/**
 * Helper function to instantiate an array of mod features all at once. Use this function if your
 * mod uses the pattern of expressing mod features as `ModFeature` classes.
 *
 * If your feature classes have `v` variables, then this function will successfully register them
 * with the save data manager.
 *
 * For example:
 *
 * ```ts
 * const MOD_FEATURES = [
 *   MyFeature1,
 *   MyFeature2,
 *   MyFeature3,
 * ] as const;
 * initModFeatures(mod, MOD_FEATURES);
 * ```
 *
 * @param mod The upgraded mod to use.
 * @param modFeatures An array of the feature classes that you have in your mod.
 * @param init Optional. Whether to automatically add the callbacks on the feature. Defaults to
 *             true.
 * @returns An array of the instantiated features in the same order that the constructors were
 *          passed in. (In most cases, you probably won't need the returned array.)
 */
export function initModFeatures<T extends ReadonlyArray<typeof ModFeature>>(
  mod: ModUpgraded,
  modFeatures: T,
  init = true,
): { [K in keyof T]: InstanceType<T[K]> } {
  const instantiatedModFeatures: ModFeature[] = [];

  for (const modFeature of modFeatures) {
    // eslint-disable-next-line new-cap
    const instantiatedModFeature = new modFeature(mod, false);
    instantiatedModFeature.init(init);

    instantiatedModFeatures.push(instantiatedModFeature);
  }

  return instantiatedModFeatures as { [K in keyof T]: InstanceType<T[K]> };
}

----
functions\newArray.ts
import { deepCopy } from "./deepCopy";
import { repeat } from "./utils";

/**
 * Initializes an array with all of the elements containing the specified default value.
 *
 * The provided default value will be copied with the `deepCopy` function before adding it to the
 * new array. Thus, you can initialize an array of arrays, or an array of maps, and so on. (If the
 * `deepCopy` function was not used, then all of the array elements would just be references to the
 * same underlying data structure.)
 *
 * For example:
 *
 * ```ts
 * const arrayWithZeroes = newArray(0, 10); // Has 10 elements of 0.
 * const arrayWithArrays = newArray([0], 20); // Has 20 elements of an array with a 0 in it.
 * ```
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function newArray<T>(defaultValue: T, size: int): T[] {
  const array: T[] = [];
  repeat(size, () => {
    const copy = deepCopy(defaultValue);
    array.push(copy);
  });

  return array;
}

----
functions\nextStage.ts
import {
  GameStateFlag,
  GridRoom,
  LevelCurse,
  LevelStage,
  StageType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { hasCurse } from "./curses";
import { getRoomGridIndex } from "./roomData";
import {
  calculateStageType,
  calculateStageTypeRepentance,
  onRepentanceStage,
} from "./stage";

/**
 * Helper function to get the stage that a trapdoor or heaven door would take the player to, based
 * on the current stage, room, and game state flags.
 *
 * If you want to account for the player having visited Repentance floors in The Ascent, use the
 * `getNextStageUsingHistory` helper function instead (from the stage history feature). Handling
 * this requires stateful tracking as the player progresses through the run.
 */
export function getNextStage(): LevelStage {
  const level = game.GetLevel();
  const backwardsPath = game.GetStateFlag(GameStateFlag.BACKWARDS_PATH);
  const mausoleumHeartKilled = game.GetStateFlag(
    GameStateFlag.MAUSOLEUM_HEART_KILLED,
  );
  const stage = level.GetStage();
  const repentanceStage = onRepentanceStage();
  const roomGridIndex = getRoomGridIndex();

  // First, handle the special case of being on the backwards path.
  if (backwardsPath) {
    const nextStage = stage - 1;
    return nextStage === 0 ? LevelStage.HOME : nextStage;
  }

  // Second, handle the special case of being in a specific off-grid room.
  switch (roomGridIndex) {
    // -8
    case GridRoom.BLUE_WOMB: {
      return LevelStage.BLUE_WOMB;
    }

    // -9
    case GridRoom.VOID: {
      return LevelStage.VOID;
    }

    // -10
    case GridRoom.SECRET_EXIT: {
      if (repentanceStage) {
        // e.g. From Downpour 2 to Mines 1, etc.
        return stage + 1;
      }

      if (
        stage === LevelStage.DEPTHS_2 ||
        (stage === LevelStage.DEPTHS_1 && hasCurse(LevelCurse.LABYRINTH))
      ) {
        // From Depths 2 to Mausoleum 2 through the strange door.
        return LevelStage.DEPTHS_2;
      }

      // e.g. From Basement 1 to Downpour 1, from Basement 2 to Downpour 2, etc.
      return stage;
    }

    default: {
      break;
    }
  }

  // 2
  if (repentanceStage && stage === LevelStage.BASEMENT_2) {
    // From Downpour 2 to Caves 2.
    return LevelStage.CAVES_2;
  }

  // 4
  if (repentanceStage && stage === LevelStage.CAVES_2) {
    // From Mines 2 to Depths 2.
    return LevelStage.DEPTHS_2;
  }

  // 6
  if (repentanceStage && stage === LevelStage.DEPTHS_2) {
    if (mausoleumHeartKilled) {
      // From Mausoleum 2 to Corpse 1.
      return LevelStage.WOMB_1;
    }

    // From Mausoleum 2 to Womb 2.
    return LevelStage.WOMB_2;
  }

  // 8
  if (stage === LevelStage.WOMB_2) {
    // From Womb 2 to Sheol or Cathedral.
    return LevelStage.SHEOL_CATHEDRAL;
  }

  // 11
  if (stage === LevelStage.DARK_ROOM_CHEST) {
    // - The Chest goes to The Chest.
    // - The Dark Room goes to the Dark Room.
    return LevelStage.DARK_ROOM_CHEST;
  }

  // 12
  if (stage === LevelStage.VOID) {
    // The Void goes to The Void.
    return LevelStage.VOID;
  }

  // By default, go to the next floor.
  return stage + 1;
}

/**
 * Helper function to get the stage type that a trapdoor or heaven door would take the player to,
 * based on the current stage, room, and game state flags.
 *
 * If you want to account for previous floors visited on The Ascent, use the
 * `getNextStageTypeUsingHistory` helper function instead (from the stage history feature). Handling
 * this requires stateful tracking as the player progresses through the run.
 *
 * @param upwards Whether the player should go up to Cathedral in the case of being on Womb 2.
 *                Default is false.
 */
export function getNextStageType(upwards = false): StageType {
  const backwardsPath = game.GetStateFlag(GameStateFlag.BACKWARDS_PATH);
  const mausoleumHeartKilled = game.GetStateFlag(
    GameStateFlag.MAUSOLEUM_HEART_KILLED,
  );
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();
  const repentanceStage = onRepentanceStage();
  const roomGridIndex = getRoomGridIndex();
  const nextStage = getNextStage();

  // First, handle the special case of being on the backwards path.
  if (backwardsPath) {
    return calculateStageType(nextStage);
  }

  // Second, handle the special case of being in a specific off-grid room.
  if (roomGridIndex === GridRoom.SECRET_EXIT) {
    return calculateStageTypeRepentance(nextStage);
  }

  if (
    repentanceStage &&
    (stage === LevelStage.BASEMENT_1 || // 1
      stage === LevelStage.CAVES_1 || // 3
      stage === LevelStage.DEPTHS_1 || // 5
      stage === LevelStage.WOMB_1) // 7
  ) {
    return calculateStageTypeRepentance(nextStage);
  }

  if (
    repentanceStage &&
    stage === LevelStage.DEPTHS_2 &&
    mausoleumHeartKilled
  ) {
    return calculateStageTypeRepentance(nextStage);
  }

  // 9
  if (nextStage === LevelStage.BLUE_WOMB) {
    // Blue Womb does not have any alternate floors.
    return StageType.ORIGINAL;
  }

  // 10
  if (nextStage === LevelStage.SHEOL_CATHEDRAL) {
    if (upwards) {
      // Go to Cathedral (10.1).
      return StageType.WRATH_OF_THE_LAMB;
    }

    // Go to Sheol (10.0).
    return StageType.ORIGINAL;
  }

  // 11
  if (nextStage === LevelStage.DARK_ROOM_CHEST) {
    if (stageType === StageType.ORIGINAL) {
      // Sheol (10.0) goes to the Dark Room (11.0).
      return StageType.ORIGINAL;
    }

    // Cathedral (10.1) goes to The Chest (11.1).
    return StageType.WRATH_OF_THE_LAMB;
  }

  // 12
  if (nextStage === LevelStage.VOID) {
    // The Void does not have any alternate floors.
    return StageType.ORIGINAL;
  }

  // 13
  if (nextStage === LevelStage.HOME) {
    // Home does not have any alternate floors.
    return StageType.ORIGINAL;
  }

  return calculateStageType(nextStage);
}

----
functions\npcDataStructures.ts
import type { DefaultMap } from "../classes/DefaultMap";

/**
 * Helper function to make using default maps with an index of `PtrHash` easier. Use this instead of
 * the `DefaultMap.getAndSetDefault` method if you have a default map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     npcsSpeedBoost: new DefaultMap<PtrHash, int>(0),
 *   },
 * };
 *
 * function npcUpdate(npc: EntityNPC) {
 *   const speedBoost = defaultMapGetNPC(v.run.npcsSpeedBoost, npc);
 *   // Do something with the speed boost.
 * }
 * ```
 *
 * Note that not all NPCs should be stored in a map with a `PtrHash` as an index, so only use this
 * in the situations where that would be okay. (For example, Dark Esau should never be stored in a
 * map like this, because the scope of `PtrHash` is per room and Dark Esau is persistent between
 * rooms.)
 */
export function defaultMapGetNPC<V, Args extends unknown[]>(
  map: DefaultMap<PtrHash, V, Args>,
  npc: EntityNPC,
  ...extraArgs: Args
): V {
  const ptrHash = GetPtrHash(npc);
  return map.getAndSetDefault(ptrHash, ...extraArgs);
}

/**
 * Helper function to make using maps with an index of `PtrHash` easier. Use this instead of the
 * `Map.set` method if you have a map of this type.
 *
 * Since `Map` and `DefaultMap` set values in the same way, this function is simply an alias for the
 * `mapSetNPC` helper function.
 */
export function defaultMapSetNPC<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PtrHash, V>,
  npc: EntityNPC,
  value: V,
): void {
  mapSetNPC(map, npc, value);
}

/**
 * Helper function to make using maps with an type of `PtrHash` easier. Use this instead of the
 * `Map.delete` method if you have a set of this type.
 */
export function mapDeleteNPC(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PtrHash, unknown>,
  npc: EntityNPC,
): boolean {
  const ptrHash = GetPtrHash(npc);
  return map.delete(ptrHash);
}

/**
 * Helper function to make using maps with an index of `PtrHash` easier. Use this instead of the
 * `Map.get` method if you have a map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     npcsSpeedBoost: new Map<PtrHash, int>(),
 *   },
 * };
 *
 * function incrementSpeedBoost(npc: EntityNPC) {
 *   const oldSpeedBoost = mapGetNPC(v.run.npcsSpeedBoost, npc);
 *   const newSpeedBoost = oldSpeedBoost + 0.1;
 *   mapSetNPC(v.run.npcsSpeedBoost, npc);
 * }
 * ```
 */
export function mapGetNPC<V>(
  map: ReadonlyMap<PtrHash, V>,
  npc: EntityNPC,
): V | undefined {
  const ptrHash = GetPtrHash(npc);
  return map.get(ptrHash);
}

/**
 * Helper function to make using maps with an index of `PtrHash` easier. Use this instead of the
 * `Map.has` method if you have a map of this type.
 */
export function mapHasNPC<V>(
  map: ReadonlyMap<PtrHash, V>,
  npc: EntityNPC,
): boolean {
  const ptrHash = GetPtrHash(npc);
  return map.has(ptrHash);
}

/**
 * Helper function to make using maps with an index of `PtrHash` easier. Use this instead of the
 * `Map.set` method if you have a map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     npcsSpeedBoost: new Map<PtrHash, int>(),
 *   },
 * };
 *
 * function incrementSpeedBoost(npc: EntityNPC) {
 *   const oldSpeedBoost = mapGetNPC(v.run.npcsSpeedBoost, npc);
 *   const newSpeedBoost = oldSpeedBoost + 0.1;
 *   mapSetNPC(v.run.npcsSpeedBoost, npc);
 * }
 * ```
 */
export function mapSetNPC<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PtrHash, V>,
  npc: EntityNPC,
  value: V,
): void {
  const ptrHash = GetPtrHash(npc);
  map.set(ptrHash, value);
}

/**
 * Helper function to make using sets with an type of `PtrHash` easier. Use this instead of the
 * `Set.add` method if you have a set of this type.
 */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function setAddNPC(set: Set<PtrHash>, npc: EntityNPC): void {
  const ptrHash = GetPtrHash(npc);
  set.add(ptrHash);
}

/**
 * Helper function to make using sets with an type of `PtrHash` easier. Use this instead of the
 * `Set.delete` method if you have a set of this type.
 */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function setDeleteNPC(set: Set<PtrHash>, npc: EntityNPC): boolean {
  const ptrHash = GetPtrHash(npc);
  return set.delete(ptrHash);
}

/**
 * Helper function to make using sets with an type of `PtrHash` easier. Use this instead of the
 * `Set.has` method if you have a set of this type.
 */
export function setHasNPC(set: ReadonlySet<PtrHash>, npc: EntityNPC): boolean {
  const ptrHash = GetPtrHash(npc);
  return set.has(ptrHash);
}

----
functions\npcs.ts
import {
  BegottenVariant,
  BigHornVariant,
  ChargerSubType,
  ChargerVariant,
  DarkEsauVariant,
  DeathVariant,
  DumpVariant,
  EntityType,
  HopperVariant,
  MamaGurdyVariant,
  MotherSubType,
  MotherVariant,
  NPCState,
  PeepVariant,
  RaglingVariant,
  VisVariant,
} from "isaac-typescript-definitions";
import { EGGY_STATE_FRAME_OF_FINAL_SPIDER } from "../core/constants";
import { ReadonlySet } from "../types/ReadonlySet";
import { getNPCs } from "./entitiesSpecific";

/**
 * Used to filter out certain NPCs when determining of an NPC is "alive" and/or should keep the
 * doors open.
 */
const NON_ALIVE_NPCS_TYPE_VARIANT = new ReadonlySet<string>([
  `${EntityType.VIS}.${VisVariant.CHUBBER_PROJECTILE}`, // 39.22
  `${EntityType.DEATH}.${DeathVariant.DEATH_SCYTHE}`, // 66.10
  `${EntityType.PEEP}.${PeepVariant.PEEP_EYE}`, // 68.10
  `${EntityType.PEEP}.${PeepVariant.BLOAT_EYE}`, // 68.11
  `${EntityType.BEGOTTEN}.${BegottenVariant.BEGOTTEN_CHAIN}`, // 251.10
  `${EntityType.MAMA_GURDY}.${MamaGurdyVariant.LEFT_HAND}`, // 266.1
  `${EntityType.MAMA_GURDY}.${MamaGurdyVariant.RIGHT_HAND}`, // 266.2
  `${EntityType.BIG_HORN}.${BigHornVariant.SMALL_HOLE}`, // 411.1
  `${EntityType.BIG_HORN}.${BigHornVariant.BIG_HOLE}`, // 411.2
  `${EntityType.DARK_ESAU}.${DarkEsauVariant.DARK_ESAU}`, // 866.0
  `${EntityType.DARK_ESAU}.${DarkEsauVariant.PIT}`, // 866.1
]);

/**
 * Used to filter out certain NPCs when determining of an NPC is "alive" and/or should keep the
 * doors open.
 */
const NON_ALIVE_NPCS_TYPE_VARIANT_SUB_TYPE = new ReadonlySet<string>([
  `${EntityType.CHARGER}.${ChargerVariant.CHARGER}.${ChargerSubType.MY_SHADOW}`, // 23.0.1
  `${EntityType.MOTHER}.${MotherVariant.MOTHER_1}.${MotherSubType.PHASE_2}`, // 912
]);

/**
 * Helper function to get all of the non-dead NPCs in the room.
 *
 * This function will not include NPCs on an internal blacklist, such as Death's scythes or Big Horn
 * holes.
 *
 * @param entityType Optional. If specified, will only get the NPCs that match the type. Default is
 *                   -1, which matches every type.
 * @param variant Optional. If specified, will only get the NPCs that match the variant. Default is
 *                -1, which matches every variant.
 * @param subType Optional. If specified, will only get the NPCs that match the sub-type. Default is
 *                -1, which matches every sub-type.
 * @param ignoreFriendly Optional. Default is false.
 */
export function getAliveNPCs(
  entityType: EntityType | -1 = -1,
  variant = -1,
  subType = -1,
  ignoreFriendly = false,
): readonly EntityNPC[] {
  const npcs = getNPCs(entityType, variant, subType, ignoreFriendly);
  return npcs.filter((npc) => !npc.IsDead() && !isAliveExceptionNPC(npc));
}

/**
 * Checks for specific NPCs that have "CanShutDoors" set to true naturally by the game, but should
 * not actually keep the doors closed (like Death's scythes).
 */
export function isAliveExceptionNPC(npc: EntityNPC): boolean {
  const entityTypeVariant = `${npc.Type}.${npc.Variant}`;
  if (NON_ALIVE_NPCS_TYPE_VARIANT.has(entityTypeVariant)) {
    return true;
  }

  const entityTypeVariantSubType = `${npc.Type}.${npc.Variant}.${npc.SubType}`;
  if (NON_ALIVE_NPCS_TYPE_VARIANT_SUB_TYPE.has(entityTypeVariantSubType)) {
    return true;
  }

  // EntityType.HOPPER (29)
  // HopperVariant.EGGY (2)
  if (isDyingEggyWithNoSpidersLeft(npc)) {
    return true;
  }

  // EntityType.DADDY_LONG_LEGS (101)
  if (isDaddyLongLegsChildStompEntity(npc)) {
    return true;
  }

  // EntityType.RAGLING (256)
  if (isRaglingDeathPatch(npc)) {
    return true;
  }

  // EntityType.DUMP (876)
  if (isDyingDump(npc)) {
    return true;
  }

  return false;
}

/**
 * Helper function to distinguish between a normal Daddy Long Legs / Triachnid and the child entity
 * that is spawned when the boss does the multi-stomp attack.
 *
 * When this attack occurs, four extra copies of Daddy Long Legs will be spawned with the same
 * entity type, variant, and sub-type. The `Entity.Parent` field will be undefined in this case, so
 * the way to tell them apart is to check for a non-undefined `Entity.SpawnerEntity` field.
 */
export function isDaddyLongLegsChildStompEntity(npc: EntityNPC): boolean {
  return (
    npc.Type === EntityType.DADDY_LONG_LEGS && npc.SpawnerEntity !== undefined
  );
}

/**
 * Helper function to detect the custom death state of a Dump. When Dumps die, they go to
 * `NPCState.SPECIAL`, spit out their head, and then slowly fade away while shooting a burst of
 * tears.
 */
export function isDyingDump(npc: EntityNPC): boolean {
  return (
    npc.Type === EntityType.DUMP &&
    npc.Variant === DumpVariant.DUMP &&
    npc.State === NPCState.SPECIAL
  );
}

/**
 * Helper function to detect the custom death state of an Eggy. Eggies are never actually marked
 * dead by the game. Instead, when Eggies take fatal damage, they go into NPCState.STATE_SUICIDE and
 * spawn 14 Swarm Spiders while their StateFrame ticks upwards.
 */
export function isDyingEggyWithNoSpidersLeft(npc: EntityNPC): boolean {
  return (
    npc.Type === EntityType.HOPPER &&
    npc.Variant === HopperVariant.EGGY &&
    npc.State === NPCState.SUICIDE &&
    npc.StateFrame >= EGGY_STATE_FRAME_OF_FINAL_SPIDER
  );
}

/**
 * Helper function to detect the custom death state of a Rag Man Ragling. When Rag Man Raglings die,
 * they turn into a patch on the ground and can be revived by Rag Man at a later time. This causes
 * them to show up as an "alive" enemy, so they should usually be filtered out of lists of alive
 * enemies.
 */
export function isRaglingDeathPatch(npc: EntityNPC): boolean {
  return (
    npc.Type === EntityType.RAGLING &&
    npc.Variant === RaglingVariant.RAG_MANS_RAGLING &&
    // They go to `STATE_SPECIAL` when they are patches on the ground.
    npc.State === NPCState.SPECIAL
  );
}

----
functions\pickupVariants.ts
/* eslint-disable sort-exports/sort-exports */

import { EntityType, PickupVariant } from "isaac-typescript-definitions";

/** For `PickupVariant.HEART` (10). */
export function isHeart(pickup: EntityPickup): pickup is EntityPickupHeart {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.HEART
  );
}

/** For `PickupVariant.COIN` (20). */
export function isCoin(pickup: EntityPickup): pickup is EntityPickupCoin {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.COIN
  );
}

/** For `PickupVariant.KEY` (30). */
export function isKey(pickup: EntityPickup): pickup is EntityPickupKey {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.KEY
  );
}

/** For `PickupVariant.BOMB` (40). */
export function isBombPickup(pickup: EntityPickup): pickup is EntityPickupBomb {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.BOMB
  );
}

/** For `PickupVariant.POOP` (42). */
export function isPoopPickup(pickup: EntityPickup): pickup is EntityPickupPoop {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.POOP
  );
}

/** For `PickupVariant.SACK` (69). */
export function isSack(pickup: EntityPickup): pickup is EntityPickupSack {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.SACK
  );
}

/** For `PickupVariant.PILL` (70). */
export function isPill(pickup: EntityPickup): pickup is EntityPickupPill {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.PILL
  );
}

/** For `PickupVariant.LIL_BATTERY` (90). */
export function isBattery(pickup: EntityPickup): pickup is EntityPickupBattery {
  return (
    pickup.Type === EntityType.PICKUP &&
    pickup.Variant === PickupVariant.LIL_BATTERY
  );
}

/** For `PickupVariant.COLLECTIBLE` (100). */
export function isCollectible(
  pickup: EntityPickup,
): pickup is EntityPickupCollectible {
  return (
    pickup.Type === EntityType.PICKUP &&
    pickup.Variant === PickupVariant.COLLECTIBLE
  );
}

/** For `PickupVariant.CARD` (300). */
export function isCardPickup(pickup: EntityPickup): pickup is EntityPickupCard {
  return (
    pickup.Type === EntityType.PICKUP && pickup.Variant === PickupVariant.CARD
  );
}

/** For `PickupVariant.TRINKET` (350). */
export function isTrinket(pickup: EntityPickup): pickup is EntityPickupTrinket {
  return (
    pickup.Type === EntityType.PICKUP &&
    pickup.Variant === PickupVariant.TRINKET
  );
}

----
functions\pickups.ts
import type {
  BatterySubType,
  BombSubType,
  CoinSubType,
  HeartSubType,
  KeySubType,
  PickupVariant,
  SackSubType,
} from "isaac-typescript-definitions";
import { CHEST_PICKUP_VARIANTS_SET } from "../core/constants";
import { BATTERY_NAMES, DEFAULT_BATTERY_NAME } from "../objects/batteryNames";
import { BOMB_NAMES, DEFAULT_BOMB_NAME } from "../objects/bombNames";
import { CHEST_NAMES, DEFAULT_CHEST_NAME } from "../objects/chestNames";
import { COIN_NAMES, DEFAULT_COIN_NAME } from "../objects/coinNames";
import {
  COIN_SUB_TYPE_TO_VALUE,
  DEFAULT_COIN_VALUE,
} from "../objects/coinSubTypeToValue";
import { DEFAULT_HEART_NAME, HEART_NAMES } from "../objects/heartNames";
import { DEFAULT_KEY_NAME, KEY_NAMES } from "../objects/keyNames";
import { DEFAULT_SACK_NAME, SACK_NAMES } from "../objects/sackNames";
import { RED_HEART_SUB_TYPES_SET } from "../sets/redHeartSubTypesSet";
import { removeEntities } from "./entities";
import { isHeart } from "./pickupVariants";
import { getHearts } from "./pickupsSpecific";

/**
 * Helper function to get the name of a battery, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided battery sub-type is not valid.
 *
 * This function only works for vanilla battery types.
 *
 * For example, `getBatteryName(BatterySubType.MICRO)` would return "Micro Battery".
 */
export function getBatteryName(batterySubType: BatterySubType): string {
  // Handle modded hearts.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return BATTERY_NAMES[batterySubType] ?? DEFAULT_BATTERY_NAME;
}

/**
 * Helper function to get the name of a bomb, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided bomb sub-type is not valid.
 *
 * This function only works for vanilla bomb types.
 *
 * For example, `getBombName(BombSubType.DOUBLE_PACK)` would return "Double Bomb".
 */
export function getBombName(bombSubType: BombSubType): string {
  // Handle modded bombs.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return BOMB_NAMES[bombSubType] ?? DEFAULT_BOMB_NAME;
}

/**
 * Helper function to get the name of a chest, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the pickup variant was not a chest.
 *
 * This function only works for vanilla chest types.
 *
 * For example, `getChestName(PickupVariant.SPIKED_CHEST)` would return "Spiked Chest".
 */
export function getChestName(pickupVariant: PickupVariant): string {
  const chestNames = CHEST_NAMES as Partial<Record<PickupVariant, string>>;
  return chestNames[pickupVariant] ?? DEFAULT_CHEST_NAME;
}

/**
 * Helper function to get the name of a coin, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided coin sub-type is not valid.
 *
 * This function only works for vanilla chest types.
 *
 * For example, `getCoinName(CoinSubType.DOUBLE_PACK)` would return "Double Penny".
 */
export function getCoinName(coinSubType: CoinSubType): string {
  // Handle modded coins.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return COIN_NAMES[coinSubType] ?? DEFAULT_COIN_NAME;
}

/**
 * Helper function to get the corresponding coin amount from a `CoinSubType`. Returns 1 for modded
 * sub-types.
 */
export function getCoinValue(coinSubType: CoinSubType): int {
  const value = COIN_SUB_TYPE_TO_VALUE[coinSubType];
  // Handle modded coin sub-types.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return value ?? DEFAULT_COIN_VALUE;
}

/**
 * Helper function to get the name of a heart, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided heart sub-type is not valid.
 *
 * This function only works for vanilla heart types.
 *
 * For example, `getHeartName(HeartSubType.ETERNAL)` would return "Heart (eternal)".
 */
export function getHeartName(heartSubType: HeartSubType): string {
  // Handle modded hearts.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return HEART_NAMES[heartSubType] ?? DEFAULT_HEART_NAME;
}

/**
 * Helper function to get the name of a key, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided key sub-type is not valid.
 *
 * This function only works for vanilla key types.
 *
 * For example, `getKeyName(KeySubType.DOUBLE_PACK)` would return "Key Ring".
 */
export function getKeyName(keySubType: KeySubType): string {
  // Handle modded bombs.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return KEY_NAMES[keySubType] ?? DEFAULT_KEY_NAME;
}

/** Helper function to get all of the red heart pickup entities in the room. */
export function getRedHearts(): readonly EntityPickupHeart[] {
  const hearts = getHearts();
  return hearts.filter((heart) => RED_HEART_SUB_TYPES_SET.has(heart.SubType));
}

/**
 * Helper function to get the name of a sack, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided sack sub-type is not valid.
 *
 * This function only works for vanilla sack types.
 *
 * For example, `getSackName(SackSubType.NORMAL)` would return "Grab Bag".
 */
export function getSackName(sackSubType: SackSubType): string {
  // Handle modded hearts.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return SACK_NAMES[sackSubType] ?? DEFAULT_SACK_NAME;
}

/** Helper function to test if the provided pickup matches one of the various chest variants. */
export function isChest(pickup: EntityPickup): boolean {
  return isChestVariant(pickup.Variant);
}

/**
 * Helper function to test if the provided pickup variant matches one of the various chest variants.
 */
export function isChestVariant(pickupVariant: PickupVariant): boolean {
  return CHEST_PICKUP_VARIANTS_SET.has(pickupVariant);
}

/**
 * Helper function to test if the provided pickup matches one of the various red heart sub-types.
 */
export function isRedHeart(pickup: EntityPickup): boolean {
  return isHeart(pickup) && RED_HEART_SUB_TYPES_SET.has(pickup.SubType);
}

/**
 * Helper function to test if the provided heart sub-type matches one of the various red heart
 * sub-types.
 */
export function isRedHeartSubType(heartSubType: HeartSubType): boolean {
  return RED_HEART_SUB_TYPES_SET.has(heartSubType);
}

/**
 * Helper function to remove all of the red heart pickup entities in the room.
 *
 * @param cap Optional. If specified, will only remove the given amount of hearts.
 * @returns The red hearts that were removed.
 */
export function removeAllRedHearts(cap?: int): readonly EntityPickupHeart[] {
  const redHearts = getRedHearts();
  return removeEntities(redHearts, cap);
}

----
functions\pickupsSpecific.ts
import type {
  BatterySubType,
  BombSubType,
  CardType,
  CoinSubType,
  CollectibleType,
  HeartSubType,
  KeySubType,
  PillColor,
  SackSubType,
  TrinketType,
} from "isaac-typescript-definitions";
import { PickupVariant } from "isaac-typescript-definitions";
import { CHEST_PICKUP_VARIANTS, VectorZero } from "../core/constants";
import { removeEntities } from "./entities";
import { getPickups, removeAllPickups, spawnPickup } from "./entitiesSpecific";

/**
 * Helper function to get all of the battery entities in the room.
 *
 * @param batterySubType Optional. If specified, will only get the batteries that match the
 *                       sub-type. Default is -1, which matches every sub-type.
 */
export function getBatteries(
  batterySubType: BatterySubType | -1 = -1,
): readonly EntityPickupBattery[] {
  return getPickups(
    PickupVariant.LIL_BATTERY,
    batterySubType,
  ) as EntityPickupBattery[];
}

/**
 * Helper function to get all of the bomb entities in the room. (Specifically, this refers to bomb
 * pickups, not the `EntityBomb` class.)
 *
 * @param bombSubType Optional. If specified, will only get the bombs that match the sub-type.
 *                    Default is -1, which matches every sub-type.
 */
export function getBombPickups(
  bombSubType: BombSubType | -1 = -1,
): readonly EntityPickupBomb[] {
  return getPickups(PickupVariant.BOMB, bombSubType) as EntityPickupBomb[];
}

/**
 * Helper function to get all of the card entities in the room.
 *
 * @param cardType Optional. If specified, will only get the cards that match the sub-type. Default
 *                 is -1, which matches every sub-type.
 */
export function getCards(
  cardType: CardType | -1 = -1,
): readonly EntityPickupCard[] {
  return getPickups(PickupVariant.CARD, cardType) as EntityPickupCard[];
}

/**
 * Helper function to get all of the chest entities in the room. Specifically, this is all of the
 * pickups with a variant in the `CHEST_PICKUP_VARIANTS` constant.
 *
 * @param subType Optional. If specified, will only get the chests that match the sub-type. Default
 *                is -1, which matches every sub-type.
 */
export function getChests(subType = -1): readonly EntityPickup[] {
  const chests: EntityPickup[] = [];

  for (const pickupVariant of CHEST_PICKUP_VARIANTS) {
    const pickups = getPickups(pickupVariant, subType);
    chests.push(...pickups);
  }

  return chests;
}

/**
 * Helper function to get all of the coin pickup entities in the room.
 *
 * @param coinSubType Optional. If specified, will only get the coins that match the sub-type.
 *                    Default is -1, which matches every sub-type.
 */
export function getCoins(
  coinSubType: CoinSubType | -1 = -1,
): readonly EntityPickupCoin[] {
  return getPickups(PickupVariant.COIN, coinSubType) as EntityPickupCoin[];
}

/**
 * Helper function to get all of the collectible entities in the room.
 *
 * @param collectibleType Optional. If specified, will only get the collectibles that match the
 *                        sub-type. Default is -1, which matches every sub-type.
 */
export function getCollectibles(
  collectibleType: CollectibleType | -1 = -1,
): readonly EntityPickupCollectible[] {
  return getPickups(
    PickupVariant.COLLECTIBLE,
    collectibleType,
  ) as EntityPickupCollectible[];
}

/**
 * Helper function to get all of the heart pickup entities in the room.
 *
 * @param heartSubType Optional. If specified, will only get the hearts that match the sub-type.
 *                     Default is -1, which matches every sub-type.
 */
export function getHearts(
  heartSubType: HeartSubType | -1 = -1,
): readonly EntityPickupHeart[] {
  return getPickups(PickupVariant.HEART, heartSubType) as EntityPickupHeart[];
}

/**
 * Helper function to get all of the key pickup entities in the room.
 *
 * @param keySubType Optional. If specified, will only get the keys that match the sub-type. Default
 *                   is -1, which matches every sub-type.
 */
export function getKeys(
  keySubType: KeySubType | -1 = -1,
): readonly EntityPickupKey[] {
  return getPickups(PickupVariant.KEY, keySubType) as EntityPickupKey[];
}

/**
 * Helper function to get all of the pill entities in the room.
 *
 * @param pillColor Optional. If specified, will only get the pills that match the sub-type. Default
 *                  is -1, which matches every sub-type.
 */
export function getPills(
  pillColor: PillColor | -1 = -1,
): readonly EntityPickupPill[] {
  return getPickups(PickupVariant.PILL, pillColor) as EntityPickupPill[];
}

/**
 * Helper function to get all of the sack (i.e. grab bag) entities in the room.
 *
 * @param sackSubType Optional. If specified, will only get the sacks that match the sub-type.
 *                    Default is -1, which matches every sub-type.
 */
export function getSacks(
  sackSubType: SackSubType | -1 = -1,
): readonly EntityPickupSack[] {
  return getPickups(PickupVariant.SACK, sackSubType) as EntityPickupSack[];
}

/**
 * Helper function to get all of the trinket entities in the room.
 *
 * @param trinketType Optional. If specified, will only get the trinkets that match the sub-type.
 *                    Default is -1, which matches every sub-type.
 */
export function getTrinkets(
  trinketType: TrinketType | -1 = -1,
): readonly EntityPickupTrinket[] {
  return getPickups(
    PickupVariant.TRINKET,
    trinketType,
  ) as EntityPickupTrinket[];
}

/**
 * Helper function to remove all of the batteries in the room.
 *
 * @param batterySubType Optional. If specified, will only remove the batteries that match this
 *                       sub-type. Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of cards.
 * @returns The batteries that were removed.
 */
export function removeAllBatteries(
  batterySubType: BatterySubType | -1 = -1,
  cap?: int,
): readonly EntityPickupBattery[] {
  return removeAllPickups(
    PickupVariant.LIL_BATTERY,
    batterySubType,
    cap,
  ) as EntityPickupBattery[];
}

/**
 * Helper function to remove all of the bomb pickups in the room. (Specifically, this refers to bomb
 * pickups, not the `EntityBomb` class.)
 *
 * @param bombSubType Optional. If specified, will only remove bombs that match this sub-type.
 *                    Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of bombs.
 * @returns The bombs that were removed.
 */
export function removeAllBombPickups(
  bombSubType: BombSubType | -1 = -1,
  cap?: int,
): readonly EntityPickupBomb[] {
  return removeAllPickups(
    PickupVariant.BOMB,
    bombSubType,
    cap,
  ) as EntityPickupBomb[];
}

/**
 * Helper function to remove all of the cards in the room.
 *
 * @param cardType Optional. If specified, will only remove cards that match this sub-type. Default
 *                 is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of cards.
 * @returns The cards that were removed.
 */
export function removeAllCards(
  cardType: CardType | -1 = -1,
  cap?: int,
): readonly EntityPickupCard[] {
  return removeAllPickups(
    PickupVariant.CARD,
    cardType,
    cap,
  ) as EntityPickupCard[];
}

/**
 * Helper function to remove all of the chests in the room. Specifically, this is all of the pickups
 * with a variant in the `CHEST_PICKUP_VARIANTS` constant.
 *
 * @param subType Optional. If specified, will only remove chests that match this sub-type. Default
 *                is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of chests.
 * @returns The chests that were removed.
 */
export function removeAllChests(
  subType = -1,
  cap?: int,
): readonly EntityPickup[] {
  const chests = getChests(subType);
  return removeEntities(chests, cap);
}

/**
 * Helper function to remove all of the coins in the room.
 *
 * @param coinSubType Optional. If specified, will only remove coins that match this sub-type.
 *                    Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of coins.
 * @returns The coins that were removed.
 */
export function removeAllCoins(
  coinSubType?: CoinSubType,
  cap?: int,
): readonly EntityPickupCoin[] {
  return removeAllPickups(
    PickupVariant.COIN,
    coinSubType,
    cap,
  ) as EntityPickupCoin[];
}

/**
 * Helper function to remove all of the collectibles in the room.
 *
 * @param collectibleType Optional. If specified, will only remove collectibles that match this
 *                        sub-type. Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of collectibles.
 * @returns The collectibles that were removed.
 */
export function removeAllCollectibles(
  collectibleType?: CollectibleType,
  cap?: int,
): readonly EntityPickupCollectible[] {
  return removeAllPickups(
    PickupVariant.COLLECTIBLE,
    collectibleType,
    cap,
  ) as EntityPickupCollectible[];
}

/**
 * Helper function to remove all of the heart pickup entities in the room.
 *
 * @param heartSubType Optional. If specified, will only remove hearts that match this sub-type.
 *                     Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of hearts.
 * @returns The hearts that were removed.
 */
export function removeAllHearts(
  heartSubType?: HeartSubType,
  cap?: int,
): readonly EntityPickupHeart[] {
  return removeAllPickups(
    PickupVariant.HEART,
    heartSubType,
    cap,
  ) as EntityPickupHeart[];
}

/**
 * Helper function to remove all of the keys in the room.
 *
 * @param keySubType Optional. If specified, will only remove keys that match this sub-type. Default
 *                   is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of keys.
 * @returns The keys that were removed.
 */
export function removeAllKeys(
  keySubType?: KeySubType,
  cap?: int,
): readonly EntityPickupKey[] {
  return removeAllPickups(
    PickupVariant.KEY,
    keySubType,
    cap,
  ) as EntityPickupKey[];
}

/**
 * Helper function to remove all of the pills in the room.
 *
 * @param pillColor Optional. If specified, will only remove pills that match this sub-type. Default
 *                  is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of pills.
 * @returns The pills that were removed.
 */
export function removeAllPills(
  pillColor?: PillColor,
  cap?: int,
): readonly EntityPickupPill[] {
  return removeAllPickups(
    PickupVariant.PILL,
    pillColor,
    cap,
  ) as EntityPickupPill[];
}

/**
 * Helper function to remove all of the sacks (i.e. grab bags) in the room.
 *
 * @param sackSubType Optional. If specified, will only remove sacks that match this sub-type.
 *                    Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of sacks.
 * @returns The sacks that were removed.
 */
export function removeAllSacks(
  sackSubType?: SackSubType,
  cap?: int,
): readonly EntityPickupSack[] {
  return removeAllPickups(
    PickupVariant.SACK,
    sackSubType,
    cap,
  ) as EntityPickupSack[];
}

/**
 * Helper function to remove all of the trinkets in the room.
 *
 * @param trinketType Optional. If specified, will only remove trinkets that match this sub-type.
 *                    Default is -1, which matches every sub-type.
 * @param cap Optional. If specified, will only remove the given amount of trinkets.
 * @returns The trinkets that were removed.
 */
export function removeAllTrinkets(
  trinketType?: TrinketType,
  cap?: int,
): readonly EntityPickupTrinket[] {
  return removeAllPickups(
    PickupVariant.TRINKET,
    trinketType,
    cap,
  ) as EntityPickupTrinket[];
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.LIL_BATTERY` (90).
 */
export function spawnBattery(
  batterySubType: BatterySubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupBattery {
  return spawnPickup(
    PickupVariant.LIL_BATTERY,
    batterySubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupBattery;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.LIL_BATTERY` (90)
 * and a specific seed.
 */
export function spawnBatteryWithSeed(
  batterySubType: BatterySubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupBattery {
  return spawnBattery(
    batterySubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.BOMB` (40). */
export function spawnBombPickup(
  bombSubType: BombSubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupBomb {
  return spawnPickup(
    PickupVariant.BOMB,
    bombSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupBomb;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.BOMB` (40) and a
 * specific seed.
 */
export function spawnBombPickupWithSeed(
  bombSubType: BombSubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupBomb {
  return spawnBombPickup(
    bombSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.CARD` (300). */
export function spawnCard(
  cardType: CardType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupCard {
  return spawnPickup(
    PickupVariant.CARD,
    cardType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupCard;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.CARD` (300) and a
 * specific seed.
 */
export function spawnCardWithSeed(
  cardType: CardType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupCard {
  return spawnCard(cardType, positionOrGridIndex, velocity, spawner, seedOrRNG);
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.COIN` (20). */
export function spawnCoin(
  coinSubType: CoinSubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupCoin {
  return spawnPickup(
    PickupVariant.COIN,
    coinSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupCoin;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.COIN` (20) and a
 * specific seed.
 */
export function spawnCoinWithSeed(
  coinSubType: CoinSubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupCoin {
  return spawnCoin(
    coinSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.HEART` (10). */
export function spawnHeart(
  heartSubType: HeartSubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupHeart {
  return spawnPickup(
    PickupVariant.HEART,
    heartSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupHeart;
}

export function spawnHeartWithSeed(
  heartSubType: HeartSubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupHeart {
  return spawnHeart(
    heartSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.KEY` (30). */
export function spawnKey(
  keySubType: KeySubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupKey {
  return spawnPickup(
    PickupVariant.KEY,
    keySubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupKey;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.KEY` (30) and a
 * specific seed.
 */
export function spawnKeyWithSeed(
  keySubType: KeySubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupKey {
  return spawnKey(
    keySubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.PILL` (70). */
export function spawnPill(
  pillColor: PillColor,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupPill {
  return spawnPickup(
    PickupVariant.PILL,
    pillColor,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupPill;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.PILL` (70) and a
 * specific seed.
 */
export function spawnPillWithSeed(
  pillColor: PillColor,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupPill {
  return spawnPill(
    pillColor,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/** Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.SACK` (69). */
export function spawnSack(
  sackSubType: SackSubType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupSack {
  return spawnPickup(
    PickupVariant.SACK,
    sackSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupSack;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.SACK` (69) and a
 * specific seed.
 */
export function spawnSackWithSeed(
  sackSubType: SackSubType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupSack {
  return spawnSack(
    sackSubType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.TRINKET` (350).
 */
export function spawnTrinket(
  trinketType: TrinketType,
  positionOrGridIndex: Vector | int,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
  seedOrRNG: Seed | RNG | undefined = undefined,
): EntityPickupTrinket {
  return spawnPickup(
    PickupVariant.TRINKET,
    trinketType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  ) as EntityPickupTrinket;
}

/**
 * Helper function to spawn a `EntityType.PICKUP` (5) with variant `PickupVariant.TRINKET` (350) and
 * a specific seed.
 */
export function spawnTrinketWithSeed(
  trinketType: TrinketType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG,
  velocity: Vector = VectorZero,
  spawner: Entity | undefined = undefined,
): EntityPickupTrinket {
  return spawnTrinket(
    trinketType,
    positionOrGridIndex,
    velocity,
    spawner,
    seedOrRNG,
  );
}

----
functions\pills.ts
import type {
  ItemConfigPillEffectClass,
  ItemConfigPillEffectType,
  PillEffect,
} from "isaac-typescript-definitions";
import { PillColor } from "isaac-typescript-definitions";
import { PILL_COLOR_VALUES } from "../cachedEnumValues";
import { game, itemConfig } from "../core/cachedClasses";
import {
  FIRST_HORSE_PILL_COLOR,
  FIRST_PILL_COLOR,
  LAST_HORSE_PILL_COLOR,
  LAST_NORMAL_PILL_COLOR,
  LAST_VANILLA_PILL_EFFECT,
} from "../core/constantsFirstLast";
import { PHD_PILL_CONVERSIONS_MAP } from "../maps/PHDPillConversionsMap";
import { FALSE_PHD_PILL_CONVERSIONS_MAP } from "../maps/falsePHDPillConversionsMap";
import {
  DEFAULT_PILL_EFFECT_CLASS,
  PILL_EFFECT_CLASSES,
} from "../objects/pillEffectClasses";
import {
  DEFAULT_PILL_EFFECT_NAME,
  PILL_EFFECT_NAMES,
} from "../objects/pillEffectNames";
import { PILL_EFFECT_TYPE_TO_PILL_EFFECTS } from "../objects/pillEffectTypeToPillEffects";
import {
  DEFAULT_PILL_EFFECT_TYPE,
  PILL_EFFECT_TYPES,
} from "../objects/pillEffectTypes";
import { asNumber, asPillColor, asPillEffect } from "./types";
import { iRange } from "./utils";

/**
 * Add this to a `PillColor` to get the corresponding giant pill color.
 *
 * Corresponds to the vanilla `PillColor.GIANT_FLAG` value.
 *
 * 1 << 11
 */
const HORSE_PILL_COLOR_ADJUSTMENT = 2048;

/**
 * Helper function to get an array with every non-null pill color. This includes all gold colors and
 * all horse colors.
 */
export function getAllPillColors(): readonly PillColor[] {
  return PILL_COLOR_VALUES.slice(1); // Remove `PillColor.NULL`
}

/**
 * Helper function to get the associated pill effect after False PHD is acquired. If a pill effect
 * is not altered by False PHD, then the same pill effect will be returned.
 */
export function getFalsePHDPillEffect(pillEffect: PillEffect): PillEffect {
  const convertedPillEffect = FALSE_PHD_PILL_CONVERSIONS_MAP.get(pillEffect);
  return convertedPillEffect ?? pillEffect;
}

/**
 * Helper function to get the corresponding horse pill color from a normal pill color.
 *
 * For example, passing `PillColor.BLUE_BLUE` would result in 2049, which is the value that
 * corresponds to the horse pill color for blue/blue.
 *
 * If passed a horse pill color, this function will return the unmodified pill color.
 */
export function getHorsePillColor(pillColor: PillColor): PillColor {
  return isHorsePill(pillColor)
    ? pillColor
    : pillColor + HORSE_PILL_COLOR_ADJUSTMENT;
}

/** Helper function to get an array with every non-gold horse pill color. */
export function getHorsePillColors(): readonly PillColor[] {
  return iRange(FIRST_HORSE_PILL_COLOR, LAST_HORSE_PILL_COLOR);
}

/**
 * Helper function to get the corresponding normal pill color from a horse pill color.
 *
 * For example, passing 2049 would result in `PillColor.BLUE_BLUE`.
 *
 * If called with a non-horse pill color, this function will return back the same color.
 */
export function getNormalPillColorFromHorse(pillColor: PillColor): PillColor {
  return isHorsePill(pillColor)
    ? asPillColor(pillColor - HORSE_PILL_COLOR_ADJUSTMENT)
    : pillColor;
}

/** Helper function to get an array with every non-gold and non-horse pill color. */
export function getNormalPillColors(): readonly PillColor[] {
  return iRange(FIRST_PILL_COLOR, LAST_NORMAL_PILL_COLOR);
}

/**
 * Helper function to get the associated pill effect after PHD is acquired. If a pill effect is not
 * altered by PHD, then the same pill effect will be returned.
 */
export function getPHDPillEffect(pillEffect: PillEffect): PillEffect {
  const convertedPillEffect = PHD_PILL_CONVERSIONS_MAP.get(pillEffect);
  return convertedPillEffect ?? pillEffect;
}

/**
 * Helper function to get the corresponding pill color from an effect by repeatedly using the
 * `ItemPool.GetPillEffect` method.
 *
 * Note that this will return the corresponding effect even if the passed pill color is not yet
 * identified by the player.
 *
 * Returns `PillColor.NULL` if there is the corresponding pill color cannot be found.
 *
 * This function is especially useful in the `POST_USE_PILL` callback, since at that point, the used
 * pill is already consumed, and the callback only passes the effect. In this specific circumstance,
 * consider using the `POST_USE_PILL_FILTER` callback instead of the `POST_USE_PILL` callback, since
 * it correctly passes the color and handles the case of horse pills.
 */
export function getPillColorFromEffect(pillEffect: PillEffect): PillColor {
  const itemPool = game.GetItemPool();
  const normalPillColors = getNormalPillColors();
  for (const normalPillColor of normalPillColors) {
    const normalPillEffect = itemPool.GetPillEffect(normalPillColor);
    if (normalPillEffect === pillEffect) {
      return normalPillColor;
    }
  }

  return PillColor.NULL;
}

/**
 * Helper function to get a pill effect class from a PillEffect enum value. In this context, the
 * class is equal to the numerical prefix in the "class" tag in the "pocketitems.xml" file. Use the
 * `getPillEffectType` helper function to determine whether the pill effect is positive, negative,
 * or neutral.
 *
 * Due to limitations in the API, this function will not work properly for modded pill effects, and
 * will always return `DEFAULT_PILL_EFFECT_CLASS` in those cases.
 */
export function getPillEffectClass(
  pillEffect: PillEffect,
): ItemConfigPillEffectClass {
  // `ItemConfigPillEffect` does not contain the "class" tag, so we must manually compile a map of
  // pill effect classes. Modded pill effects are not included in the map.
  const pillEffectClass = PILL_EFFECT_CLASSES[pillEffect];

  // Handle modded pill effects.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return pillEffectClass ?? DEFAULT_PILL_EFFECT_CLASS;
}

/**
 * Helper function to get a pill effect name from a `PillEffect`. Returns "Unknown" if the provided
 * pill effect is not valid.
 *
 * This function works for both vanilla and modded pill effects.
 *
 * For example, `getPillEffectName(PillEffect.BAD_GAS)` would return "Bad Gas".
 */
export function getPillEffectName(pillEffect: PillEffect): string {
  // `ItemConfigPillEffect.Name` is bugged with vanilla pill effects on patch v1.7.6, so we use a
  // hard-coded map as a workaround.
  const pillEffectName = PILL_EFFECT_NAMES[pillEffect];
  // Handle modded pill effects.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (pillEffectName !== undefined) {
    return pillEffectName;
  }

  const itemConfigPillEffect = itemConfig.GetPillEffect(pillEffect);
  if (itemConfigPillEffect !== undefined) {
    return itemConfigPillEffect.Name;
  }

  return DEFAULT_PILL_EFFECT_NAME;
}

/**
 * Helper function to get a pill effect type from a `PillEffect` enum value. In this context, the
 * type is equal to positive, negative, or neutral. This is derived from the suffix of the "class"
 * tag in the "pocketitems.xml" file. Use the `getPillEffectClass` helper function to determine the
 * "power" of the pill.
 *
 * Due to limitations in the API, this function will not work properly for modded pill effects, and
 * will always return `DEFAULT_PILL_EFFECT_TYPE` in those cases.
 */
export function getPillEffectType(
  pillEffect: PillEffect,
): ItemConfigPillEffectType {
  // `ItemConfigPillEffect` does not contain the "class" tag, so we must manually compile a map of
  // pill effect classes. Modded pill effects are not included in the map.
  const pillEffectType = PILL_EFFECT_TYPES[pillEffect];

  // Handle modded pill effects.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return pillEffectType ?? DEFAULT_PILL_EFFECT_TYPE;
}

export function getVanillaPillEffectsOfType(
  pillEffectType: ItemConfigPillEffectType,
): readonly PillEffect[] {
  return PILL_EFFECT_TYPE_TO_PILL_EFFECTS[pillEffectType];
}

/** Helper function to see if the given pill color is either a gold pill or a horse gold pill. */
export function isGoldPill(pillColor: PillColor): boolean {
  return pillColor === PillColor.GOLD || pillColor === PillColor.HORSE_GOLD;
}

/**
 * Helper function to see if the given pill color is a horse pill.
 *
 * Under the hood, this checks for `pillColor > 2048`.
 */
export function isHorsePill(pillColor: PillColor): boolean {
  return asNumber(pillColor) > HORSE_PILL_COLOR_ADJUSTMENT;
}

export function isModdedPillEffect(pillEffect: PillEffect): boolean {
  return !isVanillaPillEffect(pillEffect);
}

/**
 * Helper function to see if the given pill color is not a gold pill and not a horse pill and not
 * the null value.
 *
 * Under the hood, this checks using the `FIRST_PILL_COLOR` and `LAST_NORMAL_PILL_COLOR` constants.
 */
export function isNormalPillColor(pillColor: PillColor): boolean {
  return pillColor >= FIRST_PILL_COLOR && pillColor <= LAST_NORMAL_PILL_COLOR;
}

export function isValidPillEffect(pillEffect: int): pillEffect is PillEffect {
  const potentialPillEffect = asPillEffect(pillEffect);
  const itemConfigPillEffect = itemConfig.GetPillEffect(potentialPillEffect);
  return itemConfigPillEffect !== undefined;
}

export function isVanillaPillEffect(pillEffect: PillEffect): boolean {
  return pillEffect <= LAST_VANILLA_PILL_EFFECT;
}

----
functions\playerCenter.ts
import { Direction } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import {
  NEW_FLOOR_STARTING_POSITION_GREED_MODE,
  NEW_FLOOR_STARTING_POSITION_NORMAL_MODE,
} from "../core/constants";
import { getPlayerFamiliars } from "./familiars";
import { getCircleDiscretizedPoints } from "./math";
import { getAllPlayers } from "./playerIndex";

/**
 * Helper function to move all of the players to where they would normally go when arriving at a new
 * floor. (In normal mode, this is the center of the room. In Greed Mode, this is below the top
 * door.)
 *
 * If there is more than one player, they will be distributed around the center in a circle.
 *
 * This function emulates what happens in the vanilla game when you travel to a new floor.
 *
 * @param radius Optional. The radius of the circle. Default is 10.
 */
export function movePlayersToCenter(radius: float = 10): void {
  const isGreedMode = game.IsGreedMode();
  const startingPosition = isGreedMode
    ? NEW_FLOOR_STARTING_POSITION_GREED_MODE
    : NEW_FLOOR_STARTING_POSITION_NORMAL_MODE;

  const players = getAllPlayers();
  const firstPlayer = players[0];
  if (firstPlayer === undefined) {
    return;
  }

  // If there is only one player, we can move them exactly to the center of the room.
  if (players.length === 1) {
    movePlayerAndTheirFamiliars(firstPlayer, startingPosition);
    return;
  }

  // If there is more than one player, spread them out in a circle around the center of the room.
  // (This is what happens in vanilla.)
  const circlePoints = getCircleDiscretizedPoints(
    startingPosition,
    radius,
    players.length,
    1,
    1,
    Direction.LEFT,
  );

  for (const [i, player] of players.entries()) {
    const circlePosition = circlePoints[i];
    if (circlePosition !== undefined) {
      player.Position = circlePosition;
    }
  }
}

function movePlayerAndTheirFamiliars(player: EntityPlayer, position: Vector) {
  player.Position = position;

  const familiars = getPlayerFamiliars(player);
  for (const familiar of familiars) {
    familiar.Position = position;
  }
}

----
functions\playerCollectibles.ts
import {
  ActiveSlot,
  CollectibleType,
  PlayerType,
} from "isaac-typescript-definitions";
import { ACTIVE_SLOT_VALUES } from "../cachedEnumValues";
import { game, itemConfig } from "../core/cachedClasses";
import { ReadonlySet } from "../types/ReadonlySet";
import { sumArray } from "./array";
import { getCollectibleMaxCharges } from "./collectibles";
import { getAllPlayers, getPlayers } from "./playerIndex";
import { isCharacter } from "./players";

/**
 * Helper function to add one or more collectibles to a player.
 *
 * This function is variadic, meaning that you can supply as many collectible types as you want to
 * add.
 */
export function addCollectible(
  player: EntityPlayer,
  ...collectibleTypes: readonly CollectibleType[]
): void {
  for (const collectibleType of collectibleTypes) {
    player.AddCollectible(collectibleType);
  }
}

export function addCollectibleCostume(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return;
  }

  player.AddCostume(itemConfigItem, false);
}

/**
 * Helper function to check to see if any player has a particular collectible.
 *
 * @param collectibleType The collectible type to check for.
 * @param ignoreModifiers If set to true, only counts collectibles the player actually owns and
 *                        ignores effects granted by items like Zodiac, 3 Dollar Bill and Lemegeton.
 *                        Default is false.
 */
export function anyPlayerHasCollectible(
  collectibleType: CollectibleType,
  ignoreModifiers?: boolean,
): boolean {
  const players = getAllPlayers();

  return players.some((player) =>
    player.HasCollectible(collectibleType, ignoreModifiers),
  );
}

/**
 * Helper function to find the active slots that the player has the corresponding collectible type
 * in. Returns an empty array if the player does not have the collectible in any active slot.
 */
export function getActiveItemSlots(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): readonly ActiveSlot[] {
  return ACTIVE_SLOT_VALUES.filter((activeSlot) => {
    const activeItem = player.GetActiveItem(activeSlot);
    return activeItem === collectibleType;
  });
}

/**
 * Helper function to get the adjusted price for a pickup, depending on how many Steam Sales all
 * players currently have. (For example, if Jacob has one Steam Sale and Esau has one Steam Sale,
 * the prices for items in the shop would be the same as if Isaac had two Steam Sales.)
 */
export function getAdjustedPrice(basePrice: int): int {
  const numSteamSales = getTotalPlayerCollectibles(CollectibleType.STEAM_SALE);
  return numSteamSales > 0
    ? Math.floor(basePrice / (numSteamSales + 1))
    : basePrice;
}

/**
 * Helper function to return the total amount of collectibles that a player has that match the
 * collectible type(s) provided.
 *
 * This function is variadic, meaning that you can specify N collectible types.
 *
 * Note that this will filter out non-real collectibles like Lilith's Incubus.
 */
export function getPlayerCollectibleCount(
  player: EntityPlayer,
  ...collectibleTypes: readonly CollectibleType[]
): int {
  let numCollectibles = 0;
  for (const collectibleType of collectibleTypes) {
    // We specify "true" as the second argument to filter out things like Lilith's Incubus.
    numCollectibles += player.GetCollectibleNum(collectibleType, true);
  }

  return numCollectibles;
}

/**
 * Helper function to get only the players that have a certain collectible.
 *
 * This function is variadic, meaning that you can supply as many collectible types as you want to
 * check for. It only returns the players that have all of the collectibles.
 */
export function getPlayersWithCollectible(
  ...collectibleTypes: readonly CollectibleType[]
): readonly EntityPlayer[] {
  const players = getPlayers();

  return players.filter((player) =>
    collectibleTypes.every((collectibleType) =>
      player.HasCollectible(collectibleType),
    ),
  );
}

/**
 * Returns the total number of collectibles amongst all players. For example, if player 1 has 1 Sad
 * Onion and player 2 has 2 Sad Onions, then this function would return 3.
 *
 * Note that this will filter out non-real collectibles like Lilith's Incubus.
 */
export function getTotalPlayerCollectibles(
  collectibleType: CollectibleType,
): int {
  const players = getPlayers();
  const numCollectiblesArray = players.map((player) =>
    // We specify "true" as the second argument to filter out things like Lilith's Incubus.
    player.GetCollectibleNum(collectibleType, true),
  );

  return sumArray(numCollectiblesArray);
}

/**
 * Helper function to check to see if a player has one or more collectibles.
 *
 * This function is variadic, meaning that you can supply as many collectible types as you want to
 * check for. Returns true if the player has any of the supplied collectible types.
 *
 * This function always passes `false` to the `ignoreModifiers` argument.
 */
export function hasCollectible(
  player: EntityPlayer,
  ...collectibleTypes: readonly CollectibleType[]
): boolean {
  return collectibleTypes.some((collectibleType) =>
    player.HasCollectible(collectibleType),
  );
}

/**
 * Helper function to check to see if a player has a specific collectible in one or more active
 * slots.
 *
 * This function is variadic, meaning that you can specify as many active slots as you want to check
 * for. This function will return true if the collectible type is located in any of the active slots
 * provided.
 */
export function hasCollectibleInActiveSlot(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  ...activeSlots: readonly ActiveSlot[]
): boolean {
  const matchingActiveSlotsSet = new ReadonlySet(activeSlots);
  const activeItemSlots = getActiveItemSlots(player, collectibleType);

  return activeItemSlots.some((activeSlot) =>
    matchingActiveSlotsSet.has(activeSlot),
  );
}

/**
 * Returns whether the player can hold an additional active item, beyond what they are currently
 * carrying. This takes the Schoolbag into account.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export function hasOpenActiveItemSlot(player: EntityPlayer): boolean {
  if (isCharacter(player, PlayerType.SOUL_B)) {
    return false;
  }

  const activeItemPrimary = player.GetActiveItem(ActiveSlot.PRIMARY);
  const activeItemSecondary = player.GetActiveItem(ActiveSlot.SECONDARY);
  const hasSchoolbag = player.HasCollectible(CollectibleType.SCHOOLBAG);

  if (hasSchoolbag) {
    return (
      activeItemPrimary === CollectibleType.NULL ||
      activeItemSecondary === CollectibleType.NULL
    );
  }

  return activeItemPrimary === CollectibleType.NULL;
}

/**
 * Helper function to check if the active slot of a particular player is empty.
 *
 * @param player The player to check.
 * @param activeSlot Optional. The active slot to check. Default is `ActiveSlot.PRIMARY`.
 */
export function isActiveSlotEmpty(
  player: EntityPlayer,
  activeSlot = ActiveSlot.PRIMARY,
): boolean {
  const activeCollectibleType = player.GetActiveItem(activeSlot);
  return activeCollectibleType === CollectibleType.NULL;
}

/**
 * Helper function to remove all of the active items from a player. This includes the Schoolbag item
 * and any pocket actives.
 */
export function removeAllActiveItems(player: EntityPlayer): void {
  for (const activeSlot of ACTIVE_SLOT_VALUES) {
    const collectibleType = player.GetActiveItem(activeSlot);
    if (collectibleType === CollectibleType.NULL) {
      continue;
    }

    let stillHasCollectible: boolean;
    do {
      player.RemoveCollectible(collectibleType);
      stillHasCollectible = player.HasCollectible(collectibleType);
    } while (stillHasCollectible);
  }
}

/**
 * Helper function to remove one or more collectibles to a player.
 *
 * This function is variadic, meaning that you can supply as many collectible types as you want to
 * remove.
 */
export function removeCollectible(
  player: EntityPlayer,
  ...collectibleTypes: readonly CollectibleType[]
): void {
  for (const collectibleType of collectibleTypes) {
    player.RemoveCollectible(collectibleType);
  }
}

/**
 * Helper function to remove a collectible costume from a player. Use this helper function to avoid
 * having to request the collectible from the item config.
 */
export function removeCollectibleCostume(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  const itemConfigItem = itemConfig.GetCollectible(collectibleType);
  if (itemConfigItem === undefined) {
    return;
  }

  player.RemoveCostume(itemConfigItem);
}

/**
 * Helper function to remove one or more collectibles from all players. If any player has more than
 * one copy of the item, then all copies of it will be removed.
 *
 * This function is variadic, meaning that you can specify as many collectibles as you want to
 * remove.
 */
export function removeCollectibleFromAllPlayers(
  ...collectibleTypes: readonly CollectibleType[]
): void {
  for (const player of getAllPlayers()) {
    for (const collectibleType of collectibleTypes) {
      while (player.HasCollectible(collectibleType, true)) {
        player.RemoveCollectible(collectibleType);
      }
    }
  }
}

/**
 * Helper function to set an active collectible to a particular slot. This has different behavior
 * than calling the `player.AddCollectible` method with the `activeSlot` argument, because this
 * function will not shift existing items into the Schoolbag and it handles
 * `ActiveSlot.SLOT_POCKET2`.
 *
 * Note that if an item is set to `ActiveSlot.SLOT_POCKET2`, it will disappear after being used and
 * will be automatically removed upon entering a new room.
 *
 * @param player The player to give the item to.
 * @param collectibleType The collectible type of the item to give.
 * @param activeSlot Optional. The slot to set. Default is `ActiveSlot.PRIMARY`.
 * @param charge Optional. The argument of charges to set. If not specified, the item will be set
 *               with maximum charges.
 * @param keepInPools Optional. Whether to remove the item from pools. Default is false.
 */
export function setActiveItem(
  player: EntityPlayer,
  collectibleType: CollectibleType,
  activeSlot = ActiveSlot.PRIMARY,
  charge?: int,
  keepInPools = false,
): void {
  const itemPool = game.GetItemPool();
  const primaryCollectibleType = player.GetActiveItem(ActiveSlot.PRIMARY);
  const primaryCharge = player.GetActiveCharge(ActiveSlot.PRIMARY);
  const secondaryCollectibleType = player.GetActiveItem(ActiveSlot.SECONDARY);

  if (charge === undefined) {
    charge = getCollectibleMaxCharges(collectibleType);
  }

  if (!keepInPools) {
    itemPool.RemoveCollectible(collectibleType);
  }

  switch (activeSlot) {
    case ActiveSlot.PRIMARY: {
      // If there is a Schoolbag item, removing the primary item will shift the Schoolbag item to
      // the primary slot.
      if (primaryCollectibleType !== CollectibleType.NULL) {
        player.RemoveCollectible(primaryCollectibleType);
      }

      // If there was a Schoolbag item, adding a new primary item will shift it back into the
      // secondary slot.
      player.AddCollectible(collectibleType, charge, false);

      break;
    }

    case ActiveSlot.SECONDARY: {
      if (primaryCollectibleType !== CollectibleType.NULL) {
        player.RemoveCollectible(primaryCollectibleType);
      }

      if (secondaryCollectibleType !== CollectibleType.NULL) {
        player.RemoveCollectible(secondaryCollectibleType);
      }

      // Add the new item, which will go to the primary slot.
      player.AddCollectible(secondaryCollectibleType, charge, false);

      // Add back the original primary item, if any.
      if (primaryCollectibleType !== CollectibleType.NULL) {
        player.AddCollectible(primaryCollectibleType, primaryCharge, false);
      }

      break;
    }

    case ActiveSlot.POCKET: {
      player.SetPocketActiveItem(collectibleType, activeSlot, keepInPools);
      player.SetActiveCharge(charge, activeSlot);

      break;
    }

    case ActiveSlot.POCKET_SINGLE_USE: {
      player.SetPocketActiveItem(collectibleType, activeSlot, keepInPools);
      break;
    }
  }
}

/**
 * Helper function to use an active item without showing an animation, keeping the item, or adding
 * any costumes.
 */
export function useActiveItemTemp(
  player: EntityPlayer,
  collectibleType: CollectibleType,
): void {
  player.UseActiveItem(collectibleType, false, false, true, false, -1);
}

----
functions\playerDataStructures.ts
import type { DefaultMap } from "../classes/DefaultMap";
import type { PlayerIndex } from "../types/PlayerIndex";
import { getPlayerIndex } from "./playerIndex";

/**
 * Helper function to make using default maps with an index of `PlayerIndex` easier. Use this
 * instead of the `DefaultMap.getAndSetDefault` method if you have a default map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     playersSpeedBoost: new DefaultMap<PlayerIndex, int>(0),
 *   },
 * };
 *
 * function evaluateCacheSpeed(player: EntityPlayer) {
 *   player.MoveSpeed = defaultMapGetPlayer(v.run.playersSpeedBoost, player);
 * }
 * ```
 *
 * @allowEmptyVariadic
 */
export function defaultMapGetPlayer<V, Args extends unknown[]>(
  map: DefaultMap<PlayerIndex, V, Args>,
  player: EntityPlayer,
  ...extraArgs: Args
): V {
  const playerIndex = getPlayerIndex(player);
  return map.getAndSetDefault(playerIndex, ...extraArgs);
}

/**
 * Helper function to make using maps with an index of `PlayerIndex` easier. Use this instead of the
 * `Map.set` method if you have a map of this type.
 *
 * Since `Map` and `DefaultMap` set values in the same way, this function is simply an alias for the
 * `mapSetPlayer` helper function.
 */
export function defaultMapSetPlayer<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PlayerIndex, V>,
  player: EntityPlayer,
  value: V,
): void {
  mapSetPlayer(map, player, value);
}

/**
 * Helper function to make using maps with an type of `PlayerIndex` easier. Use this instead of the
 * `Map.delete` method if you have a set of this type.
 */
export function mapDeletePlayer(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PlayerIndex, unknown>,
  player: EntityPlayer,
): boolean {
  const playerIndex = getPlayerIndex(player);
  return map.delete(playerIndex);
}

/**
 * Helper function to make using maps with an index of `PlayerIndex` easier. Use this instead of the
 * `Map.get` method if you have a map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     playersSpeedBoost: new Map<PlayerIndex, int>(),
 *   },
 * };
 *
 * function incrementSpeedBoost(player: EntityPlayer) {
 *   const oldSpeedBoost = mapGetPlayer(v.run.playersSpeedBoost, player);
 *   const newSpeedBoost = oldSpeedBoost + 0.1;
 *   mapSetPlayer(v.run.playersSpeedBoost, player);
 * }
 * ```
 */
export function mapGetPlayer<V>(
  map: ReadonlyMap<PlayerIndex, V>,
  player: EntityPlayer,
): V | undefined {
  const playerIndex = getPlayerIndex(player);
  return map.get(playerIndex);
}

/**
 * Helper function to make using maps with an index of `PlayerIndex` easier. Use this instead of the
 * `Map.has` method if you have a map of this type.
 */
export function mapHasPlayer<V>(
  map: ReadonlyMap<PlayerIndex, V>,
  player: EntityPlayer,
): boolean {
  const playerIndex = getPlayerIndex(player);
  return map.has(playerIndex);
}

/**
 * Helper function to make using maps with an index of `PlayerIndex` easier. Use this instead of the
 * `Map.set` method if you have a map of this type.
 *
 * For example:
 *
 * ```ts
 * const v = {
 *   run: {
 *     playersSpeedBoost: new Map<PlayerIndex, int>(),
 *   },
 * };
 *
 * function incrementSpeedBoost(player: EntityPlayer) {
 *   const oldSpeedBoost = mapGetPlayer(v.run.playersSpeedBoost, player);
 *   const newSpeedBoost = oldSpeedBoost + 0.1;
 *   mapSetPlayer(v.run.playersSpeedBoost, player);
 * }
 * ```
 */
export function mapSetPlayer<V>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  map: Map<PlayerIndex, V>,
  player: EntityPlayer,
  value: V,
): void {
  const playerIndex = getPlayerIndex(player);
  map.set(playerIndex, value);
}

/**
 * Helper function to make using sets with an type of `PlayerIndex` easier. Use this instead of the
 * `Set.add` method if you have a set of this type.
 */
export function setAddPlayer(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  set: Set<PlayerIndex>,
  player: EntityPlayer,
): void {
  const playerIndex = getPlayerIndex(player);
  set.add(playerIndex);
}

/**
 * Helper function to make using sets with an type of `PlayerIndex` easier. Use this instead of the
 * `Set.delete` method if you have a set of this type.
 */
export function setDeletePlayer(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  set: Set<PlayerIndex>,
  player: EntityPlayer,
): boolean {
  const playerIndex = getPlayerIndex(player);
  return set.delete(playerIndex);
}

/**
 * Helper function to make using sets with an type of `PlayerIndex` easier. Use this instead of the
 * `Set.has` method if you have a set of this type.
 */
export function setHasPlayer(
  set: ReadonlySet<PlayerIndex>,
  player: EntityPlayer,
): boolean {
  const playerIndex = getPlayerIndex(player);
  return set.has(playerIndex);
}

----
functions\playerEffects.ts
import type {
  CollectibleType,
  NullItemID,
  TrinketType,
} from "isaac-typescript-definitions";
import { PlayerType } from "isaac-typescript-definitions";
import { getAllPlayers } from "./playerIndex";
import { isCharacter } from "./players";

/** Helper function to check to see if any player has a temporary collectible effect. */
export function anyPlayerHasCollectibleEffect(
  collectibleType: CollectibleType,
): boolean {
  const players = getAllPlayers();

  return players.some((player) => {
    const effects = player.GetEffects();
    return effects.HasCollectibleEffect(collectibleType);
  });
}

/** Helper function to check to see if any player has a temporary null effect. */
export function anyPlayerHasNullEffect(nullItemID: NullItemID): boolean {
  const players = getAllPlayers();

  return players.some((player) => {
    const effects = player.GetEffects();
    return effects.HasNullEffect(nullItemID);
  });
}

/** Helper function to check to see if any player has a temporary trinket effect. */
export function anyPlayerHasTrinketEffect(trinketType: TrinketType): boolean {
  const players = getAllPlayers();

  return players.some((player) => {
    const effects = player.GetEffects();
    return effects.HasTrinketEffect(trinketType);
  });
}

/**
 * Helper function to get an array of temporary effects for a player. This is helpful so that you
 * don't have to manually create an array from an `EffectsList` object.
 */
export function getEffectsList(
  player: EntityPlayer,
): readonly TemporaryEffect[] {
  const effects = player.GetEffects();
  const effectsList = effects.GetEffectsList();

  const effectArray: TemporaryEffect[] = [];
  for (let i = 0; i < effectsList.Size; i++) {
    const effect = effectsList.Get(i);
    if (effect !== undefined) {
      effectArray.push(effect);
    }
  }

  return effectArray;
}

/**
 * Helper function to check if a player should have Whore of Babylon active at their current health
 * level.
 *
 * - For most characters, Whore of Babylon activates when the red hearts are at 1/2 or less.
 * - For Eve, Whore of Babylon activates when the red hearts are at 1 or less.
 */
export function shouldWhoreOfBabylonBeActive(player: EntityPlayer): boolean {
  const redHearts = player.GetHearts();
  const threshold = isCharacter(player, PlayerType.EVE) ? 2 : 1;

  return redHearts <= threshold;
}

----
functions\playerHealth.ts
import type { ActiveSlot } from "isaac-typescript-definitions";
import {
  CollectibleType,
  HeartSubType,
  PlayerType,
  TrinketType,
} from "isaac-typescript-definitions";
import { MAX_PLAYER_HEART_CONTAINERS } from "../core/constants";
import { HealthType } from "../enums/HealthType";
import type { PlayerHealth, SoulHeartType } from "../interfaces/PlayerHealth";
import { countSetBits, getKBitOfN, getNumBitsOfN } from "./bitwise";
import { getCharacterMaxHeartContainers } from "./characters";
import { getTotalCharge } from "./charge";
import { getActiveItemSlots, setActiveItem } from "./playerCollectibles";
import { isCharacter, isKeeper } from "./players";
import { repeat } from "./utils";

export function addPlayerHealthType(
  player: EntityPlayer,
  healthType: HealthType,
  numHearts: int,
): void {
  switch (healthType) {
    case HealthType.RED: {
      player.AddHearts(numHearts);
      break;
    }

    case HealthType.SOUL: {
      player.AddSoulHearts(numHearts);
      break;
    }

    case HealthType.ETERNAL: {
      player.AddEternalHearts(numHearts);
      break;
    }

    case HealthType.BLACK: {
      player.AddBlackHearts(numHearts);
      break;
    }

    case HealthType.GOLDEN: {
      player.AddGoldenHearts(numHearts);
      break;
    }

    case HealthType.BONE: {
      player.AddBoneHearts(numHearts);
      break;
    }

    case HealthType.ROTTEN: {
      player.AddRottenHearts(numHearts);
      break;
    }

    case HealthType.BROKEN: {
      player.AddBrokenHearts(numHearts);
      break;
    }

    case HealthType.MAX_HEARTS: {
      player.AddMaxHearts(numHearts, false);
      break;
    }
  }
}

/**
 * Helper function to see if the provided player can pick up an eternal heart. (If a player already
 * has an eternal heart and full heart containers, they are not able to pick up any additional
 * eternal hearts.)
 *
 * This function's name matches the existing `EntityPlayer` methods.
 */
export function canPickEternalHearts(player: EntityPlayer): boolean {
  const eternalHearts = player.GetEternalHearts();
  const maxHearts = player.GetMaxHearts();
  const heartLimit = player.GetHeartLimit();

  return eternalHearts === 0 || maxHearts !== heartLimit;
}

/**
 * Returns whether all of the player's soul-heart-type hearts are black hearts.
 *
 * Note that this function does not consider red heart containers.
 *
 * For example:
 *
 * - If the player has one black heart, this function would return true.
 * - If the player has one soul heart and two black hearts, this function would return false.
 * - If the player has no black hearts, this function will return false.
 * - If the player has one red heart container and three black hearts, this function would return
 *   true.
 */
export function doesPlayerHaveAllBlackHearts(player: EntityPlayer): boolean {
  const soulHearts = getPlayerSoulHearts(player);
  const blackHearts = getPlayerBlackHearts(player);

  return blackHearts > 0 && soulHearts === 0;
}

/**
 * Returns whether all of the player's soul-heart-type hearts are soul hearts.
 *
 * Note that this function does not consider red heart containers.
 *
 * For example:
 *
 * - If the player has two soul hearts and one black heart, this function would return false.
 * - If the player has no soul hearts, this function will return false.
 * - If the player has one red heart container and three soul hearts, this function would return
 *   true.
 */
export function doesPlayerHaveAllSoulHearts(player: EntityPlayer): boolean {
  const soulHearts = getPlayerSoulHearts(player);
  const blackHearts = getPlayerBlackHearts(player);

  return soulHearts > 0 && blackHearts === 0;
}

/**
 * Returns the number of slots that the player has remaining for new heart containers, accounting
 * for broken hearts. For example, if the player is Judas and has 1 red heart containers and 2 full
 * soul hearts and 3 broken hearts, then this function would return 6 (i.e. 12 - 1 - 2 - 3).
 */
export function getPlayerAvailableHeartSlots(player: EntityPlayer): int {
  const maxHeartContainers = getPlayerMaxHeartContainers(player);
  const effectiveMaxHearts = player.GetEffectiveMaxHearts();
  const normalAndBoneHeartContainers = effectiveMaxHearts / 2;
  const soulHearts = player.GetSoulHearts();
  const soulHeartContainers = Math.ceil(soulHearts / 2);
  const totalHeartContainers =
    normalAndBoneHeartContainers + soulHeartContainers;
  const brokenHearts = player.GetBrokenHearts();
  const totalOccupiedHeartSlots = totalHeartContainers + brokenHearts;

  return maxHeartContainers - totalOccupiedHeartSlots;
}

/**
 * Returns the number of black hearts that the player has, excluding any soul hearts. For example,
 * if the player has one full black heart, one full soul heart, and one half black heart, this
 * function returns 3.
 *
 * This is different from the `EntityPlayer.GetBlackHearts` method, since that returns a bitmask.
 */
export function getPlayerBlackHearts(player: EntityPlayer): int {
  const blackHeartsBitmask = player.GetBlackHearts();
  const blackHeartBits = countSetBits(blackHeartsBitmask);

  return blackHeartBits * 2;
}

/**
 * Helper function to get an object representing the player's health. You can use this in
 * combination with the `setPlayerHealth` function to restore the player's health back to a certain
 * configuration at a later time.
 *
 * This is based on the `REVEL.StoreHealth` function in the Revelations mod.
 */
export function getPlayerHealth(player: EntityPlayer): Readonly<PlayerHealth> {
  const character = player.GetPlayerType();
  let maxHearts = player.GetMaxHearts();
  let hearts = getPlayerHearts(player); // We use the helper function to remove rotten hearts
  let soulHearts = player.GetSoulHearts();
  let boneHearts = player.GetBoneHearts();
  const goldenHearts = player.GetGoldenHearts();
  const eternalHearts = player.GetEternalHearts();
  const rottenHearts = player.GetRottenHearts();
  const brokenHearts = player.GetBrokenHearts();
  const subPlayer = player.GetSubPlayer();
  const soulCharges = player.GetEffectiveSoulCharge();
  const bloodCharges = player.GetEffectiveBloodCharge();

  // The Forgotten and The Soul has special health, so we need to account for this.
  if (character === PlayerType.FORGOTTEN && subPlayer !== undefined) {
    // The Forgotten does not have red heart containers.
    maxHearts = boneHearts * 2;
    boneHearts = 0;

    // The Forgotten will always have 0 soul hearts; we need to get the soul heart amount from the
    // sub player.
    soulHearts = subPlayer.GetSoulHearts();
  } else if (character === PlayerType.SOUL && subPlayer !== undefined) {
    // The Soul will always have 0 bone hearts; we need to get the bone heart amount from the sub
    // player. We need to store it as "maxHearts" instead of "boneHearts".
    maxHearts = subPlayer.GetBoneHearts() * 2;
    hearts = subPlayer.GetHearts();
  }

  // This is the number of individual hearts shown in the HUD, minus heart containers.
  const extraHearts = Math.ceil(soulHearts / 2) + boneHearts;

  // Since bone hearts can be inserted anywhere between soul hearts, we need a separate counter to
  // track which soul heart we're currently at.
  let currentSoulHeart = 0;

  const soulHeartTypes: SoulHeartType[] = [];
  for (let i = 0; i < extraHearts; i++) {
    let isBoneHeart = player.IsBoneHeart(i);
    if (character === PlayerType.FORGOTTEN && subPlayer !== undefined) {
      isBoneHeart = subPlayer.IsBoneHeart(i);
    }
    if (isBoneHeart) {
      soulHeartTypes.push(HeartSubType.BONE);
    } else {
      // We need to add 1 here because only the second half of a black heart is considered black.
      let isBlackHeart = player.IsBlackHeart(currentSoulHeart + 1);
      if (character === PlayerType.FORGOTTEN && subPlayer !== undefined) {
        isBlackHeart = subPlayer.IsBlackHeart(currentSoulHeart + 1);
      }
      if (isBlackHeart) {
        soulHeartTypes.push(HeartSubType.BLACK);
      } else {
        soulHeartTypes.push(HeartSubType.SOUL);
      }

      // Move to the next heart.
      currentSoulHeart += 2;
    }
  }

  return {
    maxHearts,
    hearts,
    eternalHearts,
    soulHearts,
    boneHearts,
    goldenHearts,
    rottenHearts,
    brokenHearts,
    soulCharges,
    bloodCharges,
    soulHeartTypes,
  };
}

export function getPlayerHealthType(
  player: EntityPlayer,
  healthType: HealthType,
): int {
  switch (healthType) {
    // 5.10.1
    case HealthType.RED: {
      // We use the standard library helper function since the `EntityPlayer.GetHearts` method
      // returns a value that includes rotten hearts.
      return getPlayerHearts(player);
    }

    // 5.10.3
    case HealthType.SOUL: {
      // We use the standard library helper function since the `EntityPlayer.GetSoulHearts` method
      // returns a value that includes black hearts.
      return getPlayerSoulHearts(player);
    }

    // 5.10.4
    case HealthType.ETERNAL: {
      return player.GetEternalHearts();
    }

    // 5.10.6
    case HealthType.BLACK: {
      // We use the standard library helper function since the `EntityPlayer.GetBlackHearts` method
      // returns a bit mask.
      return getPlayerBlackHearts(player);
    }

    // 5.10.7
    case HealthType.GOLDEN: {
      return player.GetGoldenHearts();
    }

    // 5.10.11
    case HealthType.BONE: {
      return player.GetBoneHearts();
    }

    // 5.10.12
    case HealthType.ROTTEN: {
      return player.GetRottenHearts();
    }

    case HealthType.BROKEN: {
      return player.GetBrokenHearts();
    }

    case HealthType.MAX_HEARTS: {
      return player.GetMaxHearts();
    }
  }
}

/**
 * Returns the number of red hearts that the player has, excluding any rotten hearts. For example,
 * if the player has one full black heart, one full soul heart, and one half black heart, this
 * function returns 3.
 *
 * This is different from the `EntityPlayer.GetHearts` method, since that returns a value that
 * includes rotten hearts.
 */
export function getPlayerHearts(player: EntityPlayer): int {
  const rottenHearts = player.GetRottenHearts();
  const hearts = player.GetHearts();

  return hearts - rottenHearts * 2;
}

/**
 * Helper function that returns the type of the rightmost heart. This does not including golden
 * hearts or broken hearts, since they cannot be damaged directly.
 */
export function getPlayerLastHeart(player: EntityPlayer): HealthType {
  const hearts = player.GetHearts();
  const effectiveMaxHearts = player.GetEffectiveMaxHearts();
  const soulHearts = player.GetSoulHearts();
  const blackHearts = player.GetBlackHearts();
  const eternalHearts = player.GetEternalHearts();
  const boneHearts = player.GetBoneHearts();
  const rottenHearts = player.GetRottenHearts();

  const soulHeartSlots = soulHearts / 2;
  const lastHeartIndex = boneHearts + soulHeartSlots - 1;
  const isLastHeartBone = player.IsBoneHeart(lastHeartIndex);

  if (isLastHeartBone) {
    const isLastContainerEmpty = hearts <= effectiveMaxHearts - 2;
    if (isLastContainerEmpty) {
      return HealthType.BONE;
    }

    if (rottenHearts > 0) {
      return HealthType.ROTTEN;
    }

    if (eternalHearts > 0) {
      return HealthType.ETERNAL;
    }

    return HealthType.RED;
  }

  if (soulHearts > 0) {
    const numBits = getNumBitsOfN(blackHearts);
    const finalBit = getKBitOfN(numBits - 1, blackHearts);
    const isBlack = finalBit === 1;

    if (isBlack) {
      return HealthType.BLACK;
    }

    // If it is not a black heart, it must be a soul heart.
    return HealthType.SOUL;
  }

  if (eternalHearts > 0) {
    return HealthType.ETERNAL;
  }

  if (rottenHearts > 0) {
    return HealthType.ROTTEN;
  }

  return HealthType.RED;
}

/**
 * Returns the maximum heart containers that the provided player can have. Normally, this is 12, but
 * it can change depending on the character (e.g. Keeper) and other things (e.g. Mother's Kiss).
 * This function does not account for Broken Hearts; use the `getPlayerAvailableHeartSlots` helper
 * function for that.
 */
export function getPlayerMaxHeartContainers(player: EntityPlayer): int {
  const character = player.GetPlayerType();
  const characterMaxHeartContainers = getCharacterMaxHeartContainers(character);

  // 1
  // Magdalene can increase her maximum heart containers with Birthright.
  if (
    character === PlayerType.MAGDALENE &&
    player.HasCollectible(CollectibleType.BIRTHRIGHT)
  ) {
    const extraMaxHeartContainersFromBirthright = 6;
    return characterMaxHeartContainers + extraMaxHeartContainersFromBirthright;
  }

  // 14, 33
  // Keeper and Tainted Keeper can increase their coin containers with Mother's Kiss and Greed's
  // Gullet.
  if (isKeeper(player)) {
    const numMothersKisses = player.GetTrinketMultiplier(
      TrinketType.MOTHERS_KISS,
    );
    const hasGreedsGullet = player.HasCollectible(
      CollectibleType.GREEDS_GULLET,
    );
    const coins = player.GetNumCoins();
    const greedsGulletCoinContainers = hasGreedsGullet
      ? Math.floor(coins / 25)
      : 0;

    return (
      characterMaxHeartContainers +
      numMothersKisses +
      greedsGulletCoinContainers
    );
  }

  return characterMaxHeartContainers;
}

/**
 * Returns the number of soul hearts that the player has, excluding any black hearts. For example,
 * if the player has one full black heart, one full soul heart, and one half black heart, this
 * function returns 2.
 *
 * This is different from the `EntityPlayer.GetSoulHearts` method, since that returns the combined
 * number of soul hearts and black hearts.
 */
export function getPlayerSoulHearts(player: EntityPlayer): int {
  const soulHearts = player.GetSoulHearts();
  const blackHearts = getPlayerBlackHearts(player);

  return soulHearts - blackHearts;
}

/**
 * Helper function to determine how many heart containers that Tainted Magdalene has that will not
 * be automatically depleted over time. By default, this is 2, but this function will return 4 so
 * that it is consistent with the `player.GetHearts` and `player.GetMaxHearts` methods.
 *
 * If Tainted Magdalene has Birthright, she will gained an additional non-temporary heart container.
 *
 * This function does not validate whether the provided player is Tainted Magdalene; that should be
 * accomplished before invoking this function.
 */
export function getTaintedMagdaleneNonTemporaryMaxHearts(
  player: EntityPlayer,
): int {
  const maxHearts = player.GetMaxHearts();
  const hasBirthright = player.HasCollectible(CollectibleType.BIRTHRIGHT);
  const maxNonTemporaryMaxHearts = hasBirthright ? 6 : 4;

  return Math.min(maxHearts, maxNonTemporaryMaxHearts);
}

/** Returns a `PlayerHealth` object with all zeros. */
export function newPlayerHealth(): PlayerHealth {
  return {
    maxHearts: 0,
    hearts: 0,
    eternalHearts: 0,
    soulHearts: 0,
    boneHearts: 0,
    goldenHearts: 0,
    rottenHearts: 0,
    brokenHearts: 0,
    soulCharges: 0,
    bloodCharges: 0,
    soulHeartTypes: [],
  };
}

/**
 * Helper function to remove all of a player's black hearts and add the corresponding amount of soul
 * hearts.
 */
export function playerConvertBlackHeartsToSoulHearts(
  player: EntityPlayer,
): void {
  const playerHealth = getPlayerHealth(player);
  removeAllPlayerHealth(player);

  const newSoulHeartTypes = playerHealth.soulHeartTypes.map((soulHeartType) =>
    soulHeartType === HeartSubType.BLACK ? HeartSubType.SOUL : soulHeartType,
  );

  const playerHealthWithSoulHearts = {
    ...playerHealth,
    soulHeartTypes: newSoulHeartTypes,
  };

  setPlayerHealth(player, playerHealthWithSoulHearts);
}

/**
 * Helper function to remove all of a player's soul hearts and add the corresponding amount of black
 * hearts.
 */
export function playerConvertSoulHeartsToBlackHearts(
  player: EntityPlayer,
): void {
  const playerHealth = getPlayerHealth(player);
  removeAllPlayerHealth(player);

  const newSoulHeartTypes = playerHealth.soulHeartTypes.map((soulHeartType) =>
    soulHeartType === HeartSubType.SOUL ? HeartSubType.BLACK : soulHeartType,
  );

  const playerHealthWithBlackHearts = {
    ...playerHealth,
    soulHeartTypes: newSoulHeartTypes,
  };

  setPlayerHealth(player, playerHealthWithBlackHearts);
}

/**
 * Helper function to see if the player is out of health.
 *
 * Specifically, this function will return false if the player has 0 red hearts, 0 soul/black
 * hearts, and 0 bone hearts.
 */
export function playerHasHealthLeft(player: EntityPlayer): boolean {
  const hearts = player.GetHearts();
  const soulHearts = player.GetSoulHearts();
  const boneHearts = player.GetBoneHearts();

  return hearts > 0 || soulHearts > 0 || boneHearts > 0;
}

export function removeAllPlayerHealth(player: EntityPlayer): void {
  const goldenHearts = player.GetGoldenHearts();
  const eternalHearts = player.GetEternalHearts();
  const boneHearts = player.GetBoneHearts();
  const brokenHearts = player.GetBrokenHearts();

  // To avoid bugs, we have to remove the exact amount of certain types of hearts. We remove Golden
  // Hearts first so that they don't break.
  player.AddGoldenHearts(goldenHearts * -1);
  player.AddEternalHearts(eternalHearts * -1);
  player.AddBoneHearts(boneHearts * -1);
  player.AddBrokenHearts(brokenHearts * -1);
  player.AddMaxHearts(MAX_PLAYER_HEART_CONTAINERS * -2, true);
  player.AddSoulHearts(MAX_PLAYER_HEART_CONTAINERS * -2);

  // If we are The Soul, the `EntityPlayer.AddBoneHearts` method will not remove Forgotten's bone
  // hearts, so we need to explicitly handle this.
  if (isCharacter(player, PlayerType.SOUL)) {
    const forgotten = player.GetSubPlayer();
    if (forgotten !== undefined) {
      const forgottenBoneHearts = forgotten.GetBoneHearts();
      forgotten.AddBoneHearts(forgottenBoneHearts * -1);
    }
  }
}

/**
 * Helper function to set a player's health to a specific state. You can use this in combination
 * with the `getPlayerHealth` function to restore the player's health back to a certain
 * configuration at a later time.
 *
 * Based on the `REVEL.LoadHealth` function in the Revelations mod.
 */
export function setPlayerHealth(
  player: EntityPlayer,
  playerHealth: PlayerHealth,
): void {
  const character = player.GetPlayerType();
  const subPlayer = player.GetSubPlayer();

  // Before we add or remove any health, we have to take away Alabaster Box, if present. (Removing
  // soul hearts from the player will remove Alabaster Box charges.)
  const alabasterBoxDescriptions: Array<{
    activeSlot: ActiveSlot;
    totalCharge: int;
  }> = [];
  const alabasterBoxActiveSlots = getActiveItemSlots(
    player,
    CollectibleType.ALABASTER_BOX,
  );
  for (const activeSlot of alabasterBoxActiveSlots) {
    const totalCharge = getTotalCharge(player, activeSlot);
    setActiveItem(player, CollectibleType.NULL, activeSlot);
    alabasterBoxDescriptions.push({ activeSlot, totalCharge });
  }

  removeAllPlayerHealth(player);

  // Add the red heart containers.
  if (character === PlayerType.SOUL && subPlayer !== undefined) {
    // Adding health to The Soul is a special case.
    subPlayer.AddMaxHearts(playerHealth.maxHearts, false);
  } else {
    player.AddMaxHearts(playerHealth.maxHearts, false);
  }

  // Add the eternal hearts.
  player.AddEternalHearts(playerHealth.eternalHearts);

  // Add the soul / black / bone hearts.
  let soulHeartsRemaining = playerHealth.soulHearts;
  for (const [i, soulHeartType] of playerHealth.soulHeartTypes.entries()) {
    const isHalf =
      playerHealth.soulHearts + playerHealth.boneHearts * 2 < (i + 1) * 2;
    let addAmount = 2;
    if (
      isHalf ||
      soulHeartType === HeartSubType.BONE ||
      soulHeartsRemaining < 2
    ) {
      // Fix the bug where a half soul heart to the left of a bone heart will be treated as a full
      // soul heart.
      addAmount = 1;
    }

    switch (soulHeartType) {
      case HeartSubType.SOUL: {
        player.AddSoulHearts(addAmount);
        soulHeartsRemaining -= addAmount;
        break;
      }

      case HeartSubType.BLACK: {
        player.AddBlackHearts(addAmount);
        soulHeartsRemaining -= addAmount;
        break;
      }

      case HeartSubType.BONE: {
        player.AddBoneHearts(addAmount);
        break;
      }
    }
  }

  /**
   * Fill in the red heart containers.
   *
   * Rotten Hearts must be filled in first in order for this to work properly, since they conflict
   * with half red hearts.
   *
   * We multiply by two because the `EntityPlayer.GetRottenHearts` function returns the actual
   * number of rotten hearts, but the `EntityPlayer.AddRottenHearts` works like the other heart
   * functions in that a value of 1 is equivalent to a half-heart.
   */
  player.AddRottenHearts(playerHealth.rottenHearts * 2);

  if (character === PlayerType.MAGDALENE_B) {
    // Adding 1 heart to Tainted Magdalene will actually add two hearts.
    repeat(playerHealth.hearts, () => {
      if (player.HasFullHearts()) {
        return;
      }

      const hearts = player.GetHearts();
      const maxHearts = player.GetMaxHearts();
      if (hearts === maxHearts - 1) {
        player.AddHearts(1);
        return;
      }

      player.AddHearts(1);
      player.AddHearts(-1);
    });
  } else {
    player.AddHearts(playerHealth.hearts);
  }

  player.AddGoldenHearts(playerHealth.goldenHearts);
  player.AddBrokenHearts(playerHealth.brokenHearts);

  // Set the Bethany / Tainted Bethany charges.
  if (character === PlayerType.BETHANY) {
    player.SetSoulCharge(playerHealth.soulCharges);
  } else if (character === PlayerType.BETHANY_B) {
    player.SetBloodCharge(playerHealth.bloodCharges);
  }

  // Re-add the Alabaster Box, if present.
  for (const { activeSlot, totalCharge } of alabasterBoxDescriptions) {
    setActiveItem(
      player,
      CollectibleType.ALABASTER_BOX,
      activeSlot,
      totalCharge,
    );
  }
}

/**
 * Helper function to see if a certain damage amount would deal "permanent" damage to Tainted
 * Magdalene.
 *
 * Tainted Magdalene has "permanent" health and "temporary" health. When standing still and doing
 * nothing, all of Tainted Magdalene's temporary health will eventually go away.
 *
 * Before using this function, it is expected that you check to see if the player is Tainted
 * Magdalene first, or else it will give a nonsensical result.
 */
export function wouldDamageTaintedMagdaleneNonTemporaryHeartContainers(
  player: EntityPlayer,
  damageAmount: float,
): boolean {
  // Regardless of the damage amount, damage to a player cannot remove a soul heart and a red heart
  // at the same time.
  const soulHearts = player.GetSoulHearts();
  if (soulHearts > 0) {
    return false;
  }

  // Regardless of the damage amount, damage to a player cannot remove a bone heart and a red heart
  // at the same time.
  const boneHearts = player.GetBoneHearts();
  if (boneHearts > 0) {
    return false;
  }

  // Account for rotten hearts eating away at more red hearts than usual.
  const hearts = player.GetHearts();
  const rottenHearts = player.GetRottenHearts();
  const effectiveDamageAmount =
    damageAmount + Math.min(rottenHearts, damageAmount);

  const heartsAfterDamage = hearts - effectiveDamageAmount;
  const nonTemporaryMaxHearts =
    getTaintedMagdaleneNonTemporaryMaxHearts(player);
  return heartsAfterDamage < nonTemporaryMaxHearts;
}

----
functions\playerIndex.ts
import {
  BabySubType,
  CollectibleType,
  PlayerType,
  PlayerVariant,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import type { PlayerIndex } from "../types/PlayerIndex";
import { ReadonlySet } from "../types/ReadonlySet";

const DEFAULT_COLLECTIBLE_TYPE = CollectibleType.SAD_ONION;

const EXCLUDED_CHARACTERS = new ReadonlySet<PlayerType>([
  PlayerType.ESAU, // 20
  PlayerType.SOUL_B, // 40
]);

/**
 * Helper function to get every player with no restrictions, by using `Game.GetNumPlayers` and
 * `Isaac.GetPlayer`.
 *
 * This function is almost never what you want to use. For most purposes, use the `getPlayers`
 * helper function instead to get a filtered list of players.
 */
export function getAllPlayers(): readonly EntityPlayer[] {
  const numPlayers = game.GetNumPlayers();

  const players: EntityPlayer[] = [];
  for (let i = 0; i < numPlayers; i++) {
    const player = Isaac.GetPlayer(i);
    players.push(player);
  }

  return players;
}

/**
 * Helper function to get all of the other players in the room besides the one provided. (This
 * includes "child" players.)
 */
export function getOtherPlayers(player: EntityPlayer): readonly EntityPlayer[] {
  const playerPtrHash = GetPtrHash(player);
  const players = getAllPlayers();
  return players.filter(
    (otherPlayer) => GetPtrHash(otherPlayer) !== playerPtrHash,
  );
}

/**
 * Helper function to get the corresponding `EntityPlayer` object that corresponds to a
 * `PlayerIndex`.
 */
export function getPlayerFromIndex(
  playerIndex: PlayerIndex,
): EntityPlayer | undefined {
  const players = getAllPlayers();
  return players.find((player) => getPlayerIndex(player) === playerIndex);
}

/**
 * Mods often have to track variables relating to the player. In naive mods, information will only
 * be stored about the first player. However, in order to be robust, mods must handle up to 4
 * players playing at the same time. This means that information must be stored on a map data
 * structure. Finding a good index for these types of map data structures is difficult:
 *
 * - We cannot use the index from `Isaac.GetPlayer(i)` since this fails in the case where there are
 *   two players and the first player leaves the run.
 * - We cannot use `EntityPlayer.ControllerIndex` as an index because it fails in the case of Jacob
 *   & Esau or Tainted Forgotten. It also fails in the case of a player changing their controls
 *   mid-run.
 * - We cannot use `EntityPlayer.GetData().index` because it does not persist across saving and
 *   continuing.
 * - We cannot use `GetPtrHash()` as an index because it does not persist across exiting and
 *   relaunching the game.
 * - We cannot use `EntityPlayer.InitSeed` because it is not consistent with additional players
 *   beyond the first.
 *
 * Instead, we use the `EntityPlayer.GetCollectibleRNG` method with an arbitrary value of Sad Onion
 * (1). This works even if the player does not have any Sad Onions.
 *
 * Note that by default, this returns the same index for both The Forgotten and The Soul. (Even
 * though they are technically different characters, they share the same inventory and `InitSeed`.)
 * If this is not desired, pass true for the `differentiateForgottenAndSoul` argument, and the RNG
 * of Spoon Bender (3) will be used for The Soul.
 *
 * Also note that this index does not work in the `POST_PLAYER_INIT` function for players 2 through
 * 4. With that said, in almost all cases, you should be lazy-initializing your data structures in
 * other callbacks, so this should not be an issue.
 */
export function getPlayerIndex(
  player: EntityPlayer,
  differentiateForgottenAndSoul = false,
): PlayerIndex {
  // Sub-players use separate RNG values for some reason, so we need to always use the main player:
  // https://github.com/Meowlala/RepentanceAPIIssueTracker/issues/443

  // We can safely ignore the player's character because regardless of whether the main player ends
  // up being The Forgotten or The Soul, the collectible RNG values will be the same. The
  // `EntityPlayer.IsSubPlayer` method can return true for Dead Tainted Lazarus during the
  // `POST_PLAYER_INIT` callback, but since we fall back to the player in the case of
  // "getSubPlayerParent" returning undefined, we do not need to explicitly check for this case.
  let playerToUse = player;
  const isSubPlayer = player.IsSubPlayer();
  if (isSubPlayer) {
    const subPlayer = player as EntitySubPlayer;

    // The "getSubPlayerParent" function will return undefined in the situation where we are on Dead
    // Tainted Lazarus in the `POST_PLAYER_INIT` callback.
    const playerParent = getSubPlayerParent(subPlayer);
    if (playerParent !== undefined) {
      playerToUse = playerParent;
    }
  }

  const collectibleType = getPlayerIndexCollectibleType(
    player,
    differentiateForgottenAndSoul,
  );
  const collectibleRNG = playerToUse.GetCollectibleRNG(collectibleType);
  const seed = collectibleRNG.GetSeed();

  return seed as unknown as PlayerIndex;
}

function getPlayerIndexCollectibleType(
  player: EntityPlayer,
  differentiateForgottenAndSoul: boolean,
) {
  const character = player.GetPlayerType();

  if (character === PlayerType.SOUL) {
    return differentiateForgottenAndSoul
      ? CollectibleType.INNER_EYE
      : DEFAULT_COLLECTIBLE_TYPE;
  }

  return DEFAULT_COLLECTIBLE_TYPE;
}

/**
 * Helper function to return the index of this player with respect to the output of the
 * `Isaac.GetPlayer` method.
 *
 * Note that if you storing information about a player in a data structure, you never want to use
 * this index; use the `getPlayerIndex` function instead.
 */
export function getPlayerIndexVanilla(
  playerToFind: EntityPlayer,
): int | undefined {
  const numPlayers = game.GetNumPlayers();
  const playerToFindHash = GetPtrHash(playerToFind);

  for (let i = 0; i < numPlayers; i++) {
    const player = Isaac.GetPlayer(i);
    const playerHash = GetPtrHash(player);
    if (playerHash === playerToFindHash) {
      return i;
    }
  }

  return undefined;
}

/**
 * This function always excludes players with a non-undefined parent, since they are not real
 * players (e.g. the Strawman Keeper).
 *
 * If this is not desired, use the `getAllPlayers` helper function instead.
 *
 * @param performCharacterExclusions Whether to exclude characters that are not directly controlled
 *                                 by the player (i.e. Esau & Tainted Soul). Default is false.
 */
export function getPlayers(
  performCharacterExclusions = false,
): readonly EntityPlayer[] {
  const players = getAllPlayers();
  const nonChildPlayers = players.filter((player) => !isChildPlayer(player));
  const nonChildPlayersFiltered = nonChildPlayers.filter((player) => {
    const character = player.GetPlayerType();
    return !EXCLUDED_CHARACTERS.has(character);
  });

  return performCharacterExclusions ? nonChildPlayersFiltered : nonChildPlayers;
}

/**
 * Helper function to get a parent `EntityPlayer` object for a given `EntitySubPlayer` object. This
 * is useful because calling the `EntityPlayer.GetSubPlayer` method on a sub-player object will
 * return undefined.
 */
export function getSubPlayerParent(
  subPlayer: EntitySubPlayer,
): EntityPlayer | undefined {
  const subPlayerPtrHash = GetPtrHash(subPlayer);
  const players = getPlayers();

  return players.find((player) => {
    const thisPlayerSubPlayer = player.GetSubPlayer();
    if (thisPlayerSubPlayer === undefined) {
      return false;
    }

    const thisPlayerSubPlayerPtrHash = GetPtrHash(thisPlayerSubPlayer);
    return thisPlayerSubPlayerPtrHash === subPlayerPtrHash;
  });
}

/**
 * Helper function to detect if a particular player is a "child" player, meaning that they have a
 * non-undefined `EntityPlayer.Parent` field. (For example, the Strawman Keeper.)
 */
export function isChildPlayer(player: EntityPlayer): boolean {
  return player.Parent !== undefined;
}

/**
 * Helper function to detect if a particular player is the Found Soul player provided by the
 * trinket.
 */
export function isFoundSoul(player: EntityPlayer): boolean {
  return (
    isChildPlayer(player) &&
    player.Variant === PlayerVariant.COOP_BABY &&
    player.SubType === (BabySubType.FOUND_SOUL as int)
  );
}

----
functions\playerTrinkets.ts
import {
  PlayerType,
  TrinketSlot,
  TrinketType,
} from "isaac-typescript-definitions";
import { TRINKET_SLOT_VALUES } from "../cachedEnumValues";
import { itemConfig } from "../core/cachedClasses";
import { getAllPlayers, getPlayers } from "./playerIndex";
import { isCharacter } from "./players";

export function addTrinketCostume(
  player: EntityPlayer,
  trinketType: TrinketType,
): void {
  const itemConfigTrinket = itemConfig.GetTrinket(trinketType);
  if (itemConfigTrinket === undefined) {
    return;
  }

  player.AddCostume(itemConfigTrinket, false);
}

/**
 * Helper function to check to see if any player has a particular trinket.
 *
 * @param trinketType The trinket type to check for.
 * @param ignoreModifiers If set to true, only counts trinkets the player actually holds and ignores
 *                        effects granted by other items. Default is false.
 */
export function anyPlayerHasTrinket(
  trinketType: TrinketType,
  ignoreModifiers?: boolean,
): boolean {
  const players = getAllPlayers();

  return players.some((player) =>
    player.HasTrinket(trinketType, ignoreModifiers),
  );
}

/**
 * Returns the slot number corresponding to where a trinket can be safely inserted.
 *
 * For example:
 *
 * ```ts
 * const player = Isaac.GetPlayer();
 * const trinketSlot = getOpenTrinketSlotNum(player);
 * if (trinketSlot !== undefined) {
 *   // They have one or more open trinket slots
 *   player.AddTrinket(TrinketType.SWALLOWED_PENNY);
 * }
 * ```
 */
export function getOpenTrinketSlot(player: EntityPlayer): int | undefined {
  const maxTrinkets = player.GetMaxTrinkets();
  const trinketType1 = player.GetTrinket(TrinketSlot.SLOT_1);
  const trinketType2 = player.GetTrinket(TrinketSlot.SLOT_2);

  if (maxTrinkets === 1) {
    return trinketType1 === TrinketType.NULL ? 0 : undefined;
  }

  if (maxTrinkets === 2) {
    if (trinketType1 === TrinketType.NULL) {
      return 0;
    }

    return trinketType2 === TrinketType.NULL ? 1 : undefined;
  }

  error(`The player has an unknown number of trinket slots: ${maxTrinkets}`);
}

/**
 * Helper function to get all of the trinkets that the player is currently holding. This will not
 * include any smelted trinkets.
 */
export function getPlayerTrinkets(
  player: EntityPlayer,
): readonly TrinketType[] {
  const trinketTypes: TrinketType[] = [];

  for (const trinketSlot of TRINKET_SLOT_VALUES) {
    const trinketType = player.GetTrinket(trinketSlot);
    if (trinketType !== TrinketType.NULL) {
      trinketTypes.push(trinketType);
    }
  }

  return trinketTypes;
}

/**
 * Helper function to get only the players that have a certain trinket.
 *
 * This function is variadic, meaning that you can supply as many trinket types as you want to check
 * for. It only returns the players that have all of the trinkets.
 */
export function getPlayersWithTrinket(
  ...trinketTypes: readonly TrinketType[]
): readonly EntityPlayer[] {
  const players = getPlayers();

  return players.filter((player) =>
    trinketTypes.every((trinketType) => player.HasTrinket(trinketType)),
  );
}

/** Helper function to check to see if the player is holding one or more trinkets. */
export function hasAnyTrinket(player: EntityPlayer): boolean {
  const playerTrinketTypes = TRINKET_SLOT_VALUES.map((trinketSlot) =>
    player.GetTrinket(trinketSlot),
  );
  return playerTrinketTypes.some(
    (trinketType) => trinketType !== TrinketType.NULL,
  );
}

/**
 * Returns whether the player can hold an additional trinket, beyond what they are currently
 * carrying. This takes into account items that modify the max number of trinkets, like Mom's Purse.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export function hasOpenTrinketSlot(player: EntityPlayer): boolean {
  if (isCharacter(player, PlayerType.SOUL_B)) {
    return false;
  }

  const openTrinketSlot = getOpenTrinketSlot(player);
  return openTrinketSlot !== undefined;
}

/**
 * Helper function to check to see if a player has one or more trinkets.
 *
 * This function is variadic, meaning that you can supply as many trinket types as you want to check
 * for. Returns true if the player has any of the supplied trinket types.
 *
 * This function always passes `false` to the `ignoreModifiers` argument.
 */
export function hasTrinket(
  player: EntityPlayer,
  ...trinketTypes: readonly TrinketType[]
): boolean {
  return trinketTypes.some((trinketType) => player.HasTrinket(trinketType));
}

/**
 * Helper function to remove all of the held trinkets from a player.
 *
 * This will not remove any smelted trinkets, unless the player happens to also be holding a trinket
 * that they have smelted. (In that case, both the held and the smelted trinket will be removed.)
 */
export function removeAllPlayerTrinkets(player: EntityPlayer): void {
  for (const trinketSlot of TRINKET_SLOT_VALUES) {
    const trinketType = player.GetTrinket(trinketSlot);
    if (trinketType === TrinketType.NULL) {
      continue;
    }

    let alreadyHasTrinket: boolean;
    do {
      player.TryRemoveTrinket(trinketType);
      alreadyHasTrinket = player.HasTrinket(trinketType);
    } while (alreadyHasTrinket);
  }
}

/**
 * Helper function to remove a trinket costume from a player. Use this helper function to avoid
 * having to request the trinket from the item config.
 */
export function removeTrinketCostume(
  player: EntityPlayer,
  trinketType: TrinketType,
): void {
  const itemConfigTrinket = itemConfig.GetTrinket(trinketType);
  if (itemConfigTrinket === undefined) {
    return;
  }

  player.RemoveCostume(itemConfigTrinket);
}

----
functions\players.ts
import {
  Challenge,
  CollectibleType,
  ControllerIndex,
  NullItemID,
  PlayerForm,
  PlayerType,
  TearFlag,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { ReadonlySet } from "../types/ReadonlySet";
import { getCharacterName, isVanillaCharacter } from "./characters";
import { hasFlag } from "./flag";
import {
  getAllPlayers,
  getPlayerIndexVanilla,
  getPlayers,
} from "./playerIndex";
import { isNumber } from "./types";
import { assertDefined, repeat } from "./utils";

/**
 * Helper function to check to see if any player is holding up an item (from e.g. an active item
 * activation, a poop from IBS, etc.).
 */
export function anyPlayerHoldingItem(): boolean {
  const players = getAllPlayers();
  return players.some((player) => player.IsHoldingItem());
}

/**
 * Helper function to determine if the given character is present.
 *
 * This function is variadic, meaning that you can supply as many characters as you want to check
 * for. Returns true if any of the characters supplied are present.
 */
export function anyPlayerIs(
  ...matchingCharacters: readonly PlayerType[]
): boolean {
  const matchingCharacterSet = new ReadonlySet(matchingCharacters);
  const characters = getCharacters();

  return characters.some((character) => matchingCharacterSet.has(character));
}

/**
 * Helper function to determine if a player will destroy a rock/pot/skull if they walk over it.
 *
 * The following situations allow for this to be true:
 * - the player has Leo (collectible 302)
 * - the player has Thunder Thighs (collectible 314)
 * - the player is under the effects of Mega Mush (collectible 625)
 * - the player has Stompy (transformation 13)
 */
export function canPlayerCrushRocks(player: EntityPlayer): boolean {
  const effects = player.GetEffects();

  return (
    player.HasCollectible(CollectibleType.LEO) ||
    player.HasCollectible(CollectibleType.THUNDER_THIGHS) ||
    effects.HasCollectibleEffect(CollectibleType.MEGA_MUSH) ||
    player.HasPlayerForm(PlayerForm.STOMPY)
  );
}

/**
 * Helper function to remove a collectible or trinket that is currently queued to go into a player's
 * inventory (i.e. the item is being held over their head).
 *
 * If the player does not have an item currently queued, then this function will be a no-op.
 *
 * Returns whether an item was actually dequeued.
 *
 * Under the hood, this clones the `QueuedItemData`, since directly setting the `Item` field to
 * `undefined` does not work for some reason.
 */
export function dequeueItem(player: EntityPlayer): boolean {
  if (player.QueuedItem.Item === undefined) {
    return false;
  }

  // Doing `player.QueuedItem.Item = undefined` does not work for some reason.
  const queue = player.QueuedItem;
  queue.Item = undefined;
  player.QueuedItem = queue;

  return true;
}

/**
 * Helper function to get how long Azazel's Brimstone laser should be. You can pass either an
 * `EntityPlayer` object or a tear height stat.
 *
 * The formula for calculating it is: 32 - 2.5 * tearHeight
 */
export function getAzazelBrimstoneDistance(
  playerOrTearHeight: EntityPlayer | float,
): float {
  const tearHeight = isNumber(playerOrTearHeight)
    ? playerOrTearHeight
    : playerOrTearHeight.TearHeight;

  return 32 - 2.5 * tearHeight;
}

/** Helper function to get an array containing the characters of all of the current players. */
export function getCharacters(): readonly PlayerType[] {
  const players = getPlayers();
  return players.map((player) => player.GetPlayerType());
}

/**
 * Helper function to get the closest player to a certain position. Note that this will never
 * include players with a non-undefined parent, since they are not real players (e.g. the Strawman
 * Keeper).
 */
export function getClosestPlayer(position: Vector): EntityPlayer {
  let closestPlayer: EntityPlayer | undefined;
  let closestDistance = Number.POSITIVE_INFINITY;
  for (const player of getPlayers()) {
    const distance = position.Distance(player.Position);

    if (distance < closestDistance) {
      closestPlayer = player;
      closestDistance = distance;
    }
  }

  assertDefined(closestPlayer, "Failed to find the closest player.");

  return closestPlayer;
}

/**
 * Helper function to return the player with the highest ID, according to the `Isaac.GetPlayer`
 * method.
 */
export function getFinalPlayer(): EntityPlayer {
  const players = getPlayers();

  const lastPlayer = players.at(-1);
  assertDefined(
    lastPlayer,
    "Failed to get the final player since there were 0 players.",
  );

  return lastPlayer;
}

/**
 * Helper function to get the first player with the lowest frame count. Useful to find a freshly
 * spawned player after using items like Esau Jr. Don't use this function if two or more players
 * will be spawned on the same frame.
 */
export function getNewestPlayer(): EntityPlayer {
  let newestPlayer: EntityPlayer | undefined;
  let lowestFrame = Number.POSITIVE_INFINITY;
  for (const player of getPlayers()) {
    if (player.FrameCount < lowestFrame) {
      newestPlayer = player;
      lowestFrame = player.FrameCount;
    }
  }

  assertDefined(newestPlayer, "Failed to find the newest player.");

  return newestPlayer;
}

/**
 * Iterates over all players and checks if any are close enough to the specified position.
 *
 * @returns The first player found when iterating upwards from index 0.
 */
export function getPlayerCloserThan(
  position: Vector,
  distance: float,
): EntityPlayer | undefined {
  const players = getPlayers();

  return players.find(
    (player) => player.Position.Distance(position) <= distance,
  );
}

/**
 * Helper function to get the player from a tear, laser, bomb, etc. Returns undefined if the entity
 * does not correspond to any particular player.
 *
 * This function works by looking at the `Parent` and the `SpawnerEntity` fields (in that order). As
 * a last resort, it will attempt to use the `Entity.ToPlayer` method on the entity itself.
 */
export function getPlayerFromEntity(entity: Entity): EntityPlayer | undefined {
  if (entity.Parent !== undefined) {
    const player = entity.Parent.ToPlayer();
    if (player !== undefined) {
      return player;
    }

    const familiar = entity.Parent.ToFamiliar();
    if (familiar !== undefined) {
      return familiar.Player;
    }
  }

  if (entity.SpawnerEntity !== undefined) {
    const player = entity.SpawnerEntity.ToPlayer();
    if (player !== undefined) {
      return player;
    }

    const familiar = entity.SpawnerEntity.ToFamiliar();
    if (familiar !== undefined) {
      return familiar.Player;
    }
  }

  return entity.ToPlayer();
}

/**
 * Helper function to get an `EntityPlayer` object from an `EntityPtr`. Returns undefined if the
 * entity has gone out of scope or if the associated entity is not a player.
 */
export function getPlayerFromPtr(
  entityPtr: EntityPtr,
): EntityPlayer | undefined {
  const entity = entityPtr.Ref;
  if (entity === undefined) {
    return undefined;
  }

  return entity.ToPlayer();
}

/**
 * Helper function to get the proper name of the player. Use this instead of the
 * `EntityPlayer.GetName` method because it accounts for Blue Baby, Lazarus II, and Tainted
 * characters.
 */
export function getPlayerName(player: EntityPlayer): string {
  const character = player.GetPlayerType();

  // Account for modded characters.
  return isModdedPlayer(player)
    ? player.GetName()
    : getCharacterName(character);
}

/**
 * Returns the combined value of all of the player's red hearts, soul/black hearts, and bone hearts,
 * minus the value of the player's rotten hearts.
 *
 * This is equivalent to the number of hits that the player can currently take, but does not take
 * into account double damage from champion enemies and/or being on later floors. (For example, on
 * Womb 1, players who have 1 soul heart remaining would die in 1 hit to anything, even though this
 * function would report that they have 2 hits remaining.)
 */
export function getPlayerNumHitsRemaining(player: EntityPlayer): int {
  const hearts = player.GetHearts();
  const soulHearts = player.GetSoulHearts();
  const boneHearts = player.GetBoneHearts();
  const eternalHearts = player.GetEternalHearts();
  const rottenHearts = player.GetRottenHearts();

  return hearts + soulHearts + boneHearts + eternalHearts - rottenHearts;
}

/**
 * Helper function to get all of the players that are a certain character.
 *
 * This function is variadic, meaning that you can supply as many characters as you want to check
 * for. Returns true if any of the characters supplied are present.
 */
export function getPlayersOfType(
  ...characters: readonly PlayerType[]
): readonly EntityPlayer[] {
  const charactersSet = new ReadonlySet(characters);
  const players = getPlayers();

  return players.filter((player) => {
    const character = player.GetPlayerType();
    return charactersSet.has(character);
  });
}

/**
 * Helper function to get all of the players that are using keyboard (i.e.
 * `ControllerIndex.KEYBOARD`). This function returns an array of players because it is possible
 * that there is more than one player with the same controller index (e.g. Jacob & Esau).
 *
 * Note that this function includes players with a non-undefined parent like e.g. the Strawman
 * Keeper.
 */
export function getPlayersOnKeyboard(): readonly EntityPlayer[] {
  const players = getAllPlayers();

  return players.filter(
    (player) => player.ControllerIndex === ControllerIndex.KEYBOARD,
  );
}

/**
 * Helper function to get all of the players that match the provided controller index. This function
 * returns an array of players because it is possible that there is more than one player with the
 * same controller index (e.g. Jacob & Esau).
 *
 * Note that this function includes players with a non-undefined parent like e.g. the Strawman
 * Keeper.
 */
export function getPlayersWithControllerIndex(
  controllerIndex: ControllerIndex,
): readonly EntityPlayer[] {
  const players = getAllPlayers();
  return players.filter((player) => player.ControllerIndex === controllerIndex);
}

/**
 * Helper function to check to see if a player has one or more transformations.
 *
 * This function is variadic, meaning that you can supply as many transformations as you want to
 * check for. Returns true if the player has any of the supplied transformations.
 */
export function hasForm(
  player: EntityPlayer,
  ...playerForms: readonly PlayerForm[]
): boolean {
  return playerForms.some((playerForm) => player.HasPlayerForm(playerForm));
}

/**
 * Helper function to check if a player has homing tears.
 *
 * Under the hood, this checks the `EntityPlayer.TearFlags` variable for `TearFlag.HOMING` (1 << 2).
 */
export function hasHoming(player: EntityPlayer): boolean {
  return hasFlag(player.TearFlags, TearFlag.HOMING);
}

/** After touching a white fire, a player will turn into The Lost until they clear a room. */
export function hasLostCurse(player: EntityPlayer): boolean {
  const effects = player.GetEffects();
  return effects.HasNullEffect(NullItemID.LOST_CURSE);
}

/**
 * Helper function to check if a player has piercing tears.
 *
 * Under the hood, this checks the `EntityPlayer.TearFlags` variable for `TearFlag.PIERCING` (1 <<
 * 1).
 */
export function hasPiercing(player: EntityPlayer): boolean {
  return hasFlag(player.TearFlags, TearFlag.PIERCING);
}

/**
 * Helper function to check if a player has spectral tears.
 *
 * Under the hood, this checks the `EntityPlayer.TearFlags` variable for `TearFlag.SPECTRAL` (1 <<
 * 0).
 */
export function hasSpectral(player: EntityPlayer): boolean {
  return hasFlag(player.TearFlags, TearFlag.SPECTRAL);
}

/**
 * Helper function for detecting when a player is Bethany or Tainted Bethany. This is useful if you
 * need to adjust UI elements to account for Bethany's soul charges or Tainted Bethany's blood
 * charges.
 */
export function isBethany(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return character === PlayerType.BETHANY || character === PlayerType.BETHANY_B;
}

/**
 * Helper function to check if a player is a specific character (i.e. `PlayerType`).
 *
 * This function is variadic, meaning that you can supply as many characters as you want to check
 * for. Returns true if the player is any of the supplied characters.
 */
export function isCharacter(
  player: EntityPlayer,
  ...characters: readonly PlayerType[]
): boolean {
  const characterSet = new ReadonlySet(characters);
  const character = player.GetPlayerType();

  return characterSet.has(character);
}

/**
 * Helper function to see if a damage source is from a player. Use this instead of comparing to the
 * entity directly because it takes familiars into account.
 */
export function isDamageFromPlayer(damageSource: Entity): boolean {
  const player = damageSource.ToPlayer();
  if (player !== undefined) {
    return true;
  }

  const indirectPlayer = getPlayerFromEntity(damageSource);
  return indirectPlayer !== undefined;
}

/**
 * Helper function for detecting when a player is Eden or Tainted Eden. Useful for situations where
 * you want to know if the starting stats were randomized, for example.
 */
export function isEden(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return character === PlayerType.EDEN || character === PlayerType.EDEN_B;
}

export function isFirstPlayer(player: EntityPlayer): boolean {
  return getPlayerIndexVanilla(player) === 0;
}

/**
 * Helper function for detecting when a player is Jacob or Esau. This will only match the
 * non-tainted versions of these characters.
 */
export function isJacobOrEsau(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return character === PlayerType.JACOB || character === PlayerType.ESAU;
}

/**
 * Helper function for detecting when a player is Keeper or Tainted Keeper. Useful for situations
 * where you want to know if the health is coin hearts, for example.
 */
export function isKeeper(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return character === PlayerType.KEEPER || character === PlayerType.KEEPER_B;
}

/** Helper function for detecting when a player is The Lost or Tainted Lost. */
export function isLost(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return character === PlayerType.LOST || character === PlayerType.LOST_B;
}

export function isModdedPlayer(player: EntityPlayer): boolean {
  return !isVanillaPlayer(player);
}

/**
 * Helper function for determining if a player is able to turn their head by pressing the shooting
 * buttons.
 *
 * Under the hood, this function uses the `EntityPlayer.IsExtraAnimationFinished` method.
 */
export function isPlayerAbleToAim(player: EntityPlayer): boolean {
  return player.IsExtraAnimationFinished();
}

/** Helper function for detecting if a player is one of the Tainted characters. */
export function isTainted(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();

  return isVanillaPlayer(player)
    ? character >= PlayerType.ISAAC_B
    : isTaintedModded(player);
}

/** Helper function for detecting when a player is Tainted Lazarus or Dead Tainted Lazarus. */
export function isTaintedLazarus(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();

  return (
    character === PlayerType.LAZARUS_B || character === PlayerType.LAZARUS_2_B
  );
}

export function isVanillaPlayer(player: EntityPlayer): boolean {
  const character = player.GetPlayerType();
  return isVanillaCharacter(character);
}

/**
 * Helper function to remove the Dead Eye multiplier from a player.
 *
 * Note that each time the `EntityPlayer.ClearDeadEyeCharge` method is called, it only has a chance
 * of working, so this function calls it 100 times to be safe.
 */
export function removeDeadEyeMultiplier(player: EntityPlayer): void {
  repeat(100, () => {
    player.ClearDeadEyeCharge();
  });
}

/**
 * Helper function to blindfold the player by using a hack with the challenge variable.
 *
 * Note that if the player dies and respawns (from e.g. Dead Cat), the blindfold will have to be
 * reapplied.
 *
 * Under the hood, this function sets the challenge to one with a blindfold, changes the player to
 * the same character that they currently are, and then changes the challenge back. This method was
 * discovered by im_tem.
 *
 * @param player The player to apply or remove the blindfold state from.
 * @param enabled Whether to apply or remove the blindfold.
 * @param modifyCostume Optional. Whether to add or remove the blindfold costume. Default is true.
 */
export function setBlindfold(
  player: EntityPlayer,
  enabled: boolean,
  modifyCostume = true,
): void {
  const character = player.GetPlayerType();
  const challenge = Isaac.GetChallenge();

  if (enabled) {
    game.Challenge = Challenge.SOLAR_SYSTEM; // This challenge has a blindfold
    player.ChangePlayerType(character);
    game.Challenge = challenge;

    // The costume is applied automatically.
    if (!modifyCostume) {
      player.TryRemoveNullCostume(NullItemID.BLINDFOLD);
    }
  } else {
    game.Challenge = Challenge.NULL;
    player.ChangePlayerType(character);
    game.Challenge = challenge;

    if (modifyCostume) {
      player.TryRemoveNullCostume(NullItemID.BLINDFOLD);
    }
  }
}

/** Not exported since end-users should use the `isTainted` helper function directly. */
function isTaintedModded(player: EntityPlayer) {
  // This algorithm only works for modded characters because the `Isaac.GetPlayerTypeByName` method
  // is bugged.
  // https://github.com/Meowlala/RepentanceAPIIssueTracker/issues/117
  const character = player.GetPlayerType();
  const name = player.GetName();
  const taintedCharacter = Isaac.GetPlayerTypeByName(name, true);

  return character === taintedCharacter;
}

----
functions\pocketItems.ts
import type { PocketItemSlot } from "isaac-typescript-definitions";
import {
  ActiveSlot,
  CardType,
  CollectibleType,
  PillColor,
  PlayerType,
} from "isaac-typescript-definitions";
import { POCKET_ITEM_SLOT_VALUES } from "../cachedEnumValues";
import { PocketItemType } from "../enums/PocketItemType";
import type { PocketItemDescription } from "../interfaces/PocketItemDescription";
import { isCharacter } from "./players";

/**
 * Helper function to get the `PocketItemSlot` that the player's pocket active collectible item is
 * in, if any. Returns undefined if the player does not have a pocket active item.
 */
export function getActivePocketItemSlot(
  player: EntityPlayer,
): PocketItemSlot | undefined {
  const pocketItems = getPocketItems(player);
  for (const pocketItem of pocketItems) {
    if (pocketItem.type === PocketItemType.ACTIVE_ITEM) {
      return pocketItem.slot;
    }
  }

  return undefined;
}

/** Helper item to get the first card that a player is holding in their pocket item slots. */
export function getFirstCard(
  player: EntityPlayer,
): PocketItemDescription | undefined {
  const pocketItems = getPocketItems(player);
  return pocketItems.find(
    (pocketItem) => pocketItem.type === PocketItemType.CARD,
  );
}

/**
 * Helper item to get the first card or pill that a player is holding in their pocket item slots.
 */
export function getFirstCardOrPill(
  player: EntityPlayer,
): PocketItemDescription | undefined {
  const pocketItems = getPocketItems(player);
  return pocketItems.find(
    (pocketItem) =>
      pocketItem.type === PocketItemType.CARD ||
      pocketItem.type === PocketItemType.PILL,
  );
}

/** Helper item to get the first pill that a player is holding in their pocket item slots. */
export function getFirstPill(
  player: EntityPlayer,
): PocketItemDescription | undefined {
  const pocketItems = getPocketItems(player);
  return pocketItems.find(
    (pocketItem) => pocketItem.type === PocketItemType.PILL,
  );
}

/**
 * Use this helper function as a workaround for the `EntityPlayer.GetPocketItem` method not working
 * correctly.
 *
 * Note that due to API limitations, there is no way to determine the location of a Dice Bag trinket
 * dice. Furthermore, when the player has a Dice Bag trinket dice and a pocket active at the same
 * time, there is no way to determine the location of the pocket active item. If this function
 * cannot determine the identity of a particular slot, it will mark the type of the slot as
 * `PocketItemType.UNDETERMINABLE`.
 */
export function getPocketItems(
  player: EntityPlayer,
): readonly PocketItemDescription[] {
  const pocketItem = player.GetActiveItem(ActiveSlot.POCKET);
  const hasPocketItem = pocketItem !== CollectibleType.NULL;

  const pocketItem2 = player.GetActiveItem(ActiveSlot.POCKET_SINGLE_USE);
  const hasPocketItem2 = pocketItem2 !== CollectibleType.NULL;

  const maxPocketItems = player.GetMaxPocketItems();

  const pocketItems: PocketItemDescription[] = [];
  let pocketItemIdentified = false;
  let pocketItem2Identified = false;
  for (const slot of POCKET_ITEM_SLOT_VALUES) {
    const cardType = player.GetCard(slot);
    const pillColor = player.GetPill(slot);

    if (cardType !== CardType.NULL) {
      pocketItems.push({
        slot,
        type: PocketItemType.CARD,
        subType: cardType,
      });
    } else if (pillColor !== PillColor.NULL) {
      pocketItems.push({
        slot,
        type: PocketItemType.PILL,
        subType: pillColor,
      });
    } else if (hasPocketItem && !hasPocketItem2 && !pocketItemIdentified) {
      pocketItemIdentified = true;
      pocketItems.push({
        slot,
        type: PocketItemType.ACTIVE_ITEM,
        subType: pocketItem,
      });
    } else if (!hasPocketItem && hasPocketItem2 && !pocketItem2Identified) {
      pocketItem2Identified = true;
      pocketItems.push({
        slot,
        type: PocketItemType.DICE_BAG_DICE,
        subType: pocketItem2,
      });
    } else if (hasPocketItem && hasPocketItem2) {
      pocketItems.push({
        slot,
        type: PocketItemType.UNDETERMINABLE,
        subType: 0,
      });
    } else {
      pocketItems.push({
        slot,
        type: PocketItemType.EMPTY,
        subType: 0,
      });
    }

    if (slot + 1 === maxPocketItems) {
      break;
    }
  }

  return pocketItems;
}

/**
 * Returns whether the player can hold an additional pocket item, beyond what they are currently
 * carrying. This takes into account items that modify the max number of pocket items, like Starter
 * Deck.
 *
 * If the player is the Tainted Soul, this always returns false, since that character cannot pick up
 * items. (Only Tainted Forgotten can pick up items.)
 */
export function hasOpenPocketItemSlot(player: EntityPlayer): boolean {
  if (isCharacter(player, PlayerType.SOUL_B)) {
    return false;
  }

  const pocketItems = getPocketItems(player);
  return pocketItems.some(
    (pocketItem) => pocketItem.type === PocketItemType.EMPTY,
  );
}

/**
 * Helper function to determine whether the player's "active" pocket item slot is set to their
 * pocket active item.
 */
export function isFirstSlotPocketActiveItem(player: EntityPlayer): boolean {
  const pocketItems = getPocketItems(player);
  const firstPocketItem = pocketItems[0];
  if (firstPocketItem === undefined) {
    return false;
  }

  return firstPocketItem.type === PocketItemType.ACTIVE_ITEM;
}

/** Helper function to see if two sets of pocket item descriptions are identical. */
export function pocketItemsEquals(
  pocketItems1: readonly PocketItemDescription[],
  pocketItems2: readonly PocketItemDescription[],
): boolean {
  if (pocketItems1.length !== pocketItems2.length) {
    return false;
  }

  // eslint-disable-next-line unicorn/no-for-loop
  for (let i = 0; i < pocketItems1.length; i++) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const pocketItem1 = pocketItems1[i]!;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const pocketItem2 = pocketItems2[i]!;

    const keys = Object.keys(pocketItem1) as Array<keyof PocketItemDescription>;
    for (const key of keys) {
      if (pocketItem1[key] !== pocketItem2[key]) {
        return false;
      }
    }
  }

  return true;
}

----
functions\positionVelocity.ts
import {
  EffectVariant,
  HeavenLightDoorSubType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { DISTANCE_OF_GRID_TILE } from "../core/constants";
import { getEntities } from "./entities";
import { getEffects } from "./entitiesSpecific";
import { getPlayers } from "./playerIndex";
import { getPlayerCloserThan } from "./players";

const MAX_FIND_FREE_POSITION_ATTEMPTS = 100;

export function anyEntityCloserThan(
  entities: readonly Entity[],
  position: Vector,
  distance: int,
): boolean {
  return entities.some(
    (entity) => position.Distance(entity.Position) <= distance,
  );
}

/**
 * Iterates over all players and checks if any player is close enough to the specified position.
 *
 * Note that this function does not consider players with a non-undefined parent, since they are not
 * real players (e.g. the Strawman Keeper).
 */
export function anyPlayerCloserThan(
  position: Vector,
  distance: float,
): boolean {
  const players = getPlayers();
  return players.some(
    (player) => player.Position.Distance(position) <= distance,
  );
}

/**
 * Helper function to get a room position that is not overlapping with a grid entity, a heaven door,
 * or a player. The `Room.FindFreePickupSpawnPosition` method will return locations that overlap
 * with heaven doors and partially overlap with players, if the thing being spawned is bigger than a
 * tile (like a Blood Donation Machine). Use this function instead if you want to account for those
 * specific situations.
 *
 * @param startingPosition The position to start searching from. If this position is not overlapping
 *                         with anything, then it will be returned.
 * @param avoidActiveEntities Optional. Default is false.
 * @param minimumDistance Optional. If specified, will ensure that the randomly generated position
 *                        is equal to or greater than the distance provided.
 */
export function findFreePosition(
  startingPosition: Vector,
  avoidActiveEntities = false,
  minimumDistance?: float,
): Readonly<Vector> {
  const room = game.GetRoom();
  const heavenDoors = getEffects(
    EffectVariant.HEAVEN_LIGHT_DOOR,
    HeavenLightDoorSubType.HEAVEN_DOOR,
  );

  for (
    let initialStep = 0;
    initialStep < MAX_FIND_FREE_POSITION_ATTEMPTS;
    initialStep++
  ) {
    const position = room.FindFreePickupSpawnPosition(
      startingPosition,
      initialStep,
      avoidActiveEntities,
    );

    const closePlayer = getPlayerCloserThan(position, DISTANCE_OF_GRID_TILE);
    if (closePlayer !== undefined) {
      continue;
    }

    const isCloseHeavenDoor = anyEntityCloserThan(
      heavenDoors,
      position,
      DISTANCE_OF_GRID_TILE,
    );
    if (isCloseHeavenDoor) {
      continue;
    }

    if (minimumDistance !== undefined) {
      const distance = startingPosition.Distance(position);
      if (distance < minimumDistance) {
        continue;
      }
    }

    return position;
  }

  // We failed to find a free position in N iterations.
  return room.FindFreePickupSpawnPosition(startingPosition);
}

/**
 * Helper function to get a map containing the positions of every entity in the current room.
 *
 * This is useful for rewinding entity positions at a later time. Also see `setEntityPositions`.
 *
 * @param entities Optional. If provided, will only get the positions of the provided entities. Use
 *                 this with cached entities to avoid invoking the `Isaac.GetRoomEntities` method
 *                 multiple times.
 */
export function getEntityPositions(
  entities?: readonly Entity[],
): ReadonlyMap<PtrHash, Vector> {
  if (entities === undefined) {
    entities = getEntities();
  }

  const entityPositions = new Map<PtrHash, Vector>();
  for (const entity of entities) {
    const ptrHash = GetPtrHash(entity);
    entityPositions.set(ptrHash, entity.Position);
  }

  return entityPositions;
}

/**
 * Helper function to get a map containing the velocities of every entity in the current room.
 *
 * This is useful for rewinding entity velocities at a later time. Also see `setEntityVelocities`.
 *
 * @param entities Optional. If provided, will only get the velocities of the provided entities. Use
 *                 this with cached entities to avoid invoking the `Isaac.GetRoomEntities` method
 *                 multiple times.
 */
export function getEntityVelocities(
  entities?: readonly Entity[],
): ReadonlyMap<PtrHash, Vector> {
  if (entities === undefined) {
    entities = getEntities();
  }

  const entityVelocities = new Map<PtrHash, Vector>();
  for (const entity of entities) {
    const ptrHash = GetPtrHash(entity);
    entityVelocities.set(ptrHash, entity.Velocity);
  }

  return entityVelocities;
}

/**
 * Helper function to set the position of every entity in the room based on a map of positions. If
 * an entity is found that does not have matching element in the provided map, then that entity will
 * be skipped.
 *
 * This function is useful for rewinding entity positions at a later time. Also see
 * `getEntityPositions`.
 *
 * @param entityPositions The map providing the positions for every entity.
 * @param entities Optional. If provided, will only set the positions of the provided entities. Use
 *                 this with cached entities to avoid invoking the `Isaac.GetRoomEntities` method
 *                 multiple times.
 */
export function setEntityPositions(
  entityPositions: ReadonlyMap<PtrHash, Vector>,
  entities?: readonly Entity[],
): void {
  if (entities === undefined) {
    entities = getEntities();
  }

  for (const entity of entities) {
    const ptrHash = GetPtrHash(entity);
    const entityPosition = entityPositions.get(ptrHash);
    if (entityPosition !== undefined) {
      entity.Position = entityPosition;
    }
  }
}

/**
 * Helper function to set the velocity of every entity in the room based on a map of velocities. If
 * an entity is found that does not have matching element in the provided map, then that entity will
 * be skipped.
 *
 * This function is useful for rewinding entity velocities at a later time. Also see
 * `getEntityVelocities`.
 *
 * @param entityVelocities The map providing the velocities for every entity.
 * @param entities Optional. If provided, will only set the velocities of the provided entities. Use
 *                 this with cached entities to avoid invoking the `Isaac.GetRoomEntities` method
 *                 multiple times.
 */
export function setEntityVelocities(
  entityVelocities: ReadonlyMap<PtrHash, Vector>,
  entities?: readonly Entity[],
): void {
  if (entities === undefined) {
    entities = getEntities();
  }

  for (const entity of entities) {
    const ptrHash = GetPtrHash(entity);
    const entityVelocity = entityVelocities.get(ptrHash);
    if (entityVelocity !== undefined) {
      entity.Velocity = entityVelocity;
    }
  }
}

----
functions\pressurePlate.ts
import {
  PressurePlateState,
  PressurePlateVariant,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { getPressurePlates } from "./gridEntitiesSpecific";

/**
 * Helper function to check if all of the pressure plates in the room are pushed.
 *
 * In this context, "pressure plates" refers to the grid entities that you have to press down in
 * order for the room to be cleared. This function ignores other types of pressure plates, such as
 * the ones that you press to get a reward, the ones that you press to start a Greed Mode wave, and
 * so on.
 *
 * Returns true if there are no pressure plates in the room.
 */
export function isAllPressurePlatesPushed(): boolean {
  const room = game.GetRoom();
  const hasPressurePlates = room.HasTriggerPressurePlates();

  if (!hasPressurePlates) {
    return true;
  }

  const pressurePlates = getPressurePlates(PressurePlateVariant.PRESSURE_PLATE);
  return pressurePlates.every(
    (pressurePlate) =>
      pressurePlate.State === PressurePlateState.PRESSURE_PLATE_PRESSED,
  );
}

----
functions\projectiles.ts
import {
  EntityFlag,
  EntityType,
  ProjectilesMode,
} from "isaac-typescript-definitions";
import { getFilteredNewEntities } from "./entities";
import { getProjectiles, spawnNPC } from "./entitiesSpecific";

/**
 * Helper function to make an NPC fire one or more projectiles. Returns the fired projectile(s).
 *
 * Use this function instead of the `EntityNPC.FireProjectiles` method if you need to modify or
 * access the `EntityProjectile` objects after they are fired, since this function returns the
 * objects in an array.
 *
 * @param npc The NPC to fire the projectile(s) from. You can also pass undefined if you do not want
 *            the projectile(s) to come from anything in particular.
 * @param position The staring position of the projectile(s).
 * @param velocity The starting velocity of the projectile(s).
 * @param projectilesMode Optional. The mode of the projectile(s). Default is
 *                        `ProjectilesMode.ONE_PROJECTILE`.
 * @param projectileParams Optional. The parameters of the projectile(s). Default is
 *                         `ProjectileParams()`.
 * @returns The fired projectile(s).
 */
export function fireProjectiles(
  npc: EntityNPC | undefined,
  position: Vector,
  velocity: Vector,
  projectilesMode: ProjectilesMode = ProjectilesMode.ONE_PROJECTILE,
  projectileParams: ProjectileParams = ProjectileParams(),
): readonly EntityProjectile[] {
  const oldProjectiles = getProjectiles(projectileParams.Variant);

  let spawnedFly = false;
  if (npc === undefined) {
    // Since the `EntityNPC.FireProjectiles` method is not static, we arbitrarily spawn a fly.
    spawnedFly = true;
    npc = spawnNPC(EntityType.FLY, 0, 0, position);
    npc.Visible = false;
    npc.ClearEntityFlags(EntityFlag.APPEAR);
  }

  npc.FireProjectiles(position, velocity, projectilesMode, projectileParams);
  const newProjectiles = getProjectiles(projectileParams.Variant);

  if (spawnedFly) {
    npc.Remove();
  }

  return getFilteredNewEntities(oldProjectiles, newProjectiles);
}

/**
 * Helper function to spawn projectiles in a circle around a position. Under the hood, this
 * leverages `ProjectileMode.N_PROJECTILES_IN_CIRCLE`.
 *
 * @param npc The NPC to fire the projectile(s) from. You can also pass undefined if you do not want
 *            the projectile(s) to come from anything in particular.
 * @param position The staring position of the projectile(s).
 * @param speed The speed of the projectile(s).
 * @param numProjectiles The amount of projectiles to spawn.
 * @returns The fired projectile(s).
 */
export function fireProjectilesInCircle(
  npc: EntityNPC | undefined,
  position: Vector,
  speed: float,
  numProjectiles: int,
): readonly EntityProjectile[] {
  const velocity = Vector(speed, numProjectiles);
  return fireProjectiles(
    npc,
    position,
    velocity,
    ProjectilesMode.N_PROJECTILES_IN_CIRCLE,
  );
}

----
functions\random.ts
import { ReadonlySet } from "../types/ReadonlySet";
import { isRNG, newRNG } from "./rng";

/**
 * Returns a random float between 0 and 1. It is inclusive on the low end, but exclusive on the high
 * end. (This is because the `RNG.RandomFloat` method will never return a value of exactly 1.)
 *
 * If you want to generate an unseeded number, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandom(seedOrRNG: Seed | RNG | undefined): float {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);
  return rng.RandomFloat();
}

/**
 * Returns a random float between min and max.
 *
 * For example:
 *
 * ```ts
 * const realNumberBetweenOneAndThree = getRandomFloat(1, 3, undefined);
 * ```
 *
 * If you want to generate an unseeded number, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param min The lower bound for the random number (inclusive).
 * @param max The upper bound for the random number (exclusive).
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandomFloat(
  min: int,
  max: int,
  seedOrRNG: Seed | RNG | undefined,
): float {
  if (min > max) {
    const oldMin = min;
    const oldMax = max;
    min = oldMax;
    max = oldMin;
  }

  // From: https://stackoverflow.com/questions/40431966
  return min + getRandom(seedOrRNG) * (max - min);
}

/**
 * Returns a random integer between min and max. It is inclusive on both ends.
 *
 * For example:
 *
 * ```ts
 * const oneTwoOrThree = getRandomInt(1, 3);
 * ```
 *
 * If you want to generate an unseeded number, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param min The lower bound for the random number (inclusive).
 * @param max The upper bound for the random number (inclusive).
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of elements that will be skipped over when getting the
 *                   random integer. For example, a min of 1, a max of 4, and an exceptions array of
 *                   `[2]` would cause the function to return either 1, 3, or 4. Default is an empty
 *                   array.
 */
export function getRandomInt(
  min: int,
  max: int,
  seedOrRNG: Seed | RNG | undefined,
  exceptions: readonly int[] = [],
): int {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  min = Math.ceil(min);
  max = Math.floor(max);

  if (min > max) {
    const oldMin = min;
    const oldMax = max;
    min = oldMax;
    max = oldMin;
  }

  const exceptionsSet = new ReadonlySet(exceptions);

  let randomInt: int;
  do {
    randomInt = rng.RandomInt(max - min + 1) + min;
  } while (exceptionsSet.has(randomInt));

  return randomInt;
}

----
functions\readOnly.ts
/**
 * Helper function to create a read-only `Color` object. (Otherwise, you would have to manually
 * specify both the type and the constructor.)
 *
 * Note that read-only colors will be writable at run-time.
 */
export function newReadonlyColor(
  r: float,
  g: float,
  b: float,
  a?: float,
  ro?: int,
  go?: int,
  bo?: int,
): Readonly<Color> {
  return Color(r, g, b, a, ro, go, bo);
}

/**
 * Helper function to create a read-only `KColor` object. (Otherwise, you would have to manually
 * specify both the type and the constructor.)
 *
 * Note that read-only colors will be writable at run-time.
 */
export function newReadonlyKColor(
  r: float,
  g: float,
  b: float,
  a: float,
): Readonly<KColor> {
  return KColor(r, g, b, a);
}

/**
 * Helper function to create a read-only `Vector` object. (Otherwise, you would have to manually
 * specify both the type and the constructor.)
 *
 * Note that read-only vectors will be writable at run-time.
 */
export function newReadonlyVector(x: float, y: float): Readonly<Vector> {
  return Vector(x, y);
}

----
functions\render.ts
import { RenderMode } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";

/**
 * Helper function to see if the current render callback is rendering a water reflection.
 *
 * When the player is in a room with water, things will be rendered twice: once for the normal
 * rendering, and once for the reflecting rendering. Thus, any mod code in a render callback will
 * run twice per frame in these situations, which may be unexpected or cause bugs.
 *
 * This function is typically used to early return from a render function if it returns true.
 */
export function isReflectionRender(): boolean {
  const room = game.GetRoom();
  const renderMode = room.GetRenderMode();
  return renderMode === RenderMode.WATER_REFLECT;
}

export function renderScaledTextOnEntity(
  entity: Entity | GridEntity,
  text: string,
  scaleX: float,
  scaleY: float,
): void {
  if (isReflectionRender()) {
    return;
  }

  const position = Isaac.WorldToScreen(entity.Position);
  Isaac.RenderScaledText(
    text,
    position.X,
    position.Y,
    scaleX,
    scaleY,
    1,
    1,
    1,
    1,
  );
}

export function renderTextOnEntity(
  entity: Entity | GridEntity,
  text: string,
): void {
  if (isReflectionRender()) {
    return;
  }

  const position = Isaac.WorldToScreen(entity.Position);
  Isaac.RenderText(text, position.X, position.Y, 1, 1, 1, 1);
}

----
functions\revive.ts
import {
  CollectibleType,
  EntityType,
  NullItemID,
  PlayerType,
  TrinketType,
} from "isaac-typescript-definitions";
import {
  MAX_TAINTED_SAMSON_BERSERK_CHARGE,
  TAINTED_SAMSON_BERSERK_CHARGE_FROM_TAKING_DAMAGE,
} from "../core/constants";
import { MysteriousPaperEffect } from "../enums/MysteriousPaperEffect";
import { getCharacterDeathAnimationName } from "./characters";
import { onGameFrame } from "./frames";
import { getPlayerMaxHeartContainers } from "./playerHealth";
import { getPlayerNumHitsRemaining, hasLostCurse, isKeeper } from "./players";
import { getLastFrameOfAnimation } from "./sprites";
import { giveTrinketsBack, temporarilyRemoveTrinket } from "./trinketGive";
import { getMysteriousPaperEffectForFrame } from "./trinkets";

/**
 * Uses the player's current health and other miscellaneous things to determine if incoming damage
 * will be fatal.
 */
export function isDamageToPlayerFatal(
  player: EntityPlayer,
  amount: int,
  source: EntityRef,
  lastDamageGameFrame: int | undefined,
): boolean {
  const character = player.GetPlayerType();
  const effects = player.GetEffects();
  const isBerserk = effects.HasCollectibleEffect(CollectibleType.BERSERK);

  // If we are Tainted Jacob and the damage source is Dark Esau, this will not be fatal damage
  // (because we will transform into Tainted Jacob's lost form).
  if (
    character === PlayerType.JACOB_B &&
    source.Type === EntityType.DARK_ESAU
  ) {
    return false;
  }

  // If we are berserk, no damage is fatal. (The death is deferred until the end of the berserk
  // effect.)
  if (isBerserk) {
    return false;
  }

  // If we are playing Tainted Samson and the incoming hit will cause us to become Berserk, then
  // this will not be fatal damage.
  const berserkChargeAfterHit =
    player.SamsonBerserkCharge +
    TAINTED_SAMSON_BERSERK_CHARGE_FROM_TAKING_DAMAGE;
  if (
    character === PlayerType.SAMSON_B &&
    berserkChargeAfterHit >= MAX_TAINTED_SAMSON_BERSERK_CHARGE
  ) {
    return false;
  }

  // If Spirit Shackles is activated, no damage is fatal.
  if (willReviveFromSpiritShackles(player)) {
    return false;
  }

  // If we are Tainted Jacob in the Lost Form, we may have plenty of health left, but we will still
  // die in one hit to anything.
  if (character === PlayerType.JACOB_2_B) {
    return true;
  }

  // If we are in the "Lost Curse" form from touching a white fire, all damage will be fatal.
  if (hasLostCurse(player)) {
    return true;
  }

  const playerNumAllHearts = getPlayerNumHitsRemaining(player);
  if (amount < playerNumAllHearts) {
    return false;
  }

  // This will not be fatal damage if the player has Heartbreak and two slots open for broken
  // hearts.
  if (willReviveFromHeartbreak(player)) {
    return false;
  }

  // This will not be fatal damage if we have Glass Cannon and this is the second time we are taking
  // damage on the same frame.
  if (
    player.HasCollectible(CollectibleType.BROKEN_GLASS_CANNON) &&
    onGameFrame(lastDamageGameFrame)
  ) {
    return false;
  }

  // This will not be fatal damage if we have two different kinds of hearts. For example, a bomb
  // explosion deals 2 damage, but if the player has one half soul heart and one half red heart, the
  // game will only remove the soul heart.
  const hearts = player.GetHearts();
  const eternalHearts = player.GetEternalHearts();
  const soulHearts = player.GetSoulHearts();
  const boneHearts = player.GetBoneHearts();
  if (
    (hearts > 0 && soulHearts > 0) ||
    (hearts > 0 && boneHearts > 0) ||
    (soulHearts > 0 && boneHearts > 0) ||
    (soulHearts > 0 && eternalHearts > 0) ||
    boneHearts >= 2 // Two bone hearts and nothing else should not result in a death
  ) {
    return false;
  }

  return true;
}

/**
 * Assuming that we are on the frame of fatal damage, this function returns whether Mysterious Paper
 * would rotate to Missing Poster on the frame that the "Game Over" screen would appear (which would
 * subsequently save the player from fatal damage).
 *
 * Mysterious Paper rotates between the 4 items on every frame, in order. The formula for whether
 * Mysterious Paper be Missing Power is: `gameFrameCount % 4 === 3`
 */
export function willMysteriousPaperRevive(player: EntityPlayer): boolean {
  const sprite = player.GetSprite();

  // We want to explicitly check the length of the death animation because we might be playing on a
  // modded character that has a custom death animation.
  const character = player.GetPlayerType();
  const animation = getCharacterDeathAnimationName(character);
  const deathAnimationFrames = getLastFrameOfAnimation(sprite, animation);
  const frameOfDeath = player.FrameCount + deathAnimationFrames;

  const mysteriousPaperEffect = getMysteriousPaperEffectForFrame(
    player,
    frameOfDeath,
  );
  if (mysteriousPaperEffect === undefined) {
    return false;
  }

  return mysteriousPaperEffect === MysteriousPaperEffect.MISSING_POSTER;
}

/**
 * The `EntityPlayer.WillPlayerRevive` method does not properly account for Mysterious Paper, so use
 * this helper function instead for more robust revival detection.
 */
export function willPlayerRevive(player: EntityPlayer): boolean {
  const trinketSituation = temporarilyRemoveTrinket(
    player,
    TrinketType.MYSTERIOUS_PAPER,
  );

  const willRevive =
    player.WillPlayerRevive() ||
    (trinketSituation !== undefined && willMysteriousPaperRevive(player));

  giveTrinketsBack(player, trinketSituation);

  return willRevive;
}

/**
 * Helper function to determine if the player will be revived by the Heartbreak collectible if they
 * take fatal damage. This is contingent on the character that they are playing as and the amount of
 * broken hearts that they already have.
 */
export function willReviveFromHeartbreak(player: EntityPlayer): boolean {
  if (!player.HasCollectible(CollectibleType.HEARTBREAK)) {
    return false;
  }

  const maxHeartContainers = getPlayerMaxHeartContainers(player);
  const numBrokenHeartsThatWillBeAdded = isKeeper(player) ? 1 : 2;
  const brokenHearts = player.GetBrokenHearts();
  const numBrokenHeartsAfterRevival =
    numBrokenHeartsThatWillBeAdded + brokenHearts;

  return maxHeartContainers > numBrokenHeartsAfterRevival;
}

/**
 * Helper function to determine if the Spirit Shackles item is in an enabled state. (It can be
 * either enabled or disabled.)
 */
export function willReviveFromSpiritShackles(player: EntityPlayer): boolean {
  if (!player.HasCollectible(CollectibleType.SPIRIT_SHACKLES)) {
    return false;
  }

  const effects = player.GetEffects();

  const spiritShacklesEnabled = !effects.HasNullEffect(
    NullItemID.SPIRIT_SHACKLES_DISABLED,
  );
  const playerInSoulForm = effects.HasNullEffect(
    NullItemID.SPIRIT_SHACKLES_SOUL,
  );

  return spiritShacklesEnabled && !playerInSoulForm;
}

----
functions\rng.ts
import type { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import type { ReadonlyRecord } from "../types/ReadonlyRecord";
import { traceback } from "./debugFunctions";
import { isaacAPIClassEquals, isIsaacAPIClassOfType } from "./isaacAPIClass";
import { logError } from "./log";
import { getNumbersFromTable, tableHasKeys } from "./table";
import { isTable } from "./types";
import { assertDefined } from "./utils";

export type SerializedRNG = LuaMap<string, unknown> & {
  readonly __serializedRNGBrand: symbol;
  readonly __kind: CopyableIsaacAPIClassType.RNG;
};

/**
 * This is the ShiftIdx that Blade recommended after having reviewing the game's internal functions.
 * Any value between 0 and 80 should work equally well.
 * https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf
 */
const RECOMMENDED_SHIFT_IDX = 35;

const OBJECT_NAME = "RNG";
const KEYS = ["seed"] as const;

/** Helper function to copy an `RNG` Isaac API class. */
export function copyRNG(rng: RNG): RNG {
  if (!isRNG(rng)) {
    error(
      `Failed to copy a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const seed = rng.GetSeed();
  return newRNG(seed);
}

/**
 * Helper function to convert a `SerializedRNG` object to a normal `RNG` object. (This is used by
 * the save data manager when reading data from the "save#.dat" file.)
 */
export function deserializeRNG(rng: SerializedRNG): RNG {
  if (!isTable(rng)) {
    error(
      `Failed to deserialize a ${OBJECT_NAME} object since the provided object was not a Lua table.`,
    );
  }

  const [seed] = getNumbersFromTable(rng, OBJECT_NAME, ...KEYS);

  assertDefined(
    seed,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: seed`,
  );

  return newRNG(seed as Seed);
}

/**
 * Helper function to get a random `Seed` value to be used in spawning entities and so on. Use this
 * instead of calling the `Random` function directly since that can return a value of 0 and crash
 * the game.
 */
export function getRandomSeed(): Seed {
  const randomNumber = Random(); // eslint-disable-line deprecation/deprecation
  const safeRandomNumber = randomNumber === 0 ? 1 : randomNumber;
  return safeRandomNumber as Seed;
}

/** Helper function to check if something is an instantiated `RNG` object. */
export function isRNG(object: unknown): object is RNG {
  return isIsaacAPIClassOfType(object, OBJECT_NAME);
}

/**
 * Used to determine is the given table is a serialized `RNG` object created by the `deepCopy`
 * function.
 */
export function isSerializedRNG(object: unknown): object is SerializedRNG {
  if (!isTable(object)) {
    return false;
  }

  return tableHasKeys(object, ...KEYS) && object.has(SerializationBrand.RNG);
}

/**
 * Helper function to initialize a new RNG object using Blade's recommended shift index.
 *
 * @param seed Optional. The seed to initialize it with. Default is a random seed.
 */
export function newRNG(seed = getRandomSeed()): RNG {
  const rng = RNG();
  setSeed(rng, seed);
  return rng;
}

export function rngEquals(rng1: RNG, rng2: RNG): boolean {
  return isaacAPIClassEquals(rng1, rng2, KEYS);
}

/**
 * Helper function to convert a `RNG` object to a `SerializedRNG` object. (This is used by the save
 * data manager when writing data from the "save#.dat" file.)
 */
export function serializeRNG(rng: RNG): SerializedRNG {
  if (!isRNG(rng)) {
    error(
      `Failed to serialize a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const seed = rng.GetSeed();
  const rngTable = new LuaMap<string, unknown>();
  rngTable.set("seed", seed);
  rngTable.set(SerializationBrand.RNG, "");
  return rngTable as SerializedRNG;
}

/**
 * Helper function to iterate over the provided object and set the seed for all of the values that
 * are RNG objects equal to a particular seed.
 */
export function setAllRNGToSeed(
  object: ReadonlyRecord<string, RNG>,
  seed: Seed,
): void {
  if (!isTable(object)) {
    error(
      `Failed to iterate over the object containing RNG objects since the type of the provided object was: ${typeof object}`,
    );
  }

  let setAtLeastOneSeed = false;
  for (const [_key, value] of object) {
    if (isRNG(value)) {
      setSeed(value, seed);
      setAtLeastOneSeed = true;
    }
  }

  if (!setAtLeastOneSeed) {
    error(
      `Failed to set all RNG objects to seed ${seed} because the parent object did not contain any RNG objects.`,
    );
  }
}

/**
 * Helper function to iterate over the provided object and set the seed for all of the values that
 * are RNG objects equal to the start seed for the current run.
 */
export function setAllRNGToStartSeed(
  object: ReadonlyRecord<string, RNG>,
): void {
  const seeds = game.GetSeeds();
  const startSeed = seeds.GetStartSeed();

  setAllRNGToSeed(object, startSeed);
}

/** Helper function to set a seed to an RNG object using Blade's recommended shift index. */
export function setSeed(rng: RNG, seed: Seed): void {
  if (seed === 0) {
    seed = getRandomSeed();
    logError(
      "Failed to set a RNG object to a seed of 0. Using a random value instead.",
    );
    traceback();
  }

  // The game expects seeds in the range of 1 to 4294967295 (1^32 - 1).
  // eslint-disable-next-line deprecation/deprecation
  rng.SetSeed(seed, RECOMMENDED_SHIFT_IDX);
}

----
functions\rockAlt.ts
import {
  CollectibleType,
  EntityType,
  TrinketType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import type { RockAltType } from "../enums/RockAltType";
import { BACKDROP_TYPE_TO_ROCK_ALT_TYPE } from "../objects/backdropTypeToRockAltType";
import { getNPCs } from "./entitiesSpecific";
import { removeEntitiesSpawnedFromGridEntity } from "./gridEntities";
import { getCoins, getCollectibles, getTrinkets } from "./pickupsSpecific";

/**
 * Helper function to get the alternate rock type (i.e. urn, mushroom, etc.) that the current room
 * will have.
 *
 * The rock type is based on the backdrop of the room.
 *
 * For example, if you change the backdrop of the starting room of the run to `BackdropType.CAVES`,
 * and then spawn `GridEntityType.ROCK_ALT`, it will be a mushroom instead of an urn. Additionally,
 * if it is destroyed, it will generate mushroom-appropriate rewards.
 *
 * On the other hand, if an urn is spawned first before the backdrop is changed to
 * `BackdropType.CAVES`, the graphic of the urn will not switch to a mushroom. However, when
 * destroyed, the urn will still generate mushroom-appropriate rewards.
 */
export function getRockAltType(): RockAltType {
  const room = game.GetRoom();
  const backdropType = room.GetBackdropType();

  return BACKDROP_TYPE_TO_ROCK_ALT_TYPE[backdropType];
}

/**
 * Helper function to remove all coins, trinkets, and so on that spawned from breaking an urn.
 *
 * The rewards are based on the ones from the wiki:
 * https://bindingofisaacrebirth.fandom.com/wiki/Rocks#Urns
 */
export function removeUrnRewards(gridEntity: GridEntity): void {
  // Coins
  const coins = getCoins();
  removeEntitiesSpawnedFromGridEntity(coins, gridEntity);

  // A Quarter
  const quarters = getCollectibles(CollectibleType.QUARTER);
  removeEntitiesSpawnedFromGridEntity(quarters, gridEntity);

  // Swallowed Penny
  const swallowedPennies = getTrinkets(TrinketType.SWALLOWED_PENNY);
  removeEntitiesSpawnedFromGridEntity(swallowedPennies, gridEntity);

  // Spiders
  const spiders = getNPCs(EntityType.SPIDER);
  removeEntitiesSpawnedFromGridEntity(spiders, gridEntity);
}

----
functions\roomData.ts
import type {
  DoorSlot,
  RoomShape,
  RoomType,
  StageID,
} from "isaac-typescript-definitions";
import { DOOR_SLOT_FLAG_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { doorSlotFlagToDoorSlot } from "./doors";
import { hasFlag } from "./flag";

/**
 * Helper function to get the set of allowed door slots for the room at the supplied grid index.
 * This corresponds to the doors that are enabled in the STB/XML file for the room.
 */
export function getRoomAllowedDoors(
  roomGridIndex?: int,
): ReadonlySet<DoorSlot> {
  const allowedDoors = new Set<DoorSlot>();

  const roomData = getRoomData(roomGridIndex);
  if (roomData === undefined) {
    return allowedDoors;
  }

  for (const doorSlotFlag of DOOR_SLOT_FLAG_VALUES) {
    if (hasFlag(roomData.Doors, doorSlotFlag)) {
      const doorSlot = doorSlotFlagToDoorSlot(doorSlotFlag);
      allowedDoors.add(doorSlot);
    }
  }

  return allowedDoors;
}

/**
 * Helper function to get the room data for the current room.
 *
 * You can optionally provide a room grid index as an argument to get the data for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomData(): RoomConfig;

/**
 * Helper function to get the room data for the current or provided room.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room data for the room or undefined if the provided room does not have any data.
 */
export function getRoomData(roomGridIndex?: int): RoomConfig | undefined;

export function getRoomData(roomGridIndex?: int): RoomConfig | undefined {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);
  return roomDescriptor.Data;
}

/**
 * Helper function to get the descriptor for a room.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function getRoomDescriptor(roomGridIndex?: int): RoomDescriptor {
  const level = game.GetLevel();

  if (roomGridIndex === undefined) {
    roomGridIndex = getRoomGridIndex();
  }

  return level.GetRoomByIdx(roomGridIndex);
}

/**
 * Alias for the `Level.GetCurrentRoomDesc` method. Use this to make it more clear what type of
 * `RoomDescriptor` object that you are retrieving.
 */
export function getRoomDescriptorReadOnly(): Readonly<RoomDescriptor> {
  const level = game.GetLevel();
  return level.GetCurrentRoomDesc();
}

/**
 * Helper function to get the grid index of the current room.
 *
 * - If the current room is inside of the grid, this function will return the `SafeGridIndex` from
 *   the room descriptor. (The safe grid index is defined as the top-left 1x1 section that the room
 *   overlaps with, or the top-right 1x1 section of a `RoomType.SHAPE_LTL` room.)
 * - If the current room is outside of the grid, it will return the index from the
 *   `Level.GetCurrentRoomIndex` method, since `SafeGridIndex` is bugged for these cases, as
 *   demonstrated by entering a Genesis room and entering `l
 *   print(Game():GetLevel():GetCurrentRoomDesc().SafeGridIndex)` into the console. (It prints -1
 *   instead of -12.)
 *
 * Use this function instead of the `Level.GetCurrentRoomIndex` method directly because the latter
 * will return the specific 1x1 quadrant that the player entered the room at. For most situations,
 * using the safe grid index is more reliable than this.
 *
 * Data structures that store data per room should use the room's `ListIndex` instead of
 * `SafeGridIndex`, since the former is unique across different dimensions.
 */
export function getRoomGridIndex(): int {
  const level = game.GetLevel();
  const currentRoomIndex = level.GetCurrentRoomIndex();

  if (currentRoomIndex < 0) {
    return currentRoomIndex;
  }

  const roomDescriptor = getRoomDescriptorReadOnly();
  return roomDescriptor.SafeGridIndex;
}

/**
 * Helper function to get the list grid index of the provided room, which is equal to the index in
 * the `RoomList.Get` method. In other words, this is equal to the order that the room was created
 * by the floor generation algorithm.
 *
 * Use this as an index for data structures that store data per room, since it is unique across
 * different dimensions.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function getRoomListIndex(roomGridIndex?: int): int {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);
  return roomDescriptor.ListIndex;
}

/**
 * Helper function to get the name of the current room as it appears in the STB/XML data.
 *
 * You can optionally provide a room grid index as an argument to get the name for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 *
 * If you want to get the room name for a specific room type, use the `getRoomTypeName` function.
 */
export function getRoomName(): string;

/**
 * Helper function to get the name of the room as it appears in the STB/XML data.
 *
 * If you want to get the room name for a specific room type, use the `getRoomTypeName` function.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room name. Returns undefined if the room data was not found.
 */
export function getRoomName(roomGridIndex?: int): string | undefined;

export function getRoomName(roomGridIndex?: int): string | undefined {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? undefined : roomData.Name;
}

/**
 * Helper function to get the shape of the current room as it appears in the STB/XML data.
 *
 * You can optionally provide a room grid index as an argument to get the shape for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomShape(): RoomShape;

/**
 * Helper function to get the shape of the room as it appears in the STB/XML data.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room shape. Returns undefined if the room data was not found.
 */
export function getRoomShape(roomGridIndex?: int): RoomShape | undefined;

export function getRoomShape(roomGridIndex?: int): RoomShape | undefined {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? undefined : roomData.Shape;
}

/**
 * Helper function to get the stage ID for the current room as it appears in the STB/XML data.
 *
 * The room stage ID will correspond to the first number in the filename of the XML/STB file. For
 * example, a Depths room would have a stage ID of `StageID.DEPTHS` (7).
 *
 * You can optionally provide a room grid index as an argument to get the stage ID for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomStageID(): StageID;

/**
 * Helper function to get the stage ID for a room as it appears in the STB/XML data.
 *
 * The room stage ID will correspond to the first number in the filename of the XML/STB file. For
 * example, a Depths room would have a stage ID of `StageID.DEPTHS` (7).
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room stage ID. Returns undefined if the room data was not found.
 */
export function getRoomStageID(roomGridIndex?: int): StageID | undefined;

export function getRoomStageID(roomGridIndex?: int): StageID | undefined {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? undefined : roomData.StageID;
}

/**
 * Helper function to get the sub-type for the current room as it appears in the STB/XML data.
 *
 * The room sub-type will correspond to different things depending on what XML/STB file it draws
 * from. For example, in the "00.special rooms.stb" file, an Angel Room with a sub-type of 0 will
 * correspond to a normal Angel Room and a sub-type of 1 will correspond to an Angel Room shop from
 * The Stairway.
 *
 * You can optionally provide a room grid index as an argument to get the sub-type for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomSubType(): int;

/**
 * Helper function to get the sub-type for a room as it appears in the STB/XML data.
 *
 * The room sub-type will correspond to different things depending on what XML/STB file it draws
 * from. For example, in the "00.special rooms.stb" file, an Angel Room with a sub-type of 0 will
 * correspond to a normal Angel Room and a sub-type of 1 will correspond to an Angel Room shop from
 * The Stairway.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room sub-type. Returns undefined if the room data was not found.
 */
export function getRoomSubType(roomGridIndex?: int): int | undefined;

export function getRoomSubType(roomGridIndex?: int): int | undefined {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? undefined : roomData.Subtype;
}

/**
 * Helper function to get the type for the current room as it appears in the STB/XML data.
 *
 * You can optionally provide a room grid index as an argument to get the type for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomType(): RoomType;

/**
 * Helper function to get the type for a room as it appears in the STB/XML data.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room type. Returns undefined if the room data was not found.
 */
export function getRoomType(roomGridIndex?: int): RoomType | undefined;

/**
 * Helper function for getting the type of the room with the given grid index.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room data type. Returns -1 if the room data was not found.
 */
export function getRoomType(roomGridIndex?: int): RoomType | undefined {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? undefined : roomData.Type;
}

/**
 * Helper function to get the variant for the current room as it appears in the STB/XML data.
 *
 * You can think of a room variant as its identifier. For example, to go to Basement room #123, you
 * would use a console command of `goto d.123` while on the Basement.
 *
 * You can optionally provide a room grid index as an argument to get the variant for that room
 * instead.
 *
 * (The version of the function without any arguments will not return undefined since the current
 * room is guaranteed to have data.)
 */
export function getRoomVariant(): int;

/**
 * Helper function to get the variant for a room as it appears in the STB/XML data.
 *
 * You can think of a room variant as its identifier. For example, to go to Basement room #123, you
 * would use a console command of `goto d.123` while on the Basement.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 * @returns The room variant. Returns undefined if the room data was not found.
 */
export function getRoomVariant(roomGridIndex?: int): int | undefined;

export function getRoomVariant(roomGridIndex?: int): int {
  const roomData = getRoomData(roomGridIndex);
  return roomData === undefined ? -1 : roomData.Variant;
}

/**
 * Note that the room visited count will be inaccurate during the period before the `POST_NEW_ROOM`
 * callback has fired (i.e. when entities are initializing and performing their first update). This
 * is because the variable is only incremented immediately before the `POST_NEW_ROOM` callback
 * fires.
 *
 * @param roomGridIndex Optional. Default is the current room index.
 */
export function getRoomVisitedCount(roomGridIndex?: int): int {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);
  return roomDescriptor.VisitedCount;
}

/**
 * Helper function to set the data for a given room. This will change the room type, contents, and
 * so on.
 */
export function setRoomData(roomGridIndex: int, roomData: RoomConfig): void {
  const roomDescriptor = getRoomDescriptor(roomGridIndex);
  roomDescriptor.Data = roomData;
}

----
functions\roomGrid.ts
/**
 * These functions have to do with the grid index inside of a room (i.e. the grid index that grid
 * entities use).
 *
 * For functions having to do with the room grid index of the level, see the "Level Grid" functions.
 *
 * @module
 */

import type { RoomShape } from "isaac-typescript-definitions";
import { L_ROOM_SHAPE_TO_RECTANGLES } from "../objects/LRoomShapeToRectangles";
import { inRectangle } from "./math";
import {
  getRoomShapeBottomRightPosition,
  getRoomShapeTopLeftPosition,
  getRoomShapeWidth,
  isLRoomShape,
} from "./roomShape";

/**
 * Helper function to convert grid coordinates to a world position `Vector`.
 *
 * For example, the coordinates of (0, 0) are equal to `Vector(80, 160)`.
 */
export function gridCoordinatesToWorldPosition(
  x: int,
  y: int,
): Readonly<Vector> {
  const gridPosition = Vector(x, y);
  return gridPositionToWorldPosition(gridPosition);
}

/**
 * Helper function to convert a grid index to a grid position.
 *
 * For example, in a 1x1 room, grid index 0 is equal to "Vector(-1, -1) and grid index 16 is equal
 * to "Vector(0, 0)".
 */
export function gridIndexToGridPosition(
  gridIndex: int,
  roomShape: RoomShape,
): Readonly<Vector> {
  const gridWidth = getRoomShapeWidth(roomShape);

  const x = (gridIndex % gridWidth) - 1;
  const y = Math.floor(gridIndex / gridWidth) - 1;
  return Vector(x, y);
}

/**
 * Helper function to convert a grid position `Vector` to a world position `Vector`.
 *
 * For example, the coordinates of (0, 0) are equal to `Vector(80, 160)`.
 */
export function gridPositionToWorldPosition(
  gridPosition: Vector,
): Readonly<Vector> {
  const x = (gridPosition.X + 2) * 40;
  const y = (gridPosition.Y + 4) * 40;

  return Vector(x, y);
}

/**
 * Test if a grid position is actually in the given `RoomShape`.
 *
 * In this context, the grid position of the top-left wall is "Vector(-1, -1)".
 */
export function isValidGridPosition(
  gridPosition: Vector,
  roomShape: RoomShape,
): boolean {
  return isLRoomShape(roomShape)
    ? isValidGridPositionLRoom(gridPosition, roomShape)
    : isValidGridPositionNormal(gridPosition, roomShape);
}

function isValidGridPositionNormal(gridPosition: Vector, roomShape: RoomShape) {
  const topLeft = getRoomShapeTopLeftPosition(roomShape);
  const bottomRight = getRoomShapeBottomRightPosition(roomShape);
  return inRectangle(gridPosition, topLeft, bottomRight);
}

function isValidGridPositionLRoom(gridPosition: Vector, roomShape: RoomShape) {
  const rectangles = L_ROOM_SHAPE_TO_RECTANGLES[roomShape];
  if (rectangles === undefined) {
    return false;
  }

  const {
    verticalTopLeft,
    verticalBottomRight,
    horizontalTopLeft,
    horizontalBottomRight,
  } = rectangles;
  return (
    inRectangle(gridPosition, verticalTopLeft, verticalBottomRight) ||
    inRectangle(gridPosition, horizontalTopLeft, horizontalBottomRight)
  );
}

/**
 * Helper function to convert a world position `Vector` to a grid position `Vector`.
 *
 * In this context, the grid position of the top-left wall is "Vector(-1, -1)".
 */
export function worldPositionToGridPosition(
  worldPos: Vector,
): Readonly<Vector> {
  const x = Math.round(worldPos.X / 40 - 2);
  const y = Math.round(worldPos.Y / 40 - 4);
  return Vector(x, y);
}

/**
 * Helper function to convert a world position `Vector` to a grid position `Vector`.
 *
 * In this context, the grid position of the top-left wall is "Vector(-1, -1)".
 *
 * This is similar to the `worldPositionToGridPosition` function, but the values are not rounded.
 */
export function worldPositionToGridPositionFast(
  worldPos: Vector,
): Readonly<Vector> {
  const x = worldPos.X / 40 - 2;
  const y = worldPos.Y / 40 - 4;
  return Vector(x, y);
}

----
functions\roomShape.ts
import type { DoorSlot } from "isaac-typescript-definitions";
import { RoomShape } from "isaac-typescript-definitions";
import type { Corner } from "../interfaces/Corner";
import { ROOM_SHAPE_BOUNDS } from "../objects/roomShapeBounds";
import { ROOM_SHAPE_CORNERS } from "../objects/roomShapeCorners";
import { ROOM_SHAPE_LAYOUT_SIZES } from "../objects/roomShapeLayoutSizes";
import { ROOM_SHAPE_TO_BOTTOM_RIGHT_POSITION } from "../objects/roomShapeToBottomRightPosition";
import { ROOM_SHAPE_TO_DOOR_SLOTS_TO_GRID_INDEX_DELTA } from "../objects/roomShapeToDoorSlotsToGridIndexDelta";
import { ROOM_SHAPE_TO_GRID_WIDTH } from "../objects/roomShapeToGridWidth";
import { ROOM_SHAPE_TO_TOP_LEFT_POSITION } from "../objects/roomShapeToTopLeftPosition";
import { ROOM_SHAPE_VOLUMES } from "../objects/roomShapeVolumes";
import { L_ROOM_SHAPES_SET } from "../sets/LRoomShapesSet";
import { BIG_ROOM_SHAPES_SET } from "../sets/bigRoomShapesSet";
import { NARROW_ROOM_SHAPES_SET } from "../sets/narrowRoomShapesSet";

/**
 * Helper function to get the grid index delta that a door out of the given room shape would lead
 * to. For example, if you went through the bottom door in a room of `RoomShape.SHAPE_1x2`, you
 * would end up in a room with a grid index that is +26 units from the `SafeGridIndex` of where you
 * started.
 */
export function getGridIndexDelta(
  roomShape: RoomShape,
  doorSlot: DoorSlot,
): int | undefined {
  const doorSlotToGridIndexMap =
    ROOM_SHAPE_TO_DOOR_SLOTS_TO_GRID_INDEX_DELTA[roomShape];
  return doorSlotToGridIndexMap.get(doorSlot);
}

/**
 * Helper function to see if a given room shape will grant a single charge or a double charge to the
 * player's active item(s).
 *
 * For example, `RoomShape.SHAPE_2x2` will return 2.
 */
export function getRoomShapeBottomRightPosition(
  roomShape: RoomShape,
): Readonly<Vector> {
  return ROOM_SHAPE_TO_BOTTOM_RIGHT_POSITION[roomShape];
}

/**
 * Helper function to get the grid position of the bottom-right tile of a given room shape.
 *
 * "Vector(0, 0)" corresponds to the top left tile of a room, not including the walls. (The top-left
 * wall would be at "Vector(-1, -1)".)
 */
export function getRoomShapeBounds(
  roomShape: RoomShape,
): readonly [width: int, height: int] {
  return ROOM_SHAPE_BOUNDS[roomShape];
}

/**
 * Helper function to get the number of charges that a given room shape will grant to a player upon
 * clearing it.
 *
 * For example, `RoomShape.SHAPE_2x2` will return 2.
 */
export function getRoomShapeCharges(roomShape: RoomShape): int {
  return isRoomShapeDoubleCharge(roomShape) ? 2 : 1;
}

/**
 * Helper function to get the corners that exist in the given room shape.
 *
 * Note that these corner locations are not accurate for the Mother Boss Room and the Home closet
 * rooms. (Those rooms have custom shapes.)
 */
export function getRoomShapeCorners(roomShape: RoomShape): readonly Corner[] {
  return ROOM_SHAPE_CORNERS[roomShape];
}

/**
 * Helper function to get the dimensions of a room shape's layout. This is NOT the size of the
 * room's actual contents! For that, use the `getRoomShapeBounds` function.
 *
 * For example, a horizontal narrow room has a layout size of equal to that of a 1x1 room.
 */
export function getRoomShapeLayoutSize(
  roomShape: RoomShape,
): readonly [width: int, height: int] {
  return ROOM_SHAPE_LAYOUT_SIZES[roomShape];
}

/**
 * Helper function to get the grid position of the top-left tile of a given room shape.
 *
 * "Vector(0, 0)" corresponds to the top left tile of a room, not including the walls. (The top-left
 * wall would be at "Vector(-1, -1)".)
 */
export function getRoomShapeTopLeftPosition(
  roomShape: RoomShape,
): Readonly<Vector> {
  return ROOM_SHAPE_TO_TOP_LEFT_POSITION[roomShape];
}

/**
 * Helper function to get the volume of a room shape, which is the amount of tiles that are inside
 * the room.
 *
 * (This cannot be directly calculated from the bounds since L rooms are a special case.)
 */
export function getRoomShapeVolume(roomShape: RoomShape): int {
  return ROOM_SHAPE_VOLUMES[roomShape];
}

export function getRoomShapeWidth(roomShape: RoomShape): int {
  return ROOM_SHAPE_TO_GRID_WIDTH[roomShape];
}

/**
 * Helper function to determine if the provided room is equal to `RoomShape.1x2` (4) or
 * `RoomShape.2x1` (6).
 */
export function is2x1RoomShape(roomShape: RoomShape): boolean {
  return roomShape === RoomShape.SHAPE_1x2 || roomShape === RoomShape.SHAPE_2x1;
}

/**
 * Helper function to detect if the provided room shape is big. Specifically, this is all 1x2 rooms,
 * 2x2 rooms, and L rooms.
 */
export function isBigRoomShape(roomShape: RoomShape): boolean {
  return BIG_ROOM_SHAPES_SET.has(roomShape);
}

/**
 * Helper function to determine if the provided room is equal to `RoomShape.LTL` (9),
 * `RoomShape.LTR` (10), `RoomShape.LBL` (11), or `RoomShape.LBR` (12).
 */
export function isLRoomShape(roomShape: RoomShape): boolean {
  return L_ROOM_SHAPES_SET.has(roomShape);
}

/**
 * Helper function to determine if the provided room is equal to `RoomShape.IH` (2), `RoomShape.IV`
 * (3), `RoomShape.IIV` (5), or `RoomShape.IIH` (7).
 */
export function isNarrowRoom(roomShape: RoomShape): boolean {
  return NARROW_ROOM_SHAPES_SET.has(roomShape);
}

/**
 * Helper function to see if a given room shape will grant a single charge or a double charge to the
 * player's active item(s).
 *
 * For example, `RoomShape.SHAPE_2x2` will return true.
 */
export function isRoomShapeDoubleCharge(roomShape: RoomShape): boolean {
  // 2x2 rooms and L rooms should grant 2 charges.
  return roomShape >= RoomShape.SHAPE_2x2;
}

----
functions\roomShapeWalls.ts
import { BossID, RoomShape } from "isaac-typescript-definitions";
import { ROOM_SHAPE_VALUES } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { CornerType } from "../enums/CornerType";
import type { Corner } from "../interfaces/Corner";
import { ReadonlyMap } from "../types/ReadonlyMap";
import { ReadonlySet } from "../types/ReadonlySet";
import { getGridIndexesBetween } from "./gridIndex";
import { getRoomShapeCorners, isLRoomShape } from "./roomShape";
import { inBossRoomOf, inHomeCloset } from "./rooms";
import { assertDefined } from "./utils";

const ROOM_SHAPE_TO_WALL_GRID_INDEX_MAP = new ReadonlyMap(
  ROOM_SHAPE_VALUES.map((roomShape) => [
    roomShape,
    getVanillaWallGridIndexSetForRoomShape(roomShape),
  ]),
);

/** The Home closet is is 9x3, which is different from `RoomShape.IH` (which is 13x3). */
const HOME_CLOSET_CORNERS = [
  {
    type: CornerType.TOP_LEFT,
    gridIndex: 30,
    position: Vector(60, 220),
  },
  {
    type: CornerType.TOP_RIGHT,
    gridIndex: 38,
    position: Vector(340, 220),
  },
  {
    type: CornerType.BOTTOM_LEFT,
    gridIndex: 90,
    position: Vector(60, 340),
  },
  {
    type: CornerType.BOTTOM_RIGHT,
    gridIndex: 98,
    position: Vector(340, 340),
  },
] as const;

const HOME_CLOSET_CORNERS_SET = getVanillaWallGridIndexSetForRectangleRoomShape(
  RoomShape.IH,
  HOME_CLOSET_CORNERS,
);

/**
 * The Mother Boss Room is 15x11, which is different from `RoomShape.SHAPE_1x2` (which is 15x16).
 */
const MOTHER_ROOM_CORNERS = [
  {
    type: CornerType.TOP_LEFT,
    gridIndex: 0,
    position: Vector(60, 140),
  },
  {
    type: CornerType.TOP_RIGHT,
    gridIndex: 14,
    position: Vector(580, 140),
  },
  {
    type: CornerType.BOTTOM_LEFT,
    gridIndex: 150,
    position: Vector(60, 500),
  },
  {
    type: CornerType.BOTTOM_RIGHT,
    gridIndex: 164,
    position: Vector(580, 500),
  },
] as const;

const MOTHER_ROOM_CORNERS_SET = getVanillaWallGridIndexSetForRectangleRoomShape(
  RoomShape.SHAPE_1x2,
  MOTHER_ROOM_CORNERS,
);

/**
 * Helper function to get the set of grid indexes that represent where the walls are supposed to be
 * in a given room shape.
 *
 * This function only works reliably in vanilla rooms because in a modded room, it is possible to
 * place walls in a non-standard location.
 */
export function getVanillaWallGridIndexSetForRoomShape(
  roomShape: RoomShape,
): ReadonlySet<int> {
  const corners = getRoomShapeCorners(roomShape);
  const lRoom = isLRoomShape(roomShape);

  if (lRoom && corners.length !== 6) {
    error(
      `Failed to get the correct amount of corners for: RoomShape.${RoomShape[roomShape]} (${roomShape})`,
    );
  }

  switch (roomShape) {
    // 9
    case RoomShape.LTL: {
      const [topMiddle, topRight, middleLeft, middle, bottomLeft, bottomRight] =
        corners as [Corner, Corner, Corner, Corner, Corner, Corner];
      return new ReadonlySet([
        // Horizontal
        ...getGridIndexesBetween(
          topMiddle.gridIndex,
          topRight.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middleLeft.gridIndex,
          middle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          bottomLeft.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),

        // Vertical
        ...getGridIndexesBetween(
          middleLeft.gridIndex,
          bottomLeft.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          topMiddle.gridIndex,
          middle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          topRight.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),
      ]);
    }

    // 10
    case RoomShape.LTR: {
      const [topLeft, topMiddle, middle, middleRight, bottomLeft, bottomRight] =
        corners as [Corner, Corner, Corner, Corner, Corner, Corner];
      return new ReadonlySet([
        // Horizontal
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          topMiddle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middle.gridIndex,
          middleRight.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          bottomLeft.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),

        // Vertical
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          bottomLeft.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          topMiddle.gridIndex,
          middle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middleRight.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),
      ]);
    }

    // 11
    case RoomShape.LBL: {
      const [topLeft, topRight, middleLeft, middle, bottomMiddle, bottomRight] =
        corners as [Corner, Corner, Corner, Corner, Corner, Corner];
      return new ReadonlySet([
        // Horizontal
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          topRight.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middleLeft.gridIndex,
          middle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          bottomMiddle.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),

        // Vertical
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          middleLeft.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middle.gridIndex,
          bottomMiddle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          topRight.gridIndex,
          bottomRight.gridIndex,
          roomShape,
        ),
      ]);
    }

    // 12
    case RoomShape.LBR: {
      const [topLeft, topRight, middle, middleRight, bottomLeft, bottomMiddle] =
        corners as [Corner, Corner, Corner, Corner, Corner, Corner];
      return new ReadonlySet([
        // Horizontal
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          topRight.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middle.gridIndex,
          middleRight.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          bottomLeft.gridIndex,
          bottomMiddle.gridIndex,
          roomShape,
        ),

        // Vertical
        ...getGridIndexesBetween(
          topLeft.gridIndex,
          bottomLeft.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          middle.gridIndex,
          bottomMiddle.gridIndex,
          roomShape,
        ),
        ...getGridIndexesBetween(
          topRight.gridIndex,
          middleRight.gridIndex,
          roomShape,
        ),
      ]);
    }

    default: {
      return getVanillaWallGridIndexSetForRectangleRoomShape(
        roomShape,
        corners,
      );
    }
  }
}

/**
 * Providing the room shape is necessary so that the `getGridIndexesBetween` function can use the
 * corresponding grid width.
 */
function getVanillaWallGridIndexSetForRectangleRoomShape(
  roomShape: RoomShape,
  corners: readonly Corner[],
): ReadonlySet<int> {
  if (corners.length !== 4) {
    error(
      "Failed to get the correct amount of corners for rectangular room shape.",
    );
  }

  const [topLeft, topRight, bottomLeft, bottomRight] = corners as [
    Corner,
    Corner,
    Corner,
    Corner,
  ];

  return new ReadonlySet([
    // Horizontal
    ...getGridIndexesBetween(topLeft.gridIndex, topRight.gridIndex, roomShape),
    ...getGridIndexesBetween(
      bottomLeft.gridIndex,
      bottomRight.gridIndex,
      roomShape,
    ),

    // Vertical
    ...getGridIndexesBetween(
      topLeft.gridIndex,
      bottomLeft.gridIndex,
      roomShape,
    ),
    ...getGridIndexesBetween(
      topRight.gridIndex,
      bottomRight.gridIndex,
      roomShape,
    ),
  ]);
}

/**
 * Helper function to determine if a given grid index should have a wall generated by the vanilla
 * game. This is useful as a mechanism to distinguish between real walls and custom walls spawned by
 * mods.
 *
 * This function properly handles the special cases of the Mother boss room and the Home closet
 * rooms, which are both non-standard room shapes.
 */
export function isVanillaWallGridIndex(gridIndex: int): boolean {
  const room = game.GetRoom();
  const roomShape = room.GetRoomShape();

  // Handle the special cases of non-standard room shapes.
  let wallGridIndexSet: ReadonlySet<int> | undefined;
  if (inHomeCloset()) {
    wallGridIndexSet = HOME_CLOSET_CORNERS_SET;
  } else if (inBossRoomOf(BossID.MOTHER)) {
    wallGridIndexSet = MOTHER_ROOM_CORNERS_SET;
  } else {
    wallGridIndexSet = ROOM_SHAPE_TO_WALL_GRID_INDEX_MAP.get(roomShape);
    assertDefined(
      wallGridIndexSet,
      `Failed to find the wall grid index set for: RoomShape.${RoomShape[roomShape]} (${roomShape})`,
    );
  }

  return wallGridIndexSet.has(gridIndex);
}

----
functions\roomTransition.ts
import {
  Direction,
  DoorSlot,
  RoomTransitionAnim,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { getRoomData, getRoomGridIndex } from "./roomData";
import { assertDefined } from "./utils";

/**
 * Helper function to reload the current room using `Game.StartRoomTransition`.
 *
 * This is useful for canceling the "goto" console command or to make the `Level.SetStage` method
 * take effect.
 */
export function reloadRoom(): void {
  const roomGridIndex = getRoomGridIndex();
  teleport(roomGridIndex, Direction.NO_DIRECTION, RoomTransitionAnim.FADE);
}

/**
 * Helper function to change the current room. It can be used for both teleportation and "normal"
 * room transitions, depending on what is passed for the `direction` and `roomTransitionAnim`
 * arguments.
 *
 * Use this function instead of invoking the `Game.StartRoomTransition` method directly so that:
 * - you do not forget to set the `Level.LeaveDoor` field
 * - to prevent crashing on invalid room grid indexes
 *
 * Note that if the current floor has Curse of the Maze, it may redirect the intended teleport.
 *
 * @param roomGridIndex The room grid index of the destination room.
 * @param direction Optional. Default is `Direction.NO_DIRECTION`.
 * @param roomTransitionAnim Optional. Default is `RoomTransitionAnim.TELEPORT`.
 */
export function teleport(
  roomGridIndex: int,
  direction = Direction.NO_DIRECTION,
  roomTransitionAnim = RoomTransitionAnim.TELEPORT,
): void {
  const level = game.GetLevel();

  const roomData = getRoomData(roomGridIndex);
  assertDefined(
    roomData,
    `Failed to change the room to grid index ${roomGridIndex} because that room does not exist.`,
  );

  // This must be set before every `Game.StartRoomTransition` method invocation or else the function
  // can send you to the wrong room.
  level.LeaveDoor = DoorSlot.NO_DOOR_SLOT;

  game.StartRoomTransition(roomGridIndex, direction, roomTransitionAnim);
}

----
functions\rooms.ts
import type {
  BackdropType,
  BossID,
  ItemPoolType,
  MinibossID,
  RoomShape,
} from "isaac-typescript-definitions";
import {
  AngelRoomSubType,
  Dimension,
  DoorSlot,
  DoorSlotFlag,
  DownpourRoomSubType,
  DungeonSubType,
  GridRoom,
  HomeRoomSubType,
  RoomDescriptorFlag,
  RoomType,
  SoundEffect,
  StageID,
} from "isaac-typescript-definitions";
import { game, sfxManager } from "../core/cachedClasses";
import { DIMENSIONS, MAX_LEVEL_GRID_INDEX } from "../core/constants";
import { ROOM_TYPE_NAMES } from "../objects/roomTypeNames";
import { MINE_SHAFT_ROOM_SUB_TYPE_SET } from "../sets/mineShaftRoomSubTypesSet";
import { ReadonlySet } from "../types/ReadonlySet";
import { inDimension } from "./dimensions";
import {
  closeAllDoors,
  getDoors,
  isHiddenSecretRoomDoor,
  openDoorFast,
} from "./doors";
import { getEntities } from "./entities";
import { hasFlag } from "./flag";
import {
  getEntityPositions,
  getEntityVelocities,
  setEntityPositions,
  setEntityVelocities,
} from "./positionVelocity";
import {
  getRoomData,
  getRoomDescriptor,
  getRoomDescriptorReadOnly,
  getRoomGridIndex,
} from "./roomData";
import { is2x1RoomShape, isBigRoomShape, isLRoomShape } from "./roomShape";
import { reloadRoom } from "./roomTransition";
import { getGotoCommand } from "./stage";
import { assertDefined, iRange } from "./utils";

const SECRET_ROOM_TYPES = new ReadonlySet([
  RoomType.SECRET,
  RoomType.SUPER_SECRET,
  RoomType.ULTRA_SECRET,
]);

/**
 * Helper function for quickly switching to a new room without playing a particular animation. Use
 * this helper function over invoking the `Game.ChangeRoom` method directly to ensure that you do
 * not forget to set the `LeaveDoor` field and to prevent crashing on invalid room grid indexes.
 */
export function changeRoom(roomGridIndex: int): void {
  const level = game.GetLevel();

  const roomData = getRoomData(roomGridIndex);
  assertDefined(
    roomData,
    `Failed to change the room to grid index ${roomGridIndex} because that room does not exist.`,
  );

  // LeaveDoor must be set before every `Game.ChangeRoom` invocation or else the function can send
  // you to the wrong room.
  level.LeaveDoor = DoorSlot.NO_DOOR_SLOT;

  game.ChangeRoom(roomGridIndex);
}

/**
 * Helper function to get the number of rooms that are currently on the floor layout. This does not
 * include off-grid rooms, like the Devil Room.
 */
export function getNumRooms(): int {
  const roomsInsideGrid = getRoomsInsideGrid();
  return roomsInsideGrid.length;
}

/**
 * Helper function to get a read-only copy of the room descriptor for every room on the level. This
 * includes off-grid rooms, such as the Devil Room, and extra-dimensional rooms, if they are
 * generated and exist.
 *
 * Room descriptors without any data are assumed to be non-existent and are not included.
 *
 * Under the hood, this is performed by iterating over the `RoomList` from the `Level.GetRooms`
 * method. This is the best way to see if off-grid rooms have been initialized, since it is possible
 * for mods to insert room data at non-official negative room grid indexes.
 */
export function getReadOnlyRooms(): ReadonlyArray<Readonly<RoomDescriptor>> {
  const level = game.GetLevel();
  const roomList = level.GetRooms();

  const readOnlyRoomDescriptors: Array<Readonly<RoomDescriptor>> = [];

  for (let i = 0; i < roomList.Size; i++) {
    const readOnlyRoomDescriptor = roomList.Get(i);
    if (
      readOnlyRoomDescriptor !== undefined &&
      readOnlyRoomDescriptor.Data !== undefined
    ) {
      readOnlyRoomDescriptors.push(readOnlyRoomDescriptor);
    }
  }

  return readOnlyRoomDescriptors;
}

/**
 * Helper function to get the room data for a specific room type and variant combination. This is
 * accomplished by using the "goto" console command to load the specified room into the
 * `GridRoom.DEBUG` slot.
 *
 * Returns undefined if the provided room type and variant combination were not found. (A warning
 * message will also appear on the console, since the "goto" command will fail.)
 *
 * Note that the side effect of using the "goto" console command is that it will trigger a room
 * transition after a short delay. By default, this function cancels the incoming room transition by
 * using the `Game.StartRoomTransition` method to travel to the same room.
 *
 * @param roomType The type of room to retrieve.
 * @param roomVariant The room variant to retrieve. (The room variant is the "ID" of the room in
 *                    Basement Renovator.)
 * @param cancelRoomTransition Optional. Whether to cancel the room transition by using the
 *                             `Game.StartRoomTransition` method to travel to the same room. Default
 *                             is true. Set this to false if you are getting the data for many rooms
 *                             at the same time, and then use the `teleport` helper function when
 *                             you are finished.
 * @param useSpecialRoomsForRoomTypeDefault Optional. Whether to use `s.default` as the prefix for
 *                                 the `goto` command (instead of `d`) if the room type is
 *                                 `RoomType.DEFAULT` (1). False by default.
 */
export function getRoomDataForTypeVariant(
  roomType: RoomType,
  roomVariant: int,
  cancelRoomTransition = true,
  useSpecialRoomsForRoomTypeDefault = false,
): Readonly<RoomConfig> | undefined {
  const command = getGotoCommand(
    roomType,
    roomVariant,
    useSpecialRoomsForRoomTypeDefault,
  );
  // We do not want to log the command execution, because this function will potentially be called
  // many times.
  Isaac.ExecuteCommand(command);
  const newRoomData = getRoomData(GridRoom.DEBUG);

  if (cancelRoomTransition) {
    reloadRoom();
  }

  return newRoomData;
}

/**
 * Helper function to get the item pool type for the current room. For example, this returns
 * `ItemPoolType.ItemPoolType.POOL_ANGEL` if you are in an Angel Room.
 */
export function getRoomItemPoolType(): ItemPoolType {
  const itemPool = game.GetItemPool();
  const room = game.GetRoom();
  const roomType = room.GetType();
  const roomSeed = room.GetSpawnSeed();

  return itemPool.GetPoolForRoom(roomType, roomSeed);
}

/**
 * Helper function to get the proper name of a room type.
 *
 * For example, `RoomType.TREASURE` will return "Treasure Room".
 */
export function getRoomTypeName(roomType: RoomType): string {
  return ROOM_TYPE_NAMES[roomType];
}

/**
 * Helper function to get the room descriptor for every room on the level. This includes off-grid
 * rooms, such as the Devil Room.
 *
 * Room without any data are assumed to be non-existent and are not included.
 *
 * - If you want just the rooms inside of the grid, use the `getRoomsInsideGrid` helper function.
 * - If you want just the rooms outside of the grid, use the `getRoomsOutsideGrid` helper function.
 *
 * @param includeExtraDimensionalRooms Optional. On some floors (e.g. Downpour 2, Mines 2),
 *                                 extra-dimensional rooms are automatically generated. Default is
 *                                 false.
 */
export function getRooms(
  includeExtraDimensionalRooms = false,
): readonly RoomDescriptor[] {
  // The naive way to get all of the rooms would be to iterate over the `RoomList` from the
  // `Level.GetRooms` method. However, this results in read-only data, and we want to return a
  // writable object. Instead, we let the heavy lifting be handled by other functions.
  const roomsInGrid = getRoomsInsideGrid(includeExtraDimensionalRooms);
  const roomsOutsideGrid = getRoomsOutsideGrid();
  return [...roomsInGrid, ...roomsOutsideGrid];
}

/**
 * Helper function to get the room descriptor for every room on the level that is on the grid. (For
 * example, Devil Rooms are excluded.)
 *
 * Room descriptors without any data are assumed to be non-existent and are not included.
 *
 * @param includeExtraDimensionalRooms Optional. On some floors (e.g. Downpour 2, Mines 2),
 *                                 extra-dimensional rooms are automatically be generated. Default
 *                                 is false.
 */
export function getRoomsInsideGrid(
  includeExtraDimensionalRooms = false,
): readonly RoomDescriptor[] {
  const level = game.GetLevel();

  const dimensions = includeExtraDimensionalRooms
    ? DIMENSIONS
    : [Dimension.CURRENT];

  /** We use a map instead of an array because room shapes occupy more than one room grid index. */
  const roomDescriptorMap = new Map<PtrHash, RoomDescriptor>();

  for (const dimension of dimensions) {
    for (const roomGridIndex of iRange(MAX_LEVEL_GRID_INDEX)) {
      const roomDescriptor = level.GetRoomByIdx(roomGridIndex, dimension);
      if (roomDescriptor.Data !== undefined) {
        const ptrHash = GetPtrHash(roomDescriptor);
        roomDescriptorMap.set(ptrHash, roomDescriptor);
      }
    }
  }

  return [...roomDescriptorMap.values()];
}

/**
 * Helper function to get the room descriptor for every room on the level in a specific dimension.
 * This will not include any off-grid rooms, such as the Devil Room.
 *
 * Room descriptors without any data are assumed to be non-existent and are not included.
 */
export function getRoomsOfDimension(
  dimension: Dimension,
): readonly RoomDescriptor[] {
  const level = game.GetLevel();

  /** We use a map instead of an array because room shapes occupy more than one room grid index. */
  const roomsMap = new Map<PtrHash, RoomDescriptor>();

  for (const roomGridIndex of iRange(MAX_LEVEL_GRID_INDEX)) {
    const roomDescriptor = level.GetRoomByIdx(roomGridIndex, dimension);
    if (roomDescriptor.Data !== undefined) {
      const ptrHash = GetPtrHash(roomDescriptor);
      roomsMap.set(ptrHash, roomDescriptor);
    }
  }

  return [...roomsMap.values()];
}

/**
 * Helper function to get the room descriptor for every room on the level that is outside of the
 * grid (like a Devil Room).
 *
 * Room descriptors without any data are assumed to be non-existent and are not included.
 */
export function getRoomsOutsideGrid(): readonly RoomDescriptor[] {
  // We filter an array of all rooms instead of iterating over the `GridRoom` enum because it is
  // possible for mods to insert data at arbitrary negative room grid indexes.
  const readOnlyRooms = getReadOnlyRooms();
  const readOnlyRoomsOffGrid = readOnlyRooms.filter(
    (readOnlyRoomDescriptor) => readOnlyRoomDescriptor.SafeGridIndex < 0,
  );

  return readOnlyRoomsOffGrid.map((readOnlyRoomDescriptor) =>
    getRoomDescriptor(readOnlyRoomDescriptor.SafeGridIndex),
  );
}

/**
 * Helper function to determine if the current room shape is equal to `RoomShape.1x2` or
 * `RoomShape.2x1`.
 */
export function in2x1Room(): boolean {
  const roomData = getRoomData();
  return is2x1Room(roomData);
}

/**
 * Helper function to check to see if the current room is an angel shop.
 *
 * Under the hood, this checks the room type being equal to `RoomType.ANGEL` (15) and the sub-type
 * being equal to `AngelRoomSubType.SHOP` (1).
 */
export function inAngelShop(): boolean {
  const roomData = getRoomData();
  return isAngelShop(roomData);
}

/**
 * Helper function to check to see if the current room is the Boss Room for The Beast.
 *
 * This function is useful because the `Room.GetBossID` method returns 0 for The Beast room.
 *
 * Under the hood, this checks the room type being equal to `RoomType.DUNGEON` (16) and the sub-type
 * being equal to `DungeonSubType.BEAST_ROOM` (4).
 */
export function inBeastRoom(): boolean {
  const roomData = getRoomData();
  return isBeastRoom(roomData);
}

/**
 * Helper function to detect if the current room is big. Specifically, this is all 1x2 rooms, 2x2
 * rooms, and L rooms.
 */
export function inBigRoom(): boolean {
  const roomData = getRoomData();
  return isBigRoom(roomData);
}

/**
 * Helper function to check if the current room is the Boss Room for a particular boss. This will
 * only work for bosses that have dedicated boss rooms in the "00.special rooms.stb" file.
 */
export function inBossRoomOf(bossID: BossID): boolean {
  const roomData = getRoomData();
  return isBossRoomOf(roomData, bossID);
}

/**
 * Helper function for determining whether the current room is a crawl space. Use this function over
 * comparing to `RoomType.DUNGEON` or `GridRoom.DUNGEON_IDX` since there is a special case of the
 * player being in a boss fight that takes place in a dungeon.
 */
export function inCrawlSpace(): boolean {
  const roomData = getRoomData();
  return isCrawlSpace(roomData);
}

/**
 * Helper function for checking whether the current room is a crawl space with a door corresponding
 * to `DoorSlotFlag.RIGHT_0` (1 << 2).
 */
export function inCrawlSpaceWithBlackMarketEntrance(): boolean {
  const roomData = getRoomData();
  return isCrawlSpaceWithBlackMarketEntrance(roomData);
}

/**
 * Helper function to detect if the current room is one of the rooms in the Death Certificate area.
 */
export function inDeathCertificateArea(): boolean {
  const roomData = getRoomData();
  return isDeathCertificateArea(roomData);
}

/**
 * Helper function to detect if the current room is a Treasure Room created when entering with a
 * Devil's Crown trinket.
 *
 * Under the hood, this checks for `RoomDescriptorFlag.DEVIL_TREASURE`.
 */
export function inDevilsCrownTreasureRoom(): boolean {
  const roomDescriptor = getRoomDescriptorReadOnly();
  return isDevilsCrownTreasureRoom(roomDescriptor);
}

/**
 * Helper function to check to see if the current room is the Boss Room for Dogma.
 *
 * This function is useful because the `Room.GetBossID` method returns 0 for the Dogma room.
 *
 * Note that the "living room" on the Home floor with the TV at the top of the room is not the Dogma
 * Boss Room, as the player is teleported to a different room after watching the TV cutscene.
 *
 * Under the hood, this checks the stage ID being equal to `StageID.HOME` (35) and the room type
 * being equal to `RoomType.DEFAULT` (1) and the variant being equal to 1000 (which is the only
 * Dogma Boss Room that exists in vanilla) and the sub-type being equal to
 * `HomeRoomSubType.LIVING_ROOM` (3).
 */
export function inDogmaRoom(): boolean {
  const roomData = getRoomData();
  return isDogmaRoom(roomData);
}

/**
 * Helper function to detect if the current room is a Double Trouble Boss Room.
 *
 * This is performed by checking for the string "Double Trouble" inside of the room name. The
 * vanilla game uses this convention for every Double Trouble Boss Room. Note that this method might
 * fail for mods that add extra Double Trouble rooms but do not follow the convention.
 *
 * Internally, the game is coded to detect Double Trouble Boss Rooms by checking for the variant
 * range of 3700 through 3850. We intentionally do not use this method since it may not work as well
 * with modded rooms.
 */
export function inDoubleTrouble(): boolean {
  const roomData = getRoomData();
  return isDoubleTrouble(roomData);
}

/** Helper function to determine if the current room index is equal to `GridRoom.GENESIS`. */
export function inGenesisRoom(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isGenesisRoom(roomGridIndex);
}

/**
 * Helper function to check if the current room is either the left Home closet (behind the red door)
 * or the right Home closet (with one random pickup).
 *
 * Home closets have a unique shape that is different from any other room in the game.
 */
export function inHomeCloset(): boolean {
  const roomData = getRoomData();
  return isHomeCloset(roomData);
}

/** Helper function to determine if the current room shape is one of the four L room shapes. */
export function inLRoom(): boolean {
  const roomData = getRoomData();
  return isLRoom(roomData);
}

/** Helper function to determine if the current room index is equal to `GridRoom.MEGA_SATAN`. */
export function inMegaSatanRoom(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isMegaSatanRoom(roomGridIndex);
}

/**
 * Helper function to determine if the current room is part of the Repentance "escape sequence" in
 * the Mines/Ashpit.
 */
export function inMineShaft(): boolean {
  const roomData = getRoomData();
  return isMineShaft(roomData);
}

/**
 * Helper function to check if the current room is a miniboss room for a particular miniboss. This
 * will only work for mini-bosses that have dedicated boss rooms in the "00.special rooms.stb" file.
 */
export function inMinibossRoomOf(minibossID: MinibossID): boolean {
  const roomData = getRoomData();
  return isMinibossRoomOf(roomData, minibossID);
}

/**
 * Helper function to check if the current room is a "mirror room" in Downpour or Dross. (These
 * rooms are marked with a specific sub-type.)
 */
export function inMirrorRoom(): boolean {
  const roomData = getRoomData();
  return isMirrorRoom(roomData);
}

/**
 * Helper function to check if the current room shape matches one of the given room shapes.
 *
 * This function is variadic, which means you can pass as many room shapes as you want to match for.
 */
export function inRoomShape(...roomShapes: readonly RoomShape[]): boolean {
  const roomData = getRoomData();
  return isRoomShape(roomData, ...roomShapes);
}

/**
 * Helper function to check if the current room matches one of the given room types.
 *
 * This function is variadic, which means you can pass as many room types as you want to match for.
 */
export function inRoomType(...roomTypes: readonly RoomType[]): boolean {
  const roomData = getRoomData();
  return isRoomType(roomData, ...roomTypes);
}

/**
 * Helper function for checking if the current room is a secret exit that leads to a Repentance
 * floor.
 */
export function inSecretExit(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isSecretExit(roomGridIndex);
}

/**
 * Helper function for checking if the current room is a secret shop (from the Member Card
 * collectible).
 *
 * Secret shops are simply copies of normal shops, but with the backdrop of a secret room. In other
 * words, they will have the same room type, room variant, and room sub-type of a normal shop. Thus,
 * the only way to detect them is by using the grid index.
 */
export function inSecretShop(): boolean {
  const roomGridIndex = getRoomGridIndex();
  return isSecretShop(roomGridIndex);
}

/**
 * Helper function to determine whether the current room is the starting room of a floor. It only
 * returns true for the starting room of the primary dimension (meaning that being in the starting
 * room of the mirror world does not count).
 */
export function inStartingRoom(): boolean {
  const level = game.GetLevel();
  const startingRoomGridIndex = level.GetStartingRoomIndex();
  const roomGridIndex = getRoomGridIndex();

  return roomGridIndex === startingRoomGridIndex && inDimension(Dimension.MAIN);
}

/**
 * Helper function to determine if the provided room is equal to `RoomShape.1x2` or `RoomShape.2x1`.
 */
export function is2x1Room(roomData: RoomConfig): boolean {
  return is2x1RoomShape(roomData.Shape);
}

/**
 * Helper function to loop through every room on the floor and see if it has been cleared.
 *
 * This function will only check rooms inside the grid and inside the current dimension.
 *
 * @param onlyCheckRoomTypes Optional. A whitelist of room types. If specified, room types not in
 *                           the array will be ignored. If not specified, then all rooms will be
 *                           checked. Undefined by default.
 * @param includeSecretRoom Optional. Whether to include the Secret Room. Default is false.
 * @param includeSuperSecretRoom Optional. Whether to include the Super Secret Room. Default is
 *                               false.
 * @param includeUltraSecretRoom Optional. Whether to include the Ultra Secret Room. Default is
 *                               false.
 * @allowEmptyVariadic
 */
export function isAllRoomsClear(
  onlyCheckRoomTypes?: readonly RoomType[],
  includeSecretRoom = false,
  includeSuperSecretRoom = false,
  includeUltraSecretRoom = false,
): boolean {
  const roomsInsideGrid = getRoomsInsideGrid();

  let matchingRooms: readonly RoomDescriptor[];
  if (onlyCheckRoomTypes === undefined) {
    matchingRooms = roomsInsideGrid;
  } else {
    const roomTypeWhitelist = new ReadonlySet(onlyCheckRoomTypes);
    matchingRooms = roomsInsideGrid.filter(
      (roomDescriptor) =>
        roomDescriptor.Data !== undefined &&
        roomTypeWhitelist.has(roomDescriptor.Data.Type),
    );
  }

  if (!includeSecretRoom) {
    matchingRooms = matchingRooms.filter(
      (roomDescriptor) =>
        roomDescriptor.Data !== undefined &&
        roomDescriptor.Data.Type !== RoomType.SECRET,
    );
  }

  if (!includeSuperSecretRoom) {
    matchingRooms = matchingRooms.filter(
      (roomDescriptor) =>
        roomDescriptor.Data !== undefined &&
        roomDescriptor.Data.Type !== RoomType.SUPER_SECRET,
    );
  }

  if (!includeUltraSecretRoom) {
    matchingRooms = matchingRooms.filter(
      (roomDescriptor) =>
        roomDescriptor.Data !== undefined &&
        roomDescriptor.Data.Type !== RoomType.ULTRA_SECRET,
    );
  }

  return matchingRooms.every((roomDescriptor) => roomDescriptor.Clear);
}

/**
 * Helper function to check to see if the current room is an angel shop.
 *
 * Under the hood, this checks the room type being equal to `RoomType.ANGEL` (15) and the sub-type
 * being equal to `AngelRoomSubType.SHOP` (1).
 */
export function isAngelShop(roomData: RoomConfig): boolean {
  return (
    roomData.Type === RoomType.ANGEL &&
    roomData.Subtype === AngelRoomSubType.SHOP
  );
}

/**
 * Helper function to check to see if the provided room is the Boss Room for The Beast.
 *
 * This function is useful because the `Room.GetBossID` method returns 0 for The Beast room.
 *
 * Under the hood, this checks the room type being equal to `RoomType.DUNGEON` (16) and the sub-type
 * being equal to `DungeonSubType.BEAST_ROOM` (4).
 */
export function isBeastRoom(roomData: RoomConfig): boolean {
  return (
    roomData.Type === RoomType.DUNGEON &&
    roomData.Subtype === DungeonSubType.BEAST_ROOM
  );
}

/**
 * Helper function to detect if the provided room is big. Specifically, this is all 1x2 rooms, 2x2
 * rooms, and L rooms.
 */
export function isBigRoom(roomData: RoomConfig): boolean {
  return isBigRoomShape(roomData.Shape);
}

/**
 * Helper function to check if the provided room is the Boss Room for a particular boss. This will
 * only work for bosses that have dedicated boss rooms in the "00.special rooms.stb" file.
 */
export function isBossRoomOf(roomData: RoomConfig, bossID: BossID): boolean {
  return (
    roomData.Type === RoomType.BOSS &&
    roomData.StageID === StageID.SPECIAL_ROOMS &&
    roomData.Subtype === bossID
  );
}

/**
 * Helper function for determining whether the provided room is a crawl space. Use this function
 * over comparing to `RoomType.DUNGEON` or `GridRoom.DUNGEON_IDX` since there is a special case of
 * the player being in a boss fight that takes place in a dungeon.
 */
export function isCrawlSpace(roomData: RoomConfig): boolean {
  return (
    roomData.Type === RoomType.DUNGEON &&
    roomData.Subtype === DungeonSubType.NORMAL
  );
}

/**
 * Helper function for checking whether the provided room is a crawl space with a door corresponding
 * to `DoorSlotFlag.RIGHT_0` (1 << 2).
 */
export function isCrawlSpaceWithBlackMarketEntrance(
  roomData: RoomConfig,
): boolean {
  return (
    isCrawlSpace(roomData) && hasFlag(roomData.Doors, DoorSlotFlag.RIGHT_0)
  );
}

/**
 * Helper function to detect if the provided room is one of the rooms in the Death Certificate area.
 */
export function isDeathCertificateArea(roomData: RoomConfig): boolean {
  return (
    roomData.StageID === StageID.HOME &&
    (roomData.Subtype === HomeRoomSubType.DEATH_CERTIFICATE_ENTRANCE ||
      roomData.Subtype === HomeRoomSubType.DEATH_CERTIFICATE_ITEMS)
  );
}

/**
 * Helper function to detect if the provided room is a Treasure Room created when entering with a
 * Devil's Crown trinket.
 *
 * Under the hood, this checks for `RoomDescriptorFlag.DEVIL_TREASURE`.
 */
export function isDevilsCrownTreasureRoom(
  roomDescriptor: RoomDescriptor,
): boolean {
  return hasFlag(roomDescriptor.Flags, RoomDescriptorFlag.DEVIL_TREASURE);
}

/**
 * Helper function to check to see if the provided room is the Boss Room for Dogma.
 *
 * This function is useful because the `Room.GetBossID` method returns 0 for the Dogma room.
 *
 * Note that the "living room" on the Home floor with the TV at the top of the room is not the Dogma
 * Boss Room, as the player is teleported to a different room after watching the TV cutscene.
 *
 * Under the hood, this checks the stage ID being equal to `StageID.HOME` (35) and the room type
 * being equal to `RoomType.DEFAULT` (1) and the variant being equal to 1000 (which is the only
 * Dogma Boss Room that exists in vanilla) and the sub-type being equal to
 * `HomeRoomSubType.LIVING_ROOM` (3).
 */
export function isDogmaRoom(roomData: RoomConfig): boolean {
  return (
    roomData.StageID === StageID.HOME &&
    roomData.Type === RoomType.DEFAULT &&
    roomData.Variant === 1000 &&
    roomData.Subtype === HomeRoomSubType.LIVING_ROOM
  );
}

/**
 * Helper function to detect if the provided room is a Double Trouble Boss Room.
 *
 * This is performed by checking for the string "Double Trouble" inside of the room name. The
 * vanilla game uses this convention for every Double Trouble Boss Room. Note that this method might
 * fail for mods that add extra Double Trouble rooms but do not follow the convention.
 *
 * Internally, the game is coded to detect Double Trouble Boss Rooms by checking for the variant
 * range of 3700 through 3850. We intentionally do not use this method since it may not work as well
 * with modded rooms.
 */
export function isDoubleTrouble(roomData: RoomConfig): boolean {
  return (
    roomData.Type === RoomType.BOSS && roomData.Name.includes("Double Trouble")
  );
}

/**
 * Helper function to determine if the index of the provided room is equal to `GridRoom.GENESIS`.
 */
export function isGenesisRoom(roomGridIndex: int): boolean {
  return roomGridIndex === GridRoom.GENESIS;
}

/**
 * Helper function to check if the provided room is either the left Home closet (behind the red
 * door) or the right Home closet (with one random pickup).
 *
 * Home closets have a unique shape that is different from any other room in the game.
 */
export function isHomeCloset(roomData: RoomConfig): boolean {
  return (
    roomData.StageID === StageID.HOME &&
    (roomData.Subtype === HomeRoomSubType.CLOSET_LEFT ||
      roomData.Subtype === HomeRoomSubType.CLOSET_RIGHT)
  );
}

/** Helper function to determine if the provided room is one of the four L room shapes. */
export function isLRoom(roomData: RoomConfig): boolean {
  return isLRoomShape(roomData.Shape);
}

/**
 * Helper function to determine if the index of the provided room is equal to `GridRoom.MEGA_SATAN`.
 */
export function isMegaSatanRoom(roomGridIndex: int): boolean {
  return roomGridIndex === GridRoom.MEGA_SATAN;
}

/**
 * Helper function to determine if the provided room is part of the Repentance "escape sequence" in
 * the Mines/Ashpit.
 */
export function isMineShaft(roomData: RoomConfig): boolean {
  return (
    (roomData.StageID === StageID.MINES ||
      roomData.StageID === StageID.ASHPIT) &&
    // eslint-disable-next-line isaacscript/strict-enums
    MINE_SHAFT_ROOM_SUB_TYPE_SET.has(roomData.Subtype)
  );
}

/**
 * Helper function to check if the provided room is a miniboss room for a particular miniboss. This
 * will only work for mini-bosses that have dedicated boss rooms in the "00.special rooms.stb" file.
 */
export function isMinibossRoomOf(
  roomData: RoomConfig,
  minibossID: MinibossID,
): boolean {
  return (
    roomData.Type === RoomType.MINI_BOSS &&
    roomData.StageID === StageID.SPECIAL_ROOMS &&
    roomData.Subtype === minibossID
  );
}

/**
 * Helper function to check if the provided room is a "mirror room" in Downpour or Dross. (These
 * rooms are marked with a specific sub-type.)
 */
export function isMirrorRoom(roomData: RoomConfig): boolean {
  return (
    roomData.Type === RoomType.DEFAULT &&
    (roomData.StageID === StageID.DOWNPOUR ||
      roomData.StageID === StageID.DROSS) &&
    roomData.Subtype === DownpourRoomSubType.MIRROR
  );
}

/**
 * Helper function to check if the provided room matches one of the given room shapes.
 *
 * This function is variadic, which means you can pass as many room shapes as you want to match for.
 */
export function isRoomShape(
  roomData: RoomConfig,
  ...roomShapes: readonly RoomShape[]
): boolean {
  return roomShapes.includes(roomData.Shape);
}

/**
 * Helper function to check if the provided room matches one of the given room types.
 *
 * This function is variadic, which means you can pass as many room types as you want to match for.
 */
export function isRoomType(
  roomData: RoomConfig,
  ...roomTypes: readonly RoomType[]
): boolean {
  return roomTypes.includes(roomData.Type);
}

/**
 * Helper function for checking if the provided room is a secret exit that leads to a Repentance
 * floor.
 */
export function isSecretExit(roomGridIndex: int): boolean {
  return roomGridIndex === GridRoom.SECRET_EXIT;
}

/**
 * Helper function to detect if a room type is a Secret Room, a Super Secret Room, or an Ultra
 * Secret Room.
 */
export function isSecretRoomType(roomType: RoomType): boolean {
  return SECRET_ROOM_TYPES.has(roomType);
}

/**
 * Helper function for checking if the provided room is a secret shop (from the Member Card
 * collectible).
 *
 * Secret shops are simply copies of normal shops, but with the backdrop of a secret room. In other
 * words, they will have the same room type, room variant, and room sub-type of a normal shop. Thus,
 * the only way to detect them is by using the grid index.
 */
export function isSecretShop(roomGridIndex: int): boolean {
  return roomGridIndex === GridRoom.SECRET_SHOP;
}

/**
 * If the `Room.Update` method is called in a `POST_NEW_ROOM` callback, then some entities will
 * slide around (such as the player). Since those entity velocities are already at zero, setting
 * them to zero will have no effect. Thus, a generic solution is to record all of the entity
 * positions/velocities before updating the room, and then restore those positions/velocities.
 */
export function roomUpdateSafe(): void {
  const room = game.GetRoom();
  const entities = getEntities();

  const entityPositions = getEntityPositions(entities);
  const entityVelocities = getEntityVelocities(entities);

  room.Update();

  setEntityPositions(entityPositions, entities);
  setEntityVelocities(entityVelocities, entities);
}

/** Helper function to set the backdrop (i.e. background) of the current room. */
export function setBackdrop(backdropType: BackdropType): void {
  game.ShowHallucination(0, backdropType);
  sfxManager.Stop(SoundEffect.DEATH_CARD);
}

/**
 * Helper function to convert an uncleared room to a cleared room in the `POST_NEW_ROOM` callback.
 * This is useful because if enemies are removed in this callback, a room drop will be awarded and
 * the doors will start closed and then open.
 */
export function setRoomCleared(): void {
  const room = game.GetRoom();
  const roomClear = room.IsClear();

  // If the room is already cleared, we don't have to do anything.
  if (roomClear) {
    return;
  }

  room.SetClear(true);

  for (const door of getDoors()) {
    if (isHiddenSecretRoomDoor(door)) {
      continue;
    }

    // We don't use the `EntityDoor.Open` method since that will cause the door to play an
    // animation.
    openDoorFast(door);

    // If this is a mini-boss room, then the door would be barred in addition to being closed.
    // Ensure that the bar is not visible.
    door.ExtraVisible = false;
  }

  sfxManager.Stop(SoundEffect.DOOR_HEAVY_OPEN);

  // If the room contained Mom's Hands, then a screen shake will be queued. Override it with a 0
  // frame shake.
  game.ShakeScreen(0);
}

/**
 * Helper function to emulate what happens when you bomb an Angel Statue or push a Reward Plate that
 * spawns an NPC.
 */
export function setRoomUncleared(): void {
  const room = game.GetRoom();

  room.SetClear(false);
  closeAllDoors();
}

----
functions\run.ts
import {
  Challenge,
  PlayerType,
  SeedEffect,
} from "isaac-typescript-definitions";
import { SEED_EFFECTS } from "../cachedEnumValues";
import { game } from "../core/cachedClasses";
import { getCharacterName } from "./characters";
import { log } from "./log";
import { isString } from "./types";

/** Alias for the `anySeedEffectEnabled` function. */
export function anyEasterEggEnabled(
  exceptions?: readonly SeedEffect[],
): boolean {
  return anySeedEffectEnabled(exceptions);
}

/**
 * Helper function to see if any seed effects (i.e. Easter Eggs) are enabled for the current run.
 *
 * @param exceptions Optional. An array of seed effects to ignore.
 */
export function anySeedEffectEnabled(
  exceptions?: readonly SeedEffect[],
): boolean {
  const seeds = game.GetSeeds();

  if (exceptions === undefined) {
    const numSeedEffects = seeds.CountSeedEffects();
    return numSeedEffects > 0;
  }

  const exceptionsSet = new Set(exceptions);
  return SEED_EFFECTS.some(
    (seedEffect) =>
      seeds.HasSeedEffect(seedEffect) && !exceptionsSet.has(seedEffect),
  );
}

/**
 * Helper function to get the seed effects (i.e. Easter Eggs) that are enabled for the current run.
 */
export function getSeedEffects(): readonly SeedEffect[] {
  const seeds = game.GetSeeds();

  return SEED_EFFECTS.filter(
    (seedEffect) =>
      seedEffect !== SeedEffect.NORMAL && seeds.HasSeedEffect(seedEffect),
  );
}

/**
 * Helper function to check whether the player is playing on a set seed (i.e. that they entered in a
 * specific seed by pressing tab on the character selection screen). When the player resets the game
 * on a set seed, the game will not switch to a different seed.
 *
 * Under the hood, this checks if the current challenge is `Challenge.NULL` and the
 * `Seeds.IsCustomRun` method.
 */
export function onSetSeed(): boolean {
  const seeds = game.GetSeeds();
  const customRun = seeds.IsCustomRun();
  const challenge = Isaac.GetChallenge();

  return challenge === Challenge.NULL && customRun;
}

/**
 * Helper function to check whether the player is on a Victory Lap (i.e. they answered "yes" to the
 * popup that happens after defeating The Lamb).
 */
export function onVictoryLap(): boolean {
  const numVictoryLaps = game.GetVictoryLap();
  return numVictoryLaps > 0;
}

/**
 * Helper function to restart the run using the console command of "restart". If the player is
 * playing a seeded run, then it will restart the game to the beginning of the seed. Otherwise, it
 * will put the player on a run with an entirely new seed.
 *
 * You can optionally specify a `PlayerType` to restart the game as that character.
 */
export function restart(character?: PlayerType): void {
  if (character === undefined) {
    const command = "restart";
    log(`Restarting the run with a console command of: ${command}`);
    Isaac.ExecuteCommand(command);
    return;
  }

  if (character < PlayerType.ISAAC) {
    error(`Restarting as a character of ${character} would crash the game.`);
  }

  const command = `restart ${character}`;
  const characterName = getCharacterName(character);
  log(
    `Restarting the run as ${characterName} (${character}) with a console command of: ${command}`,
  );
  Isaac.ExecuteCommand(command);
}

/**
 * Helper function to restart the run on a particular starting seed.
 *
 * Under the hood, this function executes the `seed` console command.
 *
 * @param startSeedOrStartSeedString Either the numerical start seed (e.g. 268365970) or the start
 *                                 seed string (e.g. "AAJ2 8V9C").
 */
export function setRunSeed(startSeedOrStartSeedString: Seed | string): void {
  const startSeedString = isString(startSeedOrStartSeedString)
    ? startSeedOrStartSeedString
    : Seeds.Seed2String(startSeedOrStartSeedString);

  const command = `seed ${startSeedString}`;
  log(`Restarting the run to set a seed with a console command of: ${command}`);
  Isaac.ExecuteCommand(command);
}

/**
 * Helper function to change the run status to that of an unseeded run with a new random seed.
 *
 * This is useful to revert the behavior where playing on a set seed and restarting the game will
 * not take you to a new seed.
 *
 * Under the hood, this function calls the `Seeds.Reset` method and the
 * `Seeds.Restart(Challenge.NULL)` method.
 */
export function setUnseeded(): void {
  const seeds = game.GetSeeds();

  // Invoking the `Seeds.Reset` method will cause the start seed to be set to 0. Subsequently, the
  // `Seeds.GetStartSeed` method will return 0, and can cause crashes (due to RNG objects not being
  // able to handle a seed of 0). It also causes the log to be spammed with: "[ASSERT] - Error: Game
  // Start Seed was not set." Thus, we must immediately re-initialize the game start seed by using
  // the `Seeds.Restart` method.
  seeds.Reset();
  seeds.Restart(Challenge.NULL);
}

----
functions\seeds.ts
import { game } from "../core/cachedClasses";
import { newRNG } from "./rng";

/** Alias for the `Seeds.GetStartSeedString` method. */
export function getStartSeedString(): string {
  const seeds = game.GetSeeds();
  return seeds.GetStartSeedString();
}

/**
 * Helper function to get the next seed value.
 *
 * This function is useful when you are working with seed values directly over RNG objects.
 */
export function nextSeed(seed: Seed): Seed {
  const rng = newRNG(seed);
  rng.Next();
  return rng.GetSeed();
}

----
functions\serialization.ts
import type { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { ISAAC_API_CLASS_TYPE_TO_BRAND } from "../objects/isaacAPIClassTypeToBrand";
import type {
  CopyableIsaacAPIClass,
  IsaacAPIClassTypeFunctions,
  IsaacAPIClassTypeToSerializedType,
  IsaacAPIClassTypeToType,
  SerializedIsaacAPIClass,
} from "../objects/isaacAPIClassTypeToFunctions";
import { ISAAC_API_CLASS_TYPE_TO_FUNCTIONS } from "../objects/isaacAPIClassTypeToFunctions";
import { getIsaacAPIClassName } from "./isaacAPIClass";
import { isTable, isUserdata } from "./types";
import { assertDefined } from "./utils";

/**
 * Helper function to generically copy an Isaac API class without knowing what specific type of
 * class it is. (This is used by the save data manager.)
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export function copyIsaacAPIClass<T extends CopyableIsaacAPIClass>(
  isaacAPIClass: T,
): T {
  if (!isUserdata(isaacAPIClass)) {
    error(
      `Failed to copy an Isaac API class since the provided object was of type: ${typeof isaacAPIClass}`,
    );
  }

  const isaacAPIClassType = getIsaacAPIClassName(isaacAPIClass);
  assertDefined(
    isaacAPIClassType,
    "Failed to copy an Isaac API class since it does not have a class type.",
  );

  const copyableIsaacAPIClassType =
    isaacAPIClassType as CopyableIsaacAPIClassType;

  type ThisIsaacAPIClassType = T;
  type ThisSerializedIsaacAPIClassType =
    IsaacAPIClassTypeToSerializedType[T["__kind"]];

  const functions = ISAAC_API_CLASS_TYPE_TO_FUNCTIONS[
    copyableIsaacAPIClassType
  ] as unknown as
    | IsaacAPIClassTypeFunctions<
        ThisIsaacAPIClassType,
        ThisSerializedIsaacAPIClassType
      >
    | undefined;
  assertDefined(
    functions,
    `Failed to copy an Isaac API class since the associated functions were not found for Isaac API class type: ${copyableIsaacAPIClassType}`,
  );

  return functions.copy(isaacAPIClass);
}

/**
 * Helper function to generically deserialize an Isaac API class without knowing what specific type
 * of class it is. (This is used by the save data manager when reading data from the "save#.dat"
 * file.)
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export function deserializeIsaacAPIClass<
  SerializedT extends SerializedIsaacAPIClass,
>(
  serializedIsaacAPIClass: SerializedT,
): IsaacAPIClassTypeToType[SerializedT["__kind"]] {
  if (!isTable(serializedIsaacAPIClass)) {
    error(
      `Failed to deserialize an Isaac API class since the provided object was of type: ${typeof serializedIsaacAPIClass}`,
    );
  }

  const copyableIsaacAPIClassType = getSerializedTableType(
    serializedIsaacAPIClass,
  );
  assertDefined(
    copyableIsaacAPIClassType,
    "Failed to deserialize an Isaac API class since a valid class type brand was not found.",
  );

  type ThisIsaacAPIClassType = IsaacAPIClassTypeToType[SerializedT["__kind"]];
  type ThisSerializedIsaacAPIClassType = SerializedT;

  const functions = ISAAC_API_CLASS_TYPE_TO_FUNCTIONS[
    copyableIsaacAPIClassType
  ] as unknown as
    | IsaacAPIClassTypeFunctions<
        ThisIsaacAPIClassType,
        ThisSerializedIsaacAPIClassType
      >
    | undefined;
  assertDefined(
    functions,
    `Failed to deserialize an Isaac API class since the associated functions were not found for class type: ${copyableIsaacAPIClassType}`,
  );

  return functions.deserialize(serializedIsaacAPIClass);
}

/**
 * In order to find out what type of serialized Isaac API class this is, we search through the
 * serialized table for brands.
 */
function getSerializedTableType(
  serializedIsaacAPIClass: SerializedIsaacAPIClass,
): CopyableIsaacAPIClassType | undefined {
  for (const [copyableIsaacAPIClassType, serializationBrand] of Object.entries(
    ISAAC_API_CLASS_TYPE_TO_BRAND,
  )) {
    if (serializedIsaacAPIClass.has(serializationBrand)) {
      return copyableIsaacAPIClassType as CopyableIsaacAPIClassType;
    }
  }

  return undefined;
}

/**
 * Helper function to generically check if a given object is a copyable Isaac API class. (This is
 * used by the save data manager when determining what is safe to copy.)
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export function isCopyableIsaacAPIClass(
  object: unknown,
): object is CopyableIsaacAPIClass {
  const allFunctions = Object.values(ISAAC_API_CLASS_TYPE_TO_FUNCTIONS);
  const isFunctions = allFunctions.map((functions) => functions.is);
  return isFunctions.some((identityFunction) => identityFunction(object));
}

/**
 * Helper function to generically check if a given Lua table is a serialized Isaac API class. (This
 * is used by the save data manager when reading data from the "save#.dat" file.)
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export function isSerializedIsaacAPIClass(
  object: unknown,
): object is SerializedIsaacAPIClass {
  const allFunctions = Object.values(ISAAC_API_CLASS_TYPE_TO_FUNCTIONS);
  const isSerializedFunctions = allFunctions.map(
    (functions) => functions.isSerialized,
  );
  return isSerializedFunctions.some((identityFunction) =>
    identityFunction(object),
  );
}

/**
 * Helper function to generically serialize an Isaac API class without knowing what specific type of
 * class it is. (This is used by the save data manager when writing data to the "save#.dat" file.)
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export function serializeIsaacAPIClass<T extends CopyableIsaacAPIClass>(
  isaacAPIClass: T,
): IsaacAPIClassTypeToSerializedType[T["__kind"]] {
  if (!isUserdata(isaacAPIClass)) {
    error(
      `Failed to serialize an Isaac API class since the provided object was of type: ${typeof isaacAPIClass}`,
    );
  }

  const isaacAPIClassType = getIsaacAPIClassName(isaacAPIClass);
  assertDefined(
    isaacAPIClassType,
    "Failed to serialize an Isaac API class since it does not have a class name.",
  );

  const copyableIsaacAPIClassType =
    isaacAPIClassType as CopyableIsaacAPIClassType;

  type ThisIsaacAPIClassType = T;
  type ThisSerializedIsaacAPIClassType =
    IsaacAPIClassTypeToSerializedType[T["__kind"]];

  const functions = ISAAC_API_CLASS_TYPE_TO_FUNCTIONS[
    copyableIsaacAPIClassType
  ] as unknown as
    | IsaacAPIClassTypeFunctions<
        ThisIsaacAPIClassType,
        ThisSerializedIsaacAPIClassType
      >
    | undefined;
  assertDefined(
    functions,
    `Failed to serialize an Isaac API class since the associated functions were not found for class type: ${copyableIsaacAPIClassType}`,
  );

  return functions.serialize(isaacAPIClass);
}

----
functions\set.ts
import { ReadonlySet } from "../types/ReadonlySet";
import { getArrayCombinations, getRandomArrayElement, sumArray } from "./array";
import { sortNormal } from "./sort";
import { isPrimitive } from "./types";

/**
 * Helper function to add all of the values in one set to another set. The first set passed will be
 * modified in place.
 *
 * This function is variadic, meaning that you can specify N sets to add to the first set.
 */
export function addSetsToSet<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  mainSet: Set<T>,
  ...setsToAdd: ReadonlyArray<ReadonlySet<T>>
): void {
  for (const set of setsToAdd) {
    for (const value of set) {
      mainSet.add(value);
    }
  }
}

/**
 * Helper function to create a new set that is the composition of two or more sets.
 *
 * This function is variadic, meaning that you can specify N sets.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function combineSets<T>(...sets: ReadonlyArray<ReadonlySet<T>>): Set<T> {
  const newSet = new Set<T>();
  for (const set of sets) {
    for (const value of set) {
      newSet.add(value);
    }
  }

  return newSet;
}

/** Helper function to copy a set. (You can also use a Set constructor to accomplish this task.) */
// eslint-disable-next-line isaacscript/no-mutable-return
export function copySet<T>(oldSet: ReadonlySet<T>): Set<T> {
  const newSet = new Set<T>();
  for (const value of oldSet) {
    newSet.add(value);
  }

  return newSet;
}

/**
 * Helper function to delete all of the values in one set from another set. The first set passed
 * will be modified in place.
 *
 * This function is variadic, meaning that you can specify N sets to remove from the first set.
 */
export function deleteSetsFromSet<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  mainSet: Set<T>,
  ...setsToRemove: ReadonlyArray<ReadonlySet<T>>
): void {
  for (const set of setsToRemove) {
    for (const value of set) {
      mainSet.delete(value);
    }
  }
}

/**
 * Helper function to get a random element from the provided set.
 *
 * If you want to get an unseeded element, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param set The set to get an element from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param exceptions Optional. An array of elements to skip over if selected.
 */
export function getRandomSetElement<T extends number | string>(
  set: ReadonlySet<T>,
  seedOrRNG: Seed | RNG | undefined,
  exceptions: readonly T[] = [],
): T {
  const array = getSortedSetValues(set);
  return getRandomArrayElement(array, seedOrRNG, exceptions);
}

/**
 * Helper function to get all possible combinations of the given set. This includes the combination
 * of an empty set.
 *
 * For example, if this function is provided a set containing 1, 2, and 3, then it will return an
 * array containing the following sets:
 *
 * - [] (if `includeEmptyArray` is set to true)
 * - [1]
 * - [2]
 * - [3]
 * - [1, 2]
 * - [1, 3]
 * - [2, 3]
 * - [1, 2, 3]
 *
 * @param set The set to get the combinations of.
 * @param includeEmptyArray Whether to include an empty array in the combinations.
 */
export function getSetCombinations<T extends number | string>(
  set: ReadonlySet<T>,
  includeEmptyArray: boolean,
): ReadonlyArray<ReadonlySet<T>> {
  const values = getSortedSetValues(set);
  const combinations = getArrayCombinations(values, includeEmptyArray);

  return combinations.map((array) => new ReadonlySet(array));
}

/**
 * Helper function to get a sorted array based on the contents of a set.
 *
 * Normally, set values are returned in insertion order, so use this function when the ordering of
 * the contents is important.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function getSortedSetValues<T extends number | string>(
  set: ReadonlySet<T>,
): T[] {
  const values = [...set];

  // Check for problematic types in order to throw a helpful error message.
  const firstElement = values[0];
  if (firstElement !== undefined) {
    const arrayType = type(firstElement);
    if (!isPrimitive(arrayType)) {
      error(
        `Failed to get the sorted set values because the provided set was of type "${arrayType}". Having sets with non-primitive types doesn't make much sense in general, so you might need to rethink what you are doing.`,
      );
    }
  }

  values.sort(sortNormal);

  return values;
}

/**
 * Helper function to convert the keys of an object to a read-only set.
 *
 * Note that the set values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectKeysToSet` function.
 */
export function objectKeysToReadonlySet<K extends string | number | symbol, V>(
  object: Record<K, V>,
): ReadonlySet<K> {
  return objectKeysToSet(object);
}

/**
 * Helper function to convert the keys of an object to a set.
 *
 * Note that the set values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectKeysToReadonlySet` function.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function objectKeysToSet<K extends string | number | symbol, V>(
  object: Record<K, V>,
): Set<K> {
  const set = new Set<K>();

  for (const key of Object.keys(object)) {
    set.add(key as K);
  }

  return set;
}

/**
 * Helper function to convert the values of an object to a read-only set.
 *
 * Note that the set values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectValuesToSet` function.
 */
export function objectValuesToReadonlySet<
  K extends string | number | symbol,
  V,
>(object: Record<K, V>): ReadonlySet<V> {
  return objectValuesToSet(object);
}

/**
 * Helper function to convert the values of an object to a set.
 *
 * Note that the set values will be inserted in a random order, due to how `pairs` works under the
 * hood.
 *
 * Also see the `objectValuesToReadonlySet` function.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function objectValuesToSet<K extends string | number | symbol, V>(
  object: Record<K, V>,
): Set<V> {
  const set = new Set<V>();

  for (const key of Object.values(object)) {
    set.add(key as V);
  }

  return set;
}

/**
 * Helper function to add one or more elements to a set at once without having to repeatedly call
 * the `Set.add` method.
 *
 * This function is variadic, meaning that you can pass as many things as you want to add.
 */
// eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
export function setAdd<T>(set: Set<T>, ...elements: readonly T[]): void {
  for (const element of elements) {
    set.add(element);
  }
}

/**
 * Helper function to check for one or more elements in a set at once without having to repeatedly
 * call the `Set.has` method.
 *
 * This function is variadic, meaning that you can pass as many things as you want to check for. It
 * will return true if one or more elements are found.
 */
export function setHas<T>(
  set: ReadonlySet<T>,
  ...elements: readonly T[]
): boolean {
  return elements.some((element) => set.has(element));
}

/** Helper function to sum every value in a set together. */
export function sumSet(set: ReadonlySet<number>): number {
  const values = [...set];
  return sumArray(values);
}

----
functions\slots.ts
import { SlotVariant } from "isaac-typescript-definitions";
import { DEFAULT_SLOT_NAME, SLOT_NAMES } from "../objects/slotNames";
import { ReadonlySet } from "../types/ReadonlySet";
import { isSlot } from "./entityTypes";

const SLOT_MACHINE_VARIANTS = new ReadonlySet<SlotVariant>([
  SlotVariant.SLOT_MACHINE, // 1
  SlotVariant.BLOOD_DONATION_MACHINE, // 2,
  SlotVariant.FORTUNE_TELLING_MACHINE, // 3
  SlotVariant.DONATION_MACHINE, // 8
  SlotVariant.SHOP_RESTOCK_MACHINE, // 10
  SlotVariant.GREED_DONATION_MACHINE, // 11
  SlotVariant.MOMS_DRESSING_TABLE, // 12
  SlotVariant.CRANE_GAME, // 16
  SlotVariant.CONFESSIONAL, // 17
]);

/**
 * Helper function to get the name of a slot, as listed in the "entities2.xml" file. Returns
 * "Unknown" if the provided slot variant is not valid.
 *
 * This function only works for vanilla slot variants.
 *
 * For example, `getSlotName(SlotVariant.BLOOD_DONATION_MACHINE)` would return "Blood Donation
 * Machine".
 */
export function getSlotName(slotVariant: SlotVariant): string {
  // Handle modded slots.
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  return SLOT_NAMES[slotVariant] ?? DEFAULT_SLOT_NAME;
}

/** Returns true for the specific variants of `EntityType.SLOT` that are machines. */
export function isSlotMachine(entity: Entity): boolean {
  if (!isSlot(entity)) {
    return false;
  }

  return SLOT_MACHINE_VARIANTS.has(entity.Variant);
}

----
functions\sort.ts
import { isNumber, isString, isTable } from "./types";

export function sortNormal(a: unknown, b: unknown): -1 | 0 | 1 {
  if (!isNumber(a) && !isString(a)) {
    error(
      `Failed to normal sort since the first value was not a number or string and was instead: ${type(
        a,
      )}`,
    );
  }

  if (!isNumber(b) && !isString(b)) {
    error(
      `Failed to normal sort since the second value was not a number or string and was instead: ${type(
        b,
      )}`,
    );
  }

  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}

/**
 * Helper function to sort an array of objects by one of the object keys.
 *
 * For example:
 *
 * ```ts
 * const myArray = [
 *   {
 *     name: "alice",
 *     age: 30,
 *   },
 *   {
 *     name: "bob",
 *     age: 20,
 *   },
 * ];
 * myArray.sort(sortObjectArrayByKey("age"));
 * ```
 */
export function sortObjectArrayByKey(key: string) {
  return (a: unknown, b: unknown): -1 | 0 | 1 => {
    if (!isTable(a)) {
      error(
        `Failed to sort an object array by the key of "${key}" since the first element was not a table and was instead: ${type(
          a,
        )}`,
      );
    }

    if (!isTable(b)) {
      error(
        `Failed to sort an object array by the key of "${key}" since the second element was not a table and was instead: ${type(
          b,
        )}.`,
      );
    }

    const aValue = a.get(key);
    const bValue = b.get(key);

    return sortNormal(aValue, bValue);
  };
}

/**
 * Helper function to sort a two-dimensional array by the first element.
 *
 * For example:
 *
 * ```ts
 * const myArray = [[1, 2], [2, 3], [3, 4]];
 * myArray.sort(sortTwoDimensionalArray);
 * ```
 *
 * This function also properly handles when the array elements are strings or numbers (instead of
 * another array).
 *
 * From:
 * https://stackoverflow.com/questions/16096872/how-to-sort-2-dimensional-array-by-column-value
 */
export function sortTwoDimensionalArray<T>(
  a: readonly T[],
  b: readonly T[],
): -1 | 0 | 1 {
  const aType = type(a);
  const bType = type(b);
  if (aType !== bType) {
    error(
      `Failed to two-dimensional sort since the two elements were disparate types: ${a} & ${b} (${aType} & ${bType})`,
    );
  }

  if (aType === "string" || aType === "number") {
    return sortNormal(a, b);
  }

  if (aType !== "table") {
    error(
      "Failed to two-dimensional sort since the first element was not a string, number, or table.",
    );
  }

  if (bType !== "table") {
    error(
      "Failed to two-dimensional sort since the second element was not a string, number, or table.",
    );
  }

  const firstElement1 = a[0];
  const firstElement2 = b[0];

  if (firstElement1 === undefined || firstElement1 === null) {
    error(
      "Failed to two-dimensional sort since the first element of the first array was undefined.",
    );
  }

  if (firstElement2 === undefined || firstElement2 === null) {
    error(
      "Failed to two-dimensional sort since the first element of the second array was undefined.",
    );
  }

  const elementType1 = type(firstElement1);
  const elementType2 = type(firstElement2);
  if (elementType1 !== elementType2) {
    error(
      `Failed to two-dimensional sort since the first element of each array were disparate types: ${firstElement1} & ${firstElement2} (${elementType1} & ${elementType2})`,
    );
  }

  return sortNormal(firstElement1, firstElement2);
}

/**
 * Helper function to sort an array in a stable way.
 *
 * This is useful because by default, the transpiled `Array.sort` method from TSTL is not stable.
 *
 * Under the hood, this uses the merge sort algorithm.
 */
// eslint-disable-next-line isaacscript/no-mutable-return
export function stableSort<T>(
  // eslint-disable-next-line isaacscript/prefer-readonly-parameter-types
  array: T[],
  sortFunc: (a: T, b: T) => -1 | 0 | 1 = sortNormal,
): T[] {
  // Base case: an array of zero or one elements is already sorted
  if (array.length <= 1) {
    return array;
  }

  // Split the array into two halves.
  const middleIndex = Math.floor(array.length / 2);
  const leftArray = array.slice(0, middleIndex);
  const rightArray = array.slice(middleIndex);

  // Recursively sort each half.
  const sortedLeftArray = stableSort(leftArray, sortFunc);
  const sortedRightArray = stableSort(rightArray, sortFunc);

  // Merge the two sorted halves.
  const mergedArray: T[] = [];
  let leftIndex = 0;
  let rightIndex = 0;
  while (
    leftIndex < sortedLeftArray.length &&
    rightIndex < sortedRightArray.length
  ) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const left = sortedLeftArray[leftIndex]!;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const right = sortedRightArray[rightIndex]!;

    const sortResult = sortFunc(left, right);
    if (sortResult === -1 || sortResult === 0) {
      mergedArray.push(left);
      leftIndex++;
    } else {
      mergedArray.push(right);
      rightIndex++;
    }
  }

  // Add any remaining elements from the left array.
  while (leftIndex < sortedLeftArray.length) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const left = sortedLeftArray[leftIndex]!;
    mergedArray.push(left);
    leftIndex++;
  }

  // Add any remaining elements from the right array.
  while (rightIndex < sortedRightArray.length) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const right = sortedRightArray[rightIndex]!;
    mergedArray.push(right);
    rightIndex++;
  }

  return mergedArray;
}

----
functions\sound.ts
import type {
  LevelStage,
  Music,
  SoundEffect,
  StageType,
} from "isaac-typescript-definitions";
import { SOUND_EFFECT_VALUES } from "../cachedEnumValues";
import { game, sfxManager } from "../core/cachedClasses";
import { STAGE_TO_MUSIC } from "../objects/stageToMusic";
import type { TranspiledEnum } from "./enums";
import { getEnumValues } from "./enums";

/**
 * Helper function to get the corresponding music value for a stage and stage type combination.
 *
 * @param stage Optional. The stage to get the music for. If not specified, the current stage will
 *              be used.
 * @param stageType Optional. The stage type to get the music for. If not specified, the current
 *                  stage type will be used.
 */
export function getMusicForStage(
  stage?: LevelStage,
  stageType?: StageType,
): Music {
  const level = game.GetLevel();

  if (stage === undefined) {
    stage = level.GetStage();
  }

  if (stageType === undefined) {
    stageType = level.GetStageType();
  }

  const stageTypeToMusic = STAGE_TO_MUSIC[stage];
  return stageTypeToMusic[stageType];
}

/**
 * Helper function to manually stop every vanilla sound effect. If you also want to stop custom
 * sound effects in addition to vanilla ones, then pass the `SoundEffectCustom` enum for your mod.
 *
 * @param soundEffectCustom Optional. The enum that represents all of the custom sound effects for
 *                          your mod.
 */
export function stopAllSoundEffects(soundEffectCustom?: TranspiledEnum): void {
  for (const soundEffect of SOUND_EFFECT_VALUES) {
    sfxManager.Stop(soundEffect);
  }

  if (soundEffectCustom !== undefined) {
    for (const soundEffect of getEnumValues(soundEffectCustom)) {
      sfxManager.Stop(soundEffect as SoundEffect);
    }
  }
}

----
functions\spawnCollectible.ts
import type { ItemPoolType } from "isaac-typescript-definitions";
import {
  CollectibleType,
  PickupVariant,
  PlayerType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { VectorZero } from "../core/constants";
import { isQuestCollectible } from "./collectibleTag";
import {
  preventCollectibleRotation,
  setCollectibleEmpty,
} from "./collectibles";
import { spawnPickupWithSeed } from "./entitiesSpecific";
import { anyPlayerIs } from "./players";
import { getRandomSeed, isRNG } from "./rng";

/**
 * Helper function to spawn a collectible.
 *
 * Use this instead of the `Game.Spawn` method because it handles the cases of Tainted Keeper
 * collectibles costing coins and prevents quest items from being rotated by Tainted Isaac's
 * rotation mechanic.
 *
 * If you want to spawn an unseeded collectible, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param collectibleType The collectible type to spawn.
 * @param positionOrGridIndex The position or grid index to spawn the collectible at.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param options Optional. Set to true to make the collectible a "There's Options" style
 *                collectible. Default is false.
 * @param forceFreeItem Optional. Set to true to disable the logic that gives the item a price for
 *                      Tainted Keeper. Default is false.
 * @param spawner Optional.
 */
export function spawnCollectible(
  collectibleType: CollectibleType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG | undefined,
  options = false,
  forceFreeItem = false,
  spawner?: Entity,
): EntityPickupCollectible {
  if (seedOrRNG === undefined) {
    seedOrRNG = getRandomSeed();
  }

  const seed = isRNG(seedOrRNG) ? seedOrRNG.Next() : seedOrRNG;
  const collectible = spawnPickupWithSeed(
    PickupVariant.COLLECTIBLE,
    collectibleType,
    positionOrGridIndex,
    seed,
    VectorZero,
    spawner,
  ) as EntityPickupCollectible;

  if (isQuestCollectible(collectible)) {
    preventCollectibleRotation(collectible);
  }

  if (options) {
    collectible.OptionsPickupIndex = 1;
  }

  if (
    anyPlayerIs(PlayerType.KEEPER_B) &&
    !isQuestCollectible(collectibleType) &&
    !forceFreeItem
  ) {
    // When playing Tainted Keeper, collectibles are supposed to have a price, and manually spawned
    // items will not have a price, so we have to set it manually.

    // Setting the shop item ID in this way prevents the bug where the item will sometimes change to
    // 99 cents.
    collectible.ShopItemId = -1;

    // We can set the price to any arbitrary value; it will auto-update to the true price on the
    // next frame.
    collectible.Price = 15;
  }

  return collectible;
}

/**
 * Helper function to spawn a collectible from a specific item pool.
 *
 * Use this instead of the `Game.Spawn` method because it handles the cases of Tainted Keeper
 * collectibles costing coins and prevents quest items from being rotated by Tainted Isaac's
 * rotation mechanic.
 *
 * If you want to spawn an unseeded collectible, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * In order to use this function, you must upgrade your mod with `ISCFeature.SPAWN_COLLECTIBLE`.
 *
 * @param itemPoolType The item pool to draw the collectible type from.
 * @param positionOrGridIndex The position or grid index to spawn the collectible at.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 * @param options Optional. Set to true to make the collectible a "There's Options" style
 *                collectible. Default is false.
 * @param forceFreeItem Optional. Set to true to disable the logic that gives the item a price for
 *                      Tainted Keeper. Default is false.
 * @param spawner Optional.
 */
export function spawnCollectibleFromPool(
  itemPoolType: ItemPoolType,
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG | undefined,
  options = false,
  forceFreeItem = false,
  spawner?: Entity,
): EntityPickupCollectible {
  const itemPool = game.GetItemPool();
  const collectibleType = itemPool.GetCollectible(itemPoolType);

  return spawnCollectible(
    collectibleType,
    positionOrGridIndex,
    seedOrRNG,
    options,
    forceFreeItem,
    spawner,
  );
}

/**
 * Helper function to spawn an empty collectible. Doing this is tricky since spawning a collectible
 * with `CollectibleType.NULL` will result in spawning a collectible with a random type from the
 * current room's item pool.
 *
 * Instead, this function arbitrarily spawns a collectible with `CollectibleType.BROKEN_SHOVEL_1`,
 * and then converts it to an empty pedestal afterward. (Broken Shovel is used instead of e.g. Sad
 * Onion because it is a quest collectible and quest collectibles will prevent Damocles from
 * duplicating the pedestal.)
 *
 * If you want to spawn an unseeded collectible, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param positionOrGridIndex The position or grid index to spawn the empty collectible at.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function spawnEmptyCollectible(
  positionOrGridIndex: Vector | int,
  seedOrRNG: Seed | RNG | undefined,
): EntityPickup {
  const collectible = spawnCollectible(
    CollectibleType.BROKEN_SHOVEL_1,
    positionOrGridIndex,
    seedOrRNG,
    false,
    true,
  );
  setCollectibleEmpty(collectible);

  return collectible;
}

----
functions\sprites.ts
import { EMPTY_PNG_PATH, VectorZero } from "../core/constants";
import { copyColor } from "./color";
import { kColorEquals } from "./kColor";
import { eRange } from "./utils";

/**
 * Helper function to clear all layers or specific layers from a sprite without unloading the
 * attached anm2 file.
 *
 * This function is variadic, which means you can pass as many layer IDs as you want to clear. If no
 * specific layers are passed, the function will clear every layer.
 *
 * If you want to clear all of the layers of a sprite and don't care about unloading the attached
 * anm2 file, then use the `Sprite.Reset` method instead.
 *
 * Since there is no official API method to clear specific layers from a sprite, we work around it
 * by setting the spritesheet to a transparent PNG file corresponding to the `EMPTY_PNG_PATH`
 * constant.
 *
 * This function will still work identically if PNG file does not exist, but it will cause a
 * spurious error to appear in the "log.txt" file. If silencing these errors is desired, you can
 * create a transparent 1 pixel PNG file in your mod's resources folder at `EMPTY_PNG_PATH`.
 *
 * @allowEmptyVariadic
 */
export function clearSprite(sprite: Sprite, ...layerIDs: readonly int[]): void {
  if (layerIDs.length === 0) {
    const numLayers = sprite.GetLayerCount();
    layerIDs = eRange(numLayers);
  }

  for (const layerID of layerIDs) {
    sprite.ReplaceSpritesheet(layerID, EMPTY_PNG_PATH);
  }

  sprite.LoadGraphics();
}

/**
 * Helper function that returns the number of the final frame in a particular animation for a
 * sprite. By default, it will use the currently playing animation, but you can also specify a
 * specific animation to check.
 *
 * Note that this function is bugged with the Stop Watch or the Broken Watch, since using the
 * `Sprite.SetFrame` method will reset the internal accumulator used to slow down the playback speed
 * of the animation. (The `PlaybackSpeed` field of the sprite is not used.) Thus, it is only safe to
 * use this function on animations that are not slowed down by Stop Watch or Broken Watch, such as
 * player animations.
 */
export function getLastFrameOfAnimation(
  sprite: Sprite,
  animation?: string,
): int {
  // Record the current sprite status.
  const currentAnimation = sprite.GetAnimation();
  const currentFrame = sprite.GetFrame();

  // Get the final frame.
  if (animation !== undefined && animation !== currentAnimation) {
    sprite.SetAnimation(animation);
  }
  sprite.SetLastFrame();
  const finalFrame = sprite.GetFrame();

  // Set the sprite back to the way it was.
  if (animation !== undefined && animation !== currentAnimation) {
    sprite.Play(currentAnimation, true);
  }
  sprite.SetFrame(currentFrame);

  return finalFrame;
}

/**
 * Helper function to load a new sprite and play its default animation.
 *
 * @param anm2Path The path to the "anm2" file that should be loaded.
 * @param pngPath Optional. The path to a custom PNG file that should be loaded on layer 0 of the
 *                sprite.
 */
export function newSprite(anm2Path: string, pngPath?: string): Sprite {
  const sprite = Sprite();

  if (pngPath === undefined) {
    sprite.Load(anm2Path, true);
  } else {
    sprite.Load(anm2Path, false);
    sprite.ReplaceSpritesheet(0, pngPath);
    sprite.LoadGraphics();
  }

  const defaultAnimation = sprite.GetDefaultAnimation();
  sprite.Play(defaultAnimation, true);

  return sprite;
}

/**
 * Helper function to keep a sprite's color the same values as it already is but set the opacity to
 * a specific value.
 *
 * @param sprite The sprite to set.
 * @param alpha A value between 0 and 1 that represents the fade amount.
 */
export function setSpriteOpacity(sprite: Sprite, alpha: float): void {
  const fadedColor = copyColor(sprite.Color);
  fadedColor.A = alpha;
  sprite.Color = fadedColor;
}

/**
 * Helper function to check if two sprite layers have the same sprite sheet by using the
 * `Sprite.GetTexel` method.
 *
 * Since checking every single texel in the entire sprite is very expensive, this function requires
 * that you provide a range of specific texels to check.
 */
export function spriteEquals(
  sprite1: Sprite,
  sprite2: Sprite,
  layerID: int,
  xStart: int,
  xFinish: int,
  xIncrement: int,
  yStart: int,
  yFinish: int,
  yIncrement: int,
): boolean {
  // Iterate over N texels, checking for equality at each step. The center of the sprite is equal to
  // the "pivot" point in the anm2 file.
  for (let x = xStart; x <= xFinish; x += xIncrement) {
    for (let y = yStart; y <= yFinish; y += yIncrement) {
      const position = Vector(x, y);
      if (!texelEquals(sprite1, sprite2, position, layerID)) {
        return false;
      }
    }
  }

  return true;
}

/** Helper function to check if two texels on a sprite are equivalent to each other. */
export function texelEquals(
  sprite1: Sprite,
  sprite2: Sprite,
  position: Vector,
  layerID: int,
): boolean {
  const kColor1 = sprite1.GetTexel(position, VectorZero, 1, layerID);
  const kColor2 = sprite2.GetTexel(position, VectorZero, 1, layerID);
  return kColorEquals(kColor1, kColor2);
}

----
functions\stage.ts
import {
  GameStateFlag,
  LevelStage,
  RoomType,
  StageID,
  StageType,
} from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { ROOM_TYPE_SPECIAL_GOTO_PREFIXES } from "../objects/roomTypeSpecialGotoPrefixes";
import { STAGE_ID_NAMES } from "../objects/stageIDNames";
import {
  STAGE_TO_STAGE_ID,
  STAGE_TO_STAGE_ID_GREED_MODE,
} from "../objects/stageToStageID";
import { STAGE_TYPE_SUFFIXES } from "../objects/stageTypeSuffixes";
import { log } from "./log";
import { asLevelStage } from "./types";
import { inRange } from "./utils";

/**
 * Helper function that calculates what the stage type should be for the provided stage. This
 * emulates what the game's internal code does.
 */
export function calculateStageType(stage: LevelStage): StageType {
  // The following is the game's internal code to determine the floor type. (This came directly from
  // Spider.)

  /*
    u32 Seed = g_Game->GetSeeds().GetStageSeed(NextStage);
    if (!g_Game->IsGreedMode()) {
      StageType = ((Seed % 2) == 0 && (
        ((NextStage == STAGE1_1 || NextStage == STAGE1_2) && gd.Unlocked(ACHIEVEMENT_CELLAR)) ||
        ((NextStage == STAGE2_1 || NextStage == STAGE2_2) && gd.Unlocked(ACHIEVEMENT_CATACOMBS)) ||
        ((NextStage == STAGE3_1 || NextStage == STAGE3_2) && gd.Unlocked(ACHIEVEMENT_NECROPOLIS)) ||
        ((NextStage == STAGE4_1 || NextStage == STAGE4_2)))
      ) ? STAGE_TYPE_WOTL : STAGE_TYPE_ORIGINAL;
    if (Seed % 3 == 0 && NextStage < STAGE5)
      StageType = STAGE_TYPE_AFTERBIRTH;
  */

  const seeds = game.GetSeeds();
  const stageSeed = seeds.GetStageSeed(stage);

  if (stageSeed % 2 === 0) {
    return StageType.WRATH_OF_THE_LAMB;
  }

  if (stageSeed % 3 === 0) {
    return StageType.AFTERBIRTH;
  }

  return StageType.ORIGINAL;
}

/**
 * Helper function that calculates what the Repentance stage type should be for the provided stage.
 * This emulates what the game's internal code does.
 */
export function calculateStageTypeRepentance(stage: LevelStage): StageType {
  // There is no alternate floor for Corpse.
  if (stage === LevelStage.WOMB_1 || stage === LevelStage.WOMB_2) {
    return StageType.REPENTANCE;
  }

  // This algorithm is from Kilburn. We add one because the alt path is offset by 1 relative to the
  // normal path.
  const seeds = game.GetSeeds();
  const adjustedStage = asLevelStage(stage + 1);
  const stageSeed = seeds.GetStageSeed(adjustedStage);

  // Kilburn does not know why he divided the stage seed by 2 first.
  const halfStageSeed = Math.floor(stageSeed / 2);
  if (halfStageSeed % 2 === 0) {
    return StageType.REPENTANCE_B;
  }

  return StageType.REPENTANCE;
}

/**
 * Helper function to account for Repentance floors being offset by 1. For example, Downpour 2 is
 * the third level of the run, but the game considers it to have a stage of 2. This function will
 * consider Downpour 2 to have a stage of 3.
 */
export function getEffectiveStage(): LevelStage {
  const level = game.GetLevel();
  const stage = level.GetStage();

  if (onRepentanceStage()) {
    return stage + 1;
  }

  return stage;
}

/**
 * Helper function to get the corresponding "goto" console command that would correspond to the
 * provided room type and room variant.
 *
 * @param roomType The `RoomType` of the destination room.
 * @param roomVariant The variant of the destination room.
 * @param useSpecialRoomsForRoomTypeDefault Optional. Whether to use `s.default` as the prefix for
 *                                 the `goto` command (instead of `d`) if the room type is
 *                                 `RoomType.DEFAULT` (1). False by default.
 */
export function getGotoCommand(
  roomType: RoomType,
  roomVariant: int,
  useSpecialRoomsForRoomTypeDefault = false,
): string {
  const isNormalRoom =
    roomType === RoomType.DEFAULT && !useSpecialRoomsForRoomTypeDefault;
  const roomTypeSpecialGotoPrefix = ROOM_TYPE_SPECIAL_GOTO_PREFIXES[roomType];
  const prefix = isNormalRoom ? "d" : `s.${roomTypeSpecialGotoPrefix}`;

  return `goto ${prefix}.${roomVariant}`;
}

/**
 * Helper function to get the English name of the level. For example, "Caves 1".
 *
 * This is useful because the `Level.GetName` method returns a localized version of the level name,
 * which will not display correctly on some fonts.
 *
 * Note that this returns "Blue Womb" instead of "???" for stage 9.
 *
 * @param stage Optional. If not specified, the current stage will be used.
 * @param stageType Optional. If not specified, the current stage type will be used.
 */
export function getLevelName(
  stage?: LevelStage,
  stageType?: StageType,
): string {
  const level = game.GetLevel();

  if (stage === undefined) {
    stage = level.GetStage();
  }

  if (stageType === undefined) {
    stageType = level.GetStageType();
  }

  const stageID = getStageID(stage, stageType);
  const stageIDName = getStageIDName(stageID);

  let suffix: string;
  switch (stage) {
    case LevelStage.BASEMENT_1:
    case LevelStage.CAVES_1:
    case LevelStage.DEPTHS_1:
    case LevelStage.WOMB_1: {
      suffix = " 1";
      break;
    }

    case LevelStage.BASEMENT_2:
    case LevelStage.CAVES_2:
    case LevelStage.DEPTHS_2:
    case LevelStage.WOMB_2: {
      suffix = " 2";
      break;
    }

    default: {
      suffix = "";
      break;
    }
  }

  return stageIDName + suffix;
}

/** Alias for the `Level.GetStage` method. */
export function getStage(): LevelStage {
  const level = game.GetLevel();

  return level.GetStage();
}

/**
 * Helper function to get the stage ID that corresponds to a particular stage and stage type.
 *
 * This is useful because `getRoomStageID` will not correctly return the `StageID` if the player is
 * in a special room.
 *
 * This correctly handles the case of Greed Mode. In Greed Mode, if an undefined stage and stage
 * type combination are passed, `StageID.SPECIAL_ROOMS` (0) will be returned.
 *
 * @param stage Optional. If not specified, the stage corresponding to the current floor will be
 *              used.
 * @param stageType Optional. If not specified, the stage type corresponding to the current floor
 *                  will be used.
 */
export function getStageID(stage?: LevelStage, stageType?: StageType): StageID {
  const level = game.GetLevel();

  if (stage === undefined) {
    stage = level.GetStage();
  }

  if (stageType === undefined) {
    stageType = level.GetStageType();
  }

  if (game.IsGreedMode()) {
    const stageTypeToStageID = STAGE_TO_STAGE_ID_GREED_MODE.get(stage);
    if (stageTypeToStageID === undefined) {
      return StageID.SPECIAL_ROOMS;
    }

    return stageTypeToStageID[stageType];
  }

  const stageTypeToStageID = STAGE_TO_STAGE_ID[stage];
  return stageTypeToStageID[stageType];
}

/**
 * Helper function to get the English name corresponding to a stage ID. For example, "Caves".
 *
 * This is derived from the data in the "stages.xml" file.
 *
 * Note that unlike "stages.xml", Blue Womb is specified with a name of "Blue Womb" instead of
 * "???".
 */
export function getStageIDName(stageID: StageID): string {
  return STAGE_ID_NAMES[stageID];
}

/** Alias for the `Level.GetStageType` method. */
export function getStageType(): StageType {
  const level = game.GetLevel();

  return level.GetStageType();
}

/**
 * Helper function to convert a numerical `StageType` into the letter suffix supplied to the "stage"
 * console command. For example, `StageType.REPENTANCE` is the stage type for Downpour, and the
 * console command to go to Downpour is "stage 1c", so this function converts `StageType.REPENTANCE`
 * to "c".
 */
export function getStageTypeSuffix(stageType: StageType): string {
  return STAGE_TYPE_SUFFIXES[stageType];
}

/**
 * Returns whether the provided stage and stage type represent a "final floor". This is defined as a
 * floor that prevents the player from entering the I AM ERROR room on.
 *
 * For example, when using Undefined on The Chest, it has a 50% chance of teleporting the player to
 * the Secret Room and a 50% chance of teleporting the player to the Super Secret Room, because the
 * I AM ERROR room is never entered into the list of possibilities.
 */
export function isFinalFloor(stage: LevelStage, stageType: StageType): boolean {
  return (
    stage === LevelStage.DARK_ROOM_CHEST ||
    stage === LevelStage.VOID ||
    stage === LevelStage.HOME ||
    (stage === LevelStage.WOMB_2 && isRepentanceStage(stageType)) // Corpse 2
  );
}

/**
 * Helper function to check if the provided stage type is equal to `StageType.REPENTANCE` or
 * `StageType.REPENTANCE_B`.
 */
export function isRepentanceStage(stageType: StageType): boolean {
  return (
    stageType === StageType.REPENTANCE || stageType === StageType.REPENTANCE_B
  );
}

/**
 * Helper function to check if the provided effective stage is one that has the possibility to grant
 * a natural Devil Room or Angel Room after killing the boss.
 *
 * Note that in order for this function to work properly, you must provide it with the effective
 * stage (e.g. from the `getEffectiveStage` helper function) and not the absolute stage (e.g. from
 * the `Level.GetStage` method).
 */
export function isStageWithNaturalDevilRoom(
  effectiveStage: LevelStage,
): boolean {
  return (
    inRange(effectiveStage, LevelStage.BASEMENT_2, LevelStage.WOMB_2) &&
    effectiveStage !== LevelStage.BLUE_WOMB
  );
}

/**
 * Helper function to check if the provided stage is one that will have a random collectible drop
 * upon defeating the boss of the floor.
 *
 * This happens on most stages but will not happen on Depths 2, Womb 2, Sheol, Cathedral, Dark Room,
 * The Chest, and Home (due to the presence of a story boss).
 *
 * Note that even though Delirium does not drop a random boss collectible, The Void is still
 * considered to be a stage that has a random boss collectible since all of the non-Delirium Boss
 * Rooms will drop random boss collectibles.
 */
export function isStageWithRandomBossCollectible(stage: LevelStage): boolean {
  return !isStageWithStoryBoss(stage) || stage === LevelStage.VOID;
}

/**
 * Helper function to check if the provided stage will spawn a locked door to Downpour/Dross after
 * defeating the boss.
 */
export function isStageWithSecretExitToDownpour(stage: LevelStage): boolean {
  return stage === LevelStage.BASEMENT_1 || stage === LevelStage.BASEMENT_2;
}

/**
 * Helper function to check if the provided stage and stage type will spawn a spiked door to
 * Mausoleum/Gehenna after defeating the boss.
 */
export function isStageWithSecretExitToMausoleum(
  stage: LevelStage,
  stageType: StageType,
): boolean {
  const repentanceStage = isRepentanceStage(stageType);

  return (
    (stage === LevelStage.DEPTHS_1 && !repentanceStage) ||
    (stage === LevelStage.CAVES_2 && repentanceStage)
  );
}

/**
 * Helper function to check if the provided stage and stage type will spawn a wooden door to
 * Mines/Ashpit after defeating the boss.
 */
export function isStageWithSecretExitToMines(
  stage: LevelStage,
  stageType: StageType,
): boolean {
  const repentanceStage = isRepentanceStage(stageType);

  return (
    (stage === LevelStage.CAVES_1 && !repentanceStage) ||
    (stage === LevelStage.BASEMENT_2 && repentanceStage)
  );
}

/**
 * Helper function to check if the current stage is one that would create a trapdoor if We Need to
 * Go Deeper was used.
 */
export function isStageWithShovelTrapdoors(
  stage: LevelStage,
  stageType: StageType,
): boolean {
  const repentanceStage = isRepentanceStage(stageType);

  return (
    stage < LevelStage.WOMB_2 ||
    (stage === LevelStage.WOMB_2 && !repentanceStage)
  );
}

/**
 * Helper function to check if the provided stage is one with a story boss. Specifically, this is
 * Depths 2 (Mom), Womb 2 (Mom's Heart / It Lives), Blue Womb (Hush), Sheol (Satan), Cathedral
 * (Isaac), Dark Room (Lamb), The Chest (Blue Baby), The Void (Delirium), and Home (Dogma / The
 * Beast).
 */
export function isStageWithStoryBoss(stage: LevelStage): boolean {
  return stage === LevelStage.DEPTHS_2 || stage >= LevelStage.WOMB_2;
}

/**
 * Helper function to check if the player has taken Dad's Note. This sets the game state flag of
 * `GameStateFlag.BACKWARDS_PATH` and causes floor generation to change.
 */
export function onAscent(): boolean {
  return game.GetStateFlag(GameStateFlag.BACKWARDS_PATH);
}

export function onCathedral(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return (
    stage === LevelStage.SHEOL_CATHEDRAL &&
    stageType === StageType.WRATH_OF_THE_LAMB
  );
}

export function onChest(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return (
    stage === LevelStage.DARK_ROOM_CHEST &&
    stageType === StageType.WRATH_OF_THE_LAMB
  );
}

export function onDarkRoom(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return (
    stage === LevelStage.DARK_ROOM_CHEST && stageType === StageType.ORIGINAL
  );
}

/**
 * Helper function to check if the current stage matches one of the given stages. This uses the
 * `getEffectiveStage` helper function so that the Repentance floors are correctly adjusted.
 *
 * This function is variadic, which means you can pass as many stages as you want to match for.
 */
export function onEffectiveStage(
  ...effectiveStages: readonly LevelStage[]
): boolean {
  const thisEffectiveStage = getEffectiveStage();
  return effectiveStages.includes(thisEffectiveStage);
}

/**
 * Returns whether the player is on the "final floor" of the particular run. The final floor is
 * defined as one that prevents the player from entering the I AM ERROR room on.
 *
 * For example, when using Undefined on The Chest, it has a 50% chance of teleporting the player to
 * the Secret Room and a 50% chance of teleporting the player to the Super Secret Room, because the
 * I AM ERROR room is never entered into the list of possibilities.
 */
export function onFinalFloor(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return isFinalFloor(stage, stageType);
}

/**
 * Returns whether the player is on the first floor of the particular run.
 *
 * This is tricky to determine because we have to handle the cases of Downpour/Dross 1 not being the
 * first floor and The Ascent.
 */
export function onFirstFloor(): boolean {
  const effectiveStage = getEffectiveStage();
  const isOnAscent = onAscent();

  return effectiveStage === LevelStage.BASEMENT_1 && !isOnAscent;
}

/**
 * Helper function to check if the current stage type is equal to `StageType.REPENTANCE` or
 * `StageType.REPENTANCE_B`.
 */
export function onRepentanceStage(): boolean {
  const level = game.GetLevel();
  const stageType = level.GetStageType();

  return isRepentanceStage(stageType);
}

export function onSheol(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return (
    stage === LevelStage.SHEOL_CATHEDRAL && stageType === StageType.ORIGINAL
  );
}

/**
 * Helper function to check if the current stage matches one of the given stages.
 *
 * This function is variadic, which means you can pass as many stages as you want to match for.
 */
export function onStage(...stages: readonly LevelStage[]): boolean {
  const level = game.GetLevel();
  const thisStage = level.GetStage();
  return stages.includes(thisStage);
}

/** Helper function to check if the current stage is equal to or higher than the given stage. */
export function onStageOrHigher(stage: LevelStage): boolean {
  const level = game.GetLevel();
  const thisStage = level.GetStage();
  return thisStage >= stage;
}

/** Helper function to check if the current stage is equal to or higher than the given stage. */
export function onStageOrLower(stage: LevelStage): boolean {
  const level = game.GetLevel();
  const thisStage = level.GetStage();
  return thisStage <= stage;
}

/**
 * Helper function to check if the current stage matches one of the given stage types.
 *
 * This function is variadic, which means you can pass as many room types as you want to match for.
 */
export function onStageType(...stageTypes: readonly StageType[]): boolean {
  const level = game.GetLevel();
  const thisStageType = level.GetStageType();
  return stageTypes.includes(thisStageType);
}

/**
 * Helper function to check if the current stage is one that has the possibility to grant a natural
 * Devil Room or Angel Room after killing the boss.
 */
export function onStageWithNaturalDevilRoom(): boolean {
  const effectiveStage = getEffectiveStage();
  return isStageWithNaturalDevilRoom(effectiveStage);
}

/**
 * Helper function to check if the current stage is one that will have a random collectible drop
 * upon defeating the boss of the floor.
 *
 * This happens on most stages but will not happen on Depths 2, Womb 2, Sheol, Cathedral, Dark Room,
 * The Chest, and Home (due to the presence of a story boss).
 *
 * Note that even though Delirium does not drop a random boss collectible, The Void is still
 * considered to be a stage that has a random boss collectible since all of the non-Delirium Boss
 * Rooms will drop random boss collectibles.
 */
export function onStageWithRandomBossCollectible(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();

  return isStageWithRandomBossCollectible(stage);
}

/**
 * Helper function to check if the current stage will spawn a locked door to Downpour/Dross after
 * defeating the boss.
 */
export function onStageWithSecretExitToDownpour(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();

  return isStageWithSecretExitToDownpour(stage);
}

/**
 * Helper function to check if the current stage will spawn a spiked door to Mausoleum/Gehenna after
 * defeating the boss.
 */
export function onStageWithSecretExitToMausoleum(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return isStageWithSecretExitToMausoleum(stage, stageType);
}

/**
 * Helper function to check if the current stage will spawn a wooden door to Mines/Ashpit after
 * defeating the boss.
 */
export function onStageWithSecretExitToMines(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return isStageWithSecretExitToMines(stage, stageType);
}

/**
 * Helper function to check if the current stage is one that would create a trapdoor if We Need to
 * Go Deeper was used.
 */
export function onStageWithShovelTrapdoors(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();
  const stageType = level.GetStageType();

  return isStageWithShovelTrapdoors(stage, stageType);
}

/**
 * Helper function to check if the current stage is one with a story boss. Specifically, this is
 * Depths 2 (Mom), Womb 2 (Mom's Heart / It Lives), Blue Womb (Hush), Sheol (Satan), Cathedral
 * (Isaac), Dark Room (Lamb), The Chest (Blue Baby), The Void (Delirium), and Home (Dogma / The
 * Beast).
 */
export function onStageWithStoryBoss(): boolean {
  const level = game.GetLevel();
  const stage = level.GetStage();

  return isStageWithStoryBoss(stage);
}

/**
 * Helper function to directly warp to a specific stage using the "stage" console command.
 *
 * This is different from the vanilla `Level.SetStage` method, which will change the stage and/or
 * stage type of the current floor without moving the player to a new floor.
 *
 * Note that if you use this function on game frame 0, it will confuse the
 * `POST_GAME_STARTED_REORDERED`, `POST_NEW_LEVEL_REORDERED`, and `POST_NEW_ROOM_REORDERED` custom
 * callbacks. If you are using the function in this situation, remember to call the
 * `reorderedCallbacksSetStage` function.
 *
 * @param stage The stage number to warp to.
 * @param stageType The stage type to warp to.
 * @param reseed Optional. Whether to reseed the floor upon arrival. Default is false. Set this to
 *               true if you are warping to the same stage but a different stage type (or else the
 *               floor layout will be identical to the old floor).
 */
export function setStage(
  stage: LevelStage,
  stageType: StageType,
  reseed = false,
): void {
  // Build the command that will take us to the next floor.
  const stageTypeSuffix = getStageTypeSuffix(stageType);
  const command = `stage ${stage}${stageTypeSuffix}`;
  log(`Warping to a stage with a console command of: ${command}`);
  Isaac.ExecuteCommand(command);

  if (reseed) {
    // Doing a "reseed" immediately after a "stage" command won't mess anything up.
    log("Reseeding the floor with a console command of: reseed");
    Isaac.ExecuteCommand("reseed");
  }
}

----
functions\stats.ts
import { CacheFlag } from "isaac-typescript-definitions";
import { PlayerStat } from "../enums/PlayerStat";
import type { PlayerStats } from "../interfaces/PlayerStats";
import { DEFAULT_PLAYER_STAT_MAP } from "../maps/defaultPlayerStatMap";
import { ReadonlySet } from "../types/ReadonlySet";
import { addTearsStat } from "./tears";

const STAT_CACHE_FLAGS_SET = new ReadonlySet<CacheFlag>([
  CacheFlag.DAMAGE, // 1 << 0
  CacheFlag.FIRE_DELAY, // 1 << 1
  CacheFlag.SHOT_SPEED, // 1 << 2
  CacheFlag.RANGE, // 1 << 3
  CacheFlag.SPEED, // 1 << 4
  CacheFlag.LUCK, // 1 << 10
]);

/**
 * Helper function to add a stat to a player based on the `CacheFlag` provided. Call this function
 * from the `EVALUATE_CACHE` callback.
 *
 * Note that for `CacheFlag.FIRE_DELAY`, the "amount" argument will be interpreted as the tear stat
 * to add (and not the amount to mutate `EntityPlayer.MaxFireDelay` by).
 *
 * This function supports the following cache flags:
 * - CacheFlag.DAMAGE (1 << 0)
 * - CacheFlag.FIRE_DELAY (1 << 1)
 * - CacheFlag.SHOT_SPEED (1 << 2)
 * - CacheFlag.RANGE (1 << 3)
 * - CacheFlag.SPEED (1 << 4)
 * - CacheFlag.LUCK (1 << 10)
 */
export function addPlayerStat(
  player: EntityPlayer,
  cacheFlag: CacheFlag,
  amount: number,
): void {
  if (!STAT_CACHE_FLAGS_SET.has(cacheFlag)) {
    error(
      `You cannot add a stat to a player with the cache flag of: ${cacheFlag}`,
    );
  }

  switch (cacheFlag) {
    // 1 << 0
    case CacheFlag.DAMAGE: {
      player.Damage += amount;
      break;
    }

    // 1 << 1
    case CacheFlag.FIRE_DELAY: {
      addTearsStat(player, amount);
      break;
    }

    // 1 << 2
    case CacheFlag.SHOT_SPEED: {
      player.ShotSpeed += amount;
      break;
    }

    // 1 << 3
    case CacheFlag.RANGE: {
      player.TearHeight += amount;
      break;
    }

    // 1 << 4
    case CacheFlag.SPEED: {
      player.MoveSpeed += amount;
      break;
    }

    // 1 << 10
    case CacheFlag.LUCK: {
      player.Luck += amount;
      break;
    }

    default: {
      break;
    }
  }
}

/**
 * Returns the starting stat that Isaac (the default character) starts with. For example, if you
 * pass this function `CacheFlag.DAMAGE`, it will return 3.5.
 *
 * Note that the default fire delay is represented in the tear stat, not the `MaxFireDelay` value.
 */
export function getDefaultPlayerStat(cacheFlag: CacheFlag): number | undefined {
  return DEFAULT_PLAYER_STAT_MAP.get(cacheFlag);
}

/** Helper function to get the stat for a player corresponding to the `StatType`. */
export function getPlayerStat<T extends PlayerStat>(
  player: EntityPlayer,
  playerStat: T,
): PlayerStats[T] {
  const playerStats = getPlayerStats(player);
  return playerStats[playerStat];
}

/** Helper function to get all of the stat for a player. */
export function getPlayerStats(player: EntityPlayer): PlayerStats {
  return {
    [PlayerStat.DAMAGE]: player.Damage, // 1 << 0
    [PlayerStat.FIRE_DELAY]: player.MaxFireDelay, // 1 << 1
    [PlayerStat.SHOT_SPEED]: player.ShotSpeed, // 1 << 2
    [PlayerStat.TEAR_HEIGHT]: player.TearHeight, // 1 << 3
    [PlayerStat.TEAR_RANGE]: player.TearRange, // 1 << 3
    [PlayerStat.TEAR_FALLING_ACCELERATION]: player.TearFallingAcceleration, // 1 << 3
    [PlayerStat.TEAR_FALLING_SPEED]: player.TearFallingSpeed, // 1 << 3
    [PlayerStat.MOVE_SPEED]: player.MoveSpeed, // 1 << 4
    [PlayerStat.TEAR_FLAG]: player.TearFlags, // 1 << 5
    [PlayerStat.TEAR_COLOR]: player.TearColor, // 1 << 6
    [PlayerStat.FLYING]: player.CanFly, // 1 << 7
    [PlayerStat.LUCK]: player.Luck, // 1 << 10
    [PlayerStat.SIZE]: player.SpriteScale, // 1 << 11
  };
}

----
functions\storyBosses.ts
import { BossID, EntityType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

const STORY_BOSS_IDS = [
  BossID.MOM, // 6
  BossID.MOMS_HEART, // 8
  BossID.SATAN, // 24
  BossID.IT_LIVES, // 25
  BossID.ISAAC, // 39
  BossID.BLUE_BABY, // 40
  BossID.LAMB, // 54
  BossID.MEGA_SATAN, // 55 (Mega Satan 2 is in the same room.)
  BossID.ULTRA_GREED, // 62
  BossID.HUSH, // 63
  BossID.DELIRIUM, // 70
  BossID.ULTRA_GREEDIER, // 71
  BossID.MOTHER, // 88
  BossID.MAUSOLEUM_MOM, // 89
  BossID.MAUSOLEUM_MOMS_HEART, // 90
  BossID.DOGMA, // 99
  BossID.BEAST, // 100
] as const;

const STORY_BOSS_ENTITY_TYPES_SET = new ReadonlySet([
  EntityType.MOM, // 45
  EntityType.MOMS_HEART, // 78
  EntityType.SATAN, // 84
  // - It Lives is a variant of Mom's Heart.
  EntityType.ISAAC, // 102
  // - Blue Baby is a variant of Isaac.
  EntityType.LAMB, // 273
  EntityType.MEGA_SATAN, // 274
  EntityType.MEGA_SATAN_2, // 275
  EntityType.ULTRA_GREED, // 406
  EntityType.HUSH, // 407
  EntityType.DELIRIUM, // 412
  // - Ultra Greedier is a variant of Ultra Greed.
  EntityType.MOTHER, // 912
  // - Mausoleum Mom is a sub-type of Mom.
  // - Mausoleum Mom's Heart is a sub-type of Mom's Heart.
  EntityType.DOGMA, // 950
  EntityType.BEAST, // 951
]);

const STORY_BOSS_IDS_SET = new ReadonlySet<BossID>(STORY_BOSS_IDS);

/**
 * A helper type that is a union of every story boss. Useful for data structures that must contain
 * one entry for each story boss.
 */
export type StoryBossID = (typeof STORY_BOSS_IDS)[number];

/**
 * Helper function to determine if the specified entity type is an end-game story boss, like Isaac,
 * Blue Baby, Mega Satan, The Beast, and so on. This is useful because certain effects should only
 * apply to non-story bosses, like Vanishing Twin.
 */
export function isStoryBoss(entityType: EntityType): boolean {
  return STORY_BOSS_ENTITY_TYPES_SET.has(entityType);
}

/**
 * Helper function to determine if the specified boss ID is an end-game story boss, like Isaac, Blue
 * Baby, Mega Satan, The Beast, and so on. This is useful because certain effects should only apply
 * to non-story bosses, like Vanishing Twin.
 */
export function isStoryBossID(bossID: BossID): bossID is StoryBossID {
  return STORY_BOSS_IDS_SET.has(bossID);
}

----
functions\string.ts
import type { ReadonlyRecord } from "../types/ReadonlyRecord";
import { parseIntSafe } from "./types";
import { assertDefined } from "./utils";

export function capitalizeFirstLetter(string: string): string {
  if (string === "") {
    return string;
  }

  const firstCharacter = string.charAt(0);
  const capitalizedFirstLetter = firstCharacter.toUpperCase();
  const restOfString = string.slice(1);

  return `${capitalizedFirstLetter}${restOfString}`;
}

/**
 * Helper function to get the closest key from a map based on partial search text. (It only searches
 * through the keys, not the values.)
 *
 * Note that:
 * - Spaces are automatically removed from the search text.
 * - Both the search text and the strings to search through are converted to lowercase before
 *   attempting to find a match.
 *
 * For example:
 *
 * ```ts
 * const map = new <string, number>Map([
 *   ["foo", 123],
 *   ["bar", 456],
 * ]);
 * const searchText = "f";
 * const match = getMapPartialMatch(map, searchText); // match is now equal to ["foo", 123]
 * ```
 *
 * @returns If a match was found, returns a tuple of the map key and value. If a match was not
 *          found, returns undefined.
 */
export function getMapPartialMatch<T>(
  searchText: string,
  map: ReadonlyMap<string, T>,
): [string, T] | undefined {
  const keys = [...map.keys()];

  const matchingKey = getPartialMatch(searchText, keys);
  if (matchingKey === undefined) {
    return undefined;
  }

  const value = map.get(matchingKey);
  assertDefined(
    value,
    `Failed to get the map value corresponding to the partial match of: ${matchingKey}`,
  );

  return [matchingKey, value];
}

/**
 * Helper function to get the closest key from an object based on partial search text. (It only
 * searches through the keys, not the values.)
 *
 * Note that:
 * - Spaces are automatically removed from the search text.
 * - Both the search text and the strings to search through are converted to lowercase before
 *   attempting to find a match.
 *
 * For example:
 *
 * ```ts
 * const object = {
 *   foo: 123,
 *   bar: 456,
 * };
 * const searchText = "f";
 * const match = getObjectPartialMatch(object, searchText); // match is now equal to ["foo", 123]
 * ```
 *
 * @returns If a match was found, returns a tuple of the map key and value. If a match was not
 *          found, returns undefined.
 */
export function getObjectPartialMatch<T>(
  searchText: string,
  object: ReadonlyRecord<string, T>,
): [string, T] | undefined {
  const keys = Object.keys(object);

  const matchingKey = getPartialMatch(searchText, keys);
  if (matchingKey === undefined) {
    return undefined;
  }

  const value = object[matchingKey];
  assertDefined(
    value,
    `Failed to get the object value corresponding to the partial match of: ${matchingKey}`,
  );

  return [matchingKey, value];
}

/**
 * Helper function to get the closest value from an array of strings based on partial search text.
 *
 * Note that:
 * - Spaces are automatically removed from the search text.
 * - Both the search text and the strings to search through are converted to lowercase before
 *   attempting to find a match.
 *
 * For example:
 *
 * ```ts
 * const array = ["foo", "bar"];
 * const searchText = "f";
 * const match = getPartialMatch(array, searchText); // match is now equal to "foo"
 *
 * @returns If a match was found, returns the array element. If a match was not
 * found, returns undefined.
 * ```
 */
export function getPartialMatch(
  searchText: string,
  array: readonly string[],
): string | undefined {
  const sortedArray = array.toSorted();

  searchText = searchText.toLowerCase();
  searchText = searchText.replaceAll(" ", "");

  const matchingElements = sortedArray.filter((element) =>
    element.toLowerCase().startsWith(searchText),
  );
  matchingElements.sort();

  return matchingElements[0];
}

/**
 * Helper function to parse a Semantic Versioning string into its individual constituents. Returns
 * undefined if the submitted string was not a proper Semantic Version string.
 *
 * https://semver.org/
 */
export function parseSemanticVersion(versionString: string):
  | {
      majorVersion: int;
      minorVersion: int;
      patchVersion: int;
    }
  | undefined {
  const [majorVersionString, minorVersionString, patchVersionString] =
    string.match(versionString, "(%d+).(%d+).(%d+)");

  if (
    majorVersionString === undefined ||
    minorVersionString === undefined ||
    patchVersionString === undefined
  ) {
    return undefined;
  }

  const majorVersion = parseIntSafe(majorVersionString);
  const minorVersion = parseIntSafe(minorVersionString);
  const patchVersion = parseIntSafe(patchVersionString);

  if (
    majorVersion === undefined ||
    minorVersion === undefined ||
    patchVersion === undefined
  ) {
    return undefined;
  }

  return { majorVersion, minorVersion, patchVersion };
}

export function removeAllCharacters(string: string, character: string): string {
  return string.replaceAll(character, "");
}

/**
 * Helper function to remove all of the characters in a string before a given substring. Returns the
 * modified string.
 */
export function removeCharactersBefore(
  string: string,
  substring: string,
): string {
  const index = string.indexOf(substring);
  return string.slice(index);
}

/** Helper function to remove all characters from a string that are not letters or numbers. */
export function removeNonAlphanumericCharacters(str: string): string {
  const [returnValue, _] = string.gsub(str, "%W", "");
  return returnValue;
}

/**
 * Helper function to remove one or more substrings from a string, if they exist. Returns the
 * modified string.
 *
 * This function is variadic, meaning that you can pass as many substrings as you want to remove.
 */
export function removeSubstring(
  string: string,
  ...substrings: readonly string[]
): string {
  for (const substring of substrings) {
    string = string.replaceAll(substring, "");
  }

  return string;
}

/** Helper function to trim a prefix from a string, if it exists. Returns the trimmed string. */
export function trimPrefix(string: string, prefix: string): string {
  if (!string.startsWith(prefix)) {
    return string;
  }

  return string.slice(prefix.length);
}

/** Helper function to trim a suffix from a string, if it exists. Returns the trimmed string. */
export function trimSuffix(string: string, prefix: string): string {
  if (!string.endsWith(prefix)) {
    return string;
  }

  const endCharacter = string.length - prefix.length;
  return string.slice(0, endCharacter);
}

export function uncapitalizeFirstLetter(string: string): string {
  if (string === "") {
    return string;
  }

  const firstCharacter = string.charAt(0);
  const uncapitalizedFirstLetter = firstCharacter.toLowerCase();
  const restOfString = string.slice(1);

  return `${uncapitalizedFirstLetter}${restOfString}`;
}

----
functions\table.ts
import { isBoolean, isNumber, isString, isUserdata } from "./types";
import { assertDefined } from "./utils";

/**
 * In a `Map`, you can use the `clear` method to delete every element. However, in a `LuaMap`, the
 * `clear` method does not exist. Use this helper function as a drop-in replacement for this.
 */
export function clearTable(luaMap: LuaMap<AnyNotNil, unknown>): void {
  for (const [key] of luaMap) {
    luaMap.delete(key);
  }
}

/** Helper function to copy specific values from a userdata object (e.g. `Vector`) to a table. */
export function copyUserdataValuesToTable(
  object: unknown,
  keys: readonly string[],
  luaMap: LuaMap<string, unknown>,
): void {
  if (!isUserdata(object)) {
    error(
      `Failed to copy an object values to a table, since the object was of type: ${type(
        object,
      )}`,
    );
  }

  // We can access values on userdata objects similar to a normal table.
  const userdata = object as unknown as LuaMap<AnyNotNil, unknown>;

  for (const key of keys) {
    const value = userdata.get(key);
    luaMap.set(key, value);
  }
}

/**
 * Helper function to safely get boolean values from a Lua table. Will throw an error if the
 * specific value does not exist on the table.
 *
 * This function is variadic, meaning that you can specify N arguments to get N values.
 */
export function getBooleansFromTable(
  luaMap: LuaMap<string, unknown>,
  objectName: string,
  ...keys: readonly string[]
): readonly boolean[] {
  const booleans: boolean[] = [];
  for (const key of keys) {
    const value = luaMap.get(key);
    assertDefined(
      value,
      `Failed to find a value for "${key}" in a table representing a "${objectName}" object.`,
    );

    if (isBoolean(value)) {
      booleans.push(value);
    } else {
      error(
        `Failed to get the boolean for the "${key}" value of a table representing a "${objectName}" object because the type was: ${typeof value}`,
      );
    }
  }

  return booleans;
}

/**
 * Helper function to safely get number values from specific keys on a Lua table. If the values are
 * strings, they will be converted to numbers. Will throw an error if the specific value does not
 * exist on the table or if it cannot be converted to a number.
 *
 * This function is variadic, meaning that you can specify N arguments to get N values.
 */
export function getNumbersFromTable(
  luaMap: LuaMap<string, unknown>,
  objectName: string,
  ...keys: readonly string[]
): readonly number[] {
  const numbers: number[] = [];
  for (const key of keys) {
    const value = luaMap.get(key);
    assertDefined(
      value,
      `Failed to find a value for "${key}" in a table representing a "${objectName}" object.`,
    );

    if (isNumber(value)) {
      numbers.push(value);
    } else if (isString(value)) {
      const number = tonumber(value);
      assertDefined(
        number,
        `Failed to convert the "${key}" value of a table representing a "${objectName}" object to a number: ${value}`,
      );

      numbers.push(number);
    } else {
      error(
        `Failed to get the number for the "${key}" value of a table representing a "${objectName}" object because the type was: ${typeof value}`,
      );
    }
  }

  return numbers;
}

/**
 * Helper function to safely get string values from a Lua table. Will throw an error if the specific
 * value does not exist on the table.
 *
 * This function is variadic, meaning that you can specify N arguments to get N values.
 */
export function getStringsFromTable(
  luaMap: LuaMap<string, unknown>,
  objectName: string,
  ...keys: readonly string[]
): readonly string[] {
  const strings: string[] = [];
  for (const key of keys) {
    const value = luaMap.get(key);
    assertDefined(
      value,
      `Failed to find a value for "${key}" in a table representing a "${objectName}" object.`,
    );

    if (isString(value)) {
      strings.push(value);
    } else {
      const string = tostring(value);
      strings.push(string);
    }
  }

  return strings;
}

/** Helper function to check if a Lua table has 0 keys. */
export function isTableEmpty(luaMap: LuaMap<AnyNotNil, unknown>): boolean {
  // Using `next` does not seem to work properly, so we use `pairs` instead.
  // eslint-disable-next-line no-unreachable-loop
  for (const [_key, _value] of luaMap) {
    return false;
  }

  return true;
}

/**
 * Helper function to iterate over a table deterministically. This is useful because by default, the
 * `pairs` function will return the keys of a Lua table in a random order.
 *
 * This function will sort the table entries based on the value of the key.
 *
 * This function will only work on tables that have number keys or string keys. It will throw a
 * run-time error if it encounters a key of another type.
 *
 * @param luaMap The table to iterate over.
 * @param func The function to run for each iteration.
 * @param inOrder Optional. Whether to iterate in order. True by default. You can dynamically set to
 *                false in situations where iterating randomly would not matter and you need the
 *                extra performance.
 */
export function iterateTableInOrder<K extends AnyNotNil, V>(
  luaMap: LuaMap<K, V>,
  func: (key: K, value: V) => void,
  inOrder = true,
): void {
  // First, handle the trivial case of a non-deterministic iteration.
  if (!inOrder) {
    for (const [key, value] of luaMap) {
      func(key, value);
    }
    return;
  }

  const keys = Object.keys(luaMap);
  const hasAllNumberKeys = keys.every((key) => isNumber(key));
  const hasAllStringKeys = keys.every((key) => isString(key));
  if (!hasAllNumberKeys && !hasAllStringKeys) {
    // Since the table has non-homogenous keys, we won't be able to sort it. Revert to
    // non-deterministic iteration in this case.
    for (const [key, value] of luaMap) {
      func(key, value);
    }
    return;
  }

  keys.sort(); // eslint-disable-line @typescript-eslint/require-array-sort-compare
  for (const key of keys) {
    const keyIndex = key as unknown as K;
    const value = luaMap.get(keyIndex);
    if (value !== undefined) {
      func(keyIndex, value);
    }
  }
}

/**
 * Helper function to check if a Lua table has all of the provided keys.
 *
 * This function is variadic, meaning that you can specify as many arguments as you want to check
 * for.
 */
export function tableHasKeys(
  luaMap: LuaMap<AnyNotNil, unknown>,
  ...keys: readonly string[]
): boolean {
  return keys.every((key) => luaMap.has(key));
}

----
functions\tears.ts
import type { FamiliarVariant } from "isaac-typescript-definitions";

/**
 * - Converts the specified amount of tears stat into the format of `EntityPlayer.MaxFireDelay` and
 *   adds it to the player.
 * - This function should only be used inside the `EVALUATE_CACHE` callback.
 * - In this context, the "tears stat" represents what is shown on the in-game stat UI.
 *
 * For example:
 *
 * ```ts
 * function evaluateCacheTears(player: EntityPlayer) {
 *   const numFoo = player.GetNumCollectible(CollectibleTypeCustom.FOO);
 *   const tearsStat = numFoo * FOO_TEARS_STAT;
 *   addTearsStat(player, tearsStat);
 * }
 * ```
 */
export function addTearsStat(player: EntityPlayer, tearsStat: float): void {
  const existingTearsStat = getTearsStat(player.MaxFireDelay);
  const newTearsStat = existingTearsStat + tearsStat;
  const newMaxFireDelay = getFireDelay(newTearsStat);
  player.MaxFireDelay = newMaxFireDelay;
}

/**
 * - The `EntityPlayer` object stores a player's tear rate in the `MaxFireDelay` field. This is
 *   equivalent to how many tears the player can shoot per frame.
 * - If you already have a "tears" stat and you want to convert it back to MaxFireDelay, then use
 *   this function.
 * - In this context, the "tears stat" represents what is shown on the in-game stat UI.
 */
export function getFireDelay(tearsStat: float): float {
  return Math.max(30 / tearsStat - 1, -0.9999);
}

/**
 * - The `EntityPlayer` object stores a player's tear rate in the `MaxFireDelay` field. This is
 *   equivalent to how many tears the player can shoot per frame.
 * - If you want to convert this to the "tears" stat that is shown on the in-game stat UI, then use
 *   this function.
 */
export function getTearsStat(fireDelay: float): float {
  return 30 / (fireDelay + 1);
}

/**
 * Helper function to check if a tear hit an enemy. A tear is considered to be missed if it hit the
 * ground, a wall, or a grid entity.
 *
 * Note that tears are still considered to be missed if they hit a poop or fire, so you may want to
 * handle those separately using the `POST_GRID_ENTITY_COLLISION` and `POST_ENTITY_COLLISION`
 * callbacks, respectively.
 *
 * Under the hood, this function uses the `Entity.IsDead` method. (Tears will not die if they hit an
 * enemy, but they will die if they hit a wall or object.)
 */
export function isMissedTear(tear: EntityTear): boolean {
  return tear.IsDead();
}

/**
 * Helper function to check if a given tear is from a familiar (as opposed to e.g. a player). This
 * is determined by looking at the parent.
 *
 * For the special case of Incubus and Blood Babies, the parent of the tear is always the player,
 * but the spawner entity of the tear changes. On frame 0, the spawner entity is equal to the
 * player, and on frame 1, the spawner entity is equal to the familiar. For this reason, you can
 * only use this function in the `POST_TEAR_INIT_VERY_LATE` callback or on frame 1+.
 *
 * If this function is called on frame 0, it will throw a run-time error.
 *
 * Note that this function does not work properly when the tear is from a Lead Pencil barrage. In
 * this case, it will always appear as if the tear is coming from a player.
 *
 * @param tear The tear to inspect.
 * @param familiarVariant Optional. Specify this to check if the tear came from a specific familiar
 *                        variant. Default is undefined, which checks for any familiar.
 * @param subType Optional. Specify this to check if the tear came from a specific familiar
 *                sub-type. Default is undefined, which checks for any familiar.
 */
export function isTearFromFamiliar(
  tear: EntityTear,
  familiarVariant?: FamiliarVariant,
  subType?: int,
): boolean {
  if (tear.FrameCount === 0) {
    error(
      'Failed to check if the given tear was from a player since the tear\'s frame count was equal to 0. (The "isTearFromFamiliar" function must only be used in the "POST_TEAR_INIT_VERY_LATE" callback or on frame 1 and onwards.)',
    );
  }

  // Normally, all tears have a spawner entity, which is either the player or the familiar.
  if (tear.SpawnerEntity === undefined) {
    return false;
  }

  // We cannot use `tear.SpawnerType` to determine this, since it is baked in to be equal to
  // `EntityType.PLAYER` regardless of whether the tear is from a player or familiar.
  const familiar = tear.SpawnerEntity.ToFamiliar();
  if (familiar === undefined) {
    return false;
  }

  return (
    (familiarVariant === undefined || familiarVariant === familiar.Variant) &&
    (subType === undefined || subType === familiar.SubType)
  );
}

/**
 * Helper function to check if a given tear is from a player (as opposed to e.g. a familiar). This
 * is determined by looking at the `SpawnerEntity`.
 *
 * For the special case of Incubus and Blood Babies, the `SpawnerEntity` of the tear is always the
 * player, but the spawner entity of the tear changes. On frame 0, the spawner entity is equal to
 * the player, and on frame 1, the spawner entity is equal to the familiar. For this reason, you can
 * only use this function in the `POST_TEAR_INIT_VERY_LATE` callback or on frame 1+.
 *
 * If this function is called on frame 0, it will throw a run-time error.
 *
 * Note that this function does not work properly when the tear is from a Lead Pencil barrage. In
 * this case, it will always appear as if the tear is coming from a player.
 */
export function isTearFromPlayer(tear: EntityTear): boolean {
  if (tear.FrameCount === 0) {
    error(
      'Failed to check if the given tear was from a player since the tear\'s frame count was equal to 0. (The "isTearFromPlayer" function must only be used in the "POST_TEAR_INIT_VERY_LATE" callback or on frame 1 and onwards.)',
    );
  }

  // Normally, all tears have a spawner entity, which is either the player or the familiar.
  if (tear.SpawnerEntity === undefined) {
    return false;
  }

  // We cannot use `tear.SpawnerType` to determine this, since it is baked in to be equal to
  // `EntityType.PLAYER` regardless of whether the tear is from a player or familiar.
  const player = tear.SpawnerEntity.ToPlayer();
  return player !== undefined;
}

----
functions\transformations.ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { ItemConfigTag, PlayerForm } from "isaac-typescript-definitions";
import { PLAYER_FORM_VALUES } from "../cachedEnumValues";
import { TRANSFORMATION_NAMES } from "../objects/transformationNames";
import { ReadonlyMap } from "../types/ReadonlyMap";
import { ReadonlySet } from "../types/ReadonlySet";
import { getCollectibleTags } from "./collectibles";
import { hasFlag } from "./flag";

const TRANSFORMATION_TO_TAG_MAP = new ReadonlyMap<PlayerForm, ItemConfigTag>([
  [PlayerForm.GUPPY, ItemConfigTag.GUPPY], // 0
  [PlayerForm.BEELZEBUB, ItemConfigTag.FLY], // 1
  [PlayerForm.FUN_GUY, ItemConfigTag.MUSHROOM], // 2
  [PlayerForm.SERAPHIM, ItemConfigTag.ANGEL], // 3
  [PlayerForm.BOB, ItemConfigTag.BOB], // 4
  [PlayerForm.SPUN, ItemConfigTag.SYRINGE], // 5
  [PlayerForm.YES_MOTHER, ItemConfigTag.MOM], // 6
  [PlayerForm.CONJOINED, ItemConfigTag.BABY], // 7
  [PlayerForm.LEVIATHAN, ItemConfigTag.DEVIL], // 8
  [PlayerForm.OH_CRAP, ItemConfigTag.POOP], // 9
  [PlayerForm.BOOKWORM, ItemConfigTag.BOOK], // 10
  // PlayerForm.ADULTHOOD (11) is based on pill usage.
  [PlayerForm.SPIDER_BABY, ItemConfigTag.SPIDER], // 12
  // PlayerForm.STOMPY (13) is based on size.
]);

const TRANSFORMATIONS_THAT_GRANT_FLYING = new ReadonlySet<PlayerForm>([
  PlayerForm.GUPPY, // 0
  PlayerForm.BEELZEBUB, // 1
  PlayerForm.SERAPHIM, // 3
  PlayerForm.LEVIATHAN, // 8
]);

/** Returns a set of the player's current transformations. */
export function getPlayerTransformations(
  player: EntityPlayer,
): ReadonlySet<PlayerForm> {
  const transformations = new Set<PlayerForm>();
  for (const playerForm of PLAYER_FORM_VALUES) {
    if (player.HasPlayerForm(playerForm)) {
      transformations.add(playerForm);
    }
  }

  return transformations;
}

/**
 * Helper function to get a transformation name from a PlayerForm enum.
 *
 * For example:
 *
 * ```ts
 * const transformationName = getTransformationName(PlayerForm.LORD_OF_THE_FLIES);
 * // transformationName is "Beelzebub"
 * ```
 */
export function getTransformationName(playerForm: PlayerForm): string {
  return TRANSFORMATION_NAMES[playerForm];
}

/**
 * Returns a set containing all of the transformations that the given collectible types contribute
 * towards.
 */
export function getTransformationsForCollectibleType(
  collectibleType: CollectibleType,
): ReadonlySet<PlayerForm> {
  const itemConfigTags = getCollectibleTags(collectibleType);

  const transformationSet = new Set<PlayerForm>();
  for (const playerForm of PLAYER_FORM_VALUES) {
    const itemConfigTag = TRANSFORMATION_TO_TAG_MAP.get(playerForm);
    if (itemConfigTag === undefined) {
      continue;
    }

    if (hasFlag(itemConfigTags, itemConfigTag)) {
      transformationSet.add(playerForm);
    }
  }

  return transformationSet;
}

export function hasFlyingTransformation(player: EntityPlayer): boolean {
  for (const playerForm of TRANSFORMATIONS_THAT_GRANT_FLYING) {
    if (player.HasPlayerForm(playerForm)) {
      return true;
    }
  }

  return false;
}

export function isTransformationFlying(playerForm: PlayerForm): boolean {
  return TRANSFORMATIONS_THAT_GRANT_FLYING.has(playerForm);
}

----
functions\trinketGive.ts
import {
  CollectibleType,
  TrinketSlot,
  TrinketType,
} from "isaac-typescript-definitions";
import type { TrinketSituation } from "../interfaces/TrinketSituation";
import { useActiveItemTemp } from "./playerCollectibles";
import { getGoldenTrinketType } from "./trinkets";
import { repeat } from "./utils";

/**
 * Helper function to restore the player's trinkets back to the way they were before the
 * `temporarilyRemoveTrinket` function was used. It will re-smelt any smelted trinkets that were
 * removed.
 */
export function giveTrinketsBack(
  player: EntityPlayer,
  trinketSituation: TrinketSituation | undefined,
): void {
  // A trinket situation of undefined signifies that we did not have to remove the trinket. If this
  // is the case, we do not have to give anything back.
  if (trinketSituation === undefined) {
    return;
  }

  const trinketType1 = player.GetTrinket(TrinketSlot.SLOT_1);
  const trinketType2 = player.GetTrinket(TrinketSlot.SLOT_2);

  // Remove any existing trinkets.
  if (trinketType1 !== TrinketType.NULL) {
    player.TryRemoveTrinket(trinketType1);
  }
  if (trinketType2 !== TrinketType.NULL) {
    player.TryRemoveTrinket(trinketType2);
  }

  // First, add the smelted trinkets back.
  repeat(trinketSituation.numSmeltedTrinkets, () => {
    player.AddTrinket(trinketSituation.trinketTypeRemoved, false);
    useActiveItemTemp(player, CollectibleType.SMELTER);
  });

  // Second, add back the stored trinkets.
  if (trinketSituation.trinketType1 !== TrinketType.NULL) {
    player.AddTrinket(trinketSituation.trinketType1, false);
  }
  if (trinketSituation.trinketType2 !== TrinketType.NULL) {
    player.AddTrinket(trinketSituation.trinketType2, false);
  }
}

/**
 * Helper function to smelt a trinket. Before smelting, this function will automatically remove the
 * trinkets that the player is holding, if any, and then give them back after the new trinket is
 * smelted.
 *
 * @param player The player to smelt the trinkets to.
 * @param trinketType The trinket type to smelt.
 * @param numTrinkets Optional. If specified, will smelt the given number of trinkets. Use this to
 *                    avoid calling this function multiple times. Default is 1.
 */
export function smeltTrinket(
  player: EntityPlayer,
  trinketType: TrinketType,
  numTrinkets = 1,
): void {
  const trinketSituation = temporarilyRemoveTrinkets(player);

  repeat(numTrinkets, () => {
    player.AddTrinket(trinketType);
    useActiveItemTemp(player, CollectibleType.SMELTER);
  });

  giveTrinketsBack(player, trinketSituation);
}

/**
 * Helper function to smelt two or more different trinkets. If you want to smelt one trinket (or
 * multiple copies of one trinket), then use the `smeltTrinket` helper function instead.
 *
 * This function is variadic, meaning that you can pass as many trinket types as you want to smelt.
 *
 * Before smelting, this function will automatically remove the trinkets that the player is holding,
 * if any, and then give them back after the new trinket is smelted.
 *
 * @param player The player to smelt the trinkets to.
 * @param trinketTypes The trinket types to smelt.
 */
export function smeltTrinkets(
  player: EntityPlayer,
  ...trinketTypes: readonly TrinketType[]
): void {
  for (const trinketType of trinketTypes) {
    smeltTrinket(player, trinketType);
  }
}

/**
 * Helper function to temporarily remove a specific kind of trinket from the player. Use this in
 * combination with the `giveTrinketsBack` function to take away and give back a trinket on the same
 * frame. This function correctly handles multiple trinket slots and ensures that all copies of the
 * trinket are removed, including smelted trinkets.
 *
 * Note that one smelted golden trinket is the same as two smelted normal trinkets.
 *
 * @returns Undefined if the player does not have the trinket, or TrinketSituation if they do.
 */
export function temporarilyRemoveTrinket(
  player: EntityPlayer,
  trinketType: TrinketType,
): TrinketSituation | undefined {
  if (!player.HasTrinket(trinketType)) {
    return undefined;
  }

  const trinketType1 = player.GetTrinket(TrinketSlot.SLOT_1);
  const trinketType2 = player.GetTrinket(TrinketSlot.SLOT_2);

  let numTrinkets = 0;
  while (player.HasTrinket(trinketType)) {
    player.TryRemoveTrinket(trinketType);
    numTrinkets++;
  }

  let numSmeltedTrinkets = numTrinkets;
  const trinketWasInSlot1 =
    trinketType1 === trinketType ||
    trinketType1 === getGoldenTrinketType(trinketType);
  if (trinketWasInSlot1) {
    numSmeltedTrinkets--;
  }
  const trinketWasInSlot2 =
    trinketType2 === trinketType ||
    trinketType2 === getGoldenTrinketType(trinketType);
  if (trinketWasInSlot2) {
    numSmeltedTrinkets--;
  }

  return {
    trinketTypeRemoved: trinketType,
    trinketType1,
    trinketType2,
    numSmeltedTrinkets,
  };
}

/**
 * Helper function to temporarily removes a player's held trinkets, if any. This will not remove any
 * smelted trinkets. Use this in combination with the `giveTrinketsBack` function to take away and
 * give back trinkets on the same frame.
 *
 * @returns Undefined if the player does not have any trinkets, or TrinketSituation if they do.
 */
export function temporarilyRemoveTrinkets(
  player: EntityPlayer,
): TrinketSituation | undefined {
  const trinketType1 = player.GetTrinket(TrinketSlot.SLOT_1);
  const trinketType2 = player.GetTrinket(TrinketSlot.SLOT_2);

  if (trinketType1 === TrinketType.NULL && trinketType2 === TrinketType.NULL) {
    return undefined;
  }

  if (trinketType1 !== TrinketType.NULL) {
    player.TryRemoveTrinket(trinketType1);
  }

  if (trinketType2 !== TrinketType.NULL) {
    player.TryRemoveTrinket(trinketType2);
  }

  return {
    trinketTypeRemoved: TrinketType.NULL,
    trinketType1,
    trinketType2,
    numSmeltedTrinkets: 0,
  };
}

----
functions\trinkets.ts
import type { CacheFlag } from "isaac-typescript-definitions";
import { TrinketType } from "isaac-typescript-definitions";
import { itemConfig } from "../core/cachedClasses";
import { BLIND_ITEM_PNG_PATH } from "../core/constants";
import { LAST_VANILLA_TRINKET_TYPE } from "../core/constantsFirstLast";
import { MysteriousPaperEffect } from "../enums/MysteriousPaperEffect";
import {
  DEFAULT_TRINKET_DESCRIPTION,
  TRINKET_DESCRIPTIONS,
} from "../objects/trinketDescriptions";
import { DEFAULT_TRINKET_NAME, TRINKET_NAMES } from "../objects/trinketNames";
import { getEntityID } from "./entities";
import { getEnumLength } from "./enums";
import { hasFlag } from "./flag";
import { isTrinket } from "./pickupVariants";
import { clearSprite } from "./sprites";
import { asNumber, asTrinketType } from "./types";

/**
 * Add this to a `TrinketType` to get the corresponding golden trinket type.
 *
 * Corresponds to the vanilla `PillColor.TRINKET_GOLDEN_FLAG` value.
 *
 * 1 << 15
 */
const GOLDEN_TRINKET_ADJUSTMENT = 32_768;

const NUM_MYSTERIOUS_PAPER_EFFECTS = getEnumLength(MysteriousPaperEffect);

const TRINKET_ANM2_PATH = "gfx/005.350_trinket.anm2";
const TRINKET_SPRITE_LAYER = 0;

/**
 * Helper function to get the corresponding golden trinket type from a normal trinket type.
 *
 * If the provided trinket type is already a golden trinket type, then the trinket type will be
 * returned unmodified.
 *
 * For example, passing `TrinketType.SWALLOWED_PENNY` would result in 32769, which is the value that
 * corresponds to the golden trinket sub-type for Swallowed Penny.
 */
export function getGoldenTrinketType(trinketType: TrinketType): TrinketType {
  return isGoldenTrinketType(trinketType)
    ? trinketType
    : trinketType + GOLDEN_TRINKET_ADJUSTMENT;
}

/**
 * Helper function to get the current effect that the Mysterious Paper trinket is providing to the
 * player. Returns undefined if the player does not have the Mysterious Paper trinket.
 *
 * The Mysterious Paper trinket has four different effects:
 *
 * - The Polaroid (collectible)
 * - The Negative (collectible)
 * - A Missing Page (trinket)
 * - Missing Poster (trinket)
 *
 * It rotates between these four effects on every frame. Note that Mysterious Paper will cause the
 * `EntityPlayer.HasCollectible` and `EntityPlayer.HasTrinket` methods to return true for the
 * respective items on the particular frame, with the exception of the Missing Poster. (The player
 * will never "have" the Missing Poster, even on the correct corresponding frame.)
 *
 * @param player The player to look at.
 * @param frameCount Optional. The frame count that corresponds to time the effect will be active.
 *                   Default is the current frame.
 */
export function getMysteriousPaperEffectForFrame(
  player: EntityPlayer,
  frameCount?: int,
): MysteriousPaperEffect | undefined {
  if (frameCount === undefined) {
    frameCount = player.FrameCount;
  }

  if (!player.HasTrinket(TrinketType.MYSTERIOUS_PAPER)) {
    return undefined;
  }

  return frameCount % NUM_MYSTERIOUS_PAPER_EFFECTS;
}

/**
 * Helper function to get the corresponding normal trinket type from a golden trinket type.
 *
 * If the provided trinket type is already a normal trinket type, then the trinket type will be
 * returned unmodified.
 */
export function getNormalTrinketType(trinketType: TrinketType): TrinketType {
  return isGoldenTrinketType(trinketType)
    ? trinketType - GOLDEN_TRINKET_ADJUSTMENT
    : trinketType;
}

/**
 * Helper function to get the in-game description for a trinket. Returns "Unknown" if the provided
 * trinket type was not valid.
 *
 * This function works for both vanilla and modded trinkets.
 */
export function getTrinketDescription(trinketType: TrinketType): string {
  // "ItemConfigItem.Description" is bugged with vanilla items on patch v1.7.6, so we use a
  // hard-coded object as a workaround.
  const trinketDescription = TRINKET_DESCRIPTIONS[trinketType] as
    | string
    | undefined;
  if (trinketDescription !== undefined) {
    return trinketDescription;
  }

  const itemConfigItem = itemConfig.GetTrinket(trinketType);
  if (itemConfigItem !== undefined) {
    return itemConfigItem.Description;
  }

  return DEFAULT_TRINKET_DESCRIPTION;
}

/**
 * Helper function to get the path to a trinket PNG file. Returns the path to the question mark
 * sprite (i.e. from Curse of the Blind) if the provided trinket type was not valid.
 *
 * Note that this does not return the file name, but the full path to the trinket's PNG file. The
 * function is named "GfxFilename" to correspond to the associated `ItemConfigItem.GfxFileName`
 * field.
 */
export function getTrinketGfxFilename(trinketType: TrinketType): string {
  const itemConfigItem = itemConfig.GetTrinket(trinketType);
  if (itemConfigItem === undefined) {
    return BLIND_ITEM_PNG_PATH;
  }

  return itemConfigItem.GfxFileName;
}

/**
 * Helper function to get the name of a trinket. Returns "Unknown" if the provided trinket type is
 * not valid.
 *
 * This function works for both vanilla and modded trinkets.
 *
 * For example, `getTrinketName(TrinketType.SWALLOWED_PENNY)` would return "Swallowed Penny".
 */
export function getTrinketName(trinketType: TrinketType): string {
  // "ItemConfigItem.Name" is bugged with vanilla items on patch v1.7.6, so we use a hard-coded
  // object as a workaround.
  const trinketName = TRINKET_NAMES[trinketType] as string | undefined;
  if (trinketName !== undefined) {
    return trinketName;
  }

  const itemConfigItem = itemConfig.GetTrinket(trinketType);
  if (itemConfigItem !== undefined) {
    return itemConfigItem.Name;
  }

  return DEFAULT_TRINKET_NAME;
}

export function isGoldenTrinketType(trinketType: TrinketType): boolean {
  return asNumber(trinketType) > GOLDEN_TRINKET_ADJUSTMENT;
}

export function isModdedTrinketType(trinketType: TrinketType): boolean {
  return !isVanillaTrinketType(trinketType);
}

export function isValidTrinketType(
  trinketType: int,
): trinketType is TrinketType {
  const potentialTrinketType = asTrinketType(trinketType);
  const itemConfigItem = itemConfig.GetTrinket(potentialTrinketType);
  return itemConfigItem !== undefined;
}

export function isVanillaTrinketType(trinketType: TrinketType): boolean {
  return trinketType <= LAST_VANILLA_TRINKET_TYPE;
}

/**
 * Helper function to generate a new sprite based on a collectible. If the provided collectible type
 * is invalid, a sprite with a Curse of the Blind question mark will be returned.
 */
export function newTrinketSprite(trinketType: TrinketType): Sprite {
  const sprite = Sprite();
  sprite.Load(TRINKET_ANM2_PATH, false);

  const gfxFileName = getTrinketGfxFilename(trinketType);
  sprite.ReplaceSpritesheet(TRINKET_SPRITE_LAYER, gfxFileName);
  sprite.LoadGraphics();

  const defaultAnimation = sprite.GetDefaultAnimation();
  sprite.Play(defaultAnimation, true);

  return sprite;
}

/**
 * Helper function to change the sprite of a trinket entity.
 *
 * For more information about removing the trinket sprite, see the documentation for the
 * "clearSprite" helper function.
 *
 * @param trinket The trinket whose sprite you want to modify.
 * @param pngPath Equal to either the spritesheet path to load (e.g.
 *                "gfx/items/trinkets/trinket_001_swallowedpenny.png") or undefined. If undefined,
 *                the sprite will be removed, making the trinket effectively invisible (except for
 *                the shadow underneath it).
 */
export function setTrinketSprite(
  trinket: EntityPickup,
  pngPath: string | undefined,
): void {
  if (!isTrinket(trinket)) {
    const entityID = getEntityID(trinket);
    error(
      `The "setTrinketSprite" function was given a non-trinket: ${entityID}`,
    );
  }

  const sprite = trinket.GetSprite();
  if (pngPath === undefined) {
    // We use `clearSpriteLayer` instead of `Sprite.Reset` to maintain parity with the
    // `setCollectibleSprite` function.
    clearSprite(sprite);
  } else {
    sprite.ReplaceSpritesheet(TRINKET_SPRITE_LAYER, pngPath);
    sprite.LoadGraphics();
  }
}

/** Helper function to check in the item config if a given trinket has a given cache flag. */
export function trinketHasCacheFlag(
  trinketType: TrinketType,
  cacheFlag: CacheFlag,
): boolean {
  const itemConfigItem = itemConfig.GetTrinket(trinketType);
  if (itemConfigItem === undefined) {
    return false;
  }

  return hasFlag(itemConfigItem.CacheFlags, cacheFlag);
}

----
functions\tstlClass.ts
import type { DefaultMap } from "../classes/DefaultMap";
import type { TSTLClassMetatable } from "../interfaces/TSTLClassMetatable";
import type { TSTLClass } from "../types/TSTLClass";
import { isTable } from "./types";
import { assertDefined } from "./utils";

/**
 * Helper function to get the constructor from an instantiated TypeScriptToLua class, which is
 * located on the metatable.
 *
 * Returns undefined if passed a non-table or if the provided table does not have a metatable.
 */
export function getTSTLClassConstructor(
  object: unknown,
): TSTLClassMetatable["constructor"] | undefined {
  if (!isTable(object)) {
    return undefined;
  }

  const metatable = getmetatable(object);
  if (metatable === undefined) {
    return undefined;
  }

  return metatable.constructor;
}

/**
 * Helper function to get the name of a TypeScriptToLua class from the instantiated class object.
 *
 * TSTL classes are Lua tables created with the `__TS__Class` Lua function from the TSTL lualib.
 * Their name is contained within "constructor.name" metatable key.
 *
 * For example, a `Map` class is has a name of "Map".
 *
 * Returns undefined if passed a non-table or if the provided table does not have a metatable.
 */
export function getTSTLClassName(object: unknown): string | undefined {
  const constructor = getTSTLClassConstructor(object);
  if (constructor === undefined) {
    return undefined;
  }

  return constructor.name;
}

/**
 * Helper function to determine if a given object is a TypeScriptToLua `Map`.
 *
 * It is not reliable to use the `instanceof` operator to determine this because each Lua module has
 * their own copies of the entire lualib and thus their own instantiated version of a `Map`.
 */
export function isDefaultMap(
  object: unknown,
): object is DefaultMap<AnyNotNil, unknown> {
  const className = getTSTLClassName(object);
  return className === "DefaultMap";
}

/** Helper function to check if a given table is a class table created by TypeScriptToLua. */
export function isTSTLClass(object: unknown): object is TSTLClass {
  const tstlClassName = getTSTLClassName(object);
  return tstlClassName !== undefined;
}

/**
 * Helper function to determine if a given object is a TypeScriptToLua `Map`.
 *
 * It is not reliable to use the `instanceof` operator to determine this because each Lua module
 * might have their own copy of the entire lualib and thus their own instantiated version of a
 * `Map`.
 */
export function isTSTLMap(object: unknown): object is Map<AnyNotNil, unknown> {
  const className = getTSTLClassName(object);
  return className === "Map";
}

/**
 * Helper function to determine if a given object is a TypeScriptToLua `Set`.
 *
 * It is not reliable to use the `instanceof` operator to determine this because each Lua module
 * might have their own copy of the entire lualib and thus their own instantiated version of a
 * `Set`.
 */
export function isTSTLSet(object: unknown): object is Set<AnyNotNil> {
  const className = getTSTLClassName(object);
  return className === "Set";
}

/**
 * Initializes a new TypeScriptToLua class in the situation where you do not know what kind of class
 * it is. This function requires that you provide an instantiated class of the same type, as it will
 * use the class constructor that is present on the other object's metatable to initialize the new
 * class.
 */
export function newTSTLClass(oldClass: TSTLClass): TSTLClass {
  const constructor = getTSTLClassConstructor(oldClass);
  assertDefined(
    constructor,
    "Failed to instantiate a new TypeScriptToLua class since the provided old class does not have a metatable/constructor.",
  );

  // We re-implement some of the logic from the transpiled "__TS__New" function.
  const newClass = new LuaMap<AnyNotNil, unknown>();
  const newClassMetatable = setmetatable(
    newClass,
    constructor.prototype,
  ) as unknown as TSTLClassMetatable;
  newClassMetatable.____constructor();

  return newClass as unknown as TSTLClass;
}

----
functions\types.ts
/**
 * Consider the following code that uses a number enum:
 *
 * ```ts
 * enum MyEnum {
 *   Value1,
 * }
 *
 * function asMyEnum(num: number): MyEnum {}
 *
 * declare const something: unknown;
 *
 * const foo = something as MyEnum; // no error
 * const bar: MyEnum = something; // error
 * const baz = asMyEnum(something); // error
 * ```
 *
 * Here, using `as` does not give an error because TypeScript allows you to assert a type to a
 * supertype or a subtype. Thus, using `as` to perform a type assertion is not as safe as using a
 * variable declaration or a helper function. However, if we use a variable declaration, then the
 * `isaacscript/strict-enums` rule is triggered, which requires suppressing the lint rule with a `//
 * eslint-disable-next-line`. Thus, the safest and more concise way to do a type assertion is to use
 * a helper function.
 *
 * This file contains helper functions for various number enums that might require type assertions.
 * It also contains helper functions for run-time type checks.
 *
 * @module
 */

import type {
  CardType,
  CollectibleType,
  LevelStage,
  NPCState,
  PillColor,
  PillEffect,
  PlayerType,
  RoomType,
  TrinketType,
} from "isaac-typescript-definitions";

/**
 * Helper function to safely cast an `int` to a `CardType`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asCardType(num: int): CardType {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `CollectibleType`. (This is better than using the
 * `as` TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asCollectibleType(num: int): CollectibleType {
  return num;
}

/**
 * Helper function to safely cast an enum to an `int`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asFloat(num: number): float {
  return num;
}

/**
 * Helper function to safely cast an enum to an `int`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asInt(num: number): int {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `LevelStage`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asLevelStage(num: int): LevelStage {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `NPCState`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asNPCState(num: int): NPCState {
  return num;
}

/**
 * Helper function to safely cast an enum to a `number`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asNumber(num: number): number {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `PillColor`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asPillColor(num: int): PillColor {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `PillEffect`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asPillEffect(num: int): PillEffect {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `PlayerType`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asPlayerType(num: int): PlayerType {
  return num;
}

/**
 * Helper function to safely cast an `int` to a `RoomType`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asRoomType(num: int): RoomType {
  return num;
}

/**
 * Helper function to safely cast an enum to a `string`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asString(str: string): string {
  return str;
}

/**
 * Helper function to safely cast an `int` to a `TrinketType`. (This is better than using the `as`
 * TypeScript keyword to do a type assertion, since that can obfuscate compiler errors. )
 *
 * This is useful to satisfy the "isaacscript/strict-enums" ESLint rule.
 */
export function asTrinketType(num: int): TrinketType {
  return num;
}

export function isBoolean(variable: unknown): variable is boolean {
  return typeof variable === "boolean";
}

// eslint-disable-next-line @typescript-eslint/ban-types
export function isFunction(variable: unknown): variable is Function {
  return typeof variable === "function";
}

export function isInteger(variable: unknown): variable is int {
  if (!isNumber(variable)) {
    return false;
  }

  return variable === Math.floor(variable);
}

export function isNumber(variable: unknown): variable is number {
  return typeof variable === "number";
}

/** Helper function to detect if a variable is a boolean, number, or string. */
export function isPrimitive(
  variable: unknown,
): variable is boolean | number | string {
  const variableType = typeof variable;
  return (
    variableType === "boolean" ||
    variableType === "number" ||
    variableType === "string"
  );
}

export function isString(variable: unknown): variable is string {
  return typeof variable === "string";
}

export function isTable(
  variable: unknown,
): variable is LuaMap<AnyNotNil, unknown> {
  // We cannot use `typeof` here since "table" is not a JavaScript type.
  return type(variable) === "table";
}

export function isUserdata(variable: unknown): variable is LuaUserdata {
  // We cannot use `typeof` here since "userdata" is not a JavaScript type.
  return type(variable) === "userdata";
}

/**
 * Helper function to convert a string to an integer. Returns undefined if the string is not an
 * integer.
 *
 * Under the hood, this uses the built-in `tonumber` and `math.floor` functions.
 *
 * This is named `parseIntSafe` in order to match the helper function in `isaacscript-common-ts`.
 */
export function parseIntSafe(string: string): int | undefined {
  if (!isString(string)) {
    return undefined;
  }

  // - The `tonumber` function correctly deals with leading and trailing whitespace.
  // - The `tonumber` function correctly deals with a mix of numbers and letters. (e.g. `1a` returns
  //   undefined.)
  const number = tonumber(string);
  if (number === undefined) {
    return undefined;
  }

  const flooredNumber = Math.floor(number);
  return number === flooredNumber ? flooredNumber : undefined;
}

----
functions\ui.ts
import { CollectibleType, LevelCurse } from "isaac-typescript-definitions";
import { game } from "../core/cachedClasses";
import { UI_HEART_WIDTH, VectorZero } from "../core/constants";
import { copyVector } from "./vector";

/**
 * In the options menu, players have the ability to set a HUD offset (which gets written to the
 * `HudOffset` attribute in the "options.ini" file). This function uses the current HUD offset to
 * generate a vector that should be added to the corresponding position that you want to draw a UI
 * element at.
 *
 * For example:
 * - If the user does not have a HUD offset configured, this function will return `Vector(0, 0)`.
 * - If the user has a HUD offset of 1.0 configured, this function will return `Vector(20, 12)`.
 */
export function getHUDOffsetVector(): Readonly<Vector> {
  // Convert e.g. 0.4 to 4.
  const hudOffset = Math.floor(Options.HUDOffset * 10);

  // Expected values are integers between 1 and 10.
  if (hudOffset < 1 || hudOffset > 10) {
    return copyVector(VectorZero);
  }

  const x = hudOffset * 2;
  let y = hudOffset;
  if (y >= 4) {
    y++;
  }
  if (y >= 9) {
    y++;
  }

  return Vector(x, y);
}

/**
 * Returns how many hearts are in the heart UI row. If the player has more than 6 hearts, this
 * function will return 6.
 */
export function getHeartRowLength(player: EntityPlayer): int {
  const maxHearts = player.GetMaxHearts();
  const soulHearts = player.GetSoulHearts();
  const boneHearts = player.GetBoneHearts();
  const brokenHearts = player.GetBrokenHearts();

  // There are no half bone hearts or half broken hearts.
  const combinedHearts =
    maxHearts + soulHearts + boneHearts * 2 + brokenHearts * 2;
  const heartRowLength = combinedHearts / 2;

  // After 6 hearts, the hearts wrap to a second row.
  return Math.min(heartRowLength, 6);
}

/**
 * Helper function to get the width of the first player's hearts on the UI. This is useful for
 * drawing UI elements to the right of where the player's hearts are. Make sure to use this in
 * combination with the `getHUDOffsetVector` helper function.
 */
export function getHeartsUIWidth(): int {
  const level = game.GetLevel();
  const curses = level.GetCurses();
  const player = Isaac.GetPlayer();
  const extraLives = player.GetExtraLives();
  const effects = player.GetEffects();
  const hasHolyMantleEffect = effects.HasCollectibleEffect(
    CollectibleType.HOLY_MANTLE,
  );

  let heartRowLength = getHeartRowLength(player);
  if (hasHolyMantleEffect) {
    heartRowLength++;
  }
  if (curses === LevelCurse.UNKNOWN) {
    heartRowLength = 1;
  }

  let width = heartRowLength * UI_HEART_WIDTH;
  if (extraLives > 9) {
    width += 20;
    if (player.HasCollectible(CollectibleType.GUPPYS_COLLAR)) {
      width += 6;
    }
  } else if (extraLives > 0) {
    width += 16;
    if (player.HasCollectible(CollectibleType.GUPPYS_COLLAR)) {
      width += 4;
    }
  }

  return width;
}

export function getScreenBottomCenterPos(): Readonly<Vector> {
  const bottomRightPos = getScreenBottomRightPos();
  return Vector(bottomRightPos.X / 2, bottomRightPos.Y);
}

export function getScreenBottomLeftPos(): Readonly<Vector> {
  const bottomRightPos = getScreenBottomRightPos();
  return Vector(0, bottomRightPos.Y);
}

export function getScreenBottomRightPos(): Readonly<Vector> {
  const screenWidth = Isaac.GetScreenWidth();
  const screenHeight = Isaac.GetScreenHeight();

  return Vector(screenWidth, screenHeight);
}

export function getScreenBottomY(): float {
  const bottomRightPos = getScreenBottomRightPos();
  return bottomRightPos.Y;
}

export function getScreenCenterPos(): Readonly<Vector> {
  const bottomRightPos = getScreenBottomRightPos();
  return bottomRightPos.div(2);
}

export function getScreenRightX(): float {
  const bottomRightPos = getScreenBottomRightPos();
  return bottomRightPos.X;
}

export function getScreenTopCenterPos(): Readonly<Vector> {
  const bottomRightPos = getScreenBottomRightPos();
  return Vector(bottomRightPos.X / 2, 0);
}

export function getScreenTopLeftPos(): Readonly<Vector> {
  return copyVector(VectorZero);
}

export function getScreenTopRightPos(): Readonly<Vector> {
  const bottomRightPos = getScreenBottomRightPos();
  return Vector(bottomRightPos.X, 0);
}

/**
 * Get how many hearts are currently being shown on the hearts UI.
 *
 * This function is originally from piber20 Helper.
 */
export function getVisibleHearts(player: EntityPlayer): int {
  const effectiveMaxHearts = player.GetEffectiveMaxHearts();
  const soulHearts = player.GetSoulHearts();
  const boneHearts = player.GetBoneHearts();

  const maxHearts = Math.max(effectiveMaxHearts, boneHearts * 2);

  let visibleHearts = Math.ceil((maxHearts + soulHearts) / 2);
  if (visibleHearts < 1) {
    visibleHearts = 1;
  }

  return visibleHearts;
}

----
functions\utils.ts
import { ReadonlySet } from "../types/ReadonlySet";
import { getAllPlayers } from "./playerIndex";
import { isFunction } from "./types";

/**
 * Helper function to throw an error (using the `error` Lua function) if the provided value is equal
 * to `undefined`.
 *
 * This is useful to have TypeScript narrow a `T | undefined` value to `T` in a concise way.
 */
export function assertDefined<T>(
  value: T,
  ...[msg]: [undefined] extends [T]
    ? [string]
    : [
        "The assertion is useless because the provided value does not contain undefined.",
      ]
): asserts value is Exclude<T, undefined> {
  if (value === undefined) {
    error(msg);
  }
}

/**
 * Helper function to throw an error (using the `error` Lua function) if the provided value is equal
 * to `null`.
 *
 * This is useful to have TypeScript narrow a `T | null` value to `T` in a concise way.
 */
export function assertNotNull<T>(
  value: T,
  ...[msg]: [null] extends [T]
    ? [string]
    : [
        "The assertion is useless because the provided value does not contain null.",
      ]
): asserts value is Exclude<T, null> {
  if (value === null) {
    error(msg);
  }
}

/**
 * Helper function to return an array of integers with the specified range, inclusive on the lower
 * end and exclusive on the high end. (The "e" in the function name stands for exclusive.) Thus,
 * this function works in a similar way as the built-in `range` function from Python.
 *
 * If the end is lower than the start, an empty array will be returned.
 *
 * For example:
 *
 * - `eRange(2)` returns `[0, 1]`.
 * - `eRange(3)` returns `[0, 1, 2]`.
 * - `eRange(-3)` returns `[0, -1, -2]`.
 * - `eRange(1, 3)` returns `[1, 2]`.
 * - `eRange(2, 5)` returns `[2, 3, 4]`.
 * - `eRange(5, 2)` returns `[]`.
 * - `eRange(3, 3)` returns `[]`.
 *
 * @param start The integer to start at.
 * @param end Optional. The integer to end at. If not specified, then the start will be 0 and the
 *            first argument will be the end.
 * @param increment Optional. The increment to use. Default is 1.
 */
export function eRange(start: int, end?: int, increment = 1): readonly int[] {
  if (end === undefined) {
    return eRange(0, start, increment);
  }

  const array: int[] = [];

  for (let i = start; i < end; i += increment) {
    array.push(i);
  }

  return array;
}

/**
 * Helper function to log what is happening in functions that recursively move through nested data
 * structures.
 */
export function getTraversalDescription(
  key: unknown,
  traversalDescription: string,
): string {
  if (traversalDescription !== "") {
    traversalDescription += " --> ";
  }

  traversalDescription += tostring(key);

  return traversalDescription;
}

/**
 * Helper function to return an array of integers with the specified range, inclusive on both ends.
 * (The "i" in the function name stands for inclusive.)
 *
 * If the end is lower than the start, an empty array will be returned.
 *
 * For example:
 *
 * - `iRange(2)` returns `[0, 1, 2]`.
 * - `iRange(3)` returns `[0, 1, 2, 3]`.
 * - `iRange(-3)` returns `[0, -1, -2, -3]`.
 * - `iRange(1, 3)` returns `[1, 2, 3]`.
 * - `iRange(2, 5)` returns `[2, 3, 4, 5]`.
 * - `iRange(5, 2)` returns `[]`.
 * - `iRange(3, 3)` returns `[3]`.
 *
 * @param start The integer to start at.
 * @param end Optional. The integer to end at. If not specified, then the start will be 0 and the
 *            first argument will be the end.
 * @param increment Optional. The increment to use. Default is 1.
 */
export function iRange(start: int, end?: int, increment = 1): readonly int[] {
  if (end === undefined) {
    return iRange(0, start, increment);
  }

  const exclusiveEnd = end + 1;
  return eRange(start, exclusiveEnd, increment);
}

/**
 * Helper function to check if a variable is within a certain range, inclusive on both ends.
 *
 * - For example, `inRange(1, 1, 3)` will return `true`.
 * - For example, `inRange(0, 1, 3)` will return `false`.
 *
 * @param num The number to check.
 * @param start The start of the range to check.
 * @param end The end of the range to check.
 */
export function inRange(num: int, start: int, end: int): boolean {
  return num >= start && num <= end;
}

/**
 * Helper function to detect if there is two or more players currently playing.
 *
 * Specifically, this function looks for unique `ControllerIndex` values across all players.
 *
 * This function is not safe to use in the `POST_PLAYER_INIT` callback, because the
 * `ControllerIndex` will not be set properly. As a workaround, you can use it in the
 * `POST_PLAYER_INIT_FIRST` callback (or some other callback like `POST_UPDATE`).
 */
export function isMultiplayer(): boolean {
  const players = getAllPlayers();
  const controllerIndexes = players.map((player) => player.ControllerIndex);
  const controllerIndexesSet = new ReadonlySet(controllerIndexes);

  return controllerIndexesSet.size > 1;
}

/**
 * Helper function to check if the player is using Afterbirth+ or Repentance.
 *
 * This function should always be used over the `REPENTANCE` constant, since the latter is not safe.
 *
 * Specifically, this function checks for the `Sprite.GetAnimation` method:
 * https://bindingofisaacrebirth.fandom.com/wiki/V1.06.J818#Lua_Changes
 */
export function isRepentance(): boolean {
  const metatable = getmetatable(Sprite) as LuaMap<string, unknown> | undefined;
  assertDefined(
    metatable,
    "Failed to get the metatable of the Sprite global table.",
  );

  const classTable = metatable.get("__class") as
    | LuaMap<string, unknown>
    | undefined;
  assertDefined(
    classTable,
    'Failed to get the "__class" key of the Sprite metatable.',
  );

  const getAnimation = classTable.get("GetAnimation");
  return isFunction(getAnimation);
}

/**
 * Helper function to repeat code N times. This is faster to type and cleaner than using a for loop.
 *
 * For example:
 *
 * ```ts
 * const player = Isaac.GetPlayer();
 * repeat(10, () => {
 *   player.AddCollectible(CollectibleType.STEVEN);
 * });
 * ```
 *
 * The repeated function is passed the index of the iteration, if needed:
 *
 * ```ts
 * repeat(3, (i) => {
 *   print(i); // Prints "0", "1", "2"
 * });
 * ```
 */
export function repeat(num: int, func: (i: int) => void): void {
  for (let i = 0; i < num; i++) {
    func(i);
  }
}

/**
 * Helper function to signify that the enclosing code block is not yet complete. Using this function
 * is similar to writing a "TODO" comment, but it has the benefit of preventing ESLint errors due to
 * unused variables or early returns.
 *
 * When you see this function, it simply means that the programmer intends to add in more code to
 * this spot later.
 *
 * This function is variadic, meaning that you can pass as many arguments as you want. (This is
 * useful as a means to prevent unused variables.)
 *
 * This function does not actually do anything. (It is an "empty" function.)
 *
 * @allowEmptyVariadic
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
export function todo(...args: readonly unknown[]): void {}

----
functions\vector.ts
import type {
  CopyableIsaacAPIClassType,
  Direction,
} from "isaac-typescript-definitions";
import { SerializationBrand } from "../enums/private/SerializationBrand";
import { angleToDirection } from "./direction";
import { isIsaacAPIClassOfType, isaacAPIClassEquals } from "./isaacAPIClass";
import { getRandomFloat } from "./random";
import { isRNG, newRNG } from "./rng";
import {
  copyUserdataValuesToTable,
  getNumbersFromTable,
  tableHasKeys,
} from "./table";
import { isTable } from "./types";
import { assertDefined } from "./utils";

export type SerializedVector = LuaMap<string, unknown> & {
  readonly __serializedVectorBrand: symbol;
  readonly __kind: CopyableIsaacAPIClassType.VECTOR;
};

const OBJECT_NAME = "Vector";
const KEYS = ["X", "Y"] as const;

/** Helper function to copy a `Vector` Isaac API class. */
export function copyVector(vector: Vector): Vector {
  if (!isVector(vector)) {
    error(
      `Failed to copy a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  return Vector(vector.X, vector.Y);
}

/**
 * Helper function to convert a `SerializedVector` object to a normal `RNG` object. (This is used by
 * the save data manager when reading data from the "save#.dat" file.)
 */
export function deserializeVector(vector: SerializedVector): Vector {
  if (!isTable(vector)) {
    error(
      `Failed to deserialize a ${OBJECT_NAME} object since the provided object was not a Lua table.`,
    );
  }

  const [x, y] = getNumbersFromTable(vector, OBJECT_NAME, ...KEYS);

  assertDefined(
    x,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: X`,
  );
  assertDefined(
    y,
    `Failed to deserialize a ${OBJECT_NAME} object since the provided object did not have a value for: Y`,
  );

  return Vector(x, y);
}

/**
 * Helper function to measure a vector to see if it has a non-zero length using a threshold to
 * ignore extremely small values.
 *
 * Use this function instead of explicitly checking if the length is 0 because vectors in the game
 * are unlikely to ever be exactly set to 0. Instead, they will always have some miniscule length.
 *
 * @param vector The vector to measure.
 * @param threshold Optional. The threshold from 0 to consider to be a non-zero vector. Default is
 *                  0.01.
 */
export function doesVectorHaveLength(
  vector: Vector,
  threshold = 0.01,
): boolean {
  return vector.Length() >= threshold;
}

/**
 * Given an array of vectors, this helper function returns the closest one to a provided reference
 * vector.
 *
 * @param referenceVector The vector to compare against.
 * @param vectors The array of vectors to look through.
 */
export function getClosestVectorTo(
  referenceVector: Vector,
  vectors: readonly Vector[],
): Vector | undefined {
  let closestVector: Vector | undefined;
  let closestDistance = Number.POSITIVE_INFINITY;
  for (const vector of vectors) {
    const distance = referenceVector.Distance(vector);

    if (distance < closestDistance) {
      closestVector = vector;
      closestDistance = distance;
    }
  }

  return closestVector;
}

/**
 * Helper function to get a random vector between (-1, -1) and (1, 1).
 *
 * To get random vectors with a bigger length, multiply this with a number.
 *
 * Use this over the `RandomVector` function when you need the vector to be seeded.
 *
 * If you want to generate an unseeded vector, you must explicitly pass `undefined` to the
 * `seedOrRNG` parameter.
 *
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandomVector(
  seedOrRNG: Seed | RNG | undefined,
): Readonly<Vector> {
  const rng = isRNG(seedOrRNG) ? seedOrRNG : newRNG(seedOrRNG);

  const x = getRandomFloat(-1, 1, rng);
  const y = getRandomFloat(-1, 1, rng);

  return Vector(x, y);
}

/**
 * Used to determine is the given table is a serialized `Vector` object created by the `deepCopy`
 * function.
 */
export function isSerializedVector(
  object: unknown,
): object is SerializedVector {
  if (!isTable(object)) {
    return false;
  }

  return tableHasKeys(object, ...KEYS) && object.has(SerializationBrand.VECTOR);
}

/** Helper function to check if something is an instantiated `Vector` object. */
export function isVector(object: unknown): object is Vector {
  return isIsaacAPIClassOfType(object, OBJECT_NAME);
}

/**
 * Helper function to convert a `Vector` object to a `SerializedVector` object. (This is used by the
 * save data manager when writing data from the "save#.dat" file.)
 */
export function serializeVector(vector: Vector): SerializedVector {
  if (!isVector(vector)) {
    error(
      `Failed to serialize a ${OBJECT_NAME} object since the provided object was not a userdata ${OBJECT_NAME} class.`,
    );
  }

  const vectorTable = new LuaMap<string, unknown>();
  copyUserdataValuesToTable(vector, KEYS, vectorTable);
  vectorTable.set(SerializationBrand.VECTOR, "");
  return vectorTable as SerializedVector;
}

/**
 * Helper function to compare two vectors for equality.
 *
 * This function is useful because vectors are not directly comparable. In other words, `Vector(1.2)
 * === Vector(1.2)` will be equal to false.
 */
export function vectorEquals(vector1: Vector, vector2: Vector): boolean {
  return isaacAPIClassEquals(vector1, vector2, KEYS);
}

/** Helper function for finding out which way a vector is pointing. */
export function vectorToDirection(vector: Vector): Direction {
  const angleDegrees = vector.GetAngleDegrees();
  return angleToDirection(angleDegrees);
}

/**
 * Helper function to convert a vector to a string.
 *
 * @param vector The vector to convert.
 * @param round Optional. If true, will round the vector values to the nearest integer. Default is
 *              false.
 */
export function vectorToString(vector: Vector, round = false): string {
  const x = round ? Math.round(vector.X) : vector.X;
  const y = round ? Math.round(vector.Y) : vector.Y;
  return `(${x}, ${y})`;
}

----
functions\versusScreen.ts
import type { BossID, PlayerType } from "isaac-typescript-definitions";
import { BOSS_NAME_PNG_FILE_NAMES } from "../objects/bossNamePNGFileNames";
import { BOSS_PORTRAIT_PNG_FILE_NAMES } from "../objects/bossPortraitPNGFileNames";
import { PLAYER_NAME_PNG_FILE_NAMES } from "../objects/playerNamePNGFileNames";
import { PLAYER_PORTRAIT_PNG_FILE_NAMES } from "../objects/playerPortraitPNGFileNames";

/** Most of the PNG files related to the versus screen are located in this directory. */
const PNG_PATH_PREFIX = "gfx/ui/boss";

/**
 * Player portraits are not located in the same directory as everything else, since they are re-used
 * from the animation where the player travels to a new stage.
 */
const PLAYER_PORTRAIT_PNG_PATH_PREFIX = "gfx/ui/stage";

/**
 * Helper function to get the path to the name file that corresponds to the graphic shown on the
 * versus screen for the particular boss.
 *
 * For example, the file path for `BossID.MONSTRO` is "gfx/ui/boss/bossname_20.0_monstro.png".
 */
export function getBossNamePNGFilePath(bossID: BossID): string {
  const fileName = BOSS_NAME_PNG_FILE_NAMES[bossID];
  return `${PNG_PATH_PREFIX}/${fileName}`;
}

/**
 * Helper function to get the path to the portrait file that corresponds to the graphic shown on the
 * versus screen for the particular boss.
 *
 * For example, the file path for `BossID.MONSTRO` is "gfx/ui/boss/portrait_20.0_monstro.png".
 */
export function getBossPortraitPNGFilePath(bossID: BossID): string {
  const fileName = BOSS_PORTRAIT_PNG_FILE_NAMES[bossID];
  return `${PNG_PATH_PREFIX}/${fileName}`;
}

/**
 * Helper function to get the path to the name file that corresponds to the graphic shown on the
 * versus screen for the particular character.
 *
 * For example, the file path for `PlayerType.ISAAC` is "gfx/ui/boss/playername_01_isaac.png".
 */
export function getCharacterNamePNGFilePath(character: PlayerType): string {
  const fileName = PLAYER_NAME_PNG_FILE_NAMES[character];
  return `${PNG_PATH_PREFIX}/${fileName}`;
}

/**
 * Helper function to get the path to the portrait file that corresponds to the graphic shown on the
 * versus screen for the particular character.
 *
 * For example, the file path for `PlayerType.ISAAC` is "gfx/ui/boss/playerportrait_isaac.png".
 */
export function getCharacterPortraitPNGFilePath(character: PlayerType): string {
  const fileName = PLAYER_PORTRAIT_PNG_FILE_NAMES[character];
  return `${PLAYER_PORTRAIT_PNG_PATH_PREFIX}/${fileName}`;
}

----
functions\weighted.ts
import type { WeightedArray } from "../types/WeightedArray";
import { sumArray } from "./array";
import { getRandomFloat } from "./random";
import { assertDefined } from "./utils";

/**
 * Get a random value from a `WeightedArray`. (A `WeightedArray` is an array of tuples, where the
 * first element in the tuple is a value, and the second element in the tuple is a float
 * corresponding to the value's weight.)
 *
 * If you want to get an unseeded element, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param weightedArray The array to pick from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandomFromWeightedArray<T>(
  weightedArray: Readonly<WeightedArray<T>>,
  seedOrRNG: Seed | RNG | undefined,
): T {
  const randomIndex = getRandomIndexFromWeightedArray(weightedArray, seedOrRNG);

  const randomElement = weightedArray[randomIndex];
  assertDefined(
    randomElement,
    `Failed to get an element from a weighted array using a random index of: ${randomIndex}`,
  );

  return randomElement[0];
}

/**
 * Get a random index from a `WeightedArray`. (A `WeightedArray` is an array of tuples, where the
 * first element in the tuple is a value, and the second element in the tuple is a float
 * corresponding to the value's weight.)
 *
 * If you want to get an unseeded index, you must explicitly pass `undefined` to the `seedOrRNG`
 * parameter.
 *
 * @param weightedArray The array to pick from.
 * @param seedOrRNG The `Seed` or `RNG` object to use. If an `RNG` object is provided, the
 *                  `RNG.Next` method will be called. If `undefined` is provided, it will default to
 *                  a random seed.
 */
export function getRandomIndexFromWeightedArray<T>(
  weightedArray: Readonly<WeightedArray<T>>,
  seedOrRNG: Seed | RNG | undefined,
): int {
  if (weightedArray.length === 0) {
    error(
      "Failed to get a random index from a weighted array since the provided array was empty.",
    );
  }

  const weights = weightedArray.map((tuple) => tuple[1]);
  const totalWeight = sumArray(weights);
  const randomWeight = getRandomFloat(0, totalWeight, seedOrRNG);

  let weightAccumulator = 0;
  for (const [i, tuple] of weightedArray.entries()) {
    const [_element, weight] = tuple;

    weightAccumulator += weight;
    if (weightAccumulator >= randomWeight) {
      return i;
    }
  }

  error("Failed to get a random index from a weighted array.");
}

----
index.ts
export * from "./classes/DefaultMap";
export * from "./classes/ModFeature";
export * from "./classes/ModUpgraded";
export * from "./core/cachedClasses";
export * from "./core/constants";
export * from "./core/constantsFirstLast";
export * from "./core/constantsVanilla";
export * from "./core/upgradeMod";
export * from "./enums/AmbushType";
export * from "./enums/CornerType";
export * from "./enums/HealthType";
export * from "./enums/ISCFeature";
export * from "./enums/LadderSubTypeCustom";
export * from "./enums/ModCallbackCustom";
export * from "./enums/MysteriousPaperEffect";
export * from "./enums/PlayerStat";
export * from "./enums/PocketItemType";
export * from "./enums/RockAltType";
export * from "./enums/SaveDataKey";
export * from "./enums/SerializationType";
export * from "./enums/SlotDestructionType";
export * from "./functions/ambush";
export * from "./functions/array";
export * from "./functions/arrayLua";
export * from "./functions/benchmark";
export * from "./functions/bitSet128";
export * from "./functions/bitwise";
export * from "./functions/bombs";
export * from "./functions/bosses";
export * from "./functions/cards";
export * from "./functions/challenges";
export * from "./functions/characters";
export * from "./functions/charge";
export * from "./functions/chargeBar";
export * from "./functions/collectibleTag";
export * from "./functions/collectibles";
export * from "./functions/color";
export * from "./functions/console";
export * from "./functions/curses";
export * from "./functions/debugFunctions";
export * from "./functions/decorators";
export * from "./functions/deepCopy";
export * from "./functions/deepCopyTests";
export * from "./functions/dimensions";
export * from "./functions/direction";
export * from "./functions/doors";
export * from "./functions/easing";
export * from "./functions/effects";
export * from "./functions/emptyRoom";
export * from "./functions/entities";
export * from "./functions/entitiesSpecific";
export * from "./functions/entityTypes";
export * from "./functions/enums";
export * from "./functions/external";
export * from "./functions/familiars";
export * from "./functions/flag";
export * from "./functions/frames";
export * from "./functions/globals";
export * from "./functions/gridEntities";
export * from "./functions/gridEntitiesSpecific";
export * from "./functions/gridIndex";
export * from "./functions/hash";
export * from "./functions/hex";
export * from "./functions/input";
export * from "./functions/isaacAPIClass";
export * from "./functions/itemPool";
export * from "./functions/jsonHelpers";
export * from "./functions/jsonRoom";
export * from "./functions/kColor";
export * from "./functions/language";
export * from "./functions/level";
export * from "./functions/levelGrid";
export * from "./functions/log";
export * from "./functions/logEntities";
export * from "./functions/logMisc";
export * from "./functions/map";
export * from "./functions/math";
export * from "./functions/merge";
export * from "./functions/mergeTests";
export * from "./functions/minimap";
export * from "./functions/modFeatures";
export * from "./functions/newArray";
export * from "./functions/nextStage";
export * from "./functions/npcDataStructures";
export * from "./functions/npcs";
export * from "./functions/pickupVariants";
export * from "./functions/pickups";
export * from "./functions/pickupsSpecific";
export * from "./functions/pills";
export * from "./functions/playerCenter";
export * from "./functions/playerCollectibles";
export * from "./functions/playerDataStructures";
export * from "./functions/playerEffects";
export * from "./functions/playerHealth";
export * from "./functions/playerIndex";
export * from "./functions/playerTrinkets";
export * from "./functions/players";
export * from "./functions/pocketItems";
export * from "./functions/positionVelocity";
export * from "./functions/pressurePlate";
export * from "./functions/projectiles";
export * from "./functions/random";
export * from "./functions/readOnly";
export * from "./functions/render";
export * from "./functions/revive";
export * from "./functions/rng";
export * from "./functions/rockAlt";
export * from "./functions/roomData";
export * from "./functions/roomGrid";
export * from "./functions/roomShape";
export * from "./functions/roomShapeWalls";
export * from "./functions/roomTransition";
export * from "./functions/rooms";
export * from "./functions/run";
export * from "./functions/seeds";
export * from "./functions/serialization";
export * from "./functions/set";
export * from "./functions/slots";
export * from "./functions/sort";
export * from "./functions/sound";
export * from "./functions/spawnCollectible";
export * from "./functions/sprites";
export * from "./functions/stage";
export * from "./functions/stats";
export * from "./functions/storyBosses";
export * from "./functions/string";
export * from "./functions/table";
export * from "./functions/tears";
export * from "./functions/transformations";
export * from "./functions/trinketGive";
export * from "./functions/trinkets";
export * from "./functions/tstlClass";
export * from "./functions/types";
export * from "./functions/ui";
export * from "./functions/utils";
export * from "./functions/vector";
export * from "./functions/versusScreen";
export * from "./functions/weighted";
export * from "./interfaces/ChargeBarSprites";
export * from "./interfaces/Corner";
export * from "./interfaces/CustomStageTSConfig";
export * from "./interfaces/GridEntityCustomData";
export * from "./interfaces/JSONRoomsFile";
export * from "./interfaces/PlayerHealth";
export * from "./interfaces/PlayerStats";
export * from "./interfaces/PocketItemDescription";
export * from "./interfaces/RoomDescription";
export * from "./interfaces/SaveData";
export * from "./interfaces/StageHistoryEntry";
export * from "./interfaces/TSTLClassMetatable";
export * from "./interfaces/TrinketSituation";
export * from "./maps/cardNameToTypeMap";
export * from "./maps/characterNameToTypeMap";
export * from "./maps/collectibleNameToTypeMap";
export * from "./maps/pillNameToEffectMap";
export * from "./maps/roomNameToTypeMap";
export * from "./maps/transformationNameToPlayerFormMap";
export * from "./maps/trinketNameToTypeMap";
export * from "./objects/colors";
export * from "./objects/kColors";
export * from "./types/AddSubtract";
export * from "./types/AllButFirst";
export * from "./types/AllButLast";
export * from "./types/AnyClass";
export * from "./types/AnyEntity";
export * from "./types/AnyFunction";
export * from "./types/AnyGridEntity";
export * from "./types/CompositionTypeSatisfiesEnum";
export * from "./types/ConversionHeartSubType";
export * from "./types/Decrement";
export * from "./types/ERange";
export * from "./types/EntityID";
export * from "./types/FunctionTuple";
export * from "./types/GridEntityID";
export * from "./types/HasFunction";
export * from "./types/IRange";
export * from "./types/Immutable";
export * from "./types/Increment";
export * from "./types/LowercaseKeys";
export * from "./types/NaturalNumbersLessThan";
export * from "./types/NaturalNumbersLessThanOrEqualTo";
export * from "./types/PickingUpItem";
export * from "./types/PickupIndex";
export * from "./types/PlayerIndex";
export * from "./types/PossibleStatType";
export * from "./types/PublicInterface";
export * from "./types/ReadonlyMap";
export * from "./types/ReadonlyRecord";
export * from "./types/ReadonlySet";
export * from "./types/StartsWithLowercase";
export * from "./types/StartsWithUppercase";
export * from "./types/TSTLClass";
export * from "./types/Tuple";
export * from "./types/TupleKeys";
export * from "./types/TupleToIntersection";
export * from "./types/TupleToUnion";
export * from "./types/TupleWithLengthBetween";
export * from "./types/TupleWithMaxLength";
export * from "./types/UnionToIntersection";
export * from "./types/UppercaseKeys";
export * from "./types/WeightedArray";
export * from "./types/WidenLiteral";
export * from "./types/Writable";

----
interfaces\ChargeBarSprites.ts
/**
 * A collection of the four sprites necessary in order to render a charge bar.
 *
 * This is used in the `newChargeBarSprites` and related helper functions.
 */
export interface ChargeBarSprites {
  back: Sprite;
  meter: Sprite;
  meterBattery: Sprite;
  lines: Sprite;
  maxCharges: int;
}

----
interfaces\Corner.ts
import type { CornerType } from "../enums/CornerType";

/**
 * An interface representing a corner in the room.
 *
 * This is used by the `getRoomShapeCorners` helper function.
 */
export interface Corner {
  readonly type: CornerType;

  /** The grid index of the corresponding wall tile. */
  readonly gridIndex: int;

  /**
   * The position is not the same as the center of the corresponding grid index. Rather, it is the
   * exact position of the corner, which will be offset from the grid index position by half of a
   * grid tile.
   */
  readonly position: Readonly<Vector>;
}

----
interfaces\CustomStageTSConfig.ts
import type { Immutable } from "../types/Immutable";

/**
 * This is the format of a custom stage in the "isaacscript" section of the "tsconfig.json" file.
 *
 * The contents of this interface are used to create a "tsconfig-isaacscript-section-schema.json"
 * schema with the "ts-json-schema-generator" library.
 *
 * The contents of this interface are validated at run-time against the schema.
 *
 * The `CustomStageLua` interface extends this, adding room metadata.
 */
export interface CustomStageTSConfig {
  /** Mandatory. The name of the custom stage. */
  name: string;

  /**
   * Mandatory. The path to the XML file that contains the rooms for the custom stage (created with
   * Basement Renovator).
   */
  xmlPath: string;

  /**
   * Mandatory. An arbitrarily chosen prefix in the range of 101-999 that will be unique to this
   * stage.
   *
   * Use a value of 100 when testing locally. When publishing to the workshop or otherwise
   * distributing your mod, make sure that you have chosen a prefix that does not conflict with any
   * other mods. You can find a list of registered room variant prefixes on the IsaacScript website:
   * https://isaacscript.github.io/main/custom-stages
   *
   * @minimum 100
   * @maximum 999
   */
  roomVariantPrefix: number;

  /**
   * Optional. An integer between 2 and 13, corresponding to the `LevelStage` enum. This is the
   * number of the stage that will be warped to and used as a basis for the stage by the level
   * generation algorithm.
   *
   * For example, if you wanted to have a custom stage with a small amount of rooms per floor, then
   * you should choose 2 as a base. (This would copy the number of rooms that would appear in
   * Basement 2.) And if you wanted to have a custom stage with the maximum amount of rooms, then
   * you should choose 13 as a base. (This would copy the number of rooms that would appear on The
   * Void.)
   *
   * It is not possible to use Basement 1 as a base stage due to conflicts with the `Game.SetStage`
   * method.
   *
   * If not specified, `LevelStage.BASEMENT_2` (2) will be used.
   *
   * @minimum 2
   * @maximum 13
   */
  baseStage?: number;

  /**
   * Optional. An integer between 0 and 5, corresponding to the `StageType` enum. This is the number
   * of the stage type that will be warped to and used as a basis for the stage by the level
   * generation algorithm.
   *
   * If not specified, `StageType.ORIGINAL` (0) will be used.
   *
   * @minimum 0
   * @maximum 5
   */
  baseStageType?: number;

  /**
   * Optional. A string that represents the name of the music track from the "content/music.xml"
   * file that corresponds to this custom stage. It will be manually played upon entering the stage.
   *
   * If not specified, the same music track as the base stage will be used.
   */
  music?: string;

  /**
   * Optional. An object containing the paths to the backdrop graphics for the stage. (A backdrop is
   * the graphics for the walls and floor.) If not specified, the graphics for Basement will be
   * used.
   */
  backdropPNGPaths?: {
    /**
     * An array that contains the full paths to the graphic files that are used for the floor in
     * narrow rooms. (The "n" stands for "narrow").
     *
     * You must have at least one path in this array, but you can specify more than one to randomly
     * add extra variety (like the vanilla stages do).
     *
     * For an example of this, see the vanilla file "resources/gfx/backdrop/01_basement_nfloor.png".
     */
    nFloors: string[];

    /**
     * An array that contains the full paths to the graphic files that are used for the floor in L
     * rooms.
     *
     * You must have at least one path in this array, but you can specify more than one to randomly
     * add extra variety (like the vanilla stages do).
     *
     * For an example of this, see the vanilla file "resources/gfx/backdrop/01_lbasementfloor.png".
     */
    lFloors: string[];

    /**
     * An array that contains the full paths to the graphic files that are used for the walls of the
     * floor.
     *
     * You must have at least one path in this array, but you can specify more than one to randomly
     * add extra variety (like the vanilla stages do).
     *
     * For an example of this, see the vanilla file "resources/gfx/backdrop/01_basement.png". (In
     * the vanilla file, they concatenate all four variations together into one PNG file. However,
     * for the custom stages feature, you must separate each wall variation into a separate file.)
     */
    walls: string[];

    /**
     * An array that contains the full paths to the graphic files for the stage's corners.
     *
     * You must have at least one path in this array, but you can specify more than one to randomly
     * add extra variety (like the vanilla stages do).
     *
     * For an example of this, see the vanilla file "resources/gfx/backdrop/01_basement.png". (In
     * the vanilla file, they concatenate both variations together into one PNG file and put it in
     * the top right hand corner. The corners are shown in the top right hand corner of the file,
     * with two different variations concatenated together. However, for the custom stages feature,
     * you must separate each corner variation into a separate file (and put it in a different file
     * from the walls).
     */
    corners: string[];
  };

  /**
   * Optional. The full path to the spritesheet that contains the graphics of the decorations for
   * the floor.
   *
   * If not specified, the vanilla Basement decorations spritesheet will be used. For reference,
   * this is located at: `resources/gfx/grid/props_01_basement.png`
   *
   * If you want to have custom animations for your decorations, then do not use this field and use
   * `decorationsANM2Path` instead.
   */
  decorationsPNGPath?: string;

  /**
   * Optional. The full path to the anm2 file that contains the custom animations for the
   * decorations of the floor.
   *
   * If not specified, the vanilla Basement decorations spritesheet will be used. For reference,
   * this is located at: `resources/gfx/grid/props_01_basement.png`
   *
   * If you do not want to have custom animations for your decorations, then do not use this field
   * and use `decorationsPNGPath` instead.
   */
  decorationsANM2Path?: string;

  /**
   * Optional. The full path to the spritesheet that contains the graphics of the rocks/blocks/urns
   * for the floor.
   *
   * If specified, it is assumed that you have your own custom rock alt type, and all vanilla
   * rewards/enemies that spawn from urns will be automatically removed. Use the
   * `POST_GRID_ENTITY_BROKEN` callback to make your own custom rewards. Or, if you want to emulate
   * a vanilla urn/mushroom/skull/polyp/bucket, use the `spawnRockAltReward` helper function.
   *
   * If not specified, the vanilla Basement rocks spritesheet will be used. For reference, this is
   * located at: `resources-dlc3/gfx/grid/rocks_basement.png`
   *
   * If you want to have custom animations for your rocks, then do not use this field and use
   * `rocksANM2Path` instead.
   */
  rocksPNGPath?: string;

  /**
   * Optional. The full path to the anm2 file that contains the custom animations for the
   * rocks/blocks/urns of the floor.
   *
   * If specified, it is assumed that you have your own custom rock alt type, and all vanilla
   * rewards/enemies that spawn from urns will be automatically removed. Use the
   * `POST_GRID_ENTITY_BROKEN` callback to make your own custom rewards. Or, if you want to emulate
   * a vanilla urn/mushroom/skull/polyp/bucket, use the `spawnRockAltReward` helper function.
   *
   * If not specified, the vanilla Basement rocks spritesheet will be used. For reference, this is
   * located at: `resources-dlc3/gfx/grid/rocks_basement.png`
   *
   * If you do not want to have custom animations for your rocks, then do not use this field and use
   * `rocksPNGPath` instead.
   */
  rocksANM2Path?: string;

  /**
   * Optional. The full path to the spritesheet that contains the graphics of the pits for the
   * floor.
   *
   * If not specified, the vanilla Basement pits spritesheet will be used. For reference, this is
   * located at: `resources/gfx/grid/grid_pit.png`
   *
   * If you do not want to have custom animations for your pits, then do not use this field and use
   * `pitsANM2Path` instead.
   */
  pitsPNGPath?: string;

  /**
   * Optional. The full path to the anm2 file that contains the custom animations for the pits of
   * the floor.
   *
   * If not specified, the vanilla Basement pits spritesheet will be used. For reference, this is
   * located at: `resources/gfx/grid/grid_pit.png`
   *
   * If you do not want to have custom animations for your pits, then do not use this field and use
   * `pitsPNGPath` instead.
   */
  pitsANM2Path?: string;

  /**
   * Optional. A collection of paths that contain graphics for the doors of the floor. If not
   * specified, the doors for Basement will be used.
   */
  doorPNGPaths?: {
    /**
     * Optional. The full path to the spritesheet that contains the graphics of the normal doors for
     * the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_01_normaldoor.png`
     */
    normal?: string; // RoomType.DEFAULT (1)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Treasure Room
     * doors for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_02_treasureroomdoor.png`
     */
    treasureRoom?: string; // RoomType.TREASURE (4)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Boss Room doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_10_bossroomdoor.png`
     */
    bossRoom?: string; // RoomType.BOSS (5)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Secret Room and
     * Super Secret Room doors for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_08_holeinwall.png`
     */
    secretRoom?: string; // RoomType.SECRET (7) and RoomType.SUPER_SECRET (8)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the arcade doors for
     * the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_05_arcaderoomdoor.png`
     */
    arcade?: string; // RoomType.ARCADE (9)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Curse Room doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_04_selfsacrificeroomdoor.png`
     */
    curseRoom?: string; // RoomType.CURSE (10)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the normal Challenge
     * Room doors for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_03_ambushroomdoor.png`
     */
    normalChallengeRoom?: string; // RoomType.CHALLENGE (11)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Boss Challenge
     * Room doors for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_09_bossambushroomdoor.png`
     */
    bossChallengeRoom?: string; // RoomType.CHALLENGE (11)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Devil Room doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_07_devilroomdoor.png`
     */
    devilRoom?: string; // RoomType.DEVIL (14)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Angel Room doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_07_holyroomdoor.png`
     */
    angelRoom?: string; // RoomType.ANGEL (15)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Boss Rush doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_15_bossrushdoor.png`
     */
    bossRush?: string; // RoomType.BOSS_RUSH (17)

    /**
     * Optional. The full path to the spritesheet that contains the graphics of the Chest Room doors
     * for the floor.
     *
     * If not specified, the vanilla Basement door spritesheet will be used. For reference, this is
     * located at: `resources/gfx/grid/door_02b_chestroomdoor.png`
     */
    chestRoom?: string; // RoomType.CHEST (20)
  };

  /**
   * Optional. An array of shadow objects that describe the graphics for the custom shadows of the
   * floor. (In this context, "shadows" are the outlines from things on the roof. For example, in
   * Basement, a shadow of a sideways V is used, among others.) If not specified, no extra shadows
   * will be drawn.
   */
  shadows?: {
    /**
     * Optional. An array containing the shadows that will be used in rooms of shape
     * `RoomShape.SHAPE_1x1` (1), `RoomShape.IH` (2), and `RoomShape.IV` (3).
     *
     * If more than one shadow is specified, one will be randomly chosen for each room.
     *
     * If not specified, no extra shadows will be drawn in these room shapes.
     */
    "1x1"?: CustomStageShadow[];

    /**
     * Optional. An array containing the shadows that will be used in rooms of shape
     * `RoomShape.SHAPE_1x2` (4) and `RoomShape.IIV` (5).
     *
     * If more than one shadow is specified, one will be randomly chosen for each room.
     *
     * If not specified, no extra shadows will be drawn in these room shapes.
     */
    "1x2"?: CustomStageShadow[];

    /**
     * Optional. An array containing the shadows that will be used in rooms of shape
     * `RoomShape.SHAPE_2x1` (6) and `RoomShape.IIH` (7).
     *
     * If more than one shadow is specified, one will be randomly chosen for each room.
     *
     * If not specified, no extra shadows will be drawn in these room shapes.
     */
    "2x1"?: CustomStageShadow[];

    /**
     * Optional. An array containing the shadows that will be used in rooms of shape
     * `RoomShape.SHAPE_2x2` (8), `RoomShape.LTL` (9), `RoomShape.LTR` (10), `RoomShape.LBL` (11),
     * and `RoomShape.LBR` (12).
     *
     * If more than one shadow is specified, one will be randomly chosen for each room.
     *
     * If not specified, no extra shadows will be drawn in these room shapes.
     */
    "2x2"?: CustomStageShadow[];
  };

  /**
   * Optional. An array containing the bosses that should be used for the stage. This can include
   * both vanilla bosses and modded bosses.
   */
  bossPool?: CustomStageBossPoolEntry[];

  /**
   * Optional. A collection of colors used for in the boss "versus" screen for all of the bosses.
   *
   * Note that these graphics will only be applied if one or more bosses are specified in the
   * `bossPool` field.
   */
  versusScreen?: {
    /**
     * Optional. An object representing the color to use for the background of the boss "versus"
     * screen. If not specified, the color for Basement 1 will be used.
     *
     * For a list of the colors that correspond to the vanilla stages, see
     * `versusScreenBackgroundColors.ts`.
     */
    backgroundColor?: {
      /**
       * @minimum 0
       * @maximum 1
       */
      r: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      g: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      b: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      a: number;
    };

    /**
     * Optional. An object representing the color to use for the dirt spots in the boss "versus"
     * screen. (There are two dirt spots; one for the player and one for the boss.) If not
     * specified, the color for Basement 1 will be used.
     *
     * For a list of the colors that correspond to the vanilla stages, see
     * `versusScreenDirtSpotColors.ts`.
     */
    dirtSpotColor?: {
      /**
       * @minimum 0
       * @maximum 1
       */
      r: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      g: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      b: number;

      /**
       * @minimum 0
       * @maximum 1
       */
      a: number;
    };
  };
}

/**
 * A description of a custom stage shadow. (In this context, "shadows" are the outlines from things
 * on the roof. For example, in Basement, a shadow of a sideways V is used, among others.)
 */
export interface CustomStageShadow {
  /**
   * The full path to the shadow overlay PNG file.
   *
   * For an example of a vanilla shadow overlay, see:
   * `resources/gfx/overlays/basement/1x1_overlay_1.png`
   */
  pngPath: string;

  /**
   * Optional. An object representing the color used for the shadow.
   *
   * If not specified, an object of `{ r: 0, g: 0, b: 0, a: 0.25 }` will be used (which corresponds
   * to 75% faded black).
   */
  color?: {
    /**
     * @minimum 0
     * @maximum 1
     */
    r: number;

    /**
     * @minimum 0
     * @maximum 1
     */
    g: number;

    /**
     * @minimum 0
     * @maximum 1
     */
    b: number;

    /**
     * @minimum 0
     * @maximum 1
     */
    a: number;
  };
}

/**
 * An object that represents a possible boss for a custom stage. This can be for a vanilla boss or a
 * custom boss.
 */
export interface CustomStageBossPoolEntry {
  /**
   * The name of the boss. This should correspond to the entry for the boss in the "entities2.xml"
   * file.
   */
  name: string;

  /**
   * The arbitrary sub-type chosen for this boss, ranging between 1 and 999. You must set the boss
   * rooms for this boss to this sub-type in Basement Renovator by right-clicking on the room on the
   * right-hand-side.
   *
   * It does not matter if the arbitrary sub-type overlaps with any of the vanilla `BossID` values
   * (e.g. vanilla Boss Room sub-types in "00.special_rooms.stb"). It also does not matter if this
   * value overlaps with the values from other mods.
   *
   * If you are creating an entry for a vanilla boss, it is recommended that you match the sub-type
   * with the corresponding vanilla `BossID` value. This will make things a bit easier to understand
   * for people working on your mod, but is not a hard requirement.
   *
   * @minimum 1
   * @maximum 999
   */
  subType: number;

  /**
   * The weight of the boss. This is used when randomly selecting which boss to use for the floor.
   * For example, use a value of 1 if you want this boss to be equally likely as any other boss, 0.5
   * if you want it to be half as likely, 2 if you want it to be twice as likely, and so on.
   */
  weight: number;

  /** Optional. A collection of sprites used for the boss on the "versus" screen. */
  versusScreen?: {
    /**
     * Mandatory. The full path to the spritesheet that contains the graphics of the name of the
     * boss that will be displayed on the top of the boss "versus" screen.
     *
     * If not specified, a sprite showing "???" will be used.
     */
    namePNGPath: string;

    /**
     * Mandatory. The full path to the spritesheet that contains the portrait of the boss that will
     * be displayed on the right side of the boss "versus" screen.
     *
     * If not specified, a sprite showing "???" will be used.
     */
    portraitPNGPath: string;
  };
}

/** An intermediate type that is never actually used. See `CustomStageLua`. */
interface CustomStageLuaUnsafe extends CustomStageTSConfig {
  /**
   * This contains metadata about each room in a custom stage, which is used at run-time.
   * (Internally, the IsaacScript standard library uses this as a basis for determining which rooms
   * should randomly appear on the floor.)
   */
  roomsMetadata: CustomStageRoomMetadata[];
}

/**
 * An object that represents a custom stage. The "customStageMetadata.lua" file contains an array of
 * these objects. Besides the room metadata, the data is the same as what is specified inside the
 * "tsconfig.json" file.
 *
 * The `CustomStage` interface extends this, adding more data.
 */
export type CustomStageLua = Immutable<CustomStageLuaUnsafe>;

/**
 * Metadata about a custom stage room. Each custom stage object contains an array with metadata for
 * each room.
 */
export interface CustomStageRoomMetadata {
  type: number;
  variant: number;
  subType: number;
  shape: number;
  doorSlotFlags: number;
  weight: number;
}

----
interfaces\GridEntityCustomData.ts
import type {
  GridCollisionClass,
  GridEntityType,
} from "isaac-typescript-definitions";

/**
 * This is meta-data that describes a custom grid entity.
 *
 * (One of the extra features that the standard library offers is the ability to spawn custom grid
 * entities with the `spawnCustomGridEntity` helper function.)
 */
export interface GridEntityCustomData {
  /**
   * This is not a real `GridEntityType`; rather it is an arbitrary integer selected by end-user
   * mods.
   */
  gridEntityTypeCustom: GridEntityType;

  roomListIndex: int;
  gridIndex: int;
  gridCollisionClass?: GridCollisionClass;
  anm2Path?: string;
  defaultAnimation?: string;
}

----
interfaces\JSONRoomsFile.ts
/**
 * The standard library has the feature to deploy a new room on-the-fly with the `deployJSONRoom`
 * helper function. It requires a `JSONRoomsFile` as an argument, which is simply an XML file
 * converted to JSON. (You can create XML room files using the Basement Renovator program.)
 *
 * You can convert your XML files using the following command:
 *
 * ```sh
 * npx convert-xml-to-json foo.xml foo.json
 * ```
 *
 * Note that the custom stages feature of the standard library uses real XML/STB files, not JSON
 * rooms, so you would only need to do this if you are using the `deployJSONRoom` command
 * specifically.
 */
export interface JSONRoomsFile {
  rooms: JSONRooms;
}

/** Part of `JSONRoomsFile`. */
export interface JSONRooms {
  room: JSONRoom[];
}

/** Part of `JSONRoomsFile`. */
export interface JSONRoom {
  $: {
    /** Needs to be converted to an `int`. */
    difficulty: string;

    /** Needs to be converted to an `int`. */
    height: string;

    name: string;

    /** Needs to be converted to an `int`. */
    shape: string;

    /** Needs to be converted to an `int`. */
    subtype: string;

    /** Needs to be converted to an `int`. */
    type: string;

    /** Needs to be converted to an `int`. */
    variant: string;

    /** Needs to be converted to a `float`. */
    weight: string;

    /** Needs to be converted to an `int`. */
    width: string;
  };

  door: JSONDoor[];
  spawn: JSONSpawn[];
}

/** Part of `JSONRoomsFile`. */
export interface JSONDoor {
  $: {
    /** Equal to "True" or "False". Needs to be converted to an `boolean`. */
    exists: string;

    /** Needs to be converted to an `int`. */
    x: string;

    /** Needs to be converted to an `int`. */
    y: string;
  };
}

/** Part of `JSONRoomsFile`. */
export interface JSONSpawn {
  $: {
    /** Needs to be converted to an `int`. */
    x: string;

    /** Needs to be converted to an `int`. */
    y: string;
  };

  entity: JSONEntity[];
}

/** Part of `JSONRoomsFile`. */
export interface JSONEntity {
  $: {
    /** Needs to be converted to an `int`. */
    type: string;

    /** Needs to be converted to an `int`. */
    variant: string;

    /** Needs to be converted to an `int`. */
    subtype: string;

    /** Needs to be converted to a `float`. */
    weight: string;
  };
}

----
interfaces\PlayerHealth.ts
import type { HeartSubType } from "isaac-typescript-definitions";

/** This is used by the `getPlayerHealth` and `setPlayerHealth` helper functions. */
export interface PlayerHealth {
  maxHearts: int;
  hearts: int;
  eternalHearts: int;

  /** For soul hearts to apply, they also have to be specified in the `soulHeartTypes` array. */
  soulHearts: int;

  /** For bone hearts to apply, they also have to be specified in the `soulHeartTypes` array. */
  boneHearts: int;

  goldenHearts: int;
  rottenHearts: int;
  brokenHearts: int;
  soulCharges: int;
  bloodCharges: int;

  soulHeartTypes: SoulHeartType[];
}

export type SoulHeartType =
  | HeartSubType.SOUL // 3
  | HeartSubType.BLACK // 6
  | HeartSubType.BONE; // 11

----
interfaces\PlayerStats.ts
import type { TearFlag } from "isaac-typescript-definitions";
import type { PlayerStat } from "../enums/PlayerStat";
import { interfaceSatisfiesEnum } from "../functions/enums";

/**
 * Contains every player stat along with its corresponding data type. For example, `StatType.DAMAGE`
 * is a `float` type.
 */
export interface PlayerStats {
  [PlayerStat.DAMAGE]: float;
  [PlayerStat.FIRE_DELAY]: float;
  [PlayerStat.SHOT_SPEED]: float;
  [PlayerStat.TEAR_HEIGHT]: float;
  [PlayerStat.TEAR_RANGE]: float;
  [PlayerStat.TEAR_FALLING_ACCELERATION]: float;
  [PlayerStat.TEAR_FALLING_SPEED]: float;
  [PlayerStat.MOVE_SPEED]: float;
  [PlayerStat.TEAR_FLAG]: BitFlags<TearFlag>;
  [PlayerStat.TEAR_COLOR]: Color;
  [PlayerStat.FLYING]: boolean;
  [PlayerStat.LUCK]: float;
  [PlayerStat.SIZE]: Vector;
}

interfaceSatisfiesEnum<PlayerStats, PlayerStat>();

----
interfaces\PocketItemDescription.ts
import type { PocketItemSlot } from "isaac-typescript-definitions";
import type { PocketItemType } from "../enums/PocketItemType";

/** This is used by the `getPocketItems` and related helper functions. */
export interface PocketItemDescription {
  slot: PocketItemSlot;
  type: PocketItemType;
  subType: int;
}

----
interfaces\RoomDescription.ts
import type {
  Dimension,
  LevelStage,
  RoomType,
  StageID,
  StageType,
} from "isaac-typescript-definitions";

/** This is used by the room history feature of the standard library. */
export interface RoomDescription {
  startSeedString: string;
  stage: LevelStage;
  stageType: StageType;
  stageID: StageID | -1;
  dimension: Dimension;
  roomType: RoomType;
  roomVariant: int;
  roomSubType: int;
  roomName: string;
  roomGridIndex: int;
  roomListIndex: int;
  roomVisitedCount: int;
}

----
interfaces\SaveData.ts
/* eslint-disable @typescript-eslint/explicit-member-accessibility */
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable max-classes-per-file */

import type { CopyableIsaacAPIClass } from "../objects/isaacAPIClassTypeToFunctions";

/**
 * This is the format of the object that you give to the save data manager. It will contains all of
 * the variables for the particular mod feature.
 *
 * Depending on which object keys you use, the variables will automatically be reset at certain
 * times and automatically saved to disk.
 *
 * Each sub-object of save data has a string as a key and arbitrary data as a value. However, the
 * data has to be serializable. Specifically, this means that you can only use the following types:
 *
 * - `boolean`
 * - `number`
 * - `string`
 * - `undefined` (will be skipped over when saving)
 * - `null` (will be skipped over when saving)
 * - `Map` / `DefaultMap`
 * - `Set`
 * - serializable Isaac API classes (such as `Color`)
 * - TSTL classes (i.e. classes that you made yourself)
 * - sub-objects or a `LuaMap` that contains the above values
 */
export interface SaveData<
  Persistent = unknown,
  Run = unknown,
  Level = unknown,
> {
  persistent?: Serializable<Persistent>;
  run?: Serializable<Run>;
  level?: Serializable<Level>;
  room?: Record<string, unknown>; // Room data is never saved to disk.
}

/**
 * A type that represents valid serializable data fed to the save data manager.
 *
 * Custom errors are thrown when an Isaac API class or a nested custom class is detected.
 *
 * The recursive nature of this type is based on the `Immutable` type:
 * https://stackoverflow.com/questions/41879327/deepreadonly-object-typescript
 */
type Serializable<T> =
  // Allow the trivial case of primitives.
  T extends SerializablePrimitive
    ? T
    : // Allow a specific subset of Isaac API classes that are copyable / serializable.
      T extends CopyableIsaacAPIClass
      ? T
      : // Disallow all other Isaac API classes.
        T extends IsaacAPIClass
        ? ErrorIsaacAPIClassIsNotSerializable
        : // Allow some specific "container" objects.
          // These container objects are explicitly handled by the save data manager, but there are
          // restrictions on the things inside of them.
          T extends Array<infer U>
          ? SerializableArray<U>
          : T extends ReadonlyArray<infer U>
            ? SerializableReadonlyArray<U>
            : T extends Map<infer K, infer V>
              ? SerializableMap<K, V>
              : T extends ReadonlyMap<infer K, infer V>
                ? SerializableReadonlyMap<K, V>
                : T extends Set<infer V>
                  ? SerializableSet<V>
                  : T extends ReadonlySet<infer V>
                    ? SerializableReadonlySet<V>
                    : // Allow any other object, as long as the values are themselves serializable.
                      SerializableObject<T>;

/**
 * This is mostly copied from the `Serializable` type. The difference is that we want to disallow
 * functions inside of containers.
 */
type SerializableInsideArrayOrMap<T> =
  // Allow the trivial case of primitives.
  T extends SerializablePrimitive
    ? T
    : // Allow a specific subset of Isaac API classes that are copyable / serializable.
      T extends CopyableIsaacAPIClass
      ? T
      : // Disallow all other Isaac API classes.
        T extends IsaacAPIClass
        ? ErrorIsaacAPIClassIsNotSerializable
        : // Allow some specific "container" objects.
          // These container objects are explicitly handled by the save data manager, but there are
          // restrictions on the things inside of them.
          T extends Array<infer U>
          ? SerializableArray<U>
          : T extends ReadonlyArray<infer U>
            ? SerializableReadonlyArray<U>
            : T extends Map<infer K, infer V>
              ? SerializableMap<K, V>
              : T extends ReadonlyMap<infer K, infer V>
                ? SerializableReadonlyMap<K, V>
                : T extends Set<infer V>
                  ? SerializableSet<V>
                  : T extends ReadonlySet<infer V>
                    ? SerializableReadonlySet<V>
                    : // Disallow functions.
                      // (We can only disallow functions when inside of containers, because we want
                      // to allow classes with methods attached to normal objects.)
                      T extends Function // eslint-disable-line @typescript-eslint/ban-types
                      ? FunctionIsNotSerializable
                      : // Allow any other object, as long as the values are themselves serializable.
                        SerializableObject<T>;

type SerializablePrimitive = boolean | string | number | undefined | null;
type SerializableArray<T> = Array<SerializableInsideArrayOrMap<T>>;
type SerializableReadonlyArray<T> = ReadonlyArray<
  SerializableInsideArrayOrMap<T>
>;
type SerializableMap<K, V> = Map<
  SerializableInsideArrayOrMap<K>,
  SerializableInsideArrayOrMap<V>
>;
type SerializableReadonlyMap<K, V> = ReadonlyMap<
  SerializableInsideArrayOrMap<K>,
  SerializableInsideArrayOrMap<V>
>;
type SerializableSet<T> = Set<SerializableInsideArrayOrMap<T>>;
type SerializableReadonlySet<T> = ReadonlySet<SerializableInsideArrayOrMap<T>>;
type SerializableObject<T> = { [K in keyof T]: Serializable<T[K]> };

type FunctionIsNotSerializable =
  "Error: Functions are not serializable. For more information, see: https://isaacscript.github.io/main/gotchas#functions-are-not-serializable";

type ErrorIsaacAPIClassIsNotSerializable =
  "Error: Isaac API classes (such as e.g. `Entity` or `RoomConfig`) are not serializable. For more information, see: https://isaacscript.github.io/main/gotchas#isaac-api-classes-are-not-serializable";

// -----
// Tests
// -----

function test<Persistent, Run, Level>(
  _saveData: SaveData<Persistent, Run, Level>,
) {}

{
  const saveDataWithPrimitives = {
    run: {
      foo: 123,
      bar: "bar",
      baz: true,
      nested: {
        foo: 123,
        bar: "bar",
        baz: true,
      },
    },
  };

  // Primitives and nested primitives are allowed.
  test(saveDataWithPrimitives);
}

{
  const saveDataWithEntity = {
    run: {
      foo: {} as Entity,
    },
  };

  // @ts-expect-error Isaac API classes are not serializable.
  test(saveDataWithEntity);
}

{
  const saveDataWithMap = {
    run: {
      foo: new Map<string, string>(),
    },
  };

  // Maps with primitive values are allowed.
  test(saveDataWithMap);
}

{
  const saveDataWithMap = {
    run: {
      foo: new Map<string, () => void>(),
    },
  };

  // @ts-expect-error Maps with function values are not serializable.
  test(saveDataWithMap);
}

{
  const saveDataWithMap = {
    run: {
      foo: new Map<string, Map<string, string>>(),
    },
  };

  // Nested maps are allowed.
  test(saveDataWithMap);
}

{
  class Foo {
    someField = 123;
  }

  const saveDataWithClass = {
    run: {
      foo: new Foo(),
    },
  };

  // Custom classes without methods are allowed.
  test(saveDataWithClass);
}

{
  class Foo {
    someField = 123;
    someMethod() {}
  }

  const saveDataWithClassWithMethod = {
    run: {
      foo: new Foo(),
    },
  };

  // Custom classes with methods are allowed.
  test(saveDataWithClassWithMethod);
}

{
  class Foo {
    someField = 123;
  }

  const saveDataWithNestedClass = {
    run: {
      fooMap: new Map<string, Foo>(),
    },
  };

  // Nested custom classes without methods are allowed.
  test(saveDataWithNestedClass);
}

----
interfaces\StageHistoryEntry.ts
import type { LevelStage, StageType } from "isaac-typescript-definitions";

/** This is used by the `StageHistory` feature. */
export interface StageHistoryEntry {
  readonly stage: LevelStage;
  readonly stageType: StageType;
}

----
interfaces\TSTLClassMetatable.ts
/**
 * This is a type representing the metatable of a user-created class from TypeScript code.
 * (TypeScriptToLua transpiles TypeScript classes to a Lua table with a specific kind of metatable.)
 */
export interface TSTLClassMetatable {
  ____constructor: () => void;
  __index: unknown;
  constructor: {
    name: string;
    prototype: LuaMetatable<LuaMap<AnyNotNil, unknown>>;
    // Other static things on the class will be here, if any.
  };
}

----
interfaces\TrinketSituation.ts
import type { TrinketType } from "isaac-typescript-definitions";

/** This is used by the `temporarilyRemoveTrinkets` and related helper functions. */
export interface TrinketSituation {
  trinketTypeRemoved: TrinketType;
  trinketType1: TrinketType;
  trinketType2: TrinketType;
  numSmeltedTrinkets: int;
}

----
interfaces\private\AddCallbackParametersCustom.ts
import type {
  ActiveSlot,
  BombVariant,
  ButtonAction,
  CollectibleType,
  DamageFlag,
  DiceFloorSubType,
  DoorVariant,
  EffectVariant,
  EntityType,
  FamiliarVariant,
  GridEntityType,
  GridEntityXMLType,
  InputHook,
  ItemType,
  Keyboard,
  KnifeVariant,
  LaserVariant,
  LevelStage,
  PickupVariant,
  PillColor,
  PillEffect,
  PitVariant,
  PlayerForm,
  PlayerType,
  PlayerVariant,
  PoopGridEntityVariant,
  PressurePlateVariant,
  ProjectileVariant,
  RoomType,
  SlotVariant,
  StageType,
  TearVariant,
  TrinketType,
  UseFlag,
} from "isaac-typescript-definitions";
import type { AmbushType } from "../../enums/AmbushType";
import type { HealthType } from "../../enums/HealthType";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { PlayerStat } from "../../enums/PlayerStat";
import type { SlotDestructionType } from "../../enums/SlotDestructionType";
import { interfaceSatisfiesEnum } from "../../functions/enums";
import type {
  PickingUpItem,
  PickingUpItemCollectible,
  PickingUpItemTrinket,
} from "../../types/PickingUpItem";
import type { PlayerStats } from "../PlayerStats";

export interface AddCallbackParametersCustom {
  [ModCallbackCustom.ENTITY_TAKE_DMG_FILTER]: [
    callback: (
      entity: Entity,
      amount: float,
      damageFlags: BitFlags<DamageFlag>,
      source: EntityRef,
      countdownFrames: int,
    ) => boolean | undefined,
    entityType?: EntityType,
    variant?: number,
    subType?: number,
  ];

  [ModCallbackCustom.ENTITY_TAKE_DMG_PLAYER]: [
    callback: (
      player: EntityPlayer,
      amount: float,
      damageFlags: BitFlags<DamageFlag>,
      source: EntityRef,
      countdownFrames: int,
    ) => boolean | undefined,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.INPUT_ACTION_FILTER]: [
    callback: (
      entity: Entity | undefined,
      inputHook: InputHook,
      buttonAction: ButtonAction,
    ) => boolean | float | undefined,
    inputHook?: InputHook,
    buttonAction?: ButtonAction,
  ];

  [ModCallbackCustom.INPUT_ACTION_PLAYER]: [
    callback: (
      player: EntityPlayer,
      inputHook: InputHook,
      buttonAction: ButtonAction,
    ) => boolean | float | undefined,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
    inputHook?: InputHook,
    buttonAction?: ButtonAction,
  ];

  [ModCallbackCustom.POST_AMBUSH_FINISHED]: [
    callback: (ambushType: AmbushType) => void,
    ambushType?: AmbushType,
  ];

  [ModCallbackCustom.POST_AMBUSH_STARTED]: [
    callback: (ambushType: AmbushType) => void,
    ambushType?: AmbushType,
  ];

  [ModCallbackCustom.POST_BOMB_EXPLODED]: [
    callback: (bomb: EntityBomb) => void,
    bombVariant?: BombVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_BOMB_INIT_FILTER]: [
    callback: (bomb: EntityBomb) => void,
    bombVariant?: BombVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_BOMB_INIT_LATE]: [
    callback: (bomb: EntityBomb) => void,
    bombVariant?: BombVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_BOMB_RENDER_FILTER]: [
    callback: (bomb: EntityBomb, renderOffset: Vector) => void,
    bombVariant?: BombVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_BOMB_UPDATE_FILTER]: [
    callback: (bomb: EntityBomb) => void,
    bombVariant?: BombVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_BONE_SWING]: [callback: (knife: EntityKnife) => void];

  [ModCallbackCustom.POST_COLLECTIBLE_EMPTY]: [
    callback: (
      collectible: EntityPickupCollectible,
      oldCollectibleType: CollectibleType,
    ) => void,
    collectibleType?: CollectibleType,
  ];

  [ModCallbackCustom.POST_CURSED_TELEPORT]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_CUSTOM_REVIVE]: [
    callback: (player: EntityPlayer, revivalType: int) => void,
    revivalType?: int,
  ];

  [ModCallbackCustom.POST_DICE_ROOM_ACTIVATED]: [
    callback: (
      player: EntityPlayer,
      diceFloorSubType: DiceFloorSubType,
    ) => void,
    diceFloorSubType?: DiceFloorSubType,
  ];

  [ModCallbackCustom.POST_DOOR_RENDER]: [
    callback: (door: GridEntityDoor) => void,
    doorVariant?: DoorVariant,
  ];

  [ModCallbackCustom.POST_DOOR_UPDATE]: [
    callback: (door: GridEntityDoor) => void,
    doorVariant?: DoorVariant,
  ];

  [ModCallbackCustom.POST_EFFECT_INIT_FILTER]: [
    callback: (effect: EntityEffect) => void,
    effectVariant?: EffectVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_EFFECT_INIT_LATE]: [
    callback: (effect: EntityEffect) => void,
    effectVariant?: EffectVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_EFFECT_RENDER_FILTER]: [
    callback: (effect: EntityEffect, renderOffset: Vector) => void,
    effectVariant?: EffectVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_EFFECT_STATE_CHANGED]: [
    callback: (
      effect: EntityEffect,
      previousState: int,
      currentState: int,
    ) => void,
    effectVariant?: EffectVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_EFFECT_UPDATE_FILTER]: [
    callback: (effect: EntityEffect) => void,
    effectVariant?: EffectVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_ENTITY_KILL_FILTER]: [
    callback: (entity: Entity) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  // - Co-op babies cannot turn into Esau Jr, so it does not make sense to filter by
  //   `PlayerVariant`.
  // - The character of Esau Jr. is equal to `PlayerType.ISAAC`, so it does not make sense to filter
  //   by character.
  [ModCallbackCustom.POST_ESAU_JR]: [callback: (player: EntityPlayer) => void];

  [ModCallbackCustom.POST_FAMILIAR_INIT_FILTER]: [
    callback: (familiar: EntityFamiliar) => void,
    familiarVariant?: FamiliarVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_FAMILIAR_INIT_LATE]: [
    callback: (familiar: EntityFamiliar) => void,
    familiarVariant?: FamiliarVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_FAMILIAR_RENDER_FILTER]: [
    callback: (familiar: EntityFamiliar, renderOffset: Vector) => void,
    familiarVariant?: FamiliarVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_FAMILIAR_STATE_CHANGED]: [
    callback: (
      familiar: EntityFamiliar,
      previousState: int,
      currentState: int,
    ) => void,
    familiarVariant?: FamiliarVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_FAMILIAR_UPDATE_FILTER]: [
    callback: (familiar: EntityFamiliar) => void,
    familiarVariant?: FamiliarVariant,
    subType?: int,
  ];

  // - Co-op babies cannot turn into Esau Jr, so it does not make sense to filter by
  //   `PlayerVariant`.
  // - The character of Esau Jr. is equal to `PlayerType.ISAAC`, so it does not make sense to filter
  //   by character.
  [ModCallbackCustom.POST_FIRST_ESAU_JR]: [
    callback: (player: EntityPlayer) => void,
  ];

  [ModCallbackCustom.POST_FIRST_FLIP]: [
    callback: (newLazarus: EntityPlayer, oldLazarus: EntityPlayer) => void,
  ];

  [ModCallbackCustom.POST_FLIP]: [
    callback: (newLazarus: EntityPlayer, oldLazarus: EntityPlayer) => void,
  ];

  [ModCallbackCustom.POST_GAME_END_FILTER]: [
    callback: (isGameOver: boolean) => void,
    isGameOver?: boolean,
  ];

  [ModCallbackCustom.POST_GAME_STARTED_REORDERED]: [
    callback: (isContinued: boolean) => void,
    // `isContinued` is mandatory to prevent users from shooting themselves in the foot.
    isContinued: boolean | undefined,
  ];

  [ModCallbackCustom.POST_GAME_STARTED_REORDERED_LAST]: [
    callback: (isContinued: boolean) => void,
    // `isContinued` is mandatory to prevent users from shooting themselves in the foot.
    isContinued: boolean | undefined,
  ];

  [ModCallbackCustom.POST_GREED_MODE_WAVE]: [
    callback: (oldWave: int, newWave: int) => void,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_BROKEN]: [
    callback: (gridEntity: GridEntity) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_COLLISION]: [
    callback: (gridEntity: GridEntity, entity: Entity) => void,
    gridEntityType?: GridEntityType,
    gridEntityVariant?: int,
    entityType?: EntityType,
    entityVariant?: int,
    entitySubType?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_BROKEN]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_COLLISION]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
      entity: Entity,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
    entityType?: EntityType,
    entityVariant?: int,
    entitySubType?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_INIT]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_REMOVE]: [
    callback: (gridIndex: int, gridEntityTypeCustom: GridEntityType) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_RENDER]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_STATE_CHANGED]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
      oldState: int,
      newState: int,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_CUSTOM_UPDATE]: [
    callback: (
      gridEntity: GridEntity,
      gridEntityTypeCustom: GridEntityType,
    ) => void,
    gridEntityTypeCustom?: GridEntityType,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_INIT]: [
    callback: (gridEntity: GridEntity) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_REMOVE]: [
    callback: (
      gridIndex: int,
      gridEntityType: GridEntityType,
      variant: int,
    ) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_RENDER]: [
    callback: (gridEntity: GridEntity) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_STATE_CHANGED]: [
    callback: (gridEntity: GridEntity, oldState: int, newState: int) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_GRID_ENTITY_UPDATE]: [
    callback: (gridEntity: GridEntity) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_HOLY_MANTLE_REMOVED]: [
    callback: (
      player: EntityPlayer,
      oldNumHolyMantles: int,
      newNumHolyMantles: int,
    ) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_ITEM_DISCHARGE]: [
    callback: (
      player: EntityPlayer,
      collectibleType: CollectibleType,
      activeSlot: ActiveSlot,
    ) => void,
    collectibleType?: CollectibleType,
  ];

  [ModCallbackCustom.POST_ITEM_PICKUP]:
    | [callback: (player: EntityPlayer, pickingUpItem: PickingUpItem) => void]
    | [
        callback: (
          player: EntityPlayer,
          pickingUpItem: PickingUpItemCollectible,
        ) => void,
        itemType: ItemType.PASSIVE | ItemType.ACTIVE | ItemType.FAMILIAR,
        collectibleType?: CollectibleType,
      ]
    | [
        callback: (
          player: EntityPlayer,
          pickingUpItem: PickingUpItemTrinket,
        ) => void,
        itemType: ItemType.TRINKET,
        trinketType?: TrinketType,
      ];

  [ModCallbackCustom.POST_KEYBOARD_CHANGED]: [
    callback: (keyboard: Keyboard, pressed: boolean) => void,
    keyboard?: Keyboard,
    pressed?: boolean,
  ];

  [ModCallbackCustom.POST_KNIFE_INIT_FILTER]: [
    callback: (knife: EntityKnife) => void,
    knifeVariant?: KnifeVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_KNIFE_INIT_LATE]: [
    callback: (knife: EntityKnife) => void,
    knifeVariant?: KnifeVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_KNIFE_RENDER_FILTER]: [
    callback: (knife: EntityKnife, renderOffset: Vector) => void,
    knifeVariant?: KnifeVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_KNIFE_UPDATE_FILTER]: [
    callback: (knife: EntityKnife) => void,
    knifeVariant?: KnifeVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_LASER_INIT_FILTER]: [
    callback: (laser: EntityLaser) => void,
    laserVariant?: LaserVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_LASER_INIT_LATE]: [
    callback: (laser: EntityLaser) => void,
    laserVariant?: LaserVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_LASER_RENDER_FILTER]: [
    callback: (laser: EntityLaser, renderOffset: Vector) => void,
    laserVariant?: LaserVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_LASER_UPDATE_FILTER]: [
    callback: (laser: EntityLaser) => void,
    laserVariant?: LaserVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NEW_LEVEL_REORDERED]: [
    callback: (stage: LevelStage, stageType: StageType) => void,
    stage?: LevelStage,
    stageType?: StageType,
  ];

  [ModCallbackCustom.POST_NEW_ROOM_EARLY]: [
    callback: (roomType: RoomType) => void,
    roomType?: RoomType,
  ];

  [ModCallbackCustom.POST_NEW_ROOM_REORDERED]: [
    callback: (roomType: RoomType) => void,
    roomType?: RoomType,
  ];

  [ModCallbackCustom.POST_NPC_DEATH_FILTER]: [
    callback: (npc: EntityNPC) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NPC_INIT_FILTER]: [
    callback: (npc: EntityNPC) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NPC_INIT_LATE]: [
    callback: (npc: EntityNPC) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NPC_RENDER_FILTER]: [
    callback: (npc: EntityNPC, renderOffset: Vector) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NPC_STATE_CHANGED]: [
    callback: (npc: EntityNPC, previousState: int, currentState: int) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_NPC_UPDATE_FILTER]: [
    callback: (npc: EntityNPC) => void,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PEFFECT_UPDATE_REORDERED]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PICKUP_CHANGED]: [
    callback: (
      pickup: EntityPickup,
      oldVariant: PickupVariant,
      oldSubType: int,
      newVariant: PickupVariant,
      newSubType: int,
    ) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_COLLECT]: [
    callback: (pickup: EntityPickup, player: EntityPlayer) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_INIT_FILTER]: [
    callback: (pickup: EntityPickup) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_INIT_FIRST]: [
    callback: (pickup: EntityPickup) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_INIT_LATE]: [
    callback: (pickup: EntityPickup) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_RENDER_FILTER]: [
    callback: (pickup: EntityPickup, renderOffset: Vector) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_SELECTION_FILTER]: [
    callback: (
      pickup: EntityPickup,
      variant: PickupVariant,
      subType: int,
    ) => [pickupVariant: PickupVariant, subType: int] | undefined,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_STATE_CHANGED]: [
    callback: (
      pickup: EntityPickup,
      previousState: int,
      currentState: int,
    ) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PICKUP_UPDATE_FILTER]: [
    callback: (pickup: EntityPickup) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PIT_RENDER]: [
    callback: (pit: GridEntityPit) => void,
    pitVariant?: PitVariant,
  ];

  [ModCallbackCustom.POST_PIT_UPDATE]: [
    callback: (pit: GridEntityPit) => void,
    pitVariant?: PitVariant,
  ];

  [ModCallbackCustom.POST_PLAYER_CHANGE_HEALTH]: [
    callback: (
      player: EntityPlayer,
      healthType: HealthType,
      difference: int,
      oldValue: int,
      newValue: int,
    ) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_CHANGE_STAT]: [
    callback: <T extends PlayerStat>(
      player: EntityPlayer,
      playerStat: PlayerStat,
      difference: int,
      oldValue: PlayerStats[T],
      newValue: PlayerStats[T],
    ) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_CHANGE_TYPE]: [
    callback: (
      player: EntityPlayer,
      oldCharacter: PlayerType,
      newCharacter: PlayerType,
    ) => void,
    playerVariant?: PlayerVariant,
  ];

  [ModCallbackCustom.POST_PLAYER_COLLECTIBLE_ADDED]: [
    callback: (player: EntityPlayer, collectibleType: CollectibleType) => void,
    collectibleType?: CollectibleType,
  ];

  [ModCallbackCustom.POST_PLAYER_COLLECTIBLE_REMOVED]: [
    callback: (player: EntityPlayer, collectibleType: CollectibleType) => void,
    collectibleType?: CollectibleType,
  ];

  [ModCallbackCustom.POST_PLAYER_FATAL_DAMAGE]: [
    callback: (
      player: EntityPlayer,
      amount: float,
      damageFlags: BitFlags<DamageFlag>,
      source: EntityRef,
      countdownFrames: int,
    ) => boolean | undefined,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_INIT_FIRST]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_INIT_LATE]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_RENDER_REORDERED]: [
    callback: (player: EntityPlayer, renderOffset: Vector) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_PLAYER_UPDATE_REORDERED]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_POOP_RENDER]: [
    callback: (poop: GridEntityPoop) => void,
    poopVariant?: PoopGridEntityVariant,
  ];

  [ModCallbackCustom.POST_POOP_UPDATE]: [
    callback: (poop: GridEntityPoop) => void,
    poopVariant?: PoopGridEntityVariant,
  ];

  [ModCallbackCustom.POST_PRESSURE_PLATE_RENDER]: [
    callback: (pressurePlate: GridEntityPressurePlate) => void,
    pressurePlateVariant?: PressurePlateVariant,
  ];

  [ModCallbackCustom.POST_PRESSURE_PLATE_UPDATE]: [
    callback: (pressurePlate: GridEntityPressurePlate) => void,
    pressurePlateVariant?: PressurePlateVariant,
  ];

  [ModCallbackCustom.POST_PROJECTILE_INIT_FILTER]: [
    callback: (projectile: EntityProjectile) => void,
    projectileVariant?: ProjectileVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PROJECTILE_INIT_LATE]: [
    callback: (projectile: EntityProjectile) => void,
    projectileVariant?: ProjectileVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PROJECTILE_KILL]: [
    callback: (projectile: EntityProjectile) => void,
    projectileVariant?: ProjectileVariant,
    subType?: number,
  ];

  [ModCallbackCustom.POST_PROJECTILE_UPDATE_FILTER]: [
    callback: (projectile: EntityProjectile) => void,
    projectileVariant?: ProjectileVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PROJECTILE_RENDER_FILTER]: [
    callback: (projectile: EntityProjectile, renderOffset: Vector) => void,
    projectileVariant?: ProjectileVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_PURCHASE]: [
    callback: (player: EntityPlayer, pickup: EntityPickup) => void,
    pickupVariant?: PickupVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_ROCK_RENDER]: [
    callback: (rock: GridEntityRock) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_ROCK_UPDATE]: [
    callback: (rock: GridEntityRock) => void,
    gridEntityType?: GridEntityType,
    variant?: int,
  ];

  [ModCallbackCustom.POST_ROOM_CLEAR_CHANGED]: [
    callback: (roomClear: boolean) => void,
    roomClear?: boolean,
  ];

  [ModCallbackCustom.POST_SACRIFICE]: [
    callback: (player: EntityPlayer, numSacrifices: int) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.POST_SLOT_ANIMATION_CHANGED]: [
    callback: (
      slot: EntitySlot,
      previousAnimation: string,
      currentAnimation: string,
    ) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SLOT_COLLISION]: [
    callback: (slot: EntitySlot, player: EntityPlayer) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SLOT_DESTROYED]: [
    callback: (
      slot: EntitySlot,
      slotDestructionType: SlotDestructionType,
    ) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SLOT_INIT]: [
    callback: (slot: EntitySlot) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SLOT_RENDER]: [
    callback: (slot: EntitySlot) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SLOT_UPDATE]: [
    callback: (slot: EntitySlot) => void,
    slotVariant?: SlotVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_SPIKES_RENDER]: [
    callback: (spikes: GridEntitySpikes) => void,
    variant?: int,
  ];

  [ModCallbackCustom.POST_SPIKES_UPDATE]: [
    callback: (spikes: GridEntitySpikes) => void,
    variant?: int,
  ];

  [ModCallbackCustom.POST_TEAR_INIT_FILTER]: [
    callback: (tear: EntityTear) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TEAR_INIT_LATE]: [
    callback: (tear: EntityTear) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TEAR_INIT_VERY_LATE]: [
    callback: (tear: EntityTear) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TEAR_KILL]: [
    callback: (tear: EntityTear) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TEAR_RENDER_FILTER]: [
    callback: (tear: EntityTear, renderOffset: Vector) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TEAR_UPDATE_FILTER]: [
    callback: (tear: EntityTear) => void,
    tearVariant?: TearVariant,
    subType?: int,
  ];

  [ModCallbackCustom.POST_TNT_RENDER]: [
    callback: (tnt: GridEntityTNT) => void,
    variant?: int,
  ];

  [ModCallbackCustom.POST_TNT_UPDATE]: [
    callback: (tnt: GridEntityTNT) => void,
    variant?: int,
  ];

  [ModCallbackCustom.POST_TRANSFORMATION]: [
    callback: (
      player: EntityPlayer,
      playerForm: PlayerForm,
      hasForm: boolean,
    ) => void,
    playerForm?: PlayerForm,
  ];

  [ModCallbackCustom.POST_TRINKET_BREAK]: [
    callback: (player: EntityPlayer, trinketType: TrinketType) => void,
    trinketType?: TrinketType,
  ];

  [ModCallbackCustom.POST_USE_PILL_FILTER]: [
    callback: (
      pillEffect: PillEffect,
      pillColor: PillColor,
      player: EntityPlayer,
      useFlags: BitFlags<UseFlag>,
    ) => void,
    pillEffect?: PillEffect,
    pillColor?: PillColor,
  ];

  [ModCallbackCustom.PRE_BERSERK_DEATH]: [
    callback: (player: EntityPlayer) => void,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.PRE_BOMB_COLLISION_FILTER]: [
    callback: (
      bomb: EntityBomb,
      collider: Entity,
      low: boolean,
    ) => boolean | undefined,
    bombVariant?: BombVariant,
    subtype?: int,
  ];

  [ModCallbackCustom.PRE_CUSTOM_REVIVE]: [
    callback: (player: EntityPlayer) => int | undefined,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.PRE_ENTITY_SPAWN_FILTER]: [
    callback: (
      entityType: EntityType,
      variant: int,
      subType: int,
      position: Vector,
      velocity: Vector,
      spawner: Entity | undefined,
      initSeed: Seed,
    ) =>
      | [entityType: EntityType, variant: int, subType: int, initSeed: Seed]
      | undefined,
    entityType?: EntityType,
    variant?: int,
    subtype?: int,
  ];

  [ModCallbackCustom.PRE_FAMILIAR_COLLISION_FILTER]: [
    callback: (
      familiar: EntityFamiliar,
      collider: Entity,
      low: boolean,
    ) => boolean | undefined,
    familiarVariant?: FamiliarVariant,
    subtype?: int,
  ];

  [ModCallbackCustom.PRE_GET_PEDESTAL]: [
    callback: (
      player: EntityPlayer,
      collectible: EntityPickupCollectible,
    ) => boolean | undefined,
    playerVariant?: PlayerVariant,
    character?: PlayerType,
  ];

  [ModCallbackCustom.PRE_ITEM_PICKUP]:
    | [callback: (player: EntityPlayer, pickingUpItem: PickingUpItem) => void]
    | [
        callback: (
          player: EntityPlayer,
          pickingUpItem: PickingUpItemCollectible,
        ) => void,
        itemType: ItemType.PASSIVE | ItemType.ACTIVE | ItemType.FAMILIAR,
        collectibleType?: CollectibleType,
      ]
    | [
        callback: (
          player: EntityPlayer,
          pickingUpItem: PickingUpItemTrinket,
        ) => void,
        itemType: ItemType.TRINKET,
        trinketType?: TrinketType,
      ];

  [ModCallbackCustom.PRE_KNIFE_COLLISION_FILTER]: [
    callback: (
      knife: EntityKnife,
      collider: Entity,
      low: boolean,
    ) => boolean | undefined,
    knifeVariant?: KnifeVariant,
    subtype?: int,
  ];

  [ModCallbackCustom.PRE_NEW_LEVEL]: [callback: (player: EntityPlayer) => void];

  [ModCallbackCustom.PRE_NPC_COLLISION_FILTER]: [
    callback: (
      npc: EntityNPC,
      collider: Entity,
      low: boolean,
    ) => undefined | boolean,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.PRE_NPC_UPDATE_FILTER]: [
    callback: (npc: EntityNPC) => undefined | boolean,
    entityType?: EntityType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.PRE_PROJECTILE_COLLISION_FILTER]: [
    callback: (
      projectile: EntityProjectile,
      collider: Entity,
      low: boolean,
    ) => boolean | undefined,
    projectileVariant?: ProjectileVariant,
    subtype?: int,
  ];

  [ModCallbackCustom.PRE_ROOM_ENTITY_SPAWN_FILTER]: [
    callback: (
      entityTypeOrGridEntityXMLType: EntityType | GridEntityXMLType,
      variant: int,
      subType: int,
      gridIndex: int,
      initSeed: Seed,
    ) =>
      | [type: EntityType | GridEntityXMLType, variant: int, subType: int]
      | undefined,
    entityTypeOrGridEntityXMLType?: EntityType | GridEntityXMLType,
    variant?: int,
    subType?: int,
  ];

  [ModCallbackCustom.PRE_TEAR_COLLISION_FILTER]: [
    callback: (
      tear: EntityTear,
      collider: Entity,
      low: boolean,
    ) => boolean | undefined,
    tearVariant?: TearVariant,
    subtype?: int,
  ];
}

interfaceSatisfiesEnum<AddCallbackParametersCustom, ModCallbackCustom>();

----
interfaces\private\CustomStage.ts
import type {
  DoorSlotFlag,
  RoomShape,
  RoomType,
} from "isaac-typescript-definitions";
import type {
  CustomStageLua,
  CustomStageRoomMetadata,
} from "../CustomStageTSConfig";

export interface CustomStage extends CustomStageLua {
  /** A map that makes it easier to select certain room type/shape/door combinations. */
  readonly roomTypeMap: RoomTypeMap;
}

export type RoomTypeMap = ReadonlyMap<RoomType, RoomShapeMap>;
type RoomShapeMap = ReadonlyMap<RoomShape, RoomDoorSlotMap>;
type RoomDoorSlotMap = ReadonlyMap<DoorSlotFlag, CustomStageRoomMetadata[]>;

----
interfaces\private\CustomTrapdoorDescription.ts
import type { LevelStage, StageType } from "isaac-typescript-definitions";

export interface CustomTrapdoorDescription {
  destinationName: string | undefined;
  destinationStage: LevelStage;
  destinationStageType: StageType;
  open: boolean;
  firstSpawn: boolean;
}

----
interfaces\private\ModUpgradedInterface.ts
import type { Feature } from "../../classes/private/Feature";

/**
 * An interface that represents the `ModUpgraded` class.
 *
 * This is used to prevent circular dependencies.
 *
 * These methods are private on the real `ModUpgraded` class, so the instantiated class must be
 * unsafely type-asserted.
 */
export interface ModUpgradedInterface extends Mod {
  initFeature: (feature: Feature) => void;
  uninitFeature: (feature: Feature) => void;
}

----
lib\jsonLua.d.ts
/**
 * This is the custom JSON parser library called "json.lua". It is located at:
 * https://github.com/rxi/json.lua
 *
 * This parser was measured to be 11.8 times faster than the vanilla parser at decoding a sample
 * "save1.dat" file.
 *
 * @noSelfInFile
 */

export function encode(data: unknown): string;
export function decode(data: string): unknown;

----
lib\jsonLua.js
// Created by lua.js:
// https://github.com/mherkender/lua.js?tab=readme-ov-file

// cspell: disable

/*
 Copyright 2011 Maximilian Herkender

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
var lua_print = function () {
  try {
    console.log.apply(console, arguments);
  } catch (a) {}
  return [];
};
function lua_load(a, b) {
  if (!lua_parser)
    throw Error(
      "Lua parser not available, perhaps you're not using the lua+parser.js version of the library?",
    );
  eval(
    "fn = function " +
      (b || "load") +
      "() {\nreturn (function () {\n" +
      lua_parser.parse(a) +
      "\n})()[0];\n};",
  );
}
function slice(a, b) {
  return a.slice ? a.slice(b) : Array.prototype.slice.call(a, b);
}
function not_supported() {
  throw Error("Not supported");
}
function ensure_arraymode(a) {
  if (!a.arraymode) {
    var b = [],
      c;
    for (c in a.uints) null != a.uints[c] && (b[c - 1] = a.uints[c]);
    a.uints = b;
    a.arraymode = !0;
  }
}
function ensure_notarraymode(a) {
  if (a.arraymode) {
    var b = {},
      c;
    for (c in a.uints) null != a.uints[c] && (b[c - -1] = a.uints[c]);
    a.uints = b;
    delete a.arraymode;
  }
}
function ReturnValues(a) {
  this.vars = a || [];
}
function lua_true(a) {
  return null != a && !1 !== a;
}
function lua_not(a) {
  return null == a || !1 === a;
}
function lua_and(a, b) {
  return null == a || !1 === a ? a : b();
}
function lua_or(a, b) {
  return null != a && !1 !== a ? a : b();
}
function lua_assertfloat(a) {
  var b = parseFloat(a);
  if (isNaN(b)) throw Error("Invalid number: " + a);
  return b;
}
function lua_newtable(a) {
  for (
    var b = { str: {}, uints: {}, floats: {}, bool: {}, objs: [] }, c = 1;
    c < arguments.length - 1;
    c += 2
  ) {
    var d = arguments[c + 1];
    if (null != d) {
      var e = arguments[c];
      switch (typeof e) {
        case "string":
          b.str[e] = d;
          break;
        case "number":
          if (e != e) throw Error("Table index is NaN");
          0 < e && (e | 0) == e ? (b.uints[e] = d) : (b.floats[e] = d);
          break;
        case "boolean":
          b.bool[e] = d;
          break;
        case "object":
          if (null == e) throw Error("Table index is nil");
          var f = !1;
          for (c in b.objs)
            if (b.objs[c][0] === e) {
              null == d ? b.objs.splice(c, 1) : ((f = !0), (b.objs[c][1] = d));
              break;
            }
          f || b.objs.push([e, d]);
          break;
        default:
          throw Error("Unsupported type for table: " + typeof e);
      }
    }
  }
  if (a)
    if ((ensure_arraymode(b), 0 == b.uints.length)) b.uints = a;
    else for (c = a.length; 0 < c--; ) b.uints[c] = a[c];
  return b;
}
function lua_newtable2(a) {
  var b = {},
    c;
  for (c in a) b[c] = a[c];
  return { str: b, uints: {}, floats: {}, bool: {}, objs: {} };
}
function lua_len(a) {
  if ("string" == typeof a) return a.length;
  if ("object" == typeof a && null != a) {
    if (null == a.length) {
      var b = 0;
      if (a.arraymode) for (; null != a.uints[b++]; );
      else for (; null != a.uints[++b]; );
      return (a.length = b - 1);
    }
    return a.length;
  }
  if ((b = a.metatable && a.metatable.str.__len)) return lua_rawcall(b, [a])[0];
  throw Error("Length of <" + a + "> not supported");
}
function lua_rawcall(a, b) {
  try {
    return a.apply(null, b);
  } catch (c) {
    if (c.constructor == ReturnValues) return c.vars;
    throw c;
  }
}
function lua_tablegetcall(a, b, c) {
  a = lua_tableget(a, b);
  if ("function" == typeof a) return lua_rawcall(a, c);
  if (null == a) throw Error("attempt to call field '" + b + "' (a nil value)");
  b = a.metatable && a.metatable.str.__call;
  if (null != b) return lua_rawcall(b, [a].concat(c));
  throw Error("Could not call " + a + " as function");
}
function lua_call(a, b) {
  if ("function" == typeof a) return lua_rawcall(a, b);
  if (null == a) throw Error("attempt to call function (a nil value)");
  var c = a.metatable && a.metatable.str.__call;
  if (null != c) return lua_rawcall(c, [a].concat(b));
  throw Error("Could not call " + a + " as function");
}
function lua_mcall(a, b, c) {
  var d = lua_tableget(a, b);
  if (null == d)
    throw Error("attempt to call method '" + b + "' (a nil value)");
  return lua_call(d, [a].concat(c));
}
function lua_eq(a, b) {
  if (typeof a != typeof b) return null == a && null == b ? !0 : !1;
  if (a == b) return !0;
  if (null == a || null == b) return !1;
  var c = a.metatable && a.metatable.str.__eq;
  return c && c == (b.metatable && b.metatable.str.__eq)
    ? lua_true(lua_rawcall(c, [a, b])[0])
    : !1;
}
function lua_lt(a, b) {
  if (
    ("number" == typeof a && "number" == typeof b) ||
    ("string" == typeof a && "string" == typeof b)
  )
    return a < b;
  var c = a.metatable && a.metatable.str.__lt;
  if (c && c == (b.metatable && b.metatable.str.__lt))
    return lua_true(lua_rawcall(c, [a, b])[0]);
  throw Error("Unable to compare " + a + " and " + b);
}
function lua_lte(a, b) {
  if (
    ("number" == typeof a && "number" == typeof b) ||
    ("string" == typeof a && "string" == typeof b)
  )
    return a <= b;
  var c = a.metatable && a.metatable.str.__le;
  if (c && c == (b.metatable && b.metatable.str.__le))
    return lua_true(lua_rawcall(c, [a, b])[0]);
  if (
    (c = a.metatable && a.metatable.str.__lt) &&
    c == (b.metatable && b.metatable.str.__lt)
  )
    return lua_not(lua_rawcall(c, [b, a])[0]);
  throw Error("Unable to compare " + a + " and " + b);
}
function lua_unm(a) {
  var b = parseFloat(a);
  if (isNaN(b)) {
    if ((b = a.metatable && a.metatable.str.__unm))
      return lua_rawcall(b, [a])[0];
    throw Error("Inverting <" + a + "> not supported");
  }
  return -b;
}
function lua_add(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__add) ||
        (b.metatable && b.metatable.str.__add))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("Adding <" + a + "> and <" + b + "> not supported");
  }
  return c + d;
}
function lua_subtract(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__sub) ||
        (b.metatable && b.metatable.str.__sub))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("Subtracting <" + a + "> and <" + b + "> not supported");
  }
  return c - d;
}
function lua_divide(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__div) ||
        (b.metatable && b.metatable.str.__div))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("Dividing <" + a + "> and <" + b + "> not supported");
  }
  return c / d;
}
function lua_multiply(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__mul) ||
        (b.metatable && b.metatable.str.__mul))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("Multiplying <" + a + "> and <" + b + "> not supported");
  }
  return c * d;
}
function lua_power(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__pow) ||
        (b.metatable && b.metatable.str.__pow))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("<" + a + "> to the power of <" + b + "> not supported");
  }
  return Math.pow(c, d);
}
function lua_mod(a, b) {
  var c = parseFloat(a),
    d = parseFloat(b);
  if (isNaN(c) || isNaN(d)) {
    if (
      (c =
        (a.metatable && a.metatable.str.__mod) ||
        (b.metatable && b.metatable.str.__mod))
    )
      return lua_rawcall(c, [a, b])[0];
    throw Error("Modulo <" + a + "> and <" + b + "> not supported");
  }
  return 0 <= c
    ? 0 <= d
      ? c % d
      : (d + (c % d)) % d
    : 0 <= d
      ? (d + (c % d)) % d
      : c % d;
}
function lua_rawget(a, b) {
  switch (typeof b) {
    case "string":
      return a.str[b];
    case "number":
      if (b != b) throw Error("Table index is NaN");
      return 0 < b && (b | 0) == b
        ? a.arraymode
          ? a.uints[b - 1]
          : a.uints[b]
        : a.floats[b];
    case "boolean":
      return a.bool[b];
    case "object":
      if (null == b) return null;
      for (var c in a.objs) if (a.objs[c][0] == b) return a.objs[c][1];
      break;
    default:
      throw Error("Unsupported key for table: " + typeof b);
  }
}
function lua_rawset(a, b, c) {
  delete a.length;
  switch (typeof b) {
    case "string":
      null == c ? delete a.str[b] : (a.str[b] = c);
      break;
    case "number":
      if (b != b) throw Error("Table index is NaN");
      0 < b && (b | 0) == b
        ? (ensure_notarraymode(a),
          null == c ? delete a.uints[b] : (a.uints[b] = c))
        : null == c
          ? delete a.floats[b]
          : (a.floats[b] = c);
      break;
    case "boolean":
      null == c ? delete a.bool[b] : (a.bool[b] = c);
      break;
    case "object":
      if (null == b) throw Error("Table index is nil");
      var d = !1,
        e;
      for (e in a.objs)
        if (a.objs[e][0] == b) {
          null == c ? a.objs.splice(e, 1) : ((d = !0), (a.objs[e][1] = c));
          break;
        }
      d || a.objs.push([b, c]);
      break;
    default:
      throw Error("Unsupported key for table: " + typeof b);
  }
}
function lua_tableget(a, b) {
  if (null == a)
    throw Error("attempt to index field '" + b + "' in a nil value");
  if ("object" == typeof a) {
    var c = lua_rawget(a, b);
    if (null != c) return c;
    c = a.metatable && a.metatable.str.__index;
    if (null == c) return null;
  } else if (((c = a.metatable && a.metatable.str.__index), null == c))
    throw Error("Unable to index key " + b + " from " + a);
  return "function" == typeof c
    ? lua_rawcall(c, [a, b])[0]
    : lua_tableget(c, b);
}
function lua_tableset(a, b, c) {
  if (null == a) throw Error("attempt to set field '" + b + "' in a nil value");
  if ("object" == typeof a) {
    if (null != lua_rawget(a, b)) {
      lua_rawset(a, b, c);
      return;
    }
    var d = a.metatable && a.metatable.str.__newindex;
    if (null == d) {
      lua_rawset(a, b, c);
      return;
    }
  } else if (((d = a.metatable && a.metatable.str.__newindex), null == d))
    throw Error("Unable to set key " + b + " in table " + a);
  "function" == typeof d ? lua_rawcall(d, [a, b, c]) : lua_tableset(d, b, c);
}
function lua_concat(a, b) {
  if ("number" == typeof a && "number" == typeof b)
    throw Error("number concat not supported yet");
  if (
    ("string" == typeof a || "number" == typeof a) &&
    ("string" == typeof b || "number" == typeof b)
  )
    return a + b;
  var c =
    (a.metatable && a.metatable.str.__concat) ||
    (b.metatable && b.metatable.str.__concat);
  if (c) return lua_rawcall(c, [a, b])[0];
  throw Error("Unable to concat " + a + " and " + b);
}
function _ipairs_next(a, b) {
  var c;
  c = a.arraymode ? a.uints[b] : a.uints[b + 1];
  return null == c ? [null, null] : [b + 1, c];
}
var lua_libs = {},
  lua_core = {
    assert: function (a, b) {
      1 > arguments.length && (b = "assertion failed!");
      if (null != a && !1 !== a) return [a];
      throw Error(b);
    },
    collectgarbage: function () {},
    dofile: function () {
      not_supported();
    },
    error: function (a) {
      throw Error(a);
    },
    getfenv: function () {
      not_supported();
    },
    getmetatable: function (a) {
      return [a.metatable && (a.metatable.str.__metatable || a.metatable)];
    },
    ipairs: function (a) {
      return [_ipairs_next, a, 0];
    },
    load: function (a, b) {
      for (var c = "", d; null != (d = a()) && "" != d; ) c += d;
      try {
        return [lua_load(c, b)];
      } catch (e) {
        return [null, e.message];
      }
    },
    loadfile: function () {
      not_supported();
    },
    loadstring: function (a, b) {
      try {
        return [lua_load(a, b)];
      } catch (c) {
        return [null, c.message];
      }
    },
    next: function () {
      not_supported();
    },
    pairs: function (a) {
      var b = [],
        c;
      for (c in a.str) b.push(c);
      if (a.arraymode)
        for (var d = a.uints.length; 0 < d--; )
          null != a.uints[d] && b.push(d + 1);
      else for (c in a.uints) b.push(parseFloat(c));
      for (c in a.floats) b.push(parseFloat(c));
      for (c in a.bool) b.push("true" === c ? !0 : !1);
      for (c in a.objs) b.push(a.objs[c][0]);
      c = 0;
      return [
        function (a, d) {
          var g;
          do {
            if (c >= b.length) return [null, null];
            d = b[c++];
            g = lua_rawget(a, d);
          } while (null == g);
          return [d, g];
        },
        a,
        null,
      ];
    },
    pcall: function (a) {
      try {
        return [!0].concat(a.apply(null, slice(arguments, 1)));
      } catch (b) {
        return [!1, b.message];
      }
    },
    print: lua_print,
    rawequal: function (a, b) {
      return [a == b || (null == a && null == b)];
    },
    rawget: function (a, b) {
      if ("object" == typeof a && null != a) return [lua_rawget(a, b)];
      throw Error("Unable to index key " + b + " from " + a);
    },
    rawset: function (a, b, c) {
      if ("object" == typeof a && null != a && null != b)
        return lua_rawset(a, b, c), [a];
      throw Error("Unable set key " + b + " in " + a);
    },
    select: function (a) {
      if ("#" === a) return [arguments.length - 1];
      a = lua_assertfloat(a);
      if (1 <= a) return slice(arguments, lua_assertfloat(a));
      throw Error("Index out of range");
    },
    setfenv: function () {
      not_supported();
    },
    setmetatable: function (a, b) {
      if ("object" != typeof a || null == a)
        throw Error("table expected, got " + a);
      if (null == b) delete a.metatable;
      else if ("object" === typeof b) a.metatable = b;
      else throw Error("table or nil expected, got " + b);
      return [a];
    },
    tonumber: function (a, b) {
      return "number" == typeof a
        ? [a]
        : 10 === b || null == b
          ? [parseFloat(a)]
          : [parseInt(a, b)];
    },
    tostring: function (a) {
      if (null == a) return ["nil"];
      var b = a.metatable && a.metatable.str.__tostring;
      if (b) return lua_rawcall(b, [a]);
      switch (typeof a) {
        case "number":
        case "boolean":
          return [a.toString()];
        case "string":
          return [a];
        case "object":
          return ["table"];
        case "function":
          return ["function"];
        default:
          return ["nil"];
      }
    },
    type: function (a) {
      switch (typeof a) {
        case "number":
          return ["number"];
        case "string":
          return ["string"];
        case "boolean":
          return ["boolean"];
        case "function":
          return ["function"];
        case "object":
          return [null === a ? "nil" : "table"];
        case "undefined":
          return ["nil"];
        default:
          throw Error("Unepected value of type " + typeof a);
      }
    },
    unpack: function (a, b, c) {
      ensure_arraymode(a);
      if (null != a.length) c = a.length;
      else {
        for (c = 0; null != a.uints[c++]; );
        a.length = --c;
      }
      if (null == b || 1 > b) b = 1;
      null == c && (c = a.length);
      throw new ReturnValues(a.uints.slice(b - 1, c));
    },
    _VERSION: "Lua 5.1",
    xpcall: function () {
      not_supported();
    },
  },
  _lua_coroutine = (lua_libs.coroutine = {});
_lua_coroutine.resume =
  _lua_coroutine.running =
  _lua_coroutine.status =
  _lua_coroutine.wrap =
  _lua_coroutine.yield =
  _lua_coroutine.create =
    function () {
      not_supported();
    };
var _lua_debug = (lua_libs.debug = {
  getmetatable: function (a) {
    return [a.metatable];
  },
});
_lua_debug.traceback =
  _lua_debug.getfenv =
  _lua_debug.gethook =
  _lua_debug.getinfo =
  _lua_debug.getlocal =
  _lua_debug.getregistry =
  _lua_debug.getupvalue =
  _lua_debug.setfenv =
  _lua_debug.sethook =
  _lua_debug.setlocal =
  _lua_debug.setupvalue =
  _lua_debug.debug =
    function () {
      not_supported();
    };
var _lua_write_buffer = "",
  _lua_io = (lua_libs.io = {
    write: function () {
      _lua_write_buffer += Array.prototype.join.call(arguments, "");
      for (var a = _lua_write_buffer.split("\n"); 1 < a.length; )
        _lua_print(a.shift());
      _lua_write_buffer = a[0];
      return [];
    },
    flush: function () {},
    stderr: null,
    stdin: null,
    stdout: null,
  });
_lua_io.close =
  _lua_io.input =
  _lua_io.lines =
  _lua_io.output =
  _lua_io.popen =
  _lua_io.read =
  _lua_io.tmpfile =
  _lua_io.type =
  _lua_io.open =
    function () {
      not_supported();
    };
var _lua_randmax = 4294967296,
  _lua_randseed = (Math.random() * _lua_randmax) & (_lua_randmax - 1);
lua_libs.math = {
  abs: function (a) {
    return [Math.abs(a)];
  },
  acos: function (a) {
    return [Math.acos(a)];
  },
  asin: function (a) {
    return [Math.asin(a)];
  },
  atan: function (a) {
    return [Math.atan(a)];
  },
  atan2: function (a, b) {
    return [Math.atan2(a, b)];
  },
  ceil: function (a) {
    return [Math.ceil(a)];
  },
  cos: function (a) {
    return [Math.cos(a)];
  },
  cosh: function (a) {
    return [(Math.exp(a) + Math.exp(-a)) / 2];
  },
  deg: function (a) {
    return [a * (180 / Math.PI)];
  },
  exp: function (a) {
    return [Math.exp(a)];
  },
  floor: function (a) {
    return [Math.floor(a)];
  },
  fmod: function (a, b) {
    return [a % b];
  },
  frexp: function () {
    not_supported();
  },
  huge: Infinity,
  ldexp: function (a, b) {
    return [a * Math.pow(2, b)];
  },
  log: function (a) {
    return [Math.log(a)];
  },
  log10: function (a) {
    return [Math.log(a) / Math.LN10];
  },
  max: function () {
    return [Math.max.apply(null, arguments)];
  },
  min: function () {
    return [Math.min.apply(null, arguments)];
  },
  modf: function (a) {
    var b = a % 1;
    return [a - b, b];
  },
  pi: Math.PI,
  pow: function (a, b) {
    return [Math.pow(a, b)];
  },
  rad: function (a) {
    return [a * (Math.PI / 180)];
  },
  sin: function (a) {
    return [Math.sin(a)];
  },
  sinh: function (a) {
    return [(Math.exp(a) - Math.exp(-a)) / 2];
  },
  sqrt: function (a) {
    return [Math.sqrt(a)];
  },
  tan: function (a) {
    return [Math.tan(a)];
  },
  tanh: function (a) {
    var b = Math.exp(a),
      a = Math.exp(-a);
    return [(b - a) / (b + a)];
  },
  random: function (a, b) {
    _lua_randseed = ~_lua_randseed + (_lua_randseed << 15);
    _lua_randseed ^= _lua_randseed >>> 12;
    _lua_randseed += _lua_randseed << 2;
    _lua_randseed ^= _lua_randseed >>> 4;
    _lua_randseed *= 2057;
    _lua_randseed ^= _lua_randseed >>> 16;
    var c;
    c =
      0 > _lua_randseed
        ? ((_lua_randseed + _lua_randmax) / _lua_randmax) % 1
        : (_lua_randseed / _lua_randmax) % 1;
    if (2 <= arguments.length) {
      a |= 0;
      b |= 0;
      if (a >= b) throw Error("Invalid range");
      return [Math.floor(c * (b - a + 1) + a)];
    }
    return 1 == arguments.length ? [Math.floor(c * (a | 0) + 1)] : [c];
  },
  randomseed: function (a) {
    _lua_randseed = a & (_lua_randmax - 1);
  },
};
var _lua_clock_start = new Date().getTime() / 1e3;
lua_libs.os = {
  clock: function () {
    return [new Date().getTime() / 1e3 - _lua_clock_script];
  },
  date: function (a, b) {
    return ["[" + b + "]" + a];
  },
  difftime: function (a, b) {
    return [a - b];
  },
  execute: function () {
    return 0;
  },
  exit: function () {
    not_supported();
  },
  getenv: function () {
    return [null];
  },
  remove: function () {
    not_supported();
  },
  rename: function () {
    not_supported();
  },
  setlocale: function () {
    not_supported();
  },
  time: function (a) {
    if (a) not_supported();
    else return [Math.floor(new Date().getTime() / 1e3)];
  },
};
var lua_packages = lua_newtable();
function lua_createmodule(a, b, c) {
  var d = lua_tableget(lua_packages, b) || lua_tableget(a, b) || lua_newtable();
  lua_tableset(a, b, d);
  lua_tableset(lua_packages, b, d);
  lua_tableset(d, "_NAME", b);
  lua_tableset(d, "_M", d);
  lua_tableset(d, "_PACKAGE", b.split(".").slice(0, -1).join("."));
  for (a = 0; a < c.length; a++) lua_call(c[a], [d]);
  return d;
}
function lua_module(a) {
  var b = lua_tableget(lua_packages, a);
  if (null == b)
    throw Error(
      "Module " + a + " not found. Module must be loaded before use.",
    );
  return b;
}
function lua_require(a, b) {
  for (
    var c = lua_module(b), d = a, e = b.split("."), f = 0;
    f < e.length - 1;
    f++
  )
    if (!lua_tableget(d, e[f])) {
      var g = lua_newtable();
      lua_tableset(d, e[f], g);
      d = g;
    }
  lua_tableset(d, e[e.length - 1], c);
  return c;
}
lua_libs["package"] = {
  path: "",
  cpath: "",
  loaded: lua_packages,
  loaders: lua_newtable(),
  preload: lua_newtable(),
  loadlib: function () {
    not_supported();
  },
};
lua_libs.string = {
  byte: function (a, b, c) {
    null == b && (b = 0);
    null == c && (c = b);
    for (var d = []; b < c && b < a.length; ) d.push(a.charCodeAt(b));
    return d;
  },
  char: function () {
    return [String.fromCharCode.apply(null, arguments)];
  },
  dump: function () {
    not_supported();
  },
  find: function () {
    not_supported();
  },
  format: function (a) {
    return ["[" + slice(arguments, 1).join(", ") + "]" + arguments[0]];
  },
  gmatch: function () {
    not_supported();
  },
  gsub: function () {
    not_supported();
  },
  len: function (a) {
    if ("string" == typeof a) return [a.length];
    throw Error("Input not string");
  },
  lower: function (a) {
    if ("string" == typeof a) return [a.toLowerCase()];
    throw Error("Input not string");
  },
  match: function () {
    not_supported();
  },
  rep: function (a, b) {
    if ("string" == typeof a && "number" == typeof b) {
      for (var c = []; 0 < b--; ) c.push(a);
      return [c.join("")];
    }
    throw Error("Input not string and number");
  },
  reverse: function (a) {
    if ("string" == typeof a) return [a.split("").reverse().join("")];
    throw Error("Input not string");
  },
  sub: function (a, b, c) {
    b = 0 > b ? b + a.length + 1 : 0 <= b ? b : 0;
    null == c && (c = -1);
    c = 0 > c ? c + a.length + 1 : 0 <= c ? c : 0;
    1 > b && (b = 1);
    c > a.length && (c = a.length);
    return b <= c ? [a.substr(b - 1, c - b + 1)] : [""];
  },
  upper: function (a) {
    if ("string" == typeof a) return [a.toUpperCase()];
    throw Error("Input not string");
  },
};
String.prototype.metatable = lua_newtable(
  null,
  "__index",
  lua_newtable2(lua_libs.string),
);
lua_libs.table = {
  concat: function (a, b, c, d) {
    ensure_arraymode(a);
    null == b && (b = "");
    return null != c
      ? (null == d && (d = a.uints.length), [a.uints.slice(c - 1, d).join(b)])
      : [a.uints.join(b)];
  },
  insert: function (a, b, c) {
    ensure_arraymode(a);
    2 == arguments.length && ((c = b), (b = a.uints.length + 1));
    a.uints.splice(b - 1, 0, c);
    null != a.length && a.length++;
    return [];
  },
  maxn: function (a) {
    if (a.arraymode) return [a.uints.length];
    var b = 0,
      c;
    for (c in a.uints) (a = parseFloat(c)), a > b && (b = a);
    return [b];
  },
  remove: function (a, b) {
    ensure_arraymode(a);
    b = null == b ? a.uints.length : lua_assertfloat(b);
    if (a.uints.length) {
      var c = a.uints[b - 1];
      a.uints.splice(b - 1, 1);
      null != a.length && a.length--;
      return [c];
    }
    return [];
  },
  sort: function (a, b) {
    ensure_arraymode(a);
    b
      ? a.uints.sort(function (a, d) {
          return b(a, d)[0] ? -1 : 1;
        })
      : a.uints.sort(function (a, b) {
          return lua_lt(a, b) ? -1 : 1;
        });
    return [];
  },
};
lua_libs.bit = {
  tobit: function (a) {
    return [a << 0];
  },
  tohex: function (a, b) {
    if (0 < b) {
      for (var c = a.toString(16).substr(-b); c.length < b; ) c = "0" + c;
      return [c];
    }
    if (0 > b) {
      for (c = a.toString(16).substr(b).toUpperCase(); c.length < -b; )
        c = "0" + c;
      return [c];
    }
    return [a.toString(16)];
  },
  bnot: function (a) {
    return [~a];
  },
  bor: function (a) {
    for (var a = lua_assertfloat(a), b = 1; b < arguments.length; b++)
      a |= arguments[b];
    return [a];
  },
  band: function (a) {
    for (var a = lua_assertfloat(a), b = 1; b < arguments.length; b++)
      a &= arguments[b];
    return [a];
  },
  bxor: function (a) {
    for (var a = lua_assertfloat(a), b = 1; b < arguments.length; b++)
      a ^= arguments[b];
    return [a];
  },
  lshift: function (a, b) {
    return [a << b];
  },
  rshift: function (a, b) {
    return [a >>> b];
  },
  arshift: function (a, b) {
    return [a >> b];
  },
  rol: function (a, b) {
    b &= 15;
    return [(a << b) | (a >>> -b)];
  },
  ror: function (a, b) {
    b &= 15;
    return [(a >>> b) | (a << -b)];
  },
  bswap: function (a) {
    a = ((a >> 1) & 1431655765) | ((a & 1431655765) << 1);
    a = ((a >> 2) & 858993459) | ((a & 858993459) << 2);
    a = ((a >> 4) & 252645135) | ((a & 252645135) << 4);
    a = ((a >> 8) & 16711935) | ((a & 16711935) << 8);
    return [(a >> 16) | (a << 16)];
  },
};

var lua_script = (function () {
  var tmp;
  var G = lua_newtable2(lua_core);
  for (var i in lua_libs) {
    G.str[i] = lua_newtable2(lua_libs[i]);
  }
  G.str["arg"] = lua_newtable();
  G.str["_G"] = G;
  G.str["module"] = function (name) {
    lua_createmodule(G, name, slice(arguments, 1));
  };
  G.str["require"] = function (name) {
    lua_require(G, name);
  };
  G.str["package"].str["seeall"] = function (module) {
    if (!module.metatable) {
      module.metatable = lua_newtable();
    }
    module.metatable.str["__index"] = G;
  };
  {
    var _json_1 = lua_newtable([], "_version", "0.1.2");
    var _encode_1;
    var _escape_char_map_1 = lua_newtable(
      [],
      "\\",
      "\\",
      '"',
      '"',
      "\b",
      "b",
      "\f",
      "f",
      "\n",
      "n",
      "\r",
      "r",
      "\t",
      "t",
    );
    var _escape_char_map_inv_1 = lua_newtable([], "/", "/");
    tmp = lua_call(G.str["pairs"], [_escape_char_map_1]);
    var f_2 = tmp[0],
      s_2 = tmp[1],
      var_2 = tmp[2];
    while ((tmp = lua_call(f_2, [s_2, var_2]))[0] != null) {
      var_2 = tmp[0];
      var _k_2 = var_2,
        _v_2 = tmp[1];
      tmp = null;
      lua_tableset(_escape_char_map_inv_1, _v_2, _k_2);
    }
    tmp = null;
    var _escape_char_1 = function (_c) {
      var tmp;
      return [
        lua_concat(
          "\\",
          lua_or(lua_tableget(_escape_char_map_1, _c), function () {
            return lua_tablegetcall(
              G.str["string"],
              "format",
              ["u%04x"].concat(lua_mcall(_c, "byte", [])),
            )[0];
          }),
        ),
      ];
      return [];
    };
    var _encode_nil_1 = function (_val) {
      var tmp;
      return ["null"];
      return [];
    };
    var _encode_table_1 = function (_val, _stack, _traversalDescription) {
      var tmp;
      var _res_6 = lua_newtable();
      _stack = lua_or(_stack, function () {
        return lua_newtable();
      });
      _traversalDescription = lua_or(_traversalDescription, function () {
        return "";
      });
      if (lua_true(lua_tableget(_stack, _val))) {
        lua_call(G.str["error"], ["circular reference"]);
      }
      lua_tableset(_stack, _val, true);
      if (
        !lua_eq(lua_call(G.str["rawget"], [_val, 1])[0], null) ||
        lua_eq(lua_call(G.str["next"], [_val])[0], null)
      ) {
        var _n_8 = 0;
        tmp = lua_call(G.str["pairs"], [_val]);
        var f_9 = tmp[0],
          s_9 = tmp[1],
          var_9 = tmp[2];
        tmp = null;
        while ((var_9 = lua_call(f_9, [s_9, var_9])[0]) != null) {
          var _k_9 = var_9;
          if (!lua_eq(lua_call(G.str["type"], [_k_9])[0], "number")) {
            lua_call(G.str["error"], [
              lua_concat(
                "invalid table: mixed or invalid key types for array, excepted number, got: ",
                lua_call(G.str["tostring"], lua_call(G.str["type"], [_k_9]))[0],
              ),
            ]);
          }
          _n_8 = lua_add(_n_8, 1);
        }
        if (!lua_eq(_n_8, lua_len(_val))) {
          lua_call(G.str["error"], ["invalid table: sparse array"]);
        }
        tmp = lua_call(G.str["ipairs"], [_val]);
        var f_13 = tmp[0],
          s_13 = tmp[1],
          var_13 = tmp[2];
        while ((tmp = lua_call(f_13, [s_13, var_13]))[0] != null) {
          var_13 = tmp[0];
          var _i_13 = var_13,
            _v_13 = tmp[1];
          tmp = null;
          var _newTraversalDescription_14 = lua_concat(
            _traversalDescription,
            lua_concat(lua_call(G.str["tostring"], [_i_13])[0], " - "),
          );
          lua_tablegetcall(
            G.str["table"],
            "insert",
            [_res_6].concat(
              lua_call(_encode_1, [_v_13, _stack, _newTraversalDescription_14]),
            ),
          );
        }
        tmp = null;
        lua_tableset(_stack, _val, null);
        return [
          lua_concat(
            "[",
            lua_concat(
              lua_tablegetcall(G.str["table"], "concat", [_res_6, ","])[0],
              "]",
            ),
          ),
        ];
      } else {
        tmp = lua_call(G.str["pairs"], [_val]);
        var f_16 = tmp[0],
          s_16 = tmp[1],
          var_16 = tmp[2];
        while ((tmp = lua_call(f_16, [s_16, var_16]))[0] != null) {
          var_16 = tmp[0];
          var _k_16 = var_16,
            _v_16 = tmp[1];
          tmp = null;
          var _newTraversalDescription_17 = lua_concat(
            _traversalDescription,
            lua_concat(lua_call(G.str["tostring"], [_k_16])[0], " - "),
          );
          if (!lua_eq(lua_call(G.str["type"], [_k_16])[0], "string")) {
            lua_call(G.str["error"], [
              lua_concat(
                'invalid table: mixed or invalid key types for object "',
                lua_concat(
                  _newTraversalDescription_17,
                  lua_concat(
                    '", ',
                    lua_concat(
                      "excepted string, got: ",
                      lua_call(
                        G.str["tostring"],
                        lua_call(G.str["type"], [_k_16]),
                      )[0],
                    ),
                  ),
                ),
              ),
            ]);
          }
          lua_tablegetcall(G.str["table"], "insert", [
            _res_6,
            lua_concat(
              lua_call(_encode_1, [
                _k_16,
                _stack,
                _newTraversalDescription_17,
              ])[0],
              lua_concat(
                ":",
                lua_call(_encode_1, [
                  _v_16,
                  _stack,
                  _newTraversalDescription_17,
                ])[0],
              ),
            ),
          ]);
        }
        tmp = null;
        lua_tableset(_stack, _val, null);
        return [
          lua_concat(
            "{",
            lua_concat(
              lua_tablegetcall(G.str["table"], "concat", [_res_6, ","])[0],
              "}",
            ),
          ),
        ];
      }
      return [];
    };
    var _encode_string_1 = function (_val) {
      var tmp;
      return [
        lua_concat(
          '"',
          lua_concat(
            lua_mcall(_val, "gsub", ['[%z\x01-\x19\\"]', _escape_char_1])[0],
            '"',
          ),
        ),
      ];
      return [];
    };
    var _encode_number_1 = function (_val) {
      var tmp;
      if (
        !lua_eq(_val, _val) ||
        lua_lte(_val, lua_unm(lua_tableget(G.str["math"], "huge"))) ||
        lua_lte(lua_tableget(G.str["math"], "huge"), _val)
      ) {
        lua_call(G.str["error"], [
          lua_concat(
            "unexpected number value '",
            lua_concat(lua_call(G.str["tostring"], [_val])[0], "'"),
          ),
        ]);
      }
      return lua_tablegetcall(G.str["string"], "format", ["%.14g", _val]);
      return [];
    };
    var _type_func_map_1 = lua_newtable(
      [],
      "nil",
      _encode_nil_1,
      "table",
      _encode_table_1,
      "string",
      _encode_string_1,
      "number",
      _encode_number_1,
      "boolean",
      G.str["tostring"],
    );
    _encode_1 = function (_val, _stack, _traversalDescription) {
      var tmp;
      var _t_22 = lua_call(G.str["type"], [_val])[0];
      var _f_22 = lua_tableget(_type_func_map_1, _t_22);
      if (lua_true(_f_22)) {
        return lua_call(_f_22, [_val, _stack, _traversalDescription]);
      }
      lua_call(G.str["error"], [
        lua_concat("unexpected type '", lua_concat(_t_22, "'")),
      ]);
      return [];
    };
    lua_tableset(_json_1, "encode", function (_val) {
      var tmp;
      return [lua_call(_encode_1, [_val])[0]];
      return [];
    });
    var _parse_1;
    var _create_set_1 = function () {
      var tmp;
      var varargs = slice(arguments, 0);
      var _res_25 = lua_newtable();
      var var_26 = 1,
        stop_26 = lua_assertfloat(
          lua_call(G.str["select"], ["#"].concat(varargs))[0],
        );
      for (; var_26 <= stop_26; var_26++) {
        var _i_26 = var_26;
        lua_tableset(
          _res_25,
          lua_call(G.str["select"], [_i_26].concat(varargs))[0],
          true,
        );
      }
      return [_res_25];
      return [];
    };
    var _space_chars_1 = lua_call(_create_set_1, [" ", "\t", "\r", "\n"])[0];
    var _delim_chars_1 = lua_call(_create_set_1, [
      " ",
      "\t",
      "\r",
      "\n",
      "]",
      "}",
      ",",
    ])[0];
    var _escape_chars_1 = lua_call(_create_set_1, [
      "\\",
      "/",
      '"',
      "b",
      "f",
      "n",
      "r",
      "t",
      "u",
    ])[0];
    var _literals_1 = lua_call(_create_set_1, ["true", "false", "null"])[0];
    var _literal_map_1 = lua_newtable(
      [],
      "true",
      true,
      "false",
      false,
      "null",
      null,
    );
    var _next_char_1 = function (_str, _idx, _set, _negate) {
      var tmp;
      var var_29 = lua_assertfloat(_idx),
        stop_29 = lua_assertfloat(lua_len(_str));
      for (; var_29 <= stop_29; var_29++) {
        var _i_29 = var_29;
        if (
          !lua_eq(
            lua_tableget(_set, lua_mcall(_str, "sub", [_i_29, _i_29])[0]),
            _negate,
          )
        ) {
          return [_i_29];
        }
      }
      return [lua_add(lua_len(_str), 1)];
      return [];
    };
    var _decode_error_1 = function (_str, _idx, _msg) {
      var tmp;
      var _line_count_32 = 1;
      var _col_count_32 = 1;
      var var_33 = 1,
        stop_33 = lua_assertfloat(lua_subtract(_idx, 1));
      for (; var_33 <= stop_33; var_33++) {
        var _i_33 = var_33;
        _col_count_32 = lua_add(_col_count_32, 1);
        if (lua_eq(lua_mcall(_str, "sub", [_i_33, _i_33])[0], "\n")) {
          _line_count_32 = lua_add(_line_count_32, 1);
          _col_count_32 = 1;
        }
      }
      lua_call(
        G.str["error"],
        lua_tablegetcall(G.str["string"], "format", [
          "%s at line %d col %d",
          _msg,
          _line_count_32,
          _col_count_32,
        ]),
      );
      return [];
    };
    var _codepoint_to_utf8_1 = function (_n) {
      var tmp;
      var _f_36 = lua_tableget(G.str["math"], "floor");
      if (lua_lte(_n, 0x7f)) {
        return lua_tablegetcall(G.str["string"], "char", [_n]);
      } else if (lua_lte(_n, 0x7ff)) {
        return lua_tablegetcall(G.str["string"], "char", [
          lua_add(lua_call(_f_36, [lua_divide(_n, 64)])[0], 192),
          lua_add(lua_mod(_n, 64), 128),
        ]);
      } else if (lua_lte(_n, 0xffff)) {
        return lua_tablegetcall(G.str["string"], "char", [
          lua_add(lua_call(_f_36, [lua_divide(_n, 4096)])[0], 224),
          lua_add(lua_call(_f_36, [lua_divide(lua_mod(_n, 4096), 64)])[0], 128),
          lua_add(lua_mod(_n, 64), 128),
        ]);
      } else if (lua_lte(_n, 0x10ffff)) {
        return lua_tablegetcall(G.str["string"], "char", [
          lua_add(lua_call(_f_36, [lua_divide(_n, 262144)])[0], 240),
          lua_add(
            lua_call(_f_36, [lua_divide(lua_mod(_n, 262144), 4096)])[0],
            128,
          ),
          lua_add(lua_call(_f_36, [lua_divide(lua_mod(_n, 4096), 64)])[0], 128),
          lua_add(lua_mod(_n, 64), 128),
        ]);
      }
      lua_call(
        G.str["error"],
        lua_tablegetcall(G.str["string"], "format", [
          "invalid unicode codepoint '%x'",
          _n,
        ]),
      );
      return [];
    };
    var _parse_unicode_escape_1 = function (_s) {
      var tmp;
      var _n1_41 = lua_call(G.str["tonumber"], [
        lua_mcall(_s, "sub", [1, 4])[0],
        16,
      ])[0];
      var _n2_41 = lua_call(G.str["tonumber"], [
        lua_mcall(_s, "sub", [7, 10])[0],
        16,
      ])[0];
      if (lua_true(_n2_41)) {
        return lua_call(_codepoint_to_utf8_1, [
          lua_add(
            lua_add(
              lua_multiply(lua_subtract(_n1_41, 0xd800), 0x400),
              lua_subtract(_n2_41, 0xdc00),
            ),
            0x10000,
          ),
        ]);
      } else {
        return lua_call(_codepoint_to_utf8_1, [_n1_41]);
      }
      return [];
    };
    var _parse_string_1 = function (_str, _i) {
      var tmp;
      var _res_44 = "";
      var _j_44 = lua_add(_i, 1);
      var _k_44 = _j_44;
      while (lua_lte(_j_44, lua_len(_str))) {
        var _x_45 = lua_mcall(_str, "byte", [_j_44])[0];
        if (lua_lt(_x_45, 32)) {
          lua_call(_decode_error_1, [
            _str,
            _j_44,
            "control character in string",
          ]);
        } else if (lua_eq(_x_45, 92)) {
          _res_44 = lua_concat(
            _res_44,
            lua_mcall(_str, "sub", [_k_44, lua_subtract(_j_44, 1)])[0],
          );
          _j_44 = lua_add(_j_44, 1);
          var _c_47 = lua_mcall(_str, "sub", [_j_44, _j_44])[0];
          if (lua_eq(_c_47, "u")) {
            var _hex_48 = lua_or(
              lua_or(
                lua_mcall(_str, "match", [
                  "^[dD][89aAbB]%x%x\\u%x%x%x%x",
                  lua_add(_j_44, 1),
                ])[0],
                function () {
                  return lua_mcall(_str, "match", [
                    "^%x%x%x%x",
                    lua_add(_j_44, 1),
                  ])[0];
                },
              ),
              function () {
                return lua_call(_decode_error_1, [
                  _str,
                  lua_subtract(_j_44, 1),
                  "invalid unicode escape in string",
                ])[0];
              },
            );
            _res_44 = lua_concat(
              _res_44,
              lua_call(_parse_unicode_escape_1, [_hex_48])[0],
            );
            _j_44 = lua_add(_j_44, lua_len(_hex_48));
          } else {
            if (lua_not(lua_tableget(_escape_chars_1, _c_47))) {
              lua_call(_decode_error_1, [
                _str,
                lua_subtract(_j_44, 1),
                lua_concat(
                  "invalid escape char '",
                  lua_concat(_c_47, "' in string"),
                ),
              ]);
            }
            _res_44 = lua_concat(
              _res_44,
              lua_tableget(_escape_char_map_inv_1, _c_47),
            );
          }
          _k_44 = lua_add(_j_44, 1);
        } else if (lua_eq(_x_45, 34)) {
          _res_44 = lua_concat(
            _res_44,
            lua_mcall(_str, "sub", [_k_44, lua_subtract(_j_44, 1)])[0],
          );
          return [_res_44, lua_add(_j_44, 1)];
        }
        _j_44 = lua_add(_j_44, 1);
      }
      lua_call(_decode_error_1, [
        _str,
        _i,
        "expected closing quote for string",
      ]);
      return [];
    };
    var _parse_number_1 = function (_str, _i) {
      var tmp;
      var _x_52 = lua_call(_next_char_1, [_str, _i, _delim_chars_1])[0];
      var _s_52 = lua_mcall(_str, "sub", [_i, lua_subtract(_x_52, 1)])[0];
      var _n_52 = lua_call(G.str["tonumber"], [_s_52])[0];
      if (lua_not(_n_52)) {
        lua_call(_decode_error_1, [
          _str,
          _i,
          lua_concat("invalid number '", lua_concat(_s_52, "'")),
        ]);
      }
      return [_n_52, _x_52];
      return [];
    };
    var _parse_literal_1 = function (_str, _i) {
      var tmp;
      var _x_54 = lua_call(_next_char_1, [_str, _i, _delim_chars_1])[0];
      var _word_54 = lua_mcall(_str, "sub", [_i, lua_subtract(_x_54, 1)])[0];
      if (lua_not(lua_tableget(_literals_1, _word_54))) {
        lua_call(_decode_error_1, [
          _str,
          _i,
          lua_concat("invalid literal '", lua_concat(_word_54, "'")),
        ]);
      }
      return [lua_tableget(_literal_map_1, _word_54), _x_54];
      return [];
    };
    var _parse_array_1 = function (_str, _i) {
      var tmp;
      var _res_56 = lua_newtable();
      var _n_56 = 1;
      _i = lua_add(_i, 1);
      while (lua_true(1)) {
        var _x_57;
        _i = lua_call(_next_char_1, [_str, _i, _space_chars_1, true])[0];
        if (lua_eq(lua_mcall(_str, "sub", [_i, _i])[0], "]")) {
          _i = lua_add(_i, 1);
          break;
        }
        tmp = lua_call(_parse_1, [_str, _i]);
        _x_57 = tmp[0];
        _i = tmp[1];
        tmp = null;
        lua_tableset(_res_56, _n_56, _x_57);
        _n_56 = lua_add(_n_56, 1);
        _i = lua_call(_next_char_1, [_str, _i, _space_chars_1, true])[0];
        var _chr_57 = lua_mcall(_str, "sub", [_i, _i])[0];
        _i = lua_add(_i, 1);
        if (lua_eq(_chr_57, "]")) {
          break;
        }
        if (!lua_eq(_chr_57, ",")) {
          lua_call(_decode_error_1, [_str, _i, "expected ']' or ','"]);
        }
      }
      return [_res_56, _i];
      return [];
    };
    var _parse_object_1 = function (_str, _i) {
      var tmp;
      var _res_61 = lua_newtable();
      _i = lua_add(_i, 1);
      while (lua_true(1)) {
        var _key_62, _val_62;
        _i = lua_call(_next_char_1, [_str, _i, _space_chars_1, true])[0];
        if (lua_eq(lua_mcall(_str, "sub", [_i, _i])[0], "}")) {
          _i = lua_add(_i, 1);
          break;
        }
        if (!lua_eq(lua_mcall(_str, "sub", [_i, _i])[0], '"')) {
          lua_call(_decode_error_1, [_str, _i, "expected string for key"]);
        }
        tmp = lua_call(_parse_1, [_str, _i]);
        _key_62 = tmp[0];
        _i = tmp[1];
        tmp = null;
        _i = lua_call(_next_char_1, [_str, _i, _space_chars_1, true])[0];
        if (!lua_eq(lua_mcall(_str, "sub", [_i, _i])[0], ":")) {
          lua_call(_decode_error_1, [_str, _i, "expected ':' after key"]);
        }
        _i = lua_call(_next_char_1, [
          _str,
          lua_add(_i, 1),
          _space_chars_1,
          true,
        ])[0];
        tmp = lua_call(_parse_1, [_str, _i]);
        _val_62 = tmp[0];
        _i = tmp[1];
        tmp = null;
        lua_tableset(_res_61, _key_62, _val_62);
        _i = lua_call(_next_char_1, [_str, _i, _space_chars_1, true])[0];
        var _chr_62 = lua_mcall(_str, "sub", [_i, _i])[0];
        _i = lua_add(_i, 1);
        if (lua_eq(_chr_62, "}")) {
          break;
        }
        if (!lua_eq(_chr_62, ",")) {
          lua_call(_decode_error_1, [_str, _i, "expected '}' or ','"]);
        }
      }
      return [_res_61, _i];
      return [];
    };
    var _char_func_map_1 = lua_newtable(
      [],
      '"',
      _parse_string_1,
      "0",
      _parse_number_1,
      "1",
      _parse_number_1,
      "2",
      _parse_number_1,
      "3",
      _parse_number_1,
      "4",
      _parse_number_1,
      "5",
      _parse_number_1,
      "6",
      _parse_number_1,
      "7",
      _parse_number_1,
      "8",
      _parse_number_1,
      "9",
      _parse_number_1,
      "-",
      _parse_number_1,
      "t",
      _parse_literal_1,
      "f",
      _parse_literal_1,
      "n",
      _parse_literal_1,
      "[",
      _parse_array_1,
      "{",
      _parse_object_1,
    );
    _parse_1 = function (_str, _idx) {
      var tmp;
      var _chr_68 = lua_mcall(_str, "sub", [_idx, _idx])[0];
      var _f_68 = lua_tableget(_char_func_map_1, _chr_68);
      if (lua_true(_f_68)) {
        return lua_call(_f_68, [_str, _idx]);
      }
      lua_call(_decode_error_1, [
        _str,
        _idx,
        lua_concat("unexpected character '", lua_concat(_chr_68, "'")),
      ]);
      return [];
    };
    lua_tableset(_json_1, "decode", function (_str) {
      var tmp;
      if (!lua_eq(lua_call(G.str["type"], [_str])[0], "string")) {
        lua_call(G.str["error"], [
          lua_concat(
            "expected argument of type string, got ",
            lua_call(G.str["type"], [_str])[0],
          ),
        ]);
      }
      tmp = lua_call(
        _parse_1,
        [_str].concat(lua_call(_next_char_1, [_str, 1, _space_chars_1, true])),
      );
      var _res_70 = tmp[0];
      var _idx_70 = tmp[1];
      tmp = null;
      _idx_70 = lua_call(_next_char_1, [
        _str,
        _idx_70,
        _space_chars_1,
        true,
      ])[0];
      if (lua_lte(_idx_70, lua_len(_str))) {
        lua_call(_decode_error_1, [_str, _idx_70, "trailing garbage"]);
      }
      return [_res_70];
      return [];
    });
    return [_json_1];
  }
  return [G];
})()[0];

----
lib\jsonLua.lua
-- cspell:disable

--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

-- The IsaacScript version of this file contains modifications for better error messages, which
-- assist when debugging.

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack, traversalDescription)
  local res = {}
  stack = stack or {}
  traversalDescription = traversalDescription or ""

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types for array, excepted number, got: " .. tostring(type(k)))
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      local newTraversalDescription = traversalDescription .. tostring(i) .. " - "
      table.insert(res, encode(v, stack, newTraversalDescription))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      local newTraversalDescription = traversalDescription .. tostring(k) .. " - "
      if type(k) ~= "string" then
        error(
          "invalid table: mixed or invalid key types for object \"" .. newTraversalDescription .. "\", "
          .. "excepted string, got: " .. tostring(type(k))
        )
      end
      table.insert(res, encode(k, stack, newTraversalDescription) .. ":" .. encode(v, stack, newTraversalDescription))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack, traversalDescription)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack, traversalDescription)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return json

----
maps\PHDPillConversionsMap.ts
import { PillEffect } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

export const PHD_PILL_CONVERSIONS_MAP = new ReadonlyMap<PillEffect, PillEffect>(
  [
    [PillEffect.BAD_TRIP, PillEffect.BALLS_OF_STEEL], // 1
    [PillEffect.HEALTH_DOWN, PillEffect.HEALTH_UP], // 6
    [PillEffect.RANGE_DOWN, PillEffect.RANGE_UP], // 11
    [PillEffect.SPEED_DOWN, PillEffect.SPEED_UP], // 13
    [PillEffect.TEARS_DOWN, PillEffect.TEARS_UP], // 15
    [PillEffect.LUCK_DOWN, PillEffect.LUCK_UP], // 17
    [PillEffect.PARALYSIS, PillEffect.PHEROMONES], // 22
    [PillEffect.AMNESIA, PillEffect.I_CAN_SEE_FOREVER], // 25
    [PillEffect.R_U_A_WIZARD, PillEffect.POWER], // 27
    [PillEffect.ADDICTED, PillEffect.PERCS], // 29
    [PillEffect.QUESTION_MARKS, PillEffect.TELEPILLS], // 31
    [PillEffect.RETRO_VISION, PillEffect.I_CAN_SEE_FOREVER], // 37
    [PillEffect.X_LAX, PillEffect.SOMETHINGS_WRONG], // 39
    [PillEffect.IM_EXCITED, PillEffect.IM_DROWSY], // 42
    [PillEffect.HORF, PillEffect.GULP], // 44
    [PillEffect.SHOT_SPEED_DOWN, PillEffect.SHOT_SPEED_UP], // 47
  ],
);

----
maps\cardNameToTypeMap.ts
import { CardType } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

// cspell:ignore hiero

/** Maps card names to the values of the `CardType` enum. */
export const CARD_NAME_TO_TYPE_MAP = new ReadonlyMap<string, CardType>([
  ["fool", CardType.FOOL], // 1
  ["magician", CardType.MAGICIAN], // 2
  ["mag", CardType.MAGICIAN], // 2 - Needed since we have "mag?"
  ["highPriestess", CardType.HIGH_PRIESTESS], // 3
  ["priestess", CardType.HIGH_PRIESTESS], // 3
  ["priest", CardType.HIGH_PRIESTESS], // 3 - Needed since we have "priest?"
  ["hp", CardType.HIGH_PRIESTESS], // 3
  ["empress", CardType.EMPRESS], // 4
  ["emperor", CardType.EMPEROR], // 5
  ["emp", CardType.EMPEROR], // 5 - Needed since we have "hemp?"
  ["hierophant", CardType.HIEROPHANT], // 6
  ["hi", CardType.HIEROPHANT], // 6 - Needed since we have "hiero?"
  ["lovers", CardType.LOVERS], // 7
  ["chariot", CardType.CHARIOT], // 8
  ["justice", CardType.JUSTICE], // 9
  ["hermit", CardType.HERMIT], // 10
  ["wheelOfFortune", CardType.WHEEL_OF_FORTUNE], // 11
  ["wheel", CardType.WHEEL_OF_FORTUNE], // 11 - Needed since we have "wheel?"
  ["fortune", CardType.WHEEL_OF_FORTUNE], // 11
  ["strength", CardType.STRENGTH], // 12
  ["str", CardType.STRENGTH], // 12 - Needed since we have "str?"
  ["hangedMan", CardType.HANGED_MAN], // 13
  ["hanged", CardType.HANGED_MAN], // 13
  ["death", CardType.DEATH], // 14
  ["temperance", CardType.TEMPERANCE], // 15
  ["devil", CardType.DEVIL], // 16
  ["tower", CardType.TOWER], // 17
  ["stars", CardType.STARS], // 18
  ["moon", CardType.MOON], // 19
  ["sun", CardType.SUN], // 20
  ["judgement", CardType.JUDGEMENT], // 21
  ["judge", CardType.JUDGEMENT], // 21 - Needed since we have "judge?"
  ["world", CardType.WORLD], // 22
  ["2OfClubs", CardType.TWO_OF_CLUBS], // 23
  ["2Clubs", CardType.TWO_OF_CLUBS], // 23
  ["2OfDiamonds", CardType.TWO_OF_DIAMONDS], // 24
  ["2Diamonds", CardType.TWO_OF_DIAMONDS], // 24
  ["2OfSpades", CardType.TWO_OF_SPADES], // 25
  ["2Spades", CardType.TWO_OF_SPADES], // 25
  ["2OfHearts", CardType.TWO_OF_HEARTS], // 26
  ["2Hearts", CardType.TWO_OF_HEARTS], // 26
  ["aceOfClubs", CardType.ACE_OF_CLUBS], // 27
  ["aceClubs", CardType.ACE_OF_CLUBS], // 27
  ["aceOfDiamonds", CardType.ACE_OF_DIAMONDS], // 28
  ["aceDiamonds", CardType.ACE_OF_DIAMONDS], // 28
  ["aceOfSpades", CardType.ACE_OF_SPADES], // 29
  ["aceSpades", CardType.ACE_OF_SPADES], // 29
  ["aceOfHearts", CardType.ACE_OF_HEARTS], // 30
  ["aceHearts", CardType.ACE_OF_HEARTS], // 30
  ["joker", CardType.JOKER], // 31
  ["hagalaz", CardType.RUNE_HAGALAZ], // 32
  ["destruction", CardType.RUNE_HAGALAZ], // 32
  ["jera", CardType.RUNE_JERA], // 33
  ["abundance", CardType.RUNE_JERA], // 33
  ["ehwaz", CardType.RUNE_EHWAZ], // 34
  ["passage", CardType.RUNE_EHWAZ], // 34
  ["dagaz", CardType.RUNE_DAGAZ], // 35
  ["purity", CardType.RUNE_DAGAZ], // 35
  ["ansuz", CardType.RUNE_ANSUZ], // 36
  ["vision", CardType.RUNE_ANSUZ], // 36
  ["perthro", CardType.RUNE_PERTHRO], // 37
  ["change", CardType.RUNE_PERTHRO], // 37
  ["berkano", CardType.RUNE_BERKANO], // 38
  ["companionship", CardType.RUNE_BERKANO], // 38
  ["algiz", CardType.RUNE_ALGIZ], // 39
  ["resistance", CardType.RUNE_ALGIZ], // 39
  ["shield", CardType.RUNE_ALGIZ], // 39
  ["blankRune", CardType.RUNE_BLANK], // 40
  ["blackRune", CardType.RUNE_BLACK], // 41
  ["chaos", CardType.CHAOS], // 42
  ["credit", CardType.CREDIT], // 43
  ["rules", CardType.RULES], // 44
  ["againstHumanity", CardType.AGAINST_HUMANITY], // 45
  ["humanity", CardType.AGAINST_HUMANITY], // 45
  ["suicideKing", CardType.SUICIDE_KING], // 46
  ["suicide", CardType.SUICIDE_KING], // 46
  ["getOutOfJailFree", CardType.GET_OUT_OF_JAIL_FREE], // 47
  ["jail", CardType.GET_OUT_OF_JAIL_FREE], // 47
  ["?", CardType.QUESTION_MARK], // 48
  ["diceShard", CardType.DICE_SHARD], // 49
  ["shard", CardType.DICE_SHARD], // 49
  ["emergencyContact", CardType.EMERGENCY_CONTACT], // 50
  ["contact", CardType.EMERGENCY_CONTACT], // 50
  ["holy", CardType.HOLY], // 51
  ["hugeGrowth", CardType.HUGE_GROWTH], // 52
  ["growth", CardType.HUGE_GROWTH], // 52
  ["ancientRecall", CardType.ANCIENT_RECALL], // 53
  ["recall", CardType.ANCIENT_RECALL], // 53
  ["eraWalk", CardType.ERA_WALK], // 54
  ["walk", CardType.ERA_WALK], // 54
  ["runeShard", CardType.RUNE_SHARD], // 55
  ["shard", CardType.RUNE_SHARD], // 55
  ["fool?", CardType.REVERSE_FOOL], // 56
  ["magician?", CardType.REVERSE_MAGICIAN], // 57
  ["magi?", CardType.REVERSE_MAGICIAN], // 57
  ["mag?", CardType.REVERSE_MAGICIAN], // 57
  ["highPriestess?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["high?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["hi?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["priestess?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["priest?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["hp?", CardType.REVERSE_HIGH_PRIESTESS], // 58
  ["empress?", CardType.REVERSE_EMPRESS], // 59
  ["emperor?", CardType.REVERSE_EMPEROR], // 60
  ["emp?", CardType.REVERSE_EMPEROR], // 60
  ["hierophant?", CardType.REVERSE_HIEROPHANT], // 61
  ["hiero?", CardType.REVERSE_HIEROPHANT], // 61
  ["lovers?", CardType.REVERSE_LOVERS], // 62
  ["chariot?", CardType.REVERSE_CHARIOT], // 63
  ["justice?", CardType.REVERSE_JUSTICE], // 64
  ["hermit?", CardType.REVERSE_HERMIT], // 65
  ["wheelOfFortune?", CardType.REVERSE_WHEEL_OF_FORTUNE], // 66
  ["wheel?", CardType.REVERSE_WHEEL_OF_FORTUNE], // 66
  ["fortune?", CardType.REVERSE_WHEEL_OF_FORTUNE], // 66
  ["strength?", CardType.REVERSE_STRENGTH], // 67
  ["str?", CardType.REVERSE_STRENGTH], // 67
  ["hangedMan?", CardType.REVERSE_HANGED_MAN], // 68
  ["hanged?", CardType.REVERSE_HANGED_MAN], // 68
  ["death?", CardType.REVERSE_DEATH], // 6
  ["temperance?", CardType.REVERSE_TEMPERANCE], // 70
  ["devil?", CardType.REVERSE_DEVIL], // 71
  ["tower?", CardType.REVERSE_TOWER], // 72
  ["stars?", CardType.REVERSE_STARS], // 73
  ["moon?", CardType.REVERSE_MOON], // 74
  ["sun?", CardType.REVERSE_SUN], // 75
  ["judgement?", CardType.REVERSE_JUDGEMENT], // 76
  ["judge?", CardType.REVERSE_JUDGEMENT], // 76
  ["world?", CardType.REVERSE_WORLD], // 77
  ["crackedKey", CardType.CRACKED_KEY], // 78
  ["key", CardType.CRACKED_KEY], // 78
  ["queenOfHearts", CardType.QUEEN_OF_HEARTS], // 79
  ["queenHearts", CardType.QUEEN_OF_HEARTS], // 79
  ["wildcard", CardType.WILD], // 80
  ["soulOfIsaac", CardType.SOUL_OF_ISAAC], // 81
  ["soulIsaac", CardType.SOUL_OF_ISAAC], // 81
  ["isaac", CardType.SOUL_OF_ISAAC], // 81
  ["soulOfMagdalene", CardType.SOUL_OF_MAGDALENE], // 82
  ["soulMagdalene", CardType.SOUL_OF_MAGDALENE], // 82
  ["magdalene", CardType.SOUL_OF_MAGDALENE], // 82
  ["soulOfCain", CardType.SOUL_OF_CAIN], // 83
  ["soulCain", CardType.SOUL_OF_CAIN], // 83
  ["cain", CardType.SOUL_OF_CAIN], // 83
  ["soulOfJudas", CardType.SOUL_OF_JUDAS], // 84
  ["soulJudas", CardType.SOUL_OF_JUDAS], // 84
  ["judas", CardType.SOUL_OF_JUDAS], // 84
  ["soulOf???", CardType.SOUL_OF_BLUE_BABY], // 85
  ["soul???", CardType.SOUL_OF_BLUE_BABY], // 85
  ["???", CardType.SOUL_OF_BLUE_BABY], // 85
  ["soulOfBlueBaby", CardType.SOUL_OF_BLUE_BABY], // 85
  ["soulBlueBaby", CardType.SOUL_OF_BLUE_BABY], // 85
  ["blueBaby", CardType.SOUL_OF_BLUE_BABY], // 85
  ["soulOfEve", CardType.SOUL_OF_EVE], // 86
  ["soulEve", CardType.SOUL_OF_EVE], // 86
  ["eve", CardType.SOUL_OF_EVE], // 86
  ["soulOfSamson", CardType.SOUL_OF_SAMSON], // 87
  ["soulSamson", CardType.SOUL_OF_SAMSON], // 87
  ["samson", CardType.SOUL_OF_SAMSON], // 87
  ["soulOfAzazel", CardType.SOUL_OF_AZAZEL], // 88
  ["soulAzazel", CardType.SOUL_OF_AZAZEL], // 88
  ["azazel", CardType.SOUL_OF_AZAZEL], // 88
  ["soulOfLazarus", CardType.SOUL_OF_LAZARUS], // 89
  ["soulLazarus", CardType.SOUL_OF_LAZARUS], // 89
  ["lazarus", CardType.SOUL_OF_LAZARUS], // 89
  ["soulOfEden", CardType.SOUL_OF_EDEN], // 90
  ["soulEden", CardType.SOUL_OF_EDEN], // 90
  ["eden", CardType.SOUL_OF_EDEN], // 90
  ["soulOfTheLost", CardType.SOUL_OF_LOST], // 91
  ["soulTheLost", CardType.SOUL_OF_LOST], // 91
  ["theLost", CardType.SOUL_OF_LOST], // 91
  ["soulOfLost", CardType.SOUL_OF_LOST], // 91
  ["soulLost", CardType.SOUL_OF_LOST], // 91
  ["lost", CardType.SOUL_OF_LOST], // 91
  ["soulOfLilith", CardType.SOUL_OF_LILITH], // 92
  ["soulLilith", CardType.SOUL_OF_LILITH], // 92
  ["lilith", CardType.SOUL_OF_LILITH], // 92
  ["soulOfTheKeeper", CardType.SOUL_OF_KEEPER], // 93
  ["soulTheKeeper", CardType.SOUL_OF_KEEPER], // 93
  ["theKeeper", CardType.SOUL_OF_KEEPER], // 93
  ["soulOfKeeper", CardType.SOUL_OF_KEEPER], // 93
  ["soulKeeper", CardType.SOUL_OF_KEEPER], // 93
  ["keeper", CardType.SOUL_OF_KEEPER], // 93
  ["soulOfApollyon", CardType.SOUL_OF_APOLLYON], // 94
  ["soulApollyon", CardType.SOUL_OF_APOLLYON], // 94
  ["apollyon", CardType.SOUL_OF_APOLLYON], // 94
  ["soulOfTheForgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["soulTheForgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["theForgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["soulOfForgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["soulForgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["forgotten", CardType.SOUL_OF_FORGOTTEN], // 95
  ["soulOfBethany", CardType.SOUL_OF_BETHANY], // 96
  ["soulBethany", CardType.SOUL_OF_BETHANY], // 96
  ["bethany", CardType.SOUL_OF_BETHANY], // 96
  ["soulOfJacobAndEsau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["soulJacobAndEsau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["jacobAndEsau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["soulOfJacob&Esau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["soulJacob&Esau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["jacob&Esau", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["soulOfJacob", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["soulJacob", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
  ["jacob", CardType.SOUL_OF_JACOB_AND_ESAU], // 97
]);

----
maps\characterNameToTypeMap.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Maps character names to the values of the `PlayerType` enum. */
export const CHARACTER_NAME_TO_TYPE_MAP = new ReadonlyMap<string, PlayerType>([
  ["isaac", PlayerType.ISAAC], // 0
  ["magdalene", PlayerType.MAGDALENE], // 1
  ["maggy", PlayerType.MAGDALENE], // 1
  ["cain", PlayerType.CAIN], // 2
  ["judas", PlayerType.JUDAS], // 3
  ["blueBaby", PlayerType.BLUE_BABY], // 4
  ["bb", PlayerType.BLUE_BABY], // 4
  ["eve", PlayerType.EVE], // 5
  ["samson", PlayerType.SAMSON], // 6
  ["azazel", PlayerType.AZAZEL], // 7
  ["lazarus", PlayerType.LAZARUS], // 8
  // Needed so that "laz2" does not take precedence over "lazarus".
  ["laz", PlayerType.LAZARUS], // 8
  ["eden", PlayerType.EDEN], // 9
  ["theLost", PlayerType.LOST], // 10
  ["lost", PlayerType.LOST], // 10
  ["lazarus2", PlayerType.LAZARUS_2], // 11
  ["laz2", PlayerType.LAZARUS_2], // 11
  ["darkJudas", PlayerType.DARK_JUDAS], // 12
  ["dJudas", PlayerType.DARK_JUDAS], // 12
  ["blackJudas", PlayerType.DARK_JUDAS], // 12
  ["bJudas", PlayerType.DARK_JUDAS], // 12
  ["lilith", PlayerType.LILITH], // 13
  ["keeper", PlayerType.KEEPER], // 14
  ["apollyon", PlayerType.APOLLYON], // 15
  ["theForgotten", PlayerType.FORGOTTEN], // 16
  ["forgotten", PlayerType.FORGOTTEN], // 16
  ["theSoul", PlayerType.SOUL], // 17
  ["soul", PlayerType.SOUL], // 17
  ["bethany", PlayerType.BETHANY], // 18
  ["jacob", PlayerType.JACOB], // 19
  ["esau", PlayerType.ESAU], // 20
  ["taintedIsaac", PlayerType.ISAAC_B], // 21
  ["tIsaac", PlayerType.ISAAC_B], // 21
  ["taintedMagdalene", PlayerType.MAGDALENE_B], // 22
  ["tMagdalene", PlayerType.MAGDALENE_B], // 22
  ["taintedMaggy", PlayerType.MAGDALENE_B], // 22
  ["tMaggy", PlayerType.MAGDALENE_B], // 22
  ["taintedCain", PlayerType.CAIN_B], // 23
  ["tCain", PlayerType.CAIN_B], // 23
  ["taintedJudas", PlayerType.JUDAS_B], // 24
  ["tJudas", PlayerType.JUDAS_B], // 24
  ["taintedBlueBaby", PlayerType.BLUE_BABY_B], // 25
  ["tBlueBaby", PlayerType.BLUE_BABY_B], // 25
  ["tbb", PlayerType.BLUE_BABY_B], // 25
  ["taintedEve", PlayerType.EVE_B], // 26
  ["tEve", PlayerType.EVE_B], // 26
  ["taintedSamson", PlayerType.SAMSON_B], // 27
  ["tSamson", PlayerType.SAMSON_B], // 27
  ["taintedAzazel", PlayerType.AZAZEL_B], // 28
  ["tAzazel", PlayerType.AZAZEL_B], // 28
  ["taintedLazarus", PlayerType.LAZARUS_B], // 29
  ["tLazarus", PlayerType.LAZARUS_B], // 29
  ["taintedLaz", PlayerType.LAZARUS_B], // 29
  ["tLaz", PlayerType.LAZARUS_B], // 29
  ["taintedEden", PlayerType.EDEN_B], // 30
  ["tEden", PlayerType.EDEN_B], // 30
  ["taintedLost", PlayerType.LOST_B], // 31
  ["tLost", PlayerType.LOST_B], // 31
  ["taintedLilith", PlayerType.LILITH_B], // 32
  ["tLilith", PlayerType.LILITH_B], // 32
  ["taintedKeeper", PlayerType.KEEPER_B], // 33
  ["tKeeper", PlayerType.KEEPER_B], // 33
  ["taintedApollyon", PlayerType.APOLLYON_B], // 34
  ["tApollyon", PlayerType.APOLLYON_B], // 34
  ["taintedForgotten", PlayerType.FORGOTTEN_B], // 35
  ["tForgotten", PlayerType.FORGOTTEN_B], // 35
  ["taintedBethany", PlayerType.BETHANY_B], // 36
  ["tBethany", PlayerType.BETHANY_B], // 36
  ["taintedJacob", PlayerType.JACOB_B], // 37
  ["tJacob", PlayerType.JACOB_B], // 37
  ["taintedLazarusDead", PlayerType.LAZARUS_2_B], // 38
  ["tLazarusDead", PlayerType.LAZARUS_2_B], // 38
  ["taintedLazDead", PlayerType.LAZARUS_2_B], // 38
  ["tLazDead", PlayerType.LAZARUS_2_B], // 38
  ["deadTaintedLazarus", PlayerType.LAZARUS_2_B], // 38
  ["deadTLazarus", PlayerType.LAZARUS_2_B], // 38
  ["deadTaintedLaz", PlayerType.LAZARUS_2_B], // 38
  ["deadTLaz", PlayerType.LAZARUS_2_B], // 38
  ["taintedJacobGhost", PlayerType.JACOB_2_B], // 39
  ["tJacobGhost", PlayerType.JACOB_2_B], // 39
  ["taintedSoul", PlayerType.SOUL_B], // 40
  ["tSoul", PlayerType.SOUL_B], // 40
]);

----
maps\collectibleNameToTypeMap.ts
import type { CollectibleType } from "isaac-typescript-definitions";
import { removeNonAlphanumericCharacters } from "../functions/string";
import { COLLECTIBLE_NAMES } from "../objects/collectibleNames";
import type { ReadonlyMap } from "../types/ReadonlyMap";

/**
 * Maps collectible names to the values of the `CollectibleType` enum.
 *
 * For a mapping of `CollectibleType` to name, see the `COLLECTIBLE_NAMES` constant.
 */
export const COLLECTIBLE_NAME_TO_TYPE_MAP: ReadonlyMap<
  string,
  CollectibleType
> = (() => {
  const collectibleNameToTypeMap = new Map<string, CollectibleType>();

  for (const [collectibleTypeString, name] of Object.entries(
    COLLECTIBLE_NAMES,
  )) {
    const collectibleType = collectibleTypeString as unknown as CollectibleType;
    const simpleString = removeNonAlphanumericCharacters(name);
    collectibleNameToTypeMap.set(simpleString, collectibleType);
  }

  return collectibleNameToTypeMap;
})();

----
maps\defaultPlayerStatMap.ts
import { CacheFlag } from "isaac-typescript-definitions";
import { getTearsStat } from "../functions/tears";
import { ReadonlyMap } from "../types/ReadonlyMap";

const DEFAULT_MAX_FIRE_DELAY = 10;

/** The default fire delay is represented in the tear stat, not the `MaxFireDelay` value. */
export const DEFAULT_PLAYER_STAT_MAP = new ReadonlyMap<CacheFlag, number>([
  [CacheFlag.DAMAGE, 3.5], // 1 << 0

  // The default tears stat is 2.73.
  [CacheFlag.FIRE_DELAY, getTearsStat(DEFAULT_MAX_FIRE_DELAY)], // 1 << 1

  [CacheFlag.SHOT_SPEED, 1], // 1 << 2
  [CacheFlag.RANGE, 6.5], // 1 << 3
  [CacheFlag.SPEED, 1], // 1 << 4
  [CacheFlag.LUCK, 0], // 1 << 10
]);

----
maps\entityTypeVariantToBossIDMap.ts
import type { BossID } from "isaac-typescript-definitions";
import { BOSS_ID_TO_ENTITY_TYPE_VARIANT } from "../objects/bossIDToEntityTypeVariant";
import { ReadonlyMap } from "../types/ReadonlyMap";

export const ENTITY_TYPE_VARIANT_TO_BOSS_ID_MAP = new ReadonlyMap(
  [...Object.entries(BOSS_ID_TO_ENTITY_TYPE_VARIANT)].map(
    ([bossIDRaw, entityTypeVariant]) => {
      const bossID = bossIDRaw as unknown as BossID;
      const [entityType, variant] = entityTypeVariant;
      const entityTypeVariantString = `${entityType}.${variant}`;
      return [entityTypeVariantString, bossID];
    },
  ),
);

----
maps\falsePHDPillConversionsMap.ts
import { PillEffect } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

export const FALSE_PHD_PILL_CONVERSIONS_MAP = new ReadonlyMap<
  PillEffect,
  PillEffect
>([
  [PillEffect.BAD_GAS, PillEffect.HEALTH_DOWN], // 0
  [PillEffect.BALLS_OF_STEEL, PillEffect.BAD_TRIP], // 2
  [PillEffect.BOMBS_ARE_KEYS, PillEffect.TEARS_DOWN], // 3
  [PillEffect.EXPLOSIVE_DIARRHEA, PillEffect.RANGE_DOWN], // 4
  [PillEffect.FULL_HEALTH, PillEffect.BAD_TRIP], // 5
  [PillEffect.HEALTH_UP, PillEffect.HEALTH_DOWN], // 7
  [PillEffect.PRETTY_FLY, PillEffect.LUCK_DOWN], // 10
  [PillEffect.RANGE_UP, PillEffect.RANGE_DOWN], // 12
  [PillEffect.SPEED_UP, PillEffect.SPEED_DOWN], // 14
  [PillEffect.TEARS_UP, PillEffect.TEARS_DOWN], // 16
  [PillEffect.LUCK_UP, PillEffect.LUCK_DOWN], // 18
  [PillEffect.TELEPILLS, PillEffect.QUESTION_MARKS], // 19
  [PillEffect.FORTY_EIGHT_HOUR_ENERGY, PillEffect.SPEED_DOWN], // 20
  [PillEffect.HEMATEMESIS, PillEffect.BAD_TRIP], // 21
  [PillEffect.I_CAN_SEE_FOREVER, PillEffect.AMNESIA], // 23
  [PillEffect.PHEROMONES, PillEffect.PARALYSIS], // 24
  [PillEffect.LEMON_PARTY, PillEffect.AMNESIA], // 26
  [PillEffect.PERCS, PillEffect.ADDICTED], // 28
  [PillEffect.ONE_MAKES_YOU_LARGER, PillEffect.RANGE_DOWN], // 32
  [PillEffect.ONE_MAKES_YOU_SMALL, PillEffect.SPEED_DOWN], // 33
  [PillEffect.INFESTED_EXCLAMATION, PillEffect.TEARS_DOWN], // 34
  [PillEffect.INFESTED_QUESTION, PillEffect.LUCK_DOWN], // 35
  [PillEffect.POWER, PillEffect.R_U_A_WIZARD], // 36
  [PillEffect.FRIENDS_TILL_THE_END, PillEffect.HEALTH_DOWN], // 38
  [PillEffect.SOMETHINGS_WRONG, PillEffect.X_LAX], // 40
  [PillEffect.IM_DROWSY, PillEffect.IM_EXCITED], // 41
  [PillEffect.GULP, PillEffect.HORF], // 43
  [PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE, PillEffect.RETRO_VISION], // 45
  [PillEffect.VURP, PillEffect.HORF], // 46
  [PillEffect.SHOT_SPEED_UP, PillEffect.SHOT_SPEED_DOWN], // 48
]);

----
maps\gridEntityTypeToBrokenStateMap.ts
import {
  GridEntityType,
  LockState,
  PoopState,
  RockState,
  SpiderWebState,
  TNTState,
} from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Not every grid entity can be broken. Thus use a map to represent this. */
export const GRID_ENTITY_TYPE_TO_BROKEN_STATE_MAP = new ReadonlyMap<
  GridEntityType,
  int
>([
  // 2
  [GridEntityType.ROCK, RockState.BROKEN],

  // 4
  [GridEntityType.ROCK_TINTED, RockState.BROKEN],

  // 5
  [GridEntityType.ROCK_BOMB, RockState.BROKEN],

  // 6
  [GridEntityType.ROCK_ALT, RockState.BROKEN],

  // 10
  [GridEntityType.SPIDER_WEB, SpiderWebState.BROKEN],

  // 11
  [GridEntityType.LOCK, LockState.UNLOCKED],

  // 12
  [GridEntityType.TNT, TNTState.EXPLODED],

  // 14
  [GridEntityType.POOP, PoopState.COMPLETELY_DESTROYED],

  // 22
  [GridEntityType.ROCK_SUPER_SPECIAL, RockState.BROKEN],

  // 25
  [GridEntityType.ROCK_SPIKED, RockState.BROKEN],

  // 26
  [GridEntityType.ROCK_ALT_2, RockState.BROKEN],

  // 27
  [GridEntityType.ROCK_GOLD, RockState.BROKEN],
]);

----
maps\gridEntityXMLMap.ts
import {
  CrawlSpaceVariant,
  GridEntityType,
  GridEntityXMLType,
  PitVariant,
  PoopGridEntityVariant,
  PressurePlateVariant,
  RockVariant,
  StatueVariant,
  TrapdoorVariant,
} from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/**
 * This maps the GridEntityXMLType (i.e. the type contained in the room XML/STB file) to the
 * GridEntityType and the variant used by the game.
 */
export const GRID_ENTITY_XML_MAP = new ReadonlyMap<
  GridEntityXMLType,
  [GridEntityType, int]
>([
  // 0
  [GridEntityXMLType.DECORATION, [GridEntityType.DECORATION, 0]],

  // 1000
  [GridEntityXMLType.ROCK, [GridEntityType.ROCK, RockVariant.NORMAL]],

  // 1001
  [GridEntityXMLType.ROCK_BOMB, [GridEntityType.ROCK_BOMB, 0]],

  // 1002
  [GridEntityXMLType.ROCK_ALT, [GridEntityType.ROCK_ALT, 0]],

  // 1003
  [GridEntityXMLType.ROCK_TINTED, [GridEntityType.ROCK_TINTED, 0]],

  // 1008
  [GridEntityXMLType.ROCK_ALT_2, [GridEntityType.ROCK_ALT_2, 0]],

  // 1009
  [
    GridEntityXMLType.ROCK_EVENT,
    [GridEntityType.ROCK_ALT_2, RockVariant.EVENT],
  ],

  // 1010
  [GridEntityXMLType.ROCK_SPIKED, [GridEntityType.ROCK_SPIKED, 0]],

  // 1011
  [GridEntityXMLType.ROCK_GOLD, [GridEntityType.ROCK_GOLD, 0]],

  // 1300
  [GridEntityXMLType.TNT, [GridEntityType.TNT, 0]],

  // GridEntityXMLType.FIREPLACE (1400) and GridEntityXMLType.RED_FIREPLACE (1410) are intentionally
  // not mapped; the game converts these to EntityType.FIREPLACE (33). Manually spawning the grid
  // version of the fireplace will result in a bugged entity.

  // 1490
  [
    GridEntityXMLType.POOP_RED,
    [GridEntityType.POOP, PoopGridEntityVariant.RED],
  ],

  // 1494
  [
    GridEntityXMLType.POOP_RAINBOW,
    [GridEntityType.POOP, PoopGridEntityVariant.RAINBOW],
  ],

  // 1495
  [
    GridEntityXMLType.POOP_CORNY,
    [GridEntityType.POOP, PoopGridEntityVariant.CORNY],
  ],

  // 1496
  [
    GridEntityXMLType.POOP_GOLDEN,
    [GridEntityType.POOP, PoopGridEntityVariant.GOLDEN],
  ],

  // 1497
  [
    GridEntityXMLType.POOP_BLACK,
    [GridEntityType.POOP, PoopGridEntityVariant.BLACK],
  ],

  // 1498
  [
    GridEntityXMLType.POOP_WHITE,
    [GridEntityType.POOP, PoopGridEntityVariant.WHITE],
  ],

  // GridEntityXMLType.POOP_GIGA (1499) is intentionally not mapped; the game converts this to four
  // different grid entities that are all next to each other:
  // - PoopVariant.GIGA_TOP_LEFT (7)
  // - PoopVariant.GIGA_TOP_RIGHT (8)
  // - PoopVariant.GIGA_BOTTOM_LEFT (9)
  // - PoopVariant.GIGA_BOTTOM_RIGHT (10)

  // 1500
  [GridEntityXMLType.POOP, [GridEntityType.POOP, PoopGridEntityVariant.NORMAL]],

  // 1501
  [
    GridEntityXMLType.POOP_CHARMING,
    [GridEntityType.POOP, PoopGridEntityVariant.CHARMING],
  ],

  // 1900
  [GridEntityXMLType.BLOCK, [GridEntityType.BLOCK, 0]],

  // 1901
  [GridEntityXMLType.PILLAR, [GridEntityType.PILLAR, 0]],

  // 1930
  [GridEntityXMLType.SPIKES, [GridEntityType.SPIKES, 0]],

  // 1931
  [GridEntityXMLType.SPIKES_ON_OFF, [GridEntityType.SPIKES_ON_OFF, 0]],

  // 1940
  [GridEntityXMLType.SPIDER_WEB, [GridEntityType.SPIDER_WEB, 0]],

  // 1999
  [GridEntityXMLType.WALL, [GridEntityType.WALL, 0]],

  // 3000
  [GridEntityXMLType.PIT, [GridEntityType.PIT, PitVariant.NORMAL]],

  // 3001
  [
    GridEntityXMLType.FISSURE_SPAWNER,
    [GridEntityType.PIT, PitVariant.FISSURE_SPAWNER],
  ],

  // 3009 - `GridEntityXMLType.PIT_EVENT` spawns as a normal pit with VarData equal to 1. VarData
  // must be manually handled by any code that uses this mapping.)
  [GridEntityXMLType.PIT_EVENT, [GridEntityType.PIT, PitVariant.NORMAL]],

  // 4000
  [GridEntityXMLType.LOCK, [GridEntityType.LOCK, 0]],

  // 4500
  [
    GridEntityXMLType.PRESSURE_PLATE,
    [GridEntityType.PRESSURE_PLATE, PressurePlateVariant.PRESSURE_PLATE],
  ],

  // 5000
  [
    GridEntityXMLType.STATUE_DEVIL,
    [GridEntityType.STATUE, StatueVariant.DEVIL],
  ],

  // 5001
  [
    GridEntityXMLType.STATUE_ANGEL,
    [GridEntityType.STATUE, StatueVariant.ANGEL],
  ],

  // 6100
  [GridEntityXMLType.TELEPORTER, [GridEntityType.TELEPORTER, 0]],

  // 9000
  [
    GridEntityXMLType.TRAPDOOR,
    [GridEntityType.TRAPDOOR, TrapdoorVariant.NORMAL],
  ],

  // 9100
  [
    GridEntityXMLType.CRAWL_SPACE,
    [GridEntityType.CRAWL_SPACE, CrawlSpaceVariant.NORMAL],
  ],

  // 10000
  [GridEntityXMLType.GRAVITY, [GridEntityType.GRAVITY, 0]],
]);

----
maps\itemPoolTypeToItemPoolName.ts
import { ItemPoolType } from "isaac-typescript-definitions";

/** From "itempools.xml". */
export const ITEM_POOL_TYPE_TO_ITEM_POOL_NAME = {
  [ItemPoolType.TREASURE]: "treasure", // 0
  [ItemPoolType.SHOP]: "shop", // 1
  [ItemPoolType.BOSS]: "boss", // 2
  [ItemPoolType.DEVIL]: "devil", // 3
  [ItemPoolType.ANGEL]: "angel", // 4
  [ItemPoolType.SECRET]: "secret", // 5
  [ItemPoolType.LIBRARY]: "library", // 6
  [ItemPoolType.SHELL_GAME]: "shellGame", // 7
  [ItemPoolType.GOLDEN_CHEST]: "goldenChest", // 8
  [ItemPoolType.RED_CHEST]: "redChest", // 9
  [ItemPoolType.BEGGAR]: "beggar", // 10
  [ItemPoolType.DEMON_BEGGAR]: "demonBeggar", // 11
  [ItemPoolType.CURSE]: "curse", // 12
  [ItemPoolType.KEY_MASTER]: "keyMaster", // 13
  [ItemPoolType.BATTERY_BUM]: "batteryBum", // 14
  [ItemPoolType.MOMS_CHEST]: "momsChest", // 15
  [ItemPoolType.GREED_TREASURE]: "greedTreasure", // 16
  [ItemPoolType.GREED_BOSS]: "greedBoss", // 17
  [ItemPoolType.GREED_SHOP]: "greedShop", // 18
  [ItemPoolType.GREED_DEVIL]: "greedDevil", // 19
  [ItemPoolType.GREED_ANGEL]: "greedAngel", // 20
  [ItemPoolType.GREED_CURSE]: "greedCurse", // 21
  [ItemPoolType.GREED_SECRET]: "greedSecret", // 22
  [ItemPoolType.CRANE_GAME]: "craneGame", // 23
  [ItemPoolType.ULTRA_SECRET]: "ultraSecret", // 24
  [ItemPoolType.BOMB_BUM]: "bombBum", // 25
  [ItemPoolType.PLANETARIUM]: "planetarium", // 26
  [ItemPoolType.OLD_CHEST]: "oldChest", // 27
  [ItemPoolType.BABY_SHOP]: "babyShop", // 28
  [ItemPoolType.WOODEN_CHEST]: "woodenChest", // 29
  [ItemPoolType.ROTTEN_BEGGAR]: "rottenBeggar", // 30
} as const satisfies Record<ItemPoolType, string>;

----
maps\keyboardToStringMap.ts
import { Keyboard } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Maps each keyboard enum member to its corresponding lowercase and uppercase characters. */
export const KEYBOARD_TO_STRING_MAP = new ReadonlyMap<
  Keyboard,
  readonly [lowercaseCharacter: string, uppercaseCharacter: string]
>([
  [Keyboard.SPACE, [" ", " "]], // 32
  [Keyboard.APOSTROPHE, ["'", '"']], // 39
  [Keyboard.COMMA, [",", "<"]], // 44
  [Keyboard.MINUS, ["-", "_"]], // 45
  [Keyboard.PERIOD, [".", ">"]], // 46
  [Keyboard.SLASH, ["/", "?"]], // 47

  [Keyboard.ZERO, ["0", ")"]], // 48
  [Keyboard.ONE, ["1", "!"]], // 49
  [Keyboard.TWO, ["2", "@"]], // 50
  [Keyboard.THREE, ["3", "#"]], // 51
  [Keyboard.FOUR, ["4", "$"]], // 52
  [Keyboard.FIVE, ["5", "%"]], // 53
  [Keyboard.SIX, ["6", "^"]], // 54
  [Keyboard.SEVEN, ["7", "&"]], // 55
  [Keyboard.EIGHT, ["8", "*"]], // 56
  [Keyboard.NINE, ["9", "("]], // 57

  [Keyboard.SEMICOLON, [";", ":"]], // 59
  [Keyboard.EQUAL, ["=", "+"]], // 61

  [Keyboard.A, ["a", "A"]], // 65
  [Keyboard.B, ["b", "B"]], // 66
  [Keyboard.C, ["c", "C"]], // 67
  [Keyboard.D, ["d", "D"]], // 68
  [Keyboard.E, ["e", "E"]], // 69
  [Keyboard.F, ["f", "F"]], // 70
  [Keyboard.G, ["g", "G"]], // 71
  [Keyboard.H, ["h", "H"]], // 72
  [Keyboard.I, ["i", "I"]], // 73
  [Keyboard.J, ["j", "J"]], // 74
  [Keyboard.K, ["k", "K"]], // 75
  [Keyboard.L, ["l", "L"]], // 76
  [Keyboard.M, ["m", "M"]], // 77
  [Keyboard.N, ["n", "N"]], // 78
  [Keyboard.O, ["o", "O"]], // 79
  [Keyboard.P, ["p", "P"]], // 80
  [Keyboard.Q, ["q", "Q"]], // 81
  [Keyboard.R, ["r", "R"]], // 82
  [Keyboard.S, ["s", "S"]], // 83
  [Keyboard.T, ["t", "T"]], // 84
  [Keyboard.U, ["u", "U"]], // 85
  [Keyboard.V, ["v", "V"]], // 86
  [Keyboard.W, ["w", "W"]], // 87
  [Keyboard.X, ["x", "X"]], // 88
  [Keyboard.Y, ["y", "Y"]], // 89
  [Keyboard.Z, ["z", "Z"]], // 90

  [Keyboard.KP_0, ["0", "0"]], // 320
  [Keyboard.KP_1, ["1", "1"]], // 321
  [Keyboard.KP_2, ["2", "2"]], // 322
  [Keyboard.KP_3, ["3", "3"]], // 323
  [Keyboard.KP_4, ["4", "4"]], // 324
  [Keyboard.KP_5, ["5", "5"]], // 325
  [Keyboard.KP_6, ["6", "6"]], // 326
  [Keyboard.KP_7, ["7", "7"]], // 327
  [Keyboard.KP_8, ["8", "8"]], // 328
  [Keyboard.KP_9, ["9", "9"]], // 329

  [Keyboard.KP_DECIMAL, [".", "."]], // 330
  [Keyboard.KP_DIVIDE, ["/", "/"]], // 331
  [Keyboard.KP_MULTIPLY, ["*", "*"]], // 332
  [Keyboard.KP_SUBTRACT, ["-", "-"]], // 333
  [Keyboard.KP_ADD, ["+", "+"]], // 334

  [Keyboard.LEFT_BRACKET, ["[", "{"]], // 91
  [Keyboard.BACKSLASH, ["\\", "|"]], // 92
  [Keyboard.RIGHT_BRACKET, ["]", "}"]], // 93
  [Keyboard.GRAVE_ACCENT, ["`", "~"]], // 96
]);

----
maps\pillNameToEffectMap.ts
import { PillEffect } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Maps pill effect names to the values of the `PillEffect` enum. */
export const PILL_NAME_TO_EFFECT_MAP = new ReadonlyMap<string, PillEffect>([
  ["badGas", PillEffect.BAD_GAS], // 0
  ["gas", PillEffect.BAD_GAS], // 0
  ["badTrip", PillEffect.BAD_TRIP], // 1
  ["trip", PillEffect.BAD_TRIP], // 1
  ["ballsOfSteel", PillEffect.BALLS_OF_STEEL], // 2
  ["ballsSteel", PillEffect.BALLS_OF_STEEL], // 2
  ["steel", PillEffect.BALLS_OF_STEEL], // 2
  ["bombsAreKey", PillEffect.BOMBS_ARE_KEYS], // 3
  ["bombsKey", PillEffect.BOMBS_ARE_KEYS], // 3
  ["key", PillEffect.BOMBS_ARE_KEYS], // 3
  ["explosiveDiarrhea", PillEffect.EXPLOSIVE_DIARRHEA], // 4
  ["diarrhea", PillEffect.EXPLOSIVE_DIARRHEA], // 4
  ["fullHealth", PillEffect.FULL_HEALTH], // 5
  ["healthDown", PillEffect.HEALTH_DOWN], // 6
  ["healthUp", PillEffect.HEALTH_UP], // 7
  ["iFoundPills", PillEffect.I_FOUND_PILLS], // 8
  ["foundPills", PillEffect.I_FOUND_PILLS], // 8
  ["pills", PillEffect.I_FOUND_PILLS], // 8
  ["puberty", PillEffect.PUBERTY], // 9
  ["prettyFly", PillEffect.PRETTY_FLY], // 10
  ["fly", PillEffect.PRETTY_FLY], // 10
  ["rangeDown", PillEffect.RANGE_DOWN], // 11
  ["rangeUp", PillEffect.RANGE_UP], // 12
  ["speedDown", PillEffect.SPEED_DOWN], // 13
  ["speedUp", PillEffect.SPEED_UP], // 14
  ["tearsDown", PillEffect.TEARS_DOWN], // 15
  ["tearsUp", PillEffect.TEARS_UP], // 16
  ["luckDown", PillEffect.LUCK_DOWN], // 17
  ["luckUp", PillEffect.LUCK_UP], // 18
  ["telepills", PillEffect.TELEPILLS], // 19
  ["48HourEnergy", PillEffect.FORTY_EIGHT_HOUR_ENERGY], // 20
  ["energy", PillEffect.FORTY_EIGHT_HOUR_ENERGY], // 20
  ["48", PillEffect.FORTY_EIGHT_HOUR_ENERGY], // 20
  ["hematemesis", PillEffect.HEMATEMESIS], // 21
  ["paralysis", PillEffect.PARALYSIS], // 22
  ["iCanSeeForever!", PillEffect.I_CAN_SEE_FOREVER], // 23
  ["canSee", PillEffect.I_CAN_SEE_FOREVER], // 23
  ["see", PillEffect.I_CAN_SEE_FOREVER], // 23
  ["pheromones", PillEffect.PHEROMONES], // 24
  ["amnesia", PillEffect.AMNESIA], // 25
  ["lemonParty", PillEffect.LEMON_PARTY], // 26
  ["party", PillEffect.LEMON_PARTY], // 26
  ["RUAWizard", PillEffect.R_U_A_WIZARD], // 27
  ["areYouAWizard", PillEffect.R_U_A_WIZARD], // 27
  ["wizard", PillEffect.R_U_A_WIZARD], // 27
  ["percs!", PillEffect.PERCS], // 28
  ["addicted!", PillEffect.ADDICTED], // 29
  ["relax", PillEffect.RELAX], // 30
  ["???", PillEffect.QUESTION_MARKS], // 31
  ["oneMakesYouLarger", PillEffect.ONE_MAKES_YOU_LARGER], // 32
  ["larger", PillEffect.ONE_MAKES_YOU_LARGER], // 32
  ["oneMakesYouSmaller", PillEffect.ONE_MAKES_YOU_SMALL], // 33
  ["smaller", PillEffect.ONE_MAKES_YOU_SMALL], // 33
  ["infested!", PillEffect.INFESTED_EXCLAMATION], // 34
  ["infest!", PillEffect.INFESTED_EXCLAMATION], // 34
  ["inf!", PillEffect.INFESTED_EXCLAMATION], // 34
  ["infested?", PillEffect.INFESTED_QUESTION], // 35
  ["infest?", PillEffect.INFESTED_QUESTION], // 35
  ["inf?", PillEffect.INFESTED_QUESTION], // 35
  ["powerPill", PillEffect.POWER], // 36
  ["retroVision", PillEffect.RETRO_VISION], // 37
  ["vision", PillEffect.RETRO_VISION], // 37
  ["friendsTillTheEnd", PillEffect.FRIENDS_TILL_THE_END], // 38
  ["friendsUntilTheEnd", PillEffect.FRIENDS_TILL_THE_END], // 38
  ["xlax", PillEffect.X_LAX], // 39
  ["somethingsWrong", PillEffect.SOMETHINGS_WRONG], // 40
  ["wrong", PillEffect.SOMETHINGS_WRONG], // 40
  ["imDrowsy", PillEffect.IM_DROWSY], // 41
  ["drowsy", PillEffect.IM_DROWSY], // 41
  ["imExcited!!!", PillEffect.IM_EXCITED], // 42
  ["excited", PillEffect.IM_EXCITED], // 42
  ["gulp!", PillEffect.GULP], // 43
  ["horf!", PillEffect.HORF], // 44
  [
    "feelsLikeImWalkingOnSunshine!",
    PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE,
  ], // 45
  ["walking", PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE], // 45
  ["sunshine", PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE], // 45
  ["vurp!", PillEffect.VURP], // 46
  ["shotSpeedDown", PillEffect.SHOT_SPEED_DOWN], // 47
  ["shotSpeedUp", PillEffect.SHOT_SPEED_UP], // 48
  ["experimental", PillEffect.EXPERIMENTAL], // 49
]);

----
maps\roomNameToTypeMap.ts
import { RoomType } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Maps room names to the values of the `RoomType` enum. */
export const ROOM_NAME_TO_TYPE_MAP = new ReadonlyMap<string, RoomType>([
  ["default", RoomType.DEFAULT], // 1
  ["shop", RoomType.SHOP], // 2
  ["error", RoomType.ERROR], // 3
  ["iAmError", RoomType.ERROR], // 3
  ["treasure", RoomType.TREASURE], // 4
  ["boss", RoomType.BOSS], // 5
  ["miniBoss", RoomType.MINI_BOSS], // 6
  ["secret", RoomType.SECRET], // 7
  ["superSecret", RoomType.SUPER_SECRET], // 8
  ["arcade", RoomType.ARCADE], // 9
  ["curse", RoomType.CURSE], // 10
  ["challenge", RoomType.CHALLENGE], // 11
  ["library", RoomType.LIBRARY], // 12
  ["sacrifice", RoomType.SACRIFICE], // 13
  ["devil", RoomType.DEVIL], // 14
  ["angel", RoomType.ANGEL], // 15
  ["dungeon", RoomType.DUNGEON], // 16
  ["crawlSpace", RoomType.DUNGEON], // 16
  ["bossRush", RoomType.BOSS_RUSH], // 17
  ["isaacs", RoomType.CLEAN_BEDROOM], // 18
  ["bedroom", RoomType.CLEAN_BEDROOM], // 18
  ["cleanBedroom", RoomType.CLEAN_BEDROOM], // 18
  ["dirtyBedroom", RoomType.DIRTY_BEDROOM], // 19
  ["barren", RoomType.DIRTY_BEDROOM], // 19
  ["vault", RoomType.VAULT], // 20
  ["chest", RoomType.VAULT], // 20
  ["dice", RoomType.DICE], // 21
  ["blackMarket", RoomType.BLACK_MARKET], // 22
  ["greedExit", RoomType.GREED_EXIT], // 23
  ["planetarium", RoomType.PLANETARIUM], // 24
  ["teleporter", RoomType.TELEPORTER], // 25
  ["teleporterExit", RoomType.TELEPORTER_EXIT], // 26
  ["secretExit", RoomType.SECRET_EXIT], // 27
  ["blue", RoomType.BLUE], // 28
  ["ultraSecret", RoomType.ULTRA_SECRET], // 29
]);

----
maps\roomShapeToTopLeftWallGridIndexMap.ts
import { RoomShape } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

export const DEFAULT_TOP_LEFT_WALL_GRID_INDEX = 0;

/**
 * Only used for special room shapes where the top left wall grid index is not equal to
 * `DEFAULT_TOP_LEFT_WALL_GRID_INDEX`.
 */
export const ROOM_SHAPE_TO_TOP_LEFT_WALL_GRID_INDEX_MAP = new ReadonlyMap<
  RoomShape,
  int
>([
  [RoomShape.IH, 30], // 2
  [RoomShape.IV, 4], // 3
  [RoomShape.IIV, 4], // 5
  [RoomShape.IIH, 56], // 7
  [RoomShape.LTL, 13], // 9
]);

----
maps\transformationNameToPlayerFormMap.ts
import { PlayerForm } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

/** Maps transformation names to the values of the `PlayerForm` enum. */
export const TRANSFORMATION_NAME_TO_PLAYER_FORM_MAP = new ReadonlyMap<
  string,
  PlayerForm
>([
  ["guppy", PlayerForm.GUPPY], // 0
  ["cat", PlayerForm.GUPPY], // 0
  ["beelzebub", PlayerForm.BEELZEBUB], // 1
  ["fly", PlayerForm.BEELZEBUB], // 1
  ["funGuy", PlayerForm.FUN_GUY], // 2
  ["mushroom", PlayerForm.FUN_GUY], // 2
  ["seraphim", PlayerForm.SERAPHIM], // 3
  ["angel", PlayerForm.SERAPHIM], // 3
  ["bob", PlayerForm.BOB], // 4
  ["poison", PlayerForm.BOB], // 4
  ["spun", PlayerForm.SPUN], // 5
  ["drugs", PlayerForm.SPUN], // 5
  ["needles", PlayerForm.SPUN], // 5
  ["yesMother", PlayerForm.YES_MOTHER], // 6
  ["mother", PlayerForm.YES_MOTHER], // 6
  ["mom", PlayerForm.YES_MOTHER], // 6
  ["conjoined", PlayerForm.CONJOINED], // 7
  ["triple", PlayerForm.CONJOINED], // 7
  ["leviathan", PlayerForm.LEVIATHAN], // 8
  ["devil", PlayerForm.LEVIATHAN], // 8
  ["ohCrap", PlayerForm.OH_CRAP], // 9
  ["crap", PlayerForm.OH_CRAP], // 9
  ["poop", PlayerForm.OH_CRAP], // 9
  ["bookWorm", PlayerForm.BOOKWORM], // 10
  ["adult", PlayerForm.ADULT], // 11
  ["spiderBaby", PlayerForm.SPIDER_BABY], // 12
  ["stompy", PlayerForm.STOMPY], // 13
]);

----
maps\trinketNameToTypeMap.ts
import type { TrinketType } from "isaac-typescript-definitions";
import { removeNonAlphanumericCharacters } from "../functions/string";
import { TRINKET_NAMES } from "../objects/trinketNames";

/**
 * Maps trinket names to the values of the `TrinketType` enum.
 *
 * For a mapping of `TrinketType` to name, see the `TRINKET_NAMES` constant.
 */
export const TRINKET_NAME_TO_TYPE_MAP: ReadonlyMap<string, TrinketType> =
  (() => {
    const trinketNameToTypeMap = new Map<string, TrinketType>();

    for (const [trinketTypeString, name] of Object.entries(TRINKET_NAMES)) {
      const trinketType = trinketTypeString as unknown as TrinketType;
      const simpleString = removeNonAlphanumericCharacters(name);
      trinketNameToTypeMap.set(simpleString, trinketType);
    }

    return trinketNameToTypeMap;
  })();

----
objects\LRoomShapeToRectangles.ts
import { RoomShape } from "isaac-typescript-definitions";
import { VectorZero } from "../core/constants";
import { newReadonlyVector } from "../functions/readOnly";

interface LRoomRectangles {
  readonly verticalTopLeft: Readonly<Vector>;
  readonly verticalBottomRight: Readonly<Vector>;
  readonly horizontalTopLeft: Readonly<Vector>;
  readonly horizontalBottomRight: Readonly<Vector>;
}

const TWO_BY_TWO_BOTTOM_RIGHT = newReadonlyVector(25, 13);

/**
 * "Vector(0, 0)" corresponds to the top left tile of a room, not including the walls. (The top-left
 * wall would be at "Vector(-1, -1)".)
 */
// We don't use `as const` since we need the object to be indexable by all `RoomShape`.
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const L_ROOM_SHAPE_TO_RECTANGLES: Readonly<
  Partial<Record<RoomShape, LRoomRectangles>>
> = {
  // 9
  [RoomShape.LTL]: {
    verticalTopLeft: newReadonlyVector(13, 0),
    verticalBottomRight: newReadonlyVector(25, 13),
    horizontalTopLeft: newReadonlyVector(0, 7),
    horizontalBottomRight: TWO_BY_TWO_BOTTOM_RIGHT,
  },

  // 10
  [RoomShape.LTR]: {
    verticalTopLeft: VectorZero,
    verticalBottomRight: newReadonlyVector(12, 13),
    horizontalTopLeft: newReadonlyVector(0, 7),
    horizontalBottomRight: TWO_BY_TWO_BOTTOM_RIGHT,
  },

  // 11
  [RoomShape.LBL]: {
    verticalTopLeft: VectorZero,
    verticalBottomRight: newReadonlyVector(25, 6),
    horizontalTopLeft: newReadonlyVector(13, 0),
    horizontalBottomRight: TWO_BY_TWO_BOTTOM_RIGHT,
  },

  // 12
  [RoomShape.LBR]: {
    verticalTopLeft: VectorZero,
    verticalBottomRight: newReadonlyVector(25, 6),
    horizontalTopLeft: VectorZero,
    horizontalBottomRight: newReadonlyVector(12, 13),
  },
};

----
objects\backdropTypeToRockAltType.ts
import { BackdropType } from "isaac-typescript-definitions";
import { RockAltType } from "../enums/RockAltType";

/** Used by the `getRockAltType` function. */
export const BACKDROP_TYPE_TO_ROCK_ALT_TYPE = {
  [BackdropType.BASEMENT]: RockAltType.URN, // 1
  [BackdropType.CELLAR]: RockAltType.URN, // 2
  [BackdropType.BURNING_BASEMENT]: RockAltType.URN, // 3
  [BackdropType.CAVES]: RockAltType.MUSHROOM, // 4
  [BackdropType.CATACOMBS]: RockAltType.MUSHROOM, // 5
  [BackdropType.FLOODED_CAVES]: RockAltType.MUSHROOM, // 6
  [BackdropType.DEPTHS]: RockAltType.SKULL, // 7
  [BackdropType.NECROPOLIS]: RockAltType.SKULL, // 8
  [BackdropType.DANK_DEPTHS]: RockAltType.SKULL, // 9
  [BackdropType.WOMB]: RockAltType.POLYP, // 10
  [BackdropType.UTERO]: RockAltType.POLYP, // 11
  [BackdropType.SCARRED_WOMB]: RockAltType.POLYP, // 12
  [BackdropType.BLUE_WOMB]: RockAltType.POLYP, // 13
  [BackdropType.SHEOL]: RockAltType.SKULL, // 14
  [BackdropType.CATHEDRAL]: RockAltType.URN, // 15
  [BackdropType.DARK_ROOM]: RockAltType.SKULL, // 16
  [BackdropType.CHEST]: RockAltType.URN, // 17
  [BackdropType.MEGA_SATAN]: RockAltType.URN, // 18
  [BackdropType.LIBRARY]: RockAltType.URN, // 19
  [BackdropType.SHOP]: RockAltType.URN, // 20
  [BackdropType.CLEAN_BEDROOM]: RockAltType.URN, // 21
  [BackdropType.DIRTY_BEDROOM]: RockAltType.URN, // 22
  [BackdropType.SECRET]: RockAltType.MUSHROOM, // 23
  [BackdropType.DICE]: RockAltType.URN, // 24
  [BackdropType.ARCADE]: RockAltType.URN, // 25
  [BackdropType.ERROR_ROOM]: RockAltType.URN, // 26
  [BackdropType.BLUE_WOMB_PASS]: RockAltType.POLYP, // 27
  [BackdropType.GREED_SHOP]: RockAltType.URN, // 28
  [BackdropType.DUNGEON]: RockAltType.URN, // 29
  [BackdropType.SACRIFICE]: RockAltType.SKULL, // 30
  [BackdropType.DOWNPOUR]: RockAltType.BUCKET_DOWNPOUR, // 31
  [BackdropType.MINES]: RockAltType.MUSHROOM, // 32
  [BackdropType.MAUSOLEUM]: RockAltType.SKULL, // 33
  [BackdropType.CORPSE]: RockAltType.POLYP, // 34
  [BackdropType.PLANETARIUM]: RockAltType.URN, // 35
  [BackdropType.DOWNPOUR_ENTRANCE]: RockAltType.BUCKET_DOWNPOUR, // 36
  [BackdropType.MINES_ENTRANCE]: RockAltType.MUSHROOM, // 37
  [BackdropType.MAUSOLEUM_ENTRANCE]: RockAltType.SKULL, // 38
  [BackdropType.CORPSE_ENTRANCE]: RockAltType.SKULL, // 39
  [BackdropType.MAUSOLEUM_2]: RockAltType.SKULL, // 40
  [BackdropType.MAUSOLEUM_3]: RockAltType.SKULL, // 41
  [BackdropType.MAUSOLEUM_4]: RockAltType.SKULL, // 42
  [BackdropType.CORPSE_2]: RockAltType.POLYP, // 43
  [BackdropType.CORPSE_3]: RockAltType.POLYP, // 44
  [BackdropType.DROSS]: RockAltType.BUCKET_DROSS, // 45
  [BackdropType.ASHPIT]: RockAltType.MUSHROOM, // 46
  [BackdropType.GEHENNA]: RockAltType.SKULL, // 47
  [BackdropType.MORTIS]: RockAltType.POLYP, // 48
  [BackdropType.ISAACS_BEDROOM]: RockAltType.URN, // 49
  [BackdropType.HALLWAY]: RockAltType.URN, // 50
  [BackdropType.MOMS_BEDROOM]: RockAltType.URN, // 51
  [BackdropType.CLOSET]: RockAltType.URN, // 52
  [BackdropType.CLOSET_B]: RockAltType.URN, // 53
  [BackdropType.DOGMA]: RockAltType.URN, // 54
  [BackdropType.DUNGEON_GIDEON]: RockAltType.URN, // 55
  [BackdropType.DUNGEON_ROTGUT]: RockAltType.URN, // 56
  [BackdropType.DUNGEON_BEAST]: RockAltType.URN, // 57
  [BackdropType.MINES_SHAFT]: RockAltType.MUSHROOM, // 58
  [BackdropType.ASHPIT_SHAFT]: RockAltType.MUSHROOM, // 59
  [BackdropType.DARK_CLOSET]: RockAltType.SKULL, // 60
} as const satisfies Record<BackdropType, RockAltType>;

----
objects\batteryNames.ts
import { BatterySubType } from "isaac-typescript-definitions";

export const DEFAULT_BATTERY_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const BATTERY_NAMES = {
  [BatterySubType.NULL]: DEFAULT_BATTERY_NAME, // 0
  [BatterySubType.NORMAL]: "Lil' Battery", // 1
  [BatterySubType.MICRO]: "Micro Battery", // 2
  [BatterySubType.MEGA]: "Mega Battery", // 3
  [BatterySubType.GOLDEN]: "Golden Battery", // 4
} as const satisfies Record<BatterySubType, string>;

----
objects\bombNames.ts
import { BombSubType } from "isaac-typescript-definitions";

export const DEFAULT_BOMB_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const BOMB_NAMES = {
  [BombSubType.NULL]: DEFAULT_BOMB_NAME, // 0
  [BombSubType.NORMAL]: "Bomb", // 1
  [BombSubType.DOUBLE_PACK]: "Double Bomb", // 2
  [BombSubType.TROLL]: "Troll Bomb", // 3
  [BombSubType.GOLDEN]: "Golden Bomb", // 4
  [BombSubType.MEGA_TROLL]: "Megatroll Bomb", // 5
  // The entry for "Golden Troll Bomb" is absent in "entities2.xml", so we infer the name.
  [BombSubType.GOLDEN_TROLL]: "Golden Troll Bomb", // 6
  [BombSubType.GIGA]: "Giga Bomb", // 7
} as const satisfies Record<BombSubType, string>;

----
objects\bossIDToEntityTypeVariant.ts
import {
  BeastVariant,
  BigHornVariant,
  BossID,
  ChubVariant,
  DaddyLongLegsVariant,
  DingleVariant,
  DogmaVariant,
  DukeOfFliesVariant,
  EntityType,
  FallenVariant,
  FistulaVariant,
  GeminiVariant,
  GurglingVariant,
  HauntVariant,
  IsaacVariant,
  LambVariant,
  LarryJrVariant,
  LittleHornVariant,
  LokiVariant,
  MamaGurdyVariant,
  MegaSatanVariant,
  MomVariant,
  MomsHeartVariant,
  Monstro2Variant,
  MotherVariant,
  PeepVariant,
  PinVariant,
  PolycephalusVariant,
  RagManVariant,
  RagMegaVariant,
  RaglichVariant,
  SatanVariant,
  UltraGreedVariant,
  WarVariant,
  WidowVariant,
} from "isaac-typescript-definitions";

export const BOSS_ID_TO_ENTITY_TYPE_VARIANT = {
  // 1
  [BossID.MONSTRO]: [EntityType.MONSTRO, 0],

  // 2
  [BossID.LARRY_JR]: [EntityType.LARRY_JR, LarryJrVariant.LARRY_JR],

  // 3
  [BossID.CHUB]: [EntityType.CHUB, ChubVariant.CHUB],

  // 4
  [BossID.GURDY]: [EntityType.GURDY, 0],

  // 5
  [BossID.MONSTRO_2]: [EntityType.MONSTRO_2, Monstro2Variant.MONSTRO_2],

  // 6
  [BossID.MOM]: [EntityType.MOM, MomVariant.MOM],

  // 7
  [BossID.SCOLEX]: [EntityType.PIN, PinVariant.SCOLEX],

  // 8
  [BossID.MOMS_HEART]: [EntityType.MOMS_HEART, MomsHeartVariant.MOMS_HEART],

  // 9
  [BossID.FAMINE]: [EntityType.FAMINE, 0],

  // 10
  [BossID.PESTILENCE]: [EntityType.PESTILENCE, 0],

  // 11
  [BossID.WAR]: [EntityType.WAR, WarVariant.WAR],

  // 12
  [BossID.DEATH]: [EntityType.DEATH, 0],

  // 13
  [BossID.DUKE_OF_FLIES]: [
    EntityType.DUKE_OF_FLIES,
    DukeOfFliesVariant.DUKE_OF_FLIES,
  ],

  // 14
  [BossID.PEEP]: [EntityType.PEEP, PeepVariant.PEEP],

  // 15
  [BossID.LOKI]: [EntityType.LOKI, LokiVariant.LOKI],

  // 16
  [BossID.BLASTOCYST]: [EntityType.BLASTOCYST_BIG, 0],

  // 17
  [BossID.GEMINI]: [EntityType.GEMINI, GeminiVariant.GEMINI],

  // 18
  [BossID.FISTULA]: [EntityType.FISTULA_BIG, FistulaVariant.FISTULA],

  // 19
  [BossID.GISH]: [EntityType.MONSTRO_2, Monstro2Variant.GISH],

  // 20
  [BossID.STEVEN]: [EntityType.GEMINI, GeminiVariant.STEVEN],

  // 21
  [BossID.CHAD]: [EntityType.CHUB, ChubVariant.CHAD],

  // 22
  [BossID.HEADLESS_HORSEMAN]: [EntityType.HEADLESS_HORSEMAN, 0],

  // 23
  [BossID.FALLEN]: [EntityType.FALLEN, FallenVariant.FALLEN],

  // 24
  [BossID.SATAN]: [EntityType.SATAN, SatanVariant.SATAN],

  // 25
  [BossID.IT_LIVES]: [EntityType.MOMS_HEART, MomsHeartVariant.IT_LIVES],

  // 26
  [BossID.HOLLOW]: [EntityType.LARRY_JR, LarryJrVariant.HOLLOW],

  // 27
  [BossID.CARRION_QUEEN]: [EntityType.CHUB, ChubVariant.CARRION_QUEEN],

  // 28
  [BossID.GURDY_JR]: [EntityType.GURDY_JR, 0],

  // 29
  [BossID.HUSK]: [EntityType.DUKE_OF_FLIES, DukeOfFliesVariant.HUSK],

  // 30
  [BossID.BLOAT]: [EntityType.PEEP, PeepVariant.BLOAT],

  // 31
  [BossID.LOKII]: [EntityType.LOKI, LokiVariant.LOKII],

  // 32
  [BossID.BLIGHTED_OVUM]: [EntityType.GEMINI, GeminiVariant.BLIGHTED_OVUM],

  // 33
  [BossID.TERATOMA]: [EntityType.FISTULA_BIG, FistulaVariant.TERATOMA],

  // 34
  [BossID.WIDOW]: [EntityType.WIDOW, WidowVariant.WIDOW],

  // 35
  [BossID.MASK_OF_INFAMY]: [EntityType.MASK_OF_INFAMY, 0],

  // 36
  [BossID.WRETCHED]: [EntityType.WIDOW, WidowVariant.WRETCHED],

  // 37
  [BossID.PIN]: [EntityType.PIN, PinVariant.PIN],

  // 38
  [BossID.CONQUEST]: [EntityType.WAR, WarVariant.CONQUEST],

  // 39
  [BossID.ISAAC]: [EntityType.ISAAC, IsaacVariant.ISAAC],

  // 40
  [BossID.BLUE_BABY]: [EntityType.ISAAC, IsaacVariant.BLUE_BABY],

  // 41
  [BossID.DADDY_LONG_LEGS]: [
    EntityType.DADDY_LONG_LEGS,
    DaddyLongLegsVariant.DADDY_LONG_LEGS,
  ],

  // 42
  [BossID.TRIACHNID]: [
    EntityType.DADDY_LONG_LEGS,
    DaddyLongLegsVariant.TRIACHNID,
  ],

  // 43
  [BossID.HAUNT]: [EntityType.HAUNT, HauntVariant.HAUNT],

  // 44
  [BossID.DINGLE]: [EntityType.DINGLE, DingleVariant.DINGLE],

  // 45
  [BossID.MEGA_MAW]: [EntityType.MEGA_MAW, 0],

  // 46
  [BossID.GATE]: [EntityType.GATE, 0],

  // 47
  [BossID.MEGA_FATTY]: [EntityType.MEGA_FATTY, 0],

  // 48
  [BossID.CAGE]: [EntityType.CAGE, 0],

  // 49
  [BossID.MAMA_GURDY]: [EntityType.MAMA_GURDY, MamaGurdyVariant.MAMA_GURDY],

  // 50
  [BossID.DARK_ONE]: [EntityType.DARK_ONE, 0],

  // 51
  [BossID.ADVERSARY]: [EntityType.ADVERSARY, 0],

  // 52
  [BossID.POLYCEPHALUS]: [
    EntityType.POLYCEPHALUS,
    PolycephalusVariant.POLYCEPHALUS,
  ],

  // 53
  [BossID.MR_FRED]: [EntityType.MR_FRED, 0],

  // 54
  [BossID.LAMB]: [EntityType.LAMB, LambVariant.LAMB],

  // 55
  [BossID.MEGA_SATAN]: [EntityType.MEGA_SATAN, MegaSatanVariant.MEGA_SATAN],

  // 56
  [BossID.GURGLING]: [EntityType.GURGLING, GurglingVariant.GURGLING_BOSS],

  // 57
  [BossID.STAIN]: [EntityType.STAIN, 0],

  // 58
  [BossID.BROWNIE]: [EntityType.BROWNIE, 0],

  // 59
  [BossID.FORSAKEN]: [EntityType.FORSAKEN, 0],

  // 60
  [BossID.LITTLE_HORN]: [EntityType.LITTLE_HORN, LittleHornVariant.LITTLE_HORN],

  // 61
  [BossID.RAG_MAN]: [EntityType.RAG_MAN, RagManVariant.RAG_MAN],

  // 62
  [BossID.ULTRA_GREED]: [EntityType.ULTRA_GREED, UltraGreedVariant.ULTRA_GREED],

  // 63
  [BossID.HUSH]: [EntityType.HUSH, 0],

  // 64
  [BossID.DANGLE]: [EntityType.DINGLE, DingleVariant.DANGLE],

  // 65
  [BossID.TURDLING]: [EntityType.GURGLING, GurglingVariant.TURDLING],

  // 66
  [BossID.FRAIL]: [EntityType.PIN, PinVariant.FRAIL],

  // 67
  [BossID.RAG_MEGA]: [EntityType.RAG_MEGA, RagMegaVariant.RAG_MEGA],

  // 68
  [BossID.SISTERS_VIS]: [EntityType.SISTERS_VIS, 0],

  // 69
  [BossID.BIG_HORN]: [EntityType.BIG_HORN, BigHornVariant.BIG_HORN],

  // 70
  [BossID.DELIRIUM]: [EntityType.DELIRIUM, 0],

  // 71
  [BossID.ULTRA_GREEDIER]: [
    EntityType.ULTRA_GREED,
    UltraGreedVariant.ULTRA_GREEDIER,
  ],

  // 72
  [BossID.MATRIARCH]: [EntityType.MATRIARCH, 0],

  // 73
  [BossID.PILE]: [EntityType.POLYCEPHALUS, PolycephalusVariant.PILE],

  // 74
  [BossID.REAP_CREEP]: [EntityType.REAP_CREEP, 0],

  // 75
  [BossID.LIL_BLUB]: [EntityType.LIL_BLUB, 0],

  // 76
  [BossID.WORMWOOD]: [EntityType.PIN, PinVariant.WORMWOOD],

  // 77
  [BossID.RAINMAKER]: [EntityType.RAINMAKER, 0],

  // 78
  [BossID.VISAGE]: [EntityType.VISAGE, 0],

  // 79
  [BossID.SIREN]: [EntityType.SIREN, 0],

  // 80
  [BossID.TUFF_TWINS]: [EntityType.LARRY_JR, LarryJrVariant.TUFF_TWIN],

  // 81
  [BossID.HERETIC]: [EntityType.HERETIC, 0],

  // 82
  [BossID.HORNFEL]: [EntityType.HORNFEL, 0],

  // 83
  [BossID.GREAT_GIDEON]: [EntityType.GREAT_GIDEON, 0],

  // 84
  [BossID.BABY_PLUM]: [EntityType.BABY_PLUM, 0],

  // 85
  [BossID.SCOURGE]: [EntityType.SCOURGE, 0],

  // 86
  [BossID.CHIMERA]: [EntityType.CHIMERA, 0],

  // 87
  [BossID.ROTGUT]: [EntityType.ROTGUT, 0],

  // 88
  [BossID.MOTHER]: [EntityType.MOTHER, MotherVariant.MOTHER_1],

  // 89
  [BossID.MAUSOLEUM_MOM]: [EntityType.MOM, MomVariant.MOM],

  // 90
  [BossID.MAUSOLEUM_MOMS_HEART]: [
    EntityType.MOMS_HEART,
    MomsHeartVariant.MOMS_HEART,
  ],

  // 91
  [BossID.MIN_MIN]: [EntityType.MIN_MIN, 0],

  // 92
  [BossID.CLOG]: [EntityType.CLOG, 0],

  // 93
  [BossID.SINGE]: [EntityType.SINGE, 0],

  // 94
  [BossID.BUMBINO]: [EntityType.BUMBINO, 0],

  // 95
  [BossID.COLOSTOMIA]: [EntityType.COLOSTOMIA, 0],

  // 96
  [BossID.SHELL]: [EntityType.LARRY_JR, LarryJrVariant.SHELL],

  // 97
  [BossID.TURDLET]: [EntityType.TURDLET, 0],

  // 98
  [BossID.RAGLICH]: [EntityType.RAGLICH, RaglichVariant.RAGLICH],

  // 99
  [BossID.DOGMA]: [EntityType.DOGMA, DogmaVariant.DOGMA_PHASE_1],

  // 100
  [BossID.BEAST]: [EntityType.BEAST, BeastVariant.BEAST],

  // 101
  [BossID.HORNY_BOYS]: [EntityType.HORNY_BOYS, 0],

  // 102
  [BossID.CLUTCH]: [EntityType.CLUTCH, 0],
} as const satisfies Record<BossID, readonly [EntityType, int]>;

----
objects\bossNamePNGFileNames.ts
// cspell:disable

import { BossID } from "isaac-typescript-definitions";

/**
 * From the "nameimage" attribute in the "bossportraits.xml" file. Used when rendering the
 * "versusscreen.anm2" sprite.
 */
export const BOSS_NAME_PNG_FILE_NAMES = {
  [BossID.MONSTRO]: "BossName_20.0_Monstro.png", // 1
  [BossID.LARRY_JR]: "BossName_19.0_LarryJr.png", // 2
  [BossID.CHUB]: "BossName_28.0_Chub.png", // 3
  [BossID.GURDY]: "BossName_36.0_Gurdy.png", // 4
  [BossID.MONSTRO_2]: "BossName_43.0_Monstro2.png", // 5
  [BossID.MOM]: "BossName_45.0_Mom.png", // 6
  [BossID.SCOLEX]: "BossName_62.1_Scolex.png", // 7
  [BossID.MOMS_HEART]: "BossName_78.0_MomsHeart.png", // 8
  [BossID.FAMINE]: "BossName_63.0_Famine.png", // 9
  [BossID.PESTILENCE]: "BossName_64.0_Pestilence.png", // 10
  [BossID.WAR]: "BossName_65.0_War.png", // 11
  [BossID.DEATH]: "BossName_66.0_Death.png", // 12
  [BossID.DUKE_OF_FLIES]: "BossName_67.0_DukeOfFlies.png", // 13
  [BossID.PEEP]: "BossName_68.0_Peep.png", // 14
  [BossID.LOKI]: "BossName_69.0_Loki.png", // 15
  [BossID.BLASTOCYST]: "BossName_74.0_Blastocyst.png", // 16
  [BossID.GEMINI]: "BossName_79.0_Gemini.png", // 17
  [BossID.FISTULA]: "BossName_71.0_Fistula.png", // 18
  [BossID.GISH]: "BossName_43.1_Gish.png", // 19
  [BossID.STEVEN]: "BossName_79.1_Steven.png", // 20
  [BossID.CHAD]: "BossName_28.1_CHAD.png", // 21
  [BossID.HEADLESS_HORSEMAN]: "BossName_82.0_HeadlessHorseman.png", // 22
  [BossID.FALLEN]: "BossName_81.0_TheFallen.png", // 23
  [BossID.SATAN]: "BossName_84.0_Satan.png", // 24
  [BossID.IT_LIVES]: "BossName_78.1_ItLives.png", // 25
  [BossID.HOLLOW]: "BossName_19.1_TheHollow.png", // 26
  [BossID.CARRION_QUEEN]: "BossName_28.2_CarrionQueen.png", // 27
  [BossID.GURDY_JR]: "BossName_99.0_GurdyJr.png", // 28
  [BossID.HUSK]: "BossName_67.1_TheHusk.png", // 29
  [BossID.BLOAT]: "BossName_68.1_Bloat.png", // 30
  [BossID.LOKII]: "BossName_69.1_Lokii.png", // 31
  [BossID.BLIGHTED_OVUM]: "BossName_79.2_BlightedOvum.png", // 32
  [BossID.TERATOMA]: "BossName_71.1_Teratoma.png", // 33
  [BossID.WIDOW]: "BossName_100.0_Widow.png", // 34
  [BossID.MASK_OF_INFAMY]: "BossName_97.0_MaskOfInfamy.png", // 35
  [BossID.WRETCHED]: "BossName_100.1_TheWretched.png", // 36
  [BossID.PIN]: "BossName_62.0_Pin.png", // 37
  [BossID.CONQUEST]: "BossName_65.1_Conquest.png", // 38
  // There is no dedicated "bossname_" PNG file for Isaac.
  [BossID.ISAAC]: "PlayerName_01_Isaac.png", // 39
  [BossID.BLUE_BABY]: "BossName_102.1_BlueBaby.png", // 40
  [BossID.DADDY_LONG_LEGS]: "BossName_101.0_DaddyLongLegs.png", // 41
  [BossID.TRIACHNID]: "BossName_101.1_Triachnid.png", // 42
  [BossID.HAUNT]: "BossName_260.0_TheHaunt.png", // 43
  [BossID.DINGLE]: "BossName_261.0_Dingle.png", // 44
  [BossID.MEGA_MAW]: "Portrait_262.0_MegaMaw.png", // 45
  [BossID.GATE]: "BossName_263.0_MegaMaw2.png", // 46
  [BossID.MEGA_FATTY]: "BossName_264.0_MegaFatty.png", // 47
  [BossID.CAGE]: "BossName_265.0_Fatty2.png", // 48
  [BossID.MAMA_GURDY]: "BossName_266.0_MamaGurdy.png", // 49
  [BossID.DARK_ONE]: "BossName_267.0_DarkOne.png", // 50
  [BossID.ADVERSARY]: "BossName_268.0_DarkOne2.png", // 51
  [BossID.POLYCEPHALUS]: "BossName_269.0_Polycephalus.png", // 52
  [BossID.MR_FRED]: "BossName_270.0_MegaFred.png", // 53
  [BossID.LAMB]: "BossName_273.0_TheLamb.png", // 54
  [BossID.MEGA_SATAN]: "BossName_274.0_MegaSatan.png", // 55
  [BossID.GURGLING]: "BossName_276.0_Gurglings.png", // 56
  [BossID.STAIN]: "BossName_401.0_TheStain.png", // 57
  [BossID.BROWNIE]: "BossName_402.0_Brownie.png", // 58
  [BossID.FORSAKEN]: "BossName_403.0_TheForsaken.png", // 59
  [BossID.LITTLE_HORN]: "BossName_404.0_LittleHorn.png", // 60
  [BossID.RAG_MAN]: "BossName_405.0_RagMan.png", // 61
  [BossID.ULTRA_GREED]: "BossName_406.0_UltraGreed.png", // 62
  [BossID.HUSH]: "BossName_407.0_Hush.png", // 63
  [BossID.DANGLE]: "BossName_Dangle.png", // 64
  [BossID.TURDLING]: "BossName_Turdlings.png", // 65
  [BossID.FRAIL]: "BossName_TheFrail.png", // 66
  [BossID.RAG_MEGA]: "BossName_RagMega.png", // 67
  [BossID.SISTERS_VIS]: "BossName_SisterssVis.png", // 68
  [BossID.BIG_HORN]: "BossName_BigHorn.png", // 69
  [BossID.DELIRIUM]: "BossName_Delirium.png", // 70
  // Ultra Greedier uses the same file as Ultra Greed.
  [BossID.ULTRA_GREEDIER]: "BossName_406.0_UltraGreed.png", // 71
  [BossID.MATRIARCH]: "BossName_Matriarch.png", // 72
  [BossID.PILE]: "BossName_Polycephalus2.png", // 73
  [BossID.REAP_CREEP]: "BossName_ReapCreep.png", // 74
  [BossID.LIL_BLUB]: "BossName_Beelzeblub.png", // 75
  [BossID.WORMWOOD]: "BossName_Wormwood.png", // 76
  [BossID.RAINMAKER]: "BossName_Rainmaker.png", // 77
  [BossID.VISAGE]: "BossName_Visage.png", // 78
  [BossID.SIREN]: "BossName_Siren.png", // 79
  [BossID.TUFF_TWINS]: "BossName_TuffTwins.png", // 80
  [BossID.HERETIC]: "BossName_Heretic.png", // 81
  [BossID.HORNFEL]: "BossName_Hornfel.png", // 82
  [BossID.GREAT_GIDEON]: "BossName_Gideon.png", // 83
  [BossID.BABY_PLUM]: "BossName_BabyPlum.png", // 84
  [BossID.SCOURGE]: "BossName_Scourge.png", // 85
  [BossID.CHIMERA]: "BossName_Chimera.png", // 86
  [BossID.ROTGUT]: "BossName_Rotgut.png", // 87
  [BossID.MOTHER]: "BossName_Mother.png", // 88
  // Mom (Mausoleum) uses the same file as Mom.
  [BossID.MAUSOLEUM_MOM]: "BossName_45.0_Mom.png", // 89
  // Mom's Heart (Mausoleum) uses the same file as Mom's Heart.
  [BossID.MAUSOLEUM_MOMS_HEART]: "BossName_78.0_MomsHeart.png", // 90
  [BossID.MIN_MIN]: "BossName_MinMin.png", // 91
  [BossID.CLOG]: "BossName_Clog.png", // 92
  [BossID.SINGE]: "BossName_Singe.png", // 93
  [BossID.BUMBINO]: "BossName_Bumbino.png", // 94
  [BossID.COLOSTOMIA]: "BossName_Colostomia.png", // 95
  [BossID.SHELL]: "BossName_Shell.png", // 96
  [BossID.TURDLET]: "BossName_Turdlet.png", // 97
  [BossID.RAGLICH]: "BossName_Raglich.png", // 98
  [BossID.DOGMA]: "BossName_Dogma.png", // 99
  // The file name specified in "bossportraits.xml" for The Beast does not actually exist in the
  // game files.
  [BossID.BEAST]: "BossName_TheBeast.png", // 100
  [BossID.HORNY_BOYS]: "BossName_HornyBoys.png", // 101
  [BossID.CLUTCH]: "BossName_Clutch.png", // 102
  // [BossID.CADAVRA]: "BossName_Cadavra.png", // 103
} as const satisfies Record<BossID, string>;

----
objects\bossNames.ts
import { BossID } from "isaac-typescript-definitions";

export const DEFAULT_BOSS_NAME = "Unknown";

/**
 * From "bossportraits.xml".
 *
 * Note that Blue Baby returns "Blue Baby" instead of "???".
 */
export const BOSS_NAMES = {
  [BossID.MONSTRO]: "Monstro", // 1
  [BossID.LARRY_JR]: "Larry Jr.", // 2
  [BossID.CHUB]: "Chub", // 3
  [BossID.GURDY]: "Gurdy", // 4
  [BossID.MONSTRO_2]: "Monstro II", // 5
  [BossID.MOM]: "Mom", // 6
  [BossID.SCOLEX]: "Scolex", // 7
  [BossID.MOMS_HEART]: "Mom's Heart", // 8
  [BossID.FAMINE]: "Famine", // 9
  [BossID.PESTILENCE]: "Pestilence", // 10
  [BossID.WAR]: "War", // 11
  [BossID.DEATH]: "Death", // 12
  [BossID.DUKE_OF_FLIES]: "Duke of Flies", // 13
  [BossID.PEEP]: "Peep", // 14
  [BossID.LOKI]: "Loki", // 15
  [BossID.BLASTOCYST]: "Blastocyst", // 16
  [BossID.GEMINI]: "Gemini", // 17
  [BossID.FISTULA]: "Fistula", // 18
  [BossID.GISH]: "Gish", // 19
  [BossID.STEVEN]: "Steven", // 20
  [BossID.CHAD]: "C.H.A.D.", // 21
  [BossID.HEADLESS_HORSEMAN]: "Headless Horseman", // 22
  [BossID.FALLEN]: "The Fallen", // 23
  [BossID.SATAN]: "Satan", // 24
  [BossID.IT_LIVES]: "It Lives!", // 25
  [BossID.HOLLOW]: "The Hollow", // 26
  [BossID.CARRION_QUEEN]: "The Carrion Queen", // 27
  [BossID.GURDY_JR]: "Gurdy Jr.", // 28
  [BossID.HUSK]: "The Husk", // 29
  [BossID.BLOAT]: "The Bloat", // 30
  [BossID.LOKII]: "Lokii", // 31
  [BossID.BLIGHTED_OVUM]: "The Blighted Ovum", // 32
  [BossID.TERATOMA]: "Teratoma", // 33
  [BossID.WIDOW]: "The Widow", // 34
  [BossID.MASK_OF_INFAMY]: "Mask of Infamy", // 35
  [BossID.WRETCHED]: "The Wretched", // 36
  [BossID.PIN]: "Pin", // 37
  [BossID.CONQUEST]: "Conquest", // 38
  [BossID.ISAAC]: "Isaac", // 39
  [BossID.BLUE_BABY]: "Blue Baby", // 40
  [BossID.DADDY_LONG_LEGS]: "Daddy Long Legs", // 41
  [BossID.TRIACHNID]: "Triachnid", // 42
  [BossID.HAUNT]: "The Haunt", // 43
  [BossID.DINGLE]: "Dingle", // 44
  [BossID.MEGA_MAW]: "Mega Maw", // 45
  // "Mega Maw II" is changed to "The Gate".
  [BossID.GATE]: "The Gate", // 46
  [BossID.MEGA_FATTY]: "Mega Fatty", // 47
  // "Mega Fatty II" is changed to "The Cage".
  [BossID.CAGE]: "The Cage", // 48
  [BossID.MAMA_GURDY]: "Mega Gurdy", // 49
  [BossID.DARK_ONE]: "Dark One", // 50
  // "Dark One II" is changed to "The Adversary".
  [BossID.ADVERSARY]: "The Adversary", // 51
  [BossID.POLYCEPHALUS]: "Polycephalus", // 52
  // "Mega Fred" is changed to "Mr. Fred".
  [BossID.MR_FRED]: "Mr. Fred", // 53
  [BossID.LAMB]: "The Lamb", // 54
  [BossID.MEGA_SATAN]: "Mega Satan", // 55
  [BossID.GURGLING]: "Gurglings", // 56
  [BossID.STAIN]: "The Stain", // 57
  [BossID.BROWNIE]: "Brownie", // 58
  [BossID.FORSAKEN]: "The Forsaken", // 59
  [BossID.LITTLE_HORN]: "Little Horn", // 60
  [BossID.RAG_MAN]: "Rag Man", // 61
  [BossID.ULTRA_GREED]: "Ultra Greed", // 62
  [BossID.HUSH]: "Hush", // 63
  [BossID.DANGLE]: "Dangle", // 64
  [BossID.TURDLING]: "Turdling", // 65
  [BossID.FRAIL]: "The Frail", // 66
  [BossID.RAG_MEGA]: "Rag Mega", // 67
  [BossID.SISTERS_VIS]: "Sisters Vis", // 68
  [BossID.BIG_HORN]: "Big Horn", // 69
  [BossID.DELIRIUM]: "Delirium", // 70
  [BossID.ULTRA_GREEDIER]: "Ultra Greedier", // 71
  [BossID.MATRIARCH]: "The Matriarch", // 72
  [BossID.PILE]: "The Pile", // 73
  [BossID.REAP_CREEP]: "Reap Creep", // 74
  // "Beelzeblub" is changed to "Lil Blub".
  [BossID.LIL_BLUB]: "Lil Blub", // 75
  [BossID.WORMWOOD]: "Wormwood", // 76
  [BossID.RAINMAKER]: "The Rainmaker", // 77
  [BossID.VISAGE]: "The Visage", // 78
  [BossID.SIREN]: "The Siren", // 79
  [BossID.TUFF_TWINS]: "Tuff Twins", // 80
  [BossID.HERETIC]: "The Heretic", // 81
  [BossID.HORNFEL]: "Hornfel", // 82
  [BossID.GREAT_GIDEON]: "Great Gideon", // 83
  [BossID.BABY_PLUM]: "Baby Plum", // 84
  [BossID.SCOURGE]: "The Scourge", // 85
  [BossID.CHIMERA]: "Chimera", // 86
  [BossID.ROTGUT]: "Rotgut", // 87
  [BossID.MOTHER]: "Mother", // 88
  [BossID.MAUSOLEUM_MOM]: "Mom (Mausoleum)", // 89
  [BossID.MAUSOLEUM_MOMS_HEART]: "Mom's Heart (Mausoleum)", // 90
  [BossID.MIN_MIN]: "Min-Min", // 91
  [BossID.CLOG]: "Clog", // 92
  [BossID.SINGE]: "Singe", // 93
  [BossID.BUMBINO]: "Bumbino", // 94
  [BossID.COLOSTOMIA]: "Colostomia", // 95
  [BossID.SHELL]: "The Shell", // 96
  [BossID.TURDLET]: "Turdlet", // 97
  [BossID.RAGLICH]: "Raglich", // 98
  [BossID.DOGMA]: "Dogma", // 99
  [BossID.BEAST]: "The Beast", // 100
  [BossID.HORNY_BOYS]: "Horny Boys", // 101
  [BossID.CLUTCH]: "Clutch", // 102
} as const satisfies Record<BossID, string>;

----
objects\bossPortraitPNGFileNames.ts
// cspell:disable

import { BossID } from "isaac-typescript-definitions";

/**
 * From the "portrait" attribute in the "bossportraits.xml" file. Used when rendering the
 * "versusscreen.anm2" sprite.
 */
export const BOSS_PORTRAIT_PNG_FILE_NAMES = {
  [BossID.MONSTRO]: "Portrait_20.0_Monstro.png", // 1
  [BossID.LARRY_JR]: "Portrait_19.0_LarryJr.png", // 2
  [BossID.CHUB]: "Portrait_28.0_Chub.png", // 3
  [BossID.GURDY]: "Portrait_36.0_Gurdy.png", // 4
  [BossID.MONSTRO_2]: "Portrait_43.0_Monstro2.png", // 5
  [BossID.MOM]: "Portrait_45.0_Mom.png", // 6
  [BossID.SCOLEX]: "Portrait_62.1_Scolex.png", // 7
  [BossID.MOMS_HEART]: "Portrait_78.0_MomsHeart.png", // 8
  [BossID.FAMINE]: "Portrait_63.0_Famine.png", // 9
  [BossID.PESTILENCE]: "Portrait_64.0_Pestilence.png", // 10
  [BossID.WAR]: "Portrait_65.0_War.png", // 11
  [BossID.DEATH]: "Portrait_66.0_Death.png", // 12
  [BossID.DUKE_OF_FLIES]: "Portrait_67.0_DukeOfFlies.png", // 13
  [BossID.PEEP]: "Portrait_68.0_Peep.png", // 14
  [BossID.LOKI]: "Portrait_69.0_Loki.png", // 15
  [BossID.BLASTOCYST]: "Portrait_74.0_Blastocyst.png", // 16
  [BossID.GEMINI]: "Portrait_79.0_Gemini.png", // 17
  [BossID.FISTULA]: "Portrait_71.0_Fistula.png", // 18
  [BossID.GISH]: "Portrait_43.1_Gish.png", // 19
  [BossID.STEVEN]: "Portrait_79.1_Steven.png", // 20
  [BossID.CHAD]: "Portrait_28.1_CHAD.png", // 21
  [BossID.HEADLESS_HORSEMAN]: "Portrait_82.0_HeadlessHorseman.png", // 22
  [BossID.FALLEN]: "Portrait_81.0_TheFallen.png", // 23
  [BossID.SATAN]: "Portrait_84.0_Satan.png", // 24
  [BossID.IT_LIVES]: "Portrait_78.1_ItLives.png", // 25
  [BossID.HOLLOW]: "Portrait_19.1_TheHollow.png", // 26
  [BossID.CARRION_QUEEN]: "Portrait_28.2_CarrionQueen.png", // 27
  [BossID.GURDY_JR]: "Portrait_99.0_GurdyJr.png", // 28
  [BossID.HUSK]: "Portrait_67.1_TheHusk.png", // 29
  [BossID.BLOAT]: "Portrait_68.1_Bloat.png", // 30
  [BossID.LOKII]: "Portrait_69.1_Lokii.png", // 31
  [BossID.BLIGHTED_OVUM]: "Portrait_79.2_BlightedOvum.png", // 32
  [BossID.TERATOMA]: "Portrait_71.1_Teratoma.png", // 33
  [BossID.WIDOW]: "Portrait_100.0_Widow.png", // 34
  [BossID.MASK_OF_INFAMY]: "Portrait_97.0_MaskOfInfamy.png", // 35
  [BossID.WRETCHED]: "Portrait_100.1_TheWretched.png", // 36
  [BossID.PIN]: "Portrait_62.0_Pin.png", // 37
  [BossID.CONQUEST]: "Portrait_65.1_Conquest.png", // 38
  [BossID.ISAAC]: "Portrait_102.0_Isaac.png", // 39
  [BossID.BLUE_BABY]: "Portrait_102.1_BlueBaby.png", // 40
  [BossID.DADDY_LONG_LEGS]: "Portrait_101.0_DaddyLongLegs.png", // 41
  [BossID.TRIACHNID]: "Portrait_101.1_Triachnid.png", // 42
  [BossID.HAUNT]: "Portrait_260.0_TheHaunt.png", // 43
  [BossID.DINGLE]: "Portrait_261.0_Dingle.png", // 44
  [BossID.MEGA_MAW]: "Portrait_262.0_MegaMaw.png", // 45
  [BossID.GATE]: "Portrait_263.0_MegaMaw2.png", // 46
  [BossID.MEGA_FATTY]: "Portrait_264.0_MegaFatty.png", // 47
  [BossID.CAGE]: "Portrait_265.0_Fatty2.png", // 48
  [BossID.MAMA_GURDY]: "Portrait_266.0_MamaGurdy.png", // 49
  [BossID.DARK_ONE]: "Portrait_267.0_DarkOne.png", // 50
  [BossID.ADVERSARY]: "Portrait_268.0_DarkOne2.png", // 51
  [BossID.POLYCEPHALUS]: "Portrait_269.0_Polycephalus.png", // 52
  [BossID.MR_FRED]: "Portrait_270.0_MegaFred.png", // 53
  [BossID.LAMB]: "Portrait_273.0_TheLamb.png", // 54
  [BossID.MEGA_SATAN]: "Portrait_274.0_MegaSatan.png", // 55
  [BossID.GURGLING]: "Portrait_276.0_Gurglings.png", // 56
  [BossID.STAIN]: "Portrait_401.0_TheStain.png", // 57
  [BossID.BROWNIE]: "Portrait_402.0_Brownie.png", // 58
  [BossID.FORSAKEN]: "Portrait_403.0_TheForsaken.png", // 59
  [BossID.LITTLE_HORN]: "Portrait_404.0_LittleHorn.png", // 60
  [BossID.RAG_MAN]: "Portrait_405.0_Ragman.png", // 61
  [BossID.ULTRA_GREED]: "Portrait_406.0_UltraGreed.png", // 62
  [BossID.HUSH]: "Portrait_407.0_Hush.png", // 63
  [BossID.DANGLE]: "Portrait_Dangle.png", // 64
  [BossID.TURDLING]: "Portrait_Turdlings.png", // 65
  [BossID.FRAIL]: "Portrait_TheFrail.png", // 66
  [BossID.RAG_MEGA]: "Portrait_RagMega.png", // 67
  [BossID.SISTERS_VIS]: "Portrait_SistersVis.png", // 68
  [BossID.BIG_HORN]: "Portrait_BigHorn.png", // 69
  [BossID.DELIRIUM]: "Portrait_Delirium.png", // 70
  // Ultra Greedier uses the same file as Ultra Greed.
  [BossID.ULTRA_GREEDIER]: "Portrait_406.0_UltraGreed.png", // 71
  [BossID.MATRIARCH]: "Portrait_Matriarch.png", // 72
  [BossID.PILE]: "Portrait_269.1_Polycephalus2.png", // 73
  [BossID.REAP_CREEP]: "Portrait_900.0_ReapCreep.png", // 74
  [BossID.LIL_BLUB]: "Portrait_901.0_Beelzeblub.png", // 75
  // There is also a "Portrait_901.0_Beelzeblub_Dross.png" file.
  [BossID.WORMWOOD]: "Portrait_902.0_Wormwood.png", // 76
  // There is also a "Portrait_902.0_Wormwood_Dross.png" file.
  [BossID.RAINMAKER]: "Portrait_902.0_Rainmaker.png", // 77
  [BossID.VISAGE]: "Portrait_903.0_Visage.png", // 78
  [BossID.SIREN]: "Portrait_904.0_Siren.png", // 79
  [BossID.TUFF_TWINS]: "Portrait_19.100_TuffTwins.png", // 80
  [BossID.HERETIC]: "Portrait_905.0_Heretic.png", // 81
  [BossID.HORNFEL]: "Portrait_906.0_Hornfel.png", // 82
  [BossID.GREAT_GIDEON]: "Portrait_907.0_Gideon.png", // 83
  [BossID.BABY_PLUM]: "Portrait_908.0_BabyPlum.png", // 84
  [BossID.SCOURGE]: "Portrait_909.0_Scourge.png", // 85
  [BossID.CHIMERA]: "Portrait_910.0_Chimera.png", // 86
  [BossID.ROTGUT]: "Portrait_911.0_Rotgut.png", // 87
  [BossID.MOTHER]: "Portrait_Mother.png", // 88
  // Mom (Mausoleum) uses the same file as Mom.
  [BossID.MAUSOLEUM_MOM]: "Portrait_45.0_Mom.png", // 89
  // Mom's Heart (Mausoleum) uses the same file as Mom's Heart.
  [BossID.MAUSOLEUM_MOMS_HEART]: "Portrait_78.0_MomsHeart.png", // 90
  // There also exists a "Portrait_913.0_MaidInTheMist.png" file, but that does not correspond to
  // Min Min.
  [BossID.MIN_MIN]: "Portrait_MinMin.png", // 91
  [BossID.CLOG]: "Portrait_Clog.png", // 92
  [BossID.SINGE]: "Portrait_Singe.png", // 93
  [BossID.BUMBINO]: "Portrait_Bumbino.png", // 94
  [BossID.COLOSTOMIA]: "Portrait_Colostomia.png", // 95
  [BossID.SHELL]: "Portrait_Shell.png", // 96
  [BossID.TURDLET]: "Portrait_Turdlet.png", // 97
  [BossID.RAGLICH]: "Portrait_Raglich.png", // 98
  [BossID.DOGMA]: "Portrait_Dogma.png", // 99
  // The file name specified in "bossportraits.xml" for The Beast does not actually exist in the
  // game files.
  [BossID.BEAST]: "Portrait_The Beast.png", // 100
  [BossID.HORNY_BOYS]: "Portrait_HornyBoys.png", // 101
  [BossID.CLUTCH]: "Portrait_Clutch.png", // 102
  // [BossID.CADAVRA]: "Portrait_Cadavra.png", // 103
} as const satisfies Record<BossID, string>;

----
objects\cardDescriptions.ts
import { CardType } from "isaac-typescript-definitions";

export const DEFAULT_CARD_DESCRIPTION = "Unknown";

/** This is a temporary map due to missing features in the vanilla API. */
export const CARD_DESCRIPTIONS = {
  [CardType.NULL]: DEFAULT_CARD_DESCRIPTION, // 0
  [CardType.FOOL]: "Where journey begins", // 1
  [CardType.MAGICIAN]: "May you never miss your goal", // 2
  [CardType.HIGH_PRIESTESS]: "Mother is watching you", // 3
  [CardType.EMPRESS]: "May your rage bring power", // 4
  [CardType.EMPEROR]: "Challenge me!", // 5
  [CardType.HIEROPHANT]: "Two prayers for the lost", // 6
  [CardType.LOVERS]: "May you prosper and be in good health", // 7
  [CardType.CHARIOT]: "May nothing stand before you", // 8
  [CardType.JUSTICE]: "May your future become balanced", // 9
  [CardType.HERMIT]: "May you see what life has to offer", // 10
  [CardType.WHEEL_OF_FORTUNE]: "Spin the wheel of destiny", // 11
  [CardType.STRENGTH]: "May your power bring rage", // 12
  [CardType.HANGED_MAN]: "May you find enlightenment ", // 13
  [CardType.DEATH]: "Lay waste to all that oppose you ", // 14
  [CardType.TEMPERANCE]: "May you be pure in heart", // 15
  [CardType.DEVIL]: "Revel in the power of darkness", // 16
  [CardType.TOWER]: "Destruction brings creation", // 17
  [CardType.STARS]: "May you find what you desire ", // 18
  [CardType.MOON]: "May you find all you have lost", // 19
  [CardType.SUN]: "May the light heal and enlighten you", // 20
  [CardType.JUDGEMENT]: "Judge lest ye be judged", // 21
  [CardType.WORLD]: "Open your eyes and see", // 22
  [CardType.TWO_OF_CLUBS]: "Item multiplier", // 23
  [CardType.TWO_OF_DIAMONDS]: "Item multiplier", // 24
  [CardType.TWO_OF_SPADES]: "Item multiplier", // 25
  [CardType.TWO_OF_HEARTS]: "Item multiplier", // 26
  [CardType.ACE_OF_CLUBS]: "Convert all", // 27
  [CardType.ACE_OF_DIAMONDS]: "Convert all", // 28
  [CardType.ACE_OF_SPADES]: "Convert all", // 29
  [CardType.ACE_OF_HEARTS]: "Convert all", // 30
  [CardType.JOKER]: "???", // 31
  [CardType.RUNE_HAGALAZ]: "Destruction", // 32
  [CardType.RUNE_JERA]: "Abundance", // 33
  [CardType.RUNE_EHWAZ]: "Passage", // 34
  [CardType.RUNE_DAGAZ]: "Purity", // 35
  [CardType.RUNE_ANSUZ]: "Vision", // 36
  [CardType.RUNE_PERTHRO]: "Change", // 37
  [CardType.RUNE_BERKANO]: "Companionship", // 38
  [CardType.RUNE_ALGIZ]: "Resistance", // 39
  [CardType.RUNE_BLANK]: "???", // 40
  [CardType.RUNE_BLACK]: "Void", // 41
  [CardType.CHAOS]: "???", // 42
  [CardType.CREDIT]: "Charge it!", // 43
  [CardType.RULES]: "???", // 44
  [CardType.AGAINST_HUMANITY]: "Something stinks...", // 45
  [CardType.SUICIDE_KING]: "A true ending?", // 46
  [CardType.GET_OUT_OF_JAIL_FREE]: "Open Sesame", // 47
  [CardType.QUESTION_MARK]: "Double active", // 48
  [CardType.DICE_SHARD]: "D6 + D20", // 49
  [CardType.EMERGENCY_CONTACT]: "Help from above", // 50
  [CardType.HOLY]: "You feel protected", // 51
  [CardType.HUGE_GROWTH]: "Become immense!", // 52
  [CardType.ANCIENT_RECALL]: "Draw 3 cards", // 53
  [CardType.ERA_WALK]: "Savor the moment", // 54
  [CardType.RUNE_SHARD]: "It still glows faintly", // 55
  [CardType.REVERSE_FOOL]: "Let go and move on", // 56
  [CardType.REVERSE_MAGICIAN]: "May no harm come to you", // 57
  [CardType.REVERSE_HIGH_PRIESTESS]: "Run", // 58
  [CardType.REVERSE_EMPRESS]: "May your love bring protection", // 59
  [CardType.REVERSE_EMPEROR]: "May you find a worthy opponent", // 60
  [CardType.REVERSE_HIEROPHANT]: "Two prayers for the forgotten", // 61
  [CardType.REVERSE_LOVERS]: "May your heart shatter into pieces", // 62
  [CardType.REVERSE_CHARIOT]: "May nothing walk past you", // 63
  [CardType.REVERSE_JUSTICE]: "May your sins come back to torment you", // 64
  [CardType.REVERSE_HERMIT]: "May you see the value of all things in life", // 65
  [CardType.REVERSE_WHEEL_OF_FORTUNE]: "Throw the dice of fate", // 66
  [CardType.REVERSE_STRENGTH]: "May you break their resolve", // 67
  [CardType.REVERSE_HANGED_MAN]: "May your greed know no bounds", // 68
  [CardType.REVERSE_DEATH]: "May life spring forth from the fallen", // 69
  [CardType.REVERSE_TEMPERANCE]: "May your hunger be satiated", // 70
  [CardType.REVERSE_DEVIL]: "Bask in the light of your mercy", // 71
  [CardType.REVERSE_TOWER]: "Creation brings destruction", // 72
  [CardType.REVERSE_STARS]: "May your loss bring fortune", // 73
  [CardType.REVERSE_MOON]: "May you remember lost memories", // 74
  [CardType.REVERSE_SUN]: "May the darkness swallow all around you", // 75
  [CardType.REVERSE_JUDGEMENT]: "May you redeem those found wanting", // 76
  [CardType.REVERSE_WORLD]: "Step into the abyss", // 77
  [CardType.CRACKED_KEY]: "???", // 78
  [CardType.QUEEN_OF_HEARTS]: "<3", // 79
  [CardType.WILD]: "Again", // 80
  [CardType.SOUL_OF_ISAAC]: "Reroll... or not", // 81
  [CardType.SOUL_OF_MAGDALENE]: "Give me your love!", // 82
  [CardType.SOUL_OF_CAIN]: "Opens the unopenable", // 83
  [CardType.SOUL_OF_JUDAS]: "Right behind you", // 84
  [CardType.SOUL_OF_BLUE_BABY]: "Chemical warfare", // 85
  [CardType.SOUL_OF_EVE]: "Your very own murder", // 86
  [CardType.SOUL_OF_SAMSON]: "Slay a thousand", // 87
  [CardType.SOUL_OF_AZAZEL]: "Demon rage!", // 88
  [CardType.SOUL_OF_LAZARUS]: "Life after death", // 89
  [CardType.SOUL_OF_EDEN]: "Embrace chaos", // 90
  [CardType.SOUL_OF_LOST]: "Leave your body behind", // 91
  [CardType.SOUL_OF_LILITH]: "Motherhood", // 92
  [CardType.SOUL_OF_KEEPER]: "$$$", // 93
  [CardType.SOUL_OF_APOLLYON]: "Bringer of calamity", // 94
  [CardType.SOUL_OF_FORGOTTEN]: "Skeletal protector", // 95
  [CardType.SOUL_OF_BETHANY]: "Friends from beyond", // 96
  [CardType.SOUL_OF_JACOB_AND_ESAU]: "Bound by blood", // 97
} as const satisfies Record<CardType, string>;

----
objects\cardNames.ts
import { CardType } from "isaac-typescript-definitions";

export const DEFAULT_CARD_NAME = "Unknown";

/** This is a temporary map due to missing features in the vanilla API. */
export const CARD_NAMES = {
  [CardType.NULL]: DEFAULT_CARD_NAME, // 0
  [CardType.FOOL]: "0 - The Fool", // 1
  [CardType.MAGICIAN]: "I - The Magician", // 2
  [CardType.HIGH_PRIESTESS]: "II - The High Priestess", // 3
  [CardType.EMPRESS]: "III - The Empress", // 4
  [CardType.EMPEROR]: "IV - The Emperor", // 5
  [CardType.HIEROPHANT]: "V - The Hierophant", // 6
  [CardType.LOVERS]: "VI - The Lovers", // 7
  [CardType.CHARIOT]: "VII - The Chariot", // 8
  [CardType.JUSTICE]: "VIII - Justice", // 9
  [CardType.HERMIT]: "IX - The Hermit", // 10
  [CardType.WHEEL_OF_FORTUNE]: "X - Wheel of Fortune", // 11
  [CardType.STRENGTH]: "XI - Strength", // 12
  [CardType.HANGED_MAN]: "XII - The Hanged Man", // 13
  [CardType.DEATH]: "XIII - Death", // 14
  [CardType.TEMPERANCE]: "XIV - Temperance", // 15
  [CardType.DEVIL]: "XV - The Devil", // 16
  [CardType.TOWER]: "XVI - The Tower", // 17
  [CardType.STARS]: "XVII - The Stars", // 18
  [CardType.MOON]: "XVIII - The Moon", // 19
  [CardType.SUN]: "XIX - The Sun", // 20
  [CardType.JUDGEMENT]: "XX - Judgement", // 21
  [CardType.WORLD]: "XXI - The World", // 22
  [CardType.TWO_OF_CLUBS]: "2 of Clubs", // 23
  [CardType.TWO_OF_DIAMONDS]: "2 of Diamonds", // 24
  [CardType.TWO_OF_SPADES]: "2 of Spades", // 25
  [CardType.TWO_OF_HEARTS]: "2 of Hearts", // 26
  [CardType.ACE_OF_CLUBS]: "Ace of Clubs", // 27
  [CardType.ACE_OF_DIAMONDS]: "Ace of Diamonds", // 28
  [CardType.ACE_OF_SPADES]: "Ace of Spades", // 29
  [CardType.ACE_OF_HEARTS]: "Ace of Hearts", // 30
  [CardType.JOKER]: "Joker", // 31
  [CardType.RUNE_HAGALAZ]: "Hagalaz", // 32
  [CardType.RUNE_JERA]: "Jera", // 33
  [CardType.RUNE_EHWAZ]: "Ehwaz", // 34
  [CardType.RUNE_DAGAZ]: "Dagaz", // 35
  [CardType.RUNE_ANSUZ]: "Ansuz", // 36
  [CardType.RUNE_PERTHRO]: "Perthro", // 37
  [CardType.RUNE_BERKANO]: "Berkano", // 38
  [CardType.RUNE_ALGIZ]: "Algiz", // 39
  [CardType.RUNE_BLANK]: "Blank Rune", // 40
  [CardType.RUNE_BLACK]: "Black Rune", // 41
  [CardType.CHAOS]: "Chaos Card", // 42
  [CardType.CREDIT]: "Credit Card", // 43
  [CardType.RULES]: "Rules Card", // 44
  [CardType.AGAINST_HUMANITY]: "A Card Against Humanity", // 45
  [CardType.SUICIDE_KING]: "Suicide King", // 46
  [CardType.GET_OUT_OF_JAIL_FREE]: "Get Out Of Jail Free Card", // 47
  [CardType.QUESTION_MARK]: "? Card", // 48
  [CardType.DICE_SHARD]: "Dice Shard", // 49
  [CardType.EMERGENCY_CONTACT]: "Emergency Contact", // 50
  [CardType.HOLY]: "Holy Card", // 51
  [CardType.HUGE_GROWTH]: "Huge Growth", // 52
  [CardType.ANCIENT_RECALL]: "Ancient Recall", // 53
  [CardType.ERA_WALK]: "Era Walk", // 54
  [CardType.RUNE_SHARD]: "Rune Shard", // 55
  [CardType.REVERSE_FOOL]: "0 - The Fool?", // 56
  [CardType.REVERSE_MAGICIAN]: "I - The Magician?", // 57
  [CardType.REVERSE_HIGH_PRIESTESS]: "II - The High Priestess?", // 58
  [CardType.REVERSE_EMPRESS]: "III - The Empress?", // 59
  [CardType.REVERSE_EMPEROR]: "IV - The Emperor?", // 60
  [CardType.REVERSE_HIEROPHANT]: "V - The Hierophant?", // 61
  [CardType.REVERSE_LOVERS]: "VI - The Lovers?", // 62
  [CardType.REVERSE_CHARIOT]: "VII - The Chariot?", // 63
  [CardType.REVERSE_JUSTICE]: "VIII - Justice?", // 64
  [CardType.REVERSE_HERMIT]: "IX - The Hermit?", // 65
  [CardType.REVERSE_WHEEL_OF_FORTUNE]: "X - Wheel of Fortune?", // 66
  [CardType.REVERSE_STRENGTH]: "XI - Strength?", // 67
  [CardType.REVERSE_HANGED_MAN]: "XII - The Hanged Man?", // 68
  [CardType.REVERSE_DEATH]: "XIII - Death?", // 69
  [CardType.REVERSE_TEMPERANCE]: "XIV - Temperance?", // 70
  [CardType.REVERSE_DEVIL]: "XV - The Devil?", // 71
  [CardType.REVERSE_TOWER]: "XVI - The Tower?", // 72
  [CardType.REVERSE_STARS]: "XVII - The Stars?", // 73
  [CardType.REVERSE_MOON]: "XVIII - The Moon?", // 74
  [CardType.REVERSE_SUN]: "XIX - The Sun?", // 75
  [CardType.REVERSE_JUDGEMENT]: "XX - Judgement?", // 76
  [CardType.REVERSE_WORLD]: "XXI - The World?", // 77
  [CardType.CRACKED_KEY]: "Cracked Key", // 78
  [CardType.QUEEN_OF_HEARTS]: "Queen of Hearts", // 79
  [CardType.WILD]: "Wild Card", // 80
  [CardType.SOUL_OF_ISAAC]: "Soul of Isaac", // 81
  [CardType.SOUL_OF_MAGDALENE]: "Soul of Magdalene", // 82
  [CardType.SOUL_OF_CAIN]: "Soul of Cain", // 83
  [CardType.SOUL_OF_JUDAS]: "Soul of Judas", // 84
  [CardType.SOUL_OF_BLUE_BABY]: "Soul of ???", // 85
  [CardType.SOUL_OF_EVE]: "Soul of Eve", // 86
  [CardType.SOUL_OF_SAMSON]: "Soul of Samson", // 87
  [CardType.SOUL_OF_AZAZEL]: "Soul of Azazel", // 88
  [CardType.SOUL_OF_LAZARUS]: "Soul of Lazarus", // 89
  [CardType.SOUL_OF_EDEN]: "Soul of Eden", // 90
  [CardType.SOUL_OF_LOST]: "Soul of the Lost", // 91
  [CardType.SOUL_OF_LILITH]: "Soul of Lilith", // 92
  [CardType.SOUL_OF_KEEPER]: "Soul of the Keeper", // 93
  [CardType.SOUL_OF_APOLLYON]: "Soul of Apollyon", // 94
  [CardType.SOUL_OF_FORGOTTEN]: "Soul of the Forgotten", // 95
  [CardType.SOUL_OF_BETHANY]: "Soul of Bethany", // 96
  [CardType.SOUL_OF_JACOB_AND_ESAU]: "Soul of Jacob and Esau", // 97
} as const satisfies Record<CardType, string>;

----
objects\challengeBosses.ts
import { BossID, Challenge } from "isaac-typescript-definitions";

export const DEFAULT_CHALLENGE_BOSS_ID = BossID.MOM;

/**
 * Contains the boss goal for each challenge.
 *
 * Taken from the "challenges.xml" file.
 *
 * @see https://bindingofisaacrebirth.fandom.com/wiki/Challenges
 */
export const CHALLENGE_BOSSES = {
  [Challenge.NULL]: BossID.MOM, // 0
  [Challenge.PITCH_BLACK]: BossID.MOM, // 1
  [Challenge.HIGH_BROW]: BossID.MOM, // 2
  [Challenge.HEAD_TRAUMA]: BossID.MOM, // 3
  [Challenge.DARKNESS_FALLS]: BossID.SATAN, // 4
  [Challenge.TANK]: BossID.MOM, // 5
  [Challenge.SOLAR_SYSTEM]: BossID.MOMS_HEART, // 6
  [Challenge.SUICIDE_KING]: BossID.ISAAC, // 7
  [Challenge.CAT_GOT_YOUR_TONGUE]: BossID.MOM, // 8
  [Challenge.DEMO_MAN]: BossID.MOMS_HEART, // 9
  [Challenge.CURSED]: BossID.MOM, // 10
  [Challenge.GLASS_CANNON]: BossID.SATAN, // 11
  [Challenge.WHEN_LIFE_GIVES_YOU_LEMONS]: BossID.MOM, // 12
  [Challenge.BEANS]: BossID.MOM, // 13
  [Challenge.ITS_IN_THE_CARDS]: BossID.MOM, // 14
  [Challenge.SLOW_ROLL]: BossID.MOM, // 15
  [Challenge.COMPUTER_SAVY]: BossID.MOM, // 16
  [Challenge.WAKA_WAKA]: BossID.MOM, // 17
  [Challenge.HOST]: BossID.MOM, // 18
  [Challenge.FAMILY_MAN]: BossID.ISAAC, // 19
  [Challenge.PURIST]: BossID.MOMS_HEART, // 20
  [Challenge.XXXXXXXXL]: BossID.MOMS_HEART, // 21
  [Challenge.SPEED]: BossID.MOMS_HEART, // 22
  [Challenge.BLUE_BOMBER]: BossID.SATAN, // 23
  [Challenge.PAY_TO_PLAY]: BossID.ISAAC, // 24
  [Challenge.HAVE_A_HEART]: BossID.MOMS_HEART, // 25
  [Challenge.I_RULE]: BossID.MEGA_SATAN, // 26
  [Challenge.BRAINS]: BossID.BLUE_BABY, // 27
  [Challenge.PRIDE_DAY]: BossID.MOMS_HEART, // 28
  [Challenge.ONANS_STREAK]: BossID.ISAAC, // 29
  [Challenge.GUARDIAN]: BossID.MOMS_HEART, // 30
  [Challenge.BACKASSWARDS]: BossID.MEGA_SATAN, // 31
  [Challenge.APRILS_FOOL]: BossID.MOMS_HEART, // 32
  [Challenge.POKEY_MANS]: BossID.ISAAC, // 33
  [Challenge.ULTRA_HARD]: BossID.MEGA_SATAN, // 34
  [Challenge.PONG]: BossID.BLUE_BABY, // 35
  [Challenge.SCAT_MAN]: BossID.MOM, // 36
  [Challenge.BLOODY_MARY]: BossID.SATAN, // 37
  [Challenge.BAPTISM_BY_FIRE]: BossID.SATAN, // 38
  [Challenge.ISAACS_AWAKENING]: BossID.MOTHER, // 39
  [Challenge.SEEING_DOUBLE]: BossID.MOMS_HEART, // 40
  [Challenge.PICA_RUN]: BossID.ISAAC, // 41
  [Challenge.HOT_POTATO]: BossID.SATAN, // 42
  [Challenge.CANTRIPPED]: BossID.MOM, // 43
  [Challenge.RED_REDEMPTION]: BossID.MOTHER, // 44
  [Challenge.DELETE_THIS]: BossID.BLUE_BABY, // 45
} as const satisfies Record<Challenge, BossID>;

----
objects\challengeCharacters.ts
import { Challenge, PlayerType } from "isaac-typescript-definitions";

export const DEFAULT_CHALLENGE_CHARACTER = PlayerType.ISAAC;

/**
 * Contains the starting character for each challenge.
 *
 * Taken from the "challenges.xml" file.
 */
export const CHALLENGE_CHARACTERS = {
  [Challenge.NULL]: DEFAULT_CHALLENGE_CHARACTER, // 0
  [Challenge.PITCH_BLACK]: DEFAULT_CHALLENGE_CHARACTER, // 1
  [Challenge.HIGH_BROW]: DEFAULT_CHALLENGE_CHARACTER, // 2
  [Challenge.HEAD_TRAUMA]: DEFAULT_CHALLENGE_CHARACTER, // 3
  [Challenge.DARKNESS_FALLS]: PlayerType.EVE, // 4
  [Challenge.TANK]: PlayerType.MAGDALENE, // 5
  [Challenge.SOLAR_SYSTEM]: DEFAULT_CHALLENGE_CHARACTER, // 6
  [Challenge.SUICIDE_KING]: PlayerType.LAZARUS, // 7
  [Challenge.CAT_GOT_YOUR_TONGUE]: DEFAULT_CHALLENGE_CHARACTER, // 8
  [Challenge.DEMO_MAN]: DEFAULT_CHALLENGE_CHARACTER, // 9
  [Challenge.CURSED]: PlayerType.MAGDALENE, // 10
  [Challenge.GLASS_CANNON]: PlayerType.JUDAS, // 11
  [Challenge.WHEN_LIFE_GIVES_YOU_LEMONS]: DEFAULT_CHALLENGE_CHARACTER, // 12
  [Challenge.BEANS]: DEFAULT_CHALLENGE_CHARACTER, // 13
  [Challenge.ITS_IN_THE_CARDS]: DEFAULT_CHALLENGE_CHARACTER, // 14
  [Challenge.SLOW_ROLL]: DEFAULT_CHALLENGE_CHARACTER, // 15
  [Challenge.COMPUTER_SAVY]: DEFAULT_CHALLENGE_CHARACTER, // 16
  [Challenge.WAKA_WAKA]: DEFAULT_CHALLENGE_CHARACTER, // 17
  [Challenge.HOST]: DEFAULT_CHALLENGE_CHARACTER, // 18
  [Challenge.FAMILY_MAN]: DEFAULT_CHALLENGE_CHARACTER, // 19
  [Challenge.PURIST]: DEFAULT_CHALLENGE_CHARACTER, // 20
  [Challenge.XXXXXXXXL]: DEFAULT_CHALLENGE_CHARACTER, // 21
  [Challenge.SPEED]: DEFAULT_CHALLENGE_CHARACTER, // 22
  [Challenge.BLUE_BOMBER]: PlayerType.BLUE_BABY, // 23
  [Challenge.PAY_TO_PLAY]: DEFAULT_CHALLENGE_CHARACTER, // 24
  [Challenge.HAVE_A_HEART]: DEFAULT_CHALLENGE_CHARACTER, // 25
  [Challenge.I_RULE]: DEFAULT_CHALLENGE_CHARACTER, // 26
  [Challenge.BRAINS]: PlayerType.BLUE_BABY, // 27
  [Challenge.PRIDE_DAY]: DEFAULT_CHALLENGE_CHARACTER, // 28
  [Challenge.ONANS_STREAK]: PlayerType.JUDAS, // 29
  [Challenge.GUARDIAN]: DEFAULT_CHALLENGE_CHARACTER, // 30
  [Challenge.BACKASSWARDS]: DEFAULT_CHALLENGE_CHARACTER, // 31
  [Challenge.APRILS_FOOL]: DEFAULT_CHALLENGE_CHARACTER, // 32
  [Challenge.POKEY_MANS]: DEFAULT_CHALLENGE_CHARACTER, // 33
  [Challenge.ULTRA_HARD]: DEFAULT_CHALLENGE_CHARACTER, // 34
  [Challenge.PONG]: DEFAULT_CHALLENGE_CHARACTER, // 35
  [Challenge.SCAT_MAN]: DEFAULT_CHALLENGE_CHARACTER, // 36
  [Challenge.BLOODY_MARY]: PlayerType.BETHANY, // 37
  [Challenge.BAPTISM_BY_FIRE]: PlayerType.BETHANY, // 38
  [Challenge.ISAACS_AWAKENING]: DEFAULT_CHALLENGE_CHARACTER, // 39
  [Challenge.SEEING_DOUBLE]: PlayerType.JACOB, // 40
  [Challenge.PICA_RUN]: DEFAULT_CHALLENGE_CHARACTER, // 41
  [Challenge.HOT_POTATO]: PlayerType.FORGOTTEN_B, // 42
  [Challenge.CANTRIPPED]: PlayerType.CAIN_B, // 43
  [Challenge.RED_REDEMPTION]: PlayerType.JACOB_B, // 44
  [Challenge.DELETE_THIS]: DEFAULT_CHALLENGE_CHARACTER, // 45
} as const satisfies Record<Challenge, PlayerType>;

----
objects\challengeCollectibleTypes.ts
import { Challenge, CollectibleType } from "isaac-typescript-definitions";

/**
 * Contains the extra starting collectibles for each challenge. Challenges that do not grant extra
 * starting collectibles are represented by an empty array.
 *
 * Taken from the "challenges.xml" file.
 */
export const CHALLENGE_COLLECTIBLE_TYPES = {
  // 0
  [Challenge.NULL]: [],

  // 1
  [Challenge.PITCH_BLACK]: [],

  // 2
  [Challenge.HIGH_BROW]: [
    CollectibleType.NUMBER_ONE, // 6
    CollectibleType.BUTT_BOMBS, // 209
    CollectibleType.E_COLI, // 236
    CollectibleType.FLUSH, // 291
  ],

  // 3
  [Challenge.HEAD_TRAUMA]: [
    CollectibleType.SMALL_ROCK, // 90
    CollectibleType.IRON_BAR, // 201
    CollectibleType.TINY_PLANET, // 233
    CollectibleType.SOY_MILK, // 330
  ],

  // 4
  [Challenge.DARKNESS_FALLS]: [
    CollectibleType.PENTAGRAM, // 51
    CollectibleType.RAZOR_BLADE, // 126
    CollectibleType.SACRIFICIAL_DAGGER, // 172
    CollectibleType.DARK_MATTER, // 259
  ],

  // 5
  [Challenge.TANK]: [
    CollectibleType.BUCKET_OF_LARD, // 129
    CollectibleType.INFAMY, // 242
    CollectibleType.THUNDER_THIGHS, // 314
  ],

  // 6
  [Challenge.SOLAR_SYSTEM]: [
    CollectibleType.HALO_OF_FLIES, // 10
    CollectibleType.TRANSCENDENCE, // 20
    CollectibleType.DISTANT_ADMIRATION, // 57
    CollectibleType.FOREVER_ALONE, // 128
  ],

  // 7
  [Challenge.SUICIDE_KING]: [
    CollectibleType.MY_REFLECTION, // 5
    CollectibleType.MR_MEGA, // 106
    CollectibleType.IPECAC, // 149
  ],

  // 8
  [Challenge.CAT_GOT_YOUR_TONGUE]: [
    CollectibleType.GUPPYS_TAIL, // 134
    CollectibleType.GUPPYS_HEAD, // 145
    CollectibleType.GUPPYS_HAIRBALL, // 187
  ],

  // 9
  [Challenge.DEMO_MAN]: [
    CollectibleType.DR_FETUS, // 52
    CollectibleType.REMOTE_DETONATOR, // 137
  ],

  // 10
  [Challenge.CURSED]: [
    CollectibleType.RAW_LIVER, // 16
    CollectibleType.COMPASS, // 21
    CollectibleType.TREASURE_MAP, // 54
    CollectibleType.BLUE_MAP, // 246
  ],

  // 11
  [Challenge.GLASS_CANNON]: [
    CollectibleType.LOKIS_HORNS, // 87
    CollectibleType.EPIC_FETUS, // 168
  ],

  // 12
  [Challenge.WHEN_LIFE_GIVES_YOU_LEMONS]: [
    CollectibleType.LEMON_MISHAP, // 56
    CollectibleType.NINE_VOLT, // 116
    CollectibleType.HABIT, // 156
  ],

  // 13
  [Challenge.BEANS]: [
    CollectibleType.BEAN, // 111
    CollectibleType.NINE_VOLT, // 116
    CollectibleType.BLACK_BEAN, // 180
    CollectibleType.PYRO, // 190
    CollectibleType.BUTT_BOMBS, // 209
  ],

  // 14
  [Challenge.ITS_IN_THE_CARDS]: [
    CollectibleType.BATTERY, // 63
    CollectibleType.DECK_OF_CARDS, // 85
    CollectibleType.NINE_VOLT, // 116
    CollectibleType.STARTER_DECK, // 251
  ],

  // 15
  [Challenge.SLOW_ROLL]: [
    CollectibleType.MY_REFLECTION, // 5
    CollectibleType.CUPIDS_ARROW, // 48
    CollectibleType.POLYPHEMUS, // 169
  ],

  // 16
  [Challenge.COMPUTER_SAVY]: [
    CollectibleType.SPOON_BENDER, // 3
    CollectibleType.TECHNOLOGY, // 68
    CollectibleType.TECHNOLOGY_2, // 152
  ],

  // 17
  [Challenge.WAKA_WAKA]: [
    CollectibleType.ANTI_GRAVITY, // 222
    CollectibleType.STRANGE_ATTRACTOR, // 315
  ],

  // 18
  [Challenge.HOST]: [
    CollectibleType.MULLIGAN, // 151
    CollectibleType.SPIDERBABY, // 211
  ],

  // 19
  [Challenge.FAMILY_MAN]: [
    CollectibleType.BROTHER_BOBBY, // 8
    CollectibleType.SISTER_MAGGY, // 67
    CollectibleType.DADS_KEY, // 175
    CollectibleType.BFFS, // 247
    CollectibleType.ROTTEN_BABY, // 268
  ],

  // 20
  [Challenge.PURIST]: [],

  // 21
  [Challenge.XXXXXXXXL]: [],

  // 22
  [Challenge.SPEED]: [],

  // 23
  [Challenge.BLUE_BOMBER]: [
    CollectibleType.BROTHER_BOBBY, // 8
    CollectibleType.KAMIKAZE, // 40
    CollectibleType.MR_MEGA, // 106
    CollectibleType.PYROMANIAC, // 223
  ],

  // 24
  [Challenge.PAY_TO_PLAY]: [
    CollectibleType.SACK_OF_PENNIES, // 94
    CollectibleType.MONEY_EQUALS_POWER, // 109
  ],

  // 25
  [Challenge.HAVE_A_HEART]: [
    CollectibleType.CHARM_OF_THE_VAMPIRE, // 62
  ],

  // 26
  [Challenge.I_RULE]: [
    CollectibleType.LADDER, // 60
    CollectibleType.MOMS_KNIFE, // 114
    CollectibleType.TRINITY_SHIELD, // 243
    CollectibleType.BOOMERANG, // 338
  ],

  // 27
  [Challenge.BRAINS]: [
    CollectibleType.BOBS_BRAIN, // 273
    CollectibleType.BOBS_BRAIN, // 273
    CollectibleType.BOBS_BRAIN, // 273
    CollectibleType.THUNDER_THIGHS, // 314
  ],

  // 28
  [Challenge.PRIDE_DAY]: [
    CollectibleType.RAINBOW_BABY, // 174
    CollectibleType.THREE_DOLLAR_BILL, // 191
  ],

  // 29
  [Challenge.ONANS_STREAK]: [
    CollectibleType.CHOCOLATE_MILK, // 69
  ],

  // 30
  [Challenge.GUARDIAN]: [
    CollectibleType.HOLY_GRAIL, // 184
    CollectibleType.ISAACS_HEART, // 276
    CollectibleType.PUNCHING_BAG, // 281
    CollectibleType.SPEAR_OF_DESTINY, // 400
  ],

  // 31
  [Challenge.BACKASSWARDS]: [],

  // 32
  [Challenge.APRILS_FOOL]: [],

  // 33
  [Challenge.POKEY_MANS]: [
    CollectibleType.MOMS_EYESHADOW, // 200
    CollectibleType.FRIEND_BALL, // 382
  ],

  // 34
  [Challenge.ULTRA_HARD]: [
    CollectibleType.BOOK_OF_REVELATIONS, // 78
    CollectibleType.CAFFEINE_PILL, // 340
  ],

  // 35
  [Challenge.PONG]: [
    CollectibleType.CUPIDS_ARROW, // 48
    CollectibleType.RUBBER_CEMENT, // 221
  ],

  // 36
  [Challenge.SCAT_MAN]: [
    CollectibleType.SKATOLE, // 9
    CollectibleType.POOP, // 36
    CollectibleType.NINE_VOLT, // 116
    CollectibleType.BUTT_BOMBS, // 209
    CollectibleType.BUTT_BOMBS, // 209
    CollectibleType.BUTT_BOMBS, // 209
    CollectibleType.E_COLI, // 236
    CollectibleType.BFFS, // 247
    CollectibleType.THUNDER_THIGHS, // 314
    CollectibleType.DIRTY_MIND, // 576
  ],

  // 37
  [Challenge.BLOODY_MARY]: [
    // Note that in "challenges.xml", it also includes "-584", which removes Book of Virtues from
    // Bethany.
    CollectibleType.BOOK_OF_BELIAL, // 34
    CollectibleType.BLOOD_BAG, // 119
    CollectibleType.ANEMIC, // 214
    CollectibleType.BLOOD_OATH, // 569
  ],

  // 38
  [Challenge.BAPTISM_BY_FIRE]: [
    // Note that in "challenges.xml", it also includes "-584", which removes Book of Virtues from
    // Bethany.
    CollectibleType.GUPPYS_PAW, // 133
    CollectibleType.SCHOOLBAG, // 534
    CollectibleType.URN_OF_SOULS, // 640
  ],

  // 39
  [Challenge.ISAACS_AWAKENING]: [
    CollectibleType.TRINITY_SHIELD, // 243
    CollectibleType.SPIRIT_SWORD, // 579
    CollectibleType.MOMS_BRACELET, // 604
  ],

  // 40
  [Challenge.SEEING_DOUBLE]: [245],

  // 41
  [Challenge.PICA_RUN]: [
    CollectibleType.MOMS_PURSE, // 139
    CollectibleType.MOMS_BOX, // 439
    CollectibleType.MARBLES, // 538
  ],

  // 42
  [Challenge.HOT_POTATO]: [],

  // 43
  [Challenge.CANTRIPPED]: [],

  // 44
  [Challenge.RED_REDEMPTION]: [
    CollectibleType.DADS_KEY, // 175
  ],

  // 45
  [Challenge.DELETE_THIS]: [CollectibleType.TMTRAINER],
} as const satisfies Record<Challenge, readonly CollectibleType[]>;

----
objects\challengeNames.ts
import { Challenge } from "isaac-typescript-definitions";

export const DEFAULT_CHALLENGE_NAME = "Unknown";

/** Taken from the "challenges.xml" file. */
export const CHALLENGE_NAMES = {
  [Challenge.NULL]: DEFAULT_CHALLENGE_NAME, // 0
  [Challenge.PITCH_BLACK]: "Pitch Black", // 1
  [Challenge.HIGH_BROW]: "High Brow", // 2
  [Challenge.HEAD_TRAUMA]: "Head Trauma", // 3
  [Challenge.DARKNESS_FALLS]: "Darkness Falls", // 4
  [Challenge.TANK]: "The Tank", // 5
  [Challenge.SOLAR_SYSTEM]: "Solar System", // 6
  [Challenge.SUICIDE_KING]: "Suicide King", // 7
  [Challenge.CAT_GOT_YOUR_TONGUE]: "Cat Got Your Tongue", // 8
  [Challenge.DEMO_MAN]: "Demo Man", // 9
  [Challenge.CURSED]: "Cursed!", // 10
  [Challenge.GLASS_CANNON]: "Glass Cannon", // 11
  [Challenge.WHEN_LIFE_GIVES_YOU_LEMONS]: "When Life Gives You Lemons", // 12
  [Challenge.BEANS]: "Beans!", // 13
  [Challenge.ITS_IN_THE_CARDS]: "It's In The Cards", // 14
  [Challenge.SLOW_ROLL]: "Slow Roll", // 15
  [Challenge.COMPUTER_SAVY]: "Computer Savvy", // 16
  [Challenge.WAKA_WAKA]: "Waka Waka", // 17
  [Challenge.HOST]: "The Host", // 18
  [Challenge.FAMILY_MAN]: "The Family Man", // 19
  [Challenge.PURIST]: "Purist", // 20
  [Challenge.XXXXXXXXL]: "XXXXXXXXL", // 21
  [Challenge.SPEED]: "SPEED!", // 22
  [Challenge.BLUE_BOMBER]: "Blue Bomber", // 23
  [Challenge.PAY_TO_PLAY]: "PAY TO PLAY", // 24
  [Challenge.HAVE_A_HEART]: "Have a Heart", // 25
  [Challenge.I_RULE]: "I RULE!", // 26
  [Challenge.BRAINS]: "BRAINS!", // 27
  [Challenge.PRIDE_DAY]: "PRIDE DAY!", // 28
  [Challenge.ONANS_STREAK]: "Onan's Streak", // 29
  [Challenge.GUARDIAN]: "The Guardian", // 30
  [Challenge.BACKASSWARDS]: "Backasswards", // 31
  [Challenge.APRILS_FOOL]: "Aprils Fool", // 32
  [Challenge.POKEY_MANS]: "Pokey Mans", // 33
  [Challenge.ULTRA_HARD]: "Ultra Hard", // 34
  [Challenge.PONG]: "Pong", // 35
  [Challenge.SCAT_MAN]: "Scat Man", // 36
  [Challenge.BLOODY_MARY]: "Bloody Mary", // 37
  [Challenge.BAPTISM_BY_FIRE]: "Baptism By Fire", // 38
  [Challenge.ISAACS_AWAKENING]: "Isaac's Awakening", // 39
  [Challenge.SEEING_DOUBLE]: "Seeing Double", // 40
  [Challenge.PICA_RUN]: "Pica Run", // 41
  [Challenge.HOT_POTATO]: "Hot Potato", // 42
  [Challenge.CANTRIPPED]: "Cantripped!", // 43
  [Challenge.RED_REDEMPTION]: "Red Redemption", // 44
  [Challenge.DELETE_THIS]: "DELETE THIS", // 45
} as const satisfies Record<Challenge, string>;

----
objects\challengeTrinketType.ts
import { Challenge, TrinketType } from "isaac-typescript-definitions";

/**
 * Contains the starting trinket for each challenge. Challenges that do not grant a starting trinket
 * will have a value of `undefined`.
 *
 * Taken from the "challenges.xml" file.
 */
export const CHALLENGE_TRINKET_TYPE = {
  [Challenge.NULL]: undefined, // 0
  [Challenge.PITCH_BLACK]: undefined, // 1
  [Challenge.HIGH_BROW]: TrinketType.PETRIFIED_POOP, // 2
  [Challenge.HEAD_TRAUMA]: undefined, // 3
  [Challenge.DARKNESS_FALLS]: undefined, // 4
  [Challenge.TANK]: undefined, // 5
  [Challenge.SOLAR_SYSTEM]: undefined, // 6
  [Challenge.SUICIDE_KING]: undefined, // 7
  [Challenge.CAT_GOT_YOUR_TONGUE]: undefined, // 8
  [Challenge.DEMO_MAN]: TrinketType.MATCH_STICK, // 9
  [Challenge.CURSED]: TrinketType.CHILDS_HEART, // 10
  [Challenge.GLASS_CANNON]: undefined, // 11
  [Challenge.WHEN_LIFE_GIVES_YOU_LEMONS]: undefined, // 12
  [Challenge.BEANS]: undefined, // 13
  [Challenge.ITS_IN_THE_CARDS]: undefined, // 14
  [Challenge.SLOW_ROLL]: undefined, // 15
  [Challenge.COMPUTER_SAVY]: undefined, // 16
  [Challenge.WAKA_WAKA]: undefined, // 17
  [Challenge.HOST]: TrinketType.TICK, // 18
  [Challenge.FAMILY_MAN]: undefined, // 19
  [Challenge.PURIST]: undefined, // 20
  [Challenge.XXXXXXXXL]: undefined, // 21
  [Challenge.SPEED]: undefined, // 22
  [Challenge.BLUE_BOMBER]: undefined, // 23
  [Challenge.PAY_TO_PLAY]: undefined, // 24
  [Challenge.HAVE_A_HEART]: undefined, // 25
  [Challenge.I_RULE]: undefined, // 26
  [Challenge.BRAINS]: undefined, // 27
  [Challenge.PRIDE_DAY]: TrinketType.RAINBOW_WORM, // 28
  [Challenge.ONANS_STREAK]: undefined, // 29
  [Challenge.GUARDIAN]: undefined, // 30
  [Challenge.BACKASSWARDS]: undefined, // 31
  [Challenge.APRILS_FOOL]: undefined, // 32
  [Challenge.POKEY_MANS]: undefined, // 33
  [Challenge.ULTRA_HARD]: undefined, // 34
  [Challenge.PONG]: undefined, // 35
  [Challenge.SCAT_MAN]: TrinketType.MYSTERIOUS_CANDY, // 36
  [Challenge.BLOODY_MARY]: TrinketType.CHILDS_HEART, // 37
  [Challenge.BAPTISM_BY_FIRE]: TrinketType.MAGGYS_FAITH, // 38
  [Challenge.ISAACS_AWAKENING]: undefined, // 39
  [Challenge.SEEING_DOUBLE]: undefined, // 40
  [Challenge.PICA_RUN]: undefined, // 41
  [Challenge.HOT_POTATO]: undefined, // 42
  [Challenge.CANTRIPPED]: undefined, // 43
  [Challenge.RED_REDEMPTION]: undefined, // 44
  [Challenge.DELETE_THIS]: undefined, // 45
} as const satisfies Record<Challenge, TrinketType | undefined>;

----
objects\characterDamageMultipliers.ts
import { PlayerType } from "isaac-typescript-definitions";

/** From: https://bindingofisaacrebirth.fandom.com/wiki/Characters#Regular_Characters */
export const CHARACTER_DAMAGE_MULTIPLIERS = {
  [PlayerType.POSSESSOR]: 1, // -1
  [PlayerType.ISAAC]: 1, // 0
  [PlayerType.MAGDALENE]: 1, // 1
  [PlayerType.CAIN]: 1.2, // 2
  [PlayerType.JUDAS]: 1.35, // 3
  [PlayerType.BLUE_BABY]: 1.05, // 4
  [PlayerType.EVE]: 0.75, // 5
  [PlayerType.SAMSON]: 1, // 6
  [PlayerType.AZAZEL]: 1.5, // 7
  [PlayerType.LAZARUS]: 1, // 8
  [PlayerType.EDEN]: 1, // 9
  [PlayerType.LOST]: 1, // 10
  [PlayerType.LAZARUS_2]: 1.4, // 11
  [PlayerType.DARK_JUDAS]: 2, // 12
  [PlayerType.LILITH]: 1, // 13
  [PlayerType.KEEPER]: 1.2, // 14
  [PlayerType.APOLLYON]: 1, // 15
  [PlayerType.FORGOTTEN]: 1.5, // 16
  [PlayerType.SOUL]: 1, // 17
  [PlayerType.BETHANY]: 1, // 18
  [PlayerType.JACOB]: 1, // 19
  [PlayerType.ESAU]: 1, // 20
  [PlayerType.ISAAC_B]: 1, // 21
  [PlayerType.MAGDALENE_B]: 0.75, // 22
  [PlayerType.CAIN_B]: 1, // 23
  [PlayerType.JUDAS_B]: 1, // 24
  [PlayerType.BLUE_BABY_B]: 1, // 25
  [PlayerType.EVE_B]: 1.2, // 26
  [PlayerType.SAMSON_B]: 1, // 27
  [PlayerType.AZAZEL_B]: 1.5, // 28
  [PlayerType.LAZARUS_B]: 1, // 29
  [PlayerType.EDEN_B]: 1, // 30
  [PlayerType.LOST_B]: 1.3, // 31
  [PlayerType.LILITH_B]: 1, // 32
  [PlayerType.KEEPER_B]: 1, // 33
  [PlayerType.APOLLYON_B]: 1, // 34
  [PlayerType.FORGOTTEN_B]: 1.5, // 35
  [PlayerType.BETHANY_B]: 1, // 36
  [PlayerType.JACOB_B]: 1, // 37
  [PlayerType.LAZARUS_2_B]: 1.5, // 38
  [PlayerType.JACOB_2_B]: 1, // 39
  [PlayerType.SOUL_B]: 1, // 40
} as const satisfies Record<PlayerType, float>;

----
objects\characterNames.ts
import { PlayerType } from "isaac-typescript-definitions";

export const CHARACTER_NAMES = {
  [PlayerType.POSSESSOR]: "Possessor", // -1
  [PlayerType.ISAAC]: "Isaac", // 0
  [PlayerType.MAGDALENE]: "Magdalene", // 1
  [PlayerType.CAIN]: "Cain", // 2
  [PlayerType.JUDAS]: "Judas", // 3
  [PlayerType.BLUE_BABY]: "Blue Baby", // 4
  [PlayerType.EVE]: "Eve", // 5
  [PlayerType.SAMSON]: "Samson", // 6
  [PlayerType.AZAZEL]: "Azazel", // 7
  [PlayerType.LAZARUS]: "Lazarus", // 8
  [PlayerType.EDEN]: "Eden", // 9
  [PlayerType.LOST]: "The Lost", // 10
  [PlayerType.LAZARUS_2]: "Lazarus II", // 11
  [PlayerType.DARK_JUDAS]: "Dark Judas", // 12
  [PlayerType.LILITH]: "Lilith", // 13
  [PlayerType.KEEPER]: "Keeper", // 14
  [PlayerType.APOLLYON]: "Apollyon", // 15
  [PlayerType.FORGOTTEN]: "The Forgotten", // 16
  [PlayerType.SOUL]: "The Soul", // 17
  [PlayerType.BETHANY]: "Bethany", // 18
  [PlayerType.JACOB]: "Jacob", // 19
  [PlayerType.ESAU]: "Esau", // 20
  [PlayerType.ISAAC_B]: "Tainted Isaac", // 21
  [PlayerType.MAGDALENE_B]: "Tainted Magdalene", // 22
  [PlayerType.CAIN_B]: "Tainted Cain", // 23
  [PlayerType.JUDAS_B]: "Tainted Judas", // 24
  [PlayerType.BLUE_BABY_B]: "Tainted Blue Baby", // 25
  [PlayerType.EVE_B]: "Tainted Eve", // 26
  [PlayerType.SAMSON_B]: "Tainted Samson", // 27
  [PlayerType.AZAZEL_B]: "Tainted Azazel", // 28
  [PlayerType.LAZARUS_B]: "Tainted Lazarus", // 29
  [PlayerType.EDEN_B]: "Tainted Eden", // 30
  [PlayerType.LOST_B]: "Tainted Lost", // 31
  [PlayerType.LILITH_B]: "Tainted Lilith", // 32
  [PlayerType.KEEPER_B]: "Tainted Keeper", // 33
  [PlayerType.APOLLYON_B]: "Tainted Apollyon", // 34
  [PlayerType.FORGOTTEN_B]: "Tainted Forgotten", // 35
  [PlayerType.BETHANY_B]: "Tainted Bethany", // 36
  [PlayerType.JACOB_B]: "Tainted Jacob", // 37
  [PlayerType.LAZARUS_2_B]: "Dead Tainted Lazarus", // 38
  [PlayerType.JACOB_2_B]: "Dead Tainted Jacob", // 39
  [PlayerType.SOUL_B]: "Tainted Soul", // 40
} as const satisfies Record<PlayerType, string>;

----
objects\characterSpritePNGFileNames.ts
// cspell:disable

import { PlayerType } from "isaac-typescript-definitions";

export const CHARACTER_SPRITE_PNG_FILE_NAMES = {
  // Possessor uses the same sprite as Isaac.
  [PlayerType.POSSESSOR]: "character_001_isaac.png", // 0
  [PlayerType.ISAAC]: "character_001_isaac.png", // 0
  [PlayerType.MAGDALENE]: "character_002_magdalene.png", // 1
  [PlayerType.CAIN]: "character_003_cain.png", // 2
  [PlayerType.JUDAS]: "character_004_judas.png", // 3
  [PlayerType.BLUE_BABY]: "character_006_bluebaby.png", // 4
  [PlayerType.EVE]: "character_005_eve.png", // 5
  [PlayerType.SAMSON]: "character_007_samson.png", // 6
  [PlayerType.AZAZEL]: "character_008_azazel.png", // 7
  [PlayerType.LAZARUS]: "character_009_lazarus.png", // 8
  [PlayerType.EDEN]: "character_009_eden.png", // 9
  [PlayerType.LOST]: "character_012_thelost.png", // 10
  [PlayerType.LAZARUS_2]: "character_010_lazarus2.png", // 11
  [PlayerType.DARK_JUDAS]: "character_013_blackjudas.png", // 12
  [PlayerType.LILITH]: "character_014_lilith.png", // 13
  [PlayerType.KEEPER]: "character_015_keeper.png", // 14
  [PlayerType.APOLLYON]: "character_016_apollyon.png", // 15
  [PlayerType.FORGOTTEN]: "character_017_theforgotten.png", // 16
  [PlayerType.SOUL]: "character_018_thesoul.png", // 17
  [PlayerType.BETHANY]: "character_001x_bethany.png", // 18
  [PlayerType.JACOB]: "character_002x_jacob.png", // 19
  [PlayerType.ESAU]: "character_003x_esau.png", // 20
  [PlayerType.ISAAC_B]: "character_001b_isaac.png", // 21
  [PlayerType.MAGDALENE_B]: "character_002b_magdalene.png", // 22
  [PlayerType.CAIN_B]: "character_003b_cain.png", // 23
  [PlayerType.JUDAS_B]: "character_004b_judas.png", // 24
  [PlayerType.BLUE_BABY_B]: "character_005b_bluebaby.png", // 25
  [PlayerType.EVE_B]: "character_006b_eve.png", // 26
  [PlayerType.SAMSON_B]: "character_007b_samson.png", // 27
  [PlayerType.AZAZEL_B]: "character_008b_azazel.png", // 28
  [PlayerType.LAZARUS_B]: "character_009b_lazarus.png", // 29
  [PlayerType.EDEN_B]: "character_009_eden.png", // 30
  [PlayerType.LOST_B]: "character_012b_thelost.png", // 31
  [PlayerType.LILITH_B]: "character_014b_lilith.png", // 32
  [PlayerType.KEEPER_B]: "character_015b_keeper.png", // 33
  [PlayerType.APOLLYON_B]: "character_016b_apollyon.png", // 34
  [PlayerType.FORGOTTEN_B]: "character_016b_theforgotten.png", // 35
  [PlayerType.BETHANY_B]: "character_018b_bethany.png", // 36
  [PlayerType.JACOB_B]: "character_019b_jacob.png", // 37
  [PlayerType.LAZARUS_2_B]: "character_009b_lazarus2.png", // 38
  [PlayerType.JACOB_2_B]: "character_019b_jacob2.png", // 39
  [PlayerType.SOUL_B]: "character_017b_thesoul.png", // 40
} as const satisfies Record<PlayerType, string>;

----
objects\characterStartingCollectibleTypes.ts
import { CollectibleType, PlayerType } from "isaac-typescript-definitions";

export const CHARACTER_STARTING_COLLECTIBLE_TYPES = {
  // -1
  [PlayerType.POSSESSOR]: [],

  // 0
  [PlayerType.ISAAC]: [CollectibleType.D6],

  // 1
  [PlayerType.MAGDALENE]: [CollectibleType.YUM_HEART],

  // 2
  [PlayerType.CAIN]: [CollectibleType.LUCKY_FOOT],

  // 3
  [PlayerType.JUDAS]: [CollectibleType.BOOK_OF_BELIAL],

  // 4
  [PlayerType.BLUE_BABY]: [CollectibleType.POOP],

  // 5
  [PlayerType.EVE]: [
    CollectibleType.DEAD_BIRD, // 117
    CollectibleType.WHORE_OF_BABYLON, // 122
    CollectibleType.RAZOR_BLADE, // 126
  ],

  // 6
  [PlayerType.SAMSON]: [CollectibleType.BLOODY_LUST],

  // 7
  [PlayerType.AZAZEL]: [],

  // 8
  [PlayerType.LAZARUS]: [CollectibleType.ANEMIC],
  // (Lazarus Rags is not granted; the extra life is innate.)

  // 9
  [PlayerType.EDEN]: [],

  // 10
  [PlayerType.LOST]: [CollectibleType.ETERNAL_D6],
  // (Holy Mantle is not granted; the effect is innate.)

  // 11
  [PlayerType.LAZARUS_2]: [CollectibleType.ANEMIC],
  // (Even if the run is started as Lazarus 2 using e.g. `restart 11`, Anemic is still granted.)

  // 12
  [PlayerType.DARK_JUDAS]: [],

  // 13
  [PlayerType.LILITH]: [
    CollectibleType.BOX_OF_FRIENDS, // 357
    CollectibleType.CAMBION_CONCEPTION, // 412
  ],

  // 14
  [PlayerType.KEEPER]: [CollectibleType.WOODEN_NICKEL],

  // 15
  [PlayerType.APOLLYON]: [CollectibleType.VOID],

  // 16
  [PlayerType.FORGOTTEN]: [],

  // 17
  [PlayerType.SOUL]: [],

  // 18
  [PlayerType.BETHANY]: [CollectibleType.BOOK_OF_VIRTUES],

  // 19
  [PlayerType.JACOB]: [],

  // 20
  [PlayerType.ESAU]: [],

  // 21
  [PlayerType.ISAAC_B]: [],

  // 22
  [PlayerType.MAGDALENE_B]: [CollectibleType.YUM_HEART],

  // 23
  [PlayerType.CAIN_B]: [CollectibleType.BAG_OF_CRAFTING],

  // 24
  [PlayerType.JUDAS_B]: [CollectibleType.DARK_ARTS],

  // 25
  [PlayerType.BLUE_BABY_B]: [CollectibleType.HOLD],

  // 26
  [PlayerType.EVE_B]: [CollectibleType.SUMPTORIUM],

  // 27
  [PlayerType.SAMSON_B]: [],
  // (Berserk is not granted; the rage is innate.)

  // 28
  [PlayerType.AZAZEL_B]: [],

  // 29
  [PlayerType.LAZARUS_B]: [CollectibleType.FLIP],

  // 30
  [PlayerType.EDEN_B]: [],

  // 31
  [PlayerType.LOST_B]: [],

  // 32
  [PlayerType.LILITH_B]: [],

  // 33
  [PlayerType.KEEPER_B]: [],

  // 34
  [PlayerType.APOLLYON_B]: [CollectibleType.ABYSS],

  // 35
  [PlayerType.FORGOTTEN_B]: [],

  // 36
  [PlayerType.BETHANY_B]: [CollectibleType.LEMEGETON],

  // 37
  [PlayerType.JACOB_B]: [CollectibleType.ANIMA_SOLA],

  // 38
  [PlayerType.LAZARUS_2_B]: [CollectibleType.FLIP],
  // (Even if the run is started as Dead Tainted Lazarus using e.g. `restart 38`, Flip is still
  // granted.)

  // 39
  [PlayerType.JACOB_2_B]: [CollectibleType.ANIMA_SOLA],
  // (Even if the run is started as Tainted Jacob in "Lost" form using e.g. `restart 39`, Anima Sola
  // is still granted.)

  // 40
  [PlayerType.SOUL_B]: [],
} as const satisfies Record<PlayerType, readonly CollectibleType[]>;

----
objects\characterStartingTrinketTypes.ts
import { PlayerType, TrinketType } from "isaac-typescript-definitions";

export const CHARACTER_STARTING_TRINKET_TYPE = {
  // -1
  [PlayerType.POSSESSOR]: undefined,

  // 0
  [PlayerType.ISAAC]: undefined,

  // 1
  [PlayerType.MAGDALENE]: undefined,

  // 2
  [PlayerType.CAIN]: TrinketType.PAPER_CLIP,

  // 3
  [PlayerType.JUDAS]: undefined,

  // 4
  [PlayerType.BLUE_BABY]: undefined,

  // 5
  [PlayerType.EVE]: undefined,

  // 6
  [PlayerType.SAMSON]: TrinketType.CHILDS_HEART,

  // 7
  [PlayerType.AZAZEL]: undefined,

  // 8
  [PlayerType.LAZARUS]: undefined,

  // 9
  [PlayerType.EDEN]: undefined,

  // 10
  [PlayerType.LOST]: undefined,

  // 11
  [PlayerType.LAZARUS_2]: undefined,

  // 12
  [PlayerType.DARK_JUDAS]: undefined,

  // 13
  [PlayerType.LILITH]: undefined,

  // 14
  [PlayerType.KEEPER]: TrinketType.STORE_KEY,

  // 15
  [PlayerType.APOLLYON]: undefined,

  // 16
  [PlayerType.FORGOTTEN]: undefined,

  // 17
  [PlayerType.SOUL]: undefined,

  // 18
  [PlayerType.BETHANY]: undefined,

  // 19
  [PlayerType.JACOB]: undefined,

  // 20
  [PlayerType.ESAU]: undefined,

  // 21
  [PlayerType.ISAAC_B]: undefined,

  // 22
  [PlayerType.MAGDALENE_B]: undefined,

  // 23
  [PlayerType.CAIN_B]: undefined,

  // 24
  [PlayerType.JUDAS_B]: undefined,

  // 25
  [PlayerType.BLUE_BABY_B]: undefined,

  // 26
  [PlayerType.EVE_B]: undefined,

  // 27
  [PlayerType.SAMSON_B]: undefined,

  // 28
  [PlayerType.AZAZEL_B]: undefined,

  // 29
  [PlayerType.LAZARUS_B]: undefined,

  // 30
  [PlayerType.EDEN_B]: undefined,

  // 31
  [PlayerType.LOST_B]: undefined,

  // 32
  [PlayerType.LILITH_B]: undefined,

  // 33
  [PlayerType.KEEPER_B]: undefined,

  // 34
  [PlayerType.APOLLYON_B]: undefined,

  // 35
  [PlayerType.FORGOTTEN_B]: undefined,

  // 36
  [PlayerType.BETHANY_B]: undefined,

  // 37
  [PlayerType.JACOB_B]: undefined,

  // 38
  [PlayerType.LAZARUS_2_B]: undefined,

  // 39
  [PlayerType.JACOB_2_B]: undefined,

  // 40
  [PlayerType.SOUL_B]: undefined,
} as const satisfies Record<PlayerType, TrinketType | undefined>;

----
objects\chestNames.ts
import { PickupVariant } from "isaac-typescript-definitions";
import type { CHEST_PICKUP_VARIANTS } from "../core/constants";

export const DEFAULT_CHEST_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const CHEST_NAMES = {
  [PickupVariant.CHEST]: "Chest", // 50
  [PickupVariant.BOMB_CHEST]: "Bomb Chest", // 51
  [PickupVariant.SPIKED_CHEST]: "Spiked Chest", // 52
  [PickupVariant.ETERNAL_CHEST]: "Eternal Chest", // 53
  [PickupVariant.MIMIC_CHEST]: "Mimic Chest", // 54
  [PickupVariant.OLD_CHEST]: "Old Chest", // 55
  [PickupVariant.WOODEN_CHEST]: "Wooden Chest", // 56
  [PickupVariant.MEGA_CHEST]: "Mega Chest", // 57
  [PickupVariant.HAUNTED_CHEST]: "Haunted Chest", // 58
  [PickupVariant.LOCKED_CHEST]: "Locked Chest", // 60
  [PickupVariant.RED_CHEST]: "Red Chest", // 360
  [PickupVariant.MOMS_CHEST]: "Mom's Chest", // 390
} as const satisfies Record<(typeof CHEST_PICKUP_VARIANTS)[number], string>;

----
objects\coinNames.ts
import { CoinSubType } from "isaac-typescript-definitions";

export const DEFAULT_COIN_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const COIN_NAMES = {
  [CoinSubType.NULL]: DEFAULT_COIN_NAME, // 0
  [CoinSubType.PENNY]: "Penny", // 1
  [CoinSubType.NICKEL]: "Nickel", // 2
  [CoinSubType.DIME]: "Dime", // 3
  [CoinSubType.DOUBLE_PACK]: "Double Penny", // 4
  [CoinSubType.LUCKY_PENNY]: "Lucky Penny", // 5
  [CoinSubType.STICKY_NICKEL]: "Sticky Nickel", // 6
  [CoinSubType.GOLDEN]: "Golden Penny", // 7
} as const satisfies Record<CoinSubType, string>;

----
objects\coinSubTypeToValue.ts
import { CoinSubType } from "isaac-typescript-definitions";

export const DEFAULT_COIN_VALUE = 1;

export const COIN_SUB_TYPE_TO_VALUE = {
  [CoinSubType.NULL]: 0, // 0
  [CoinSubType.PENNY]: 1, // 1
  [CoinSubType.NICKEL]: 5, // 2
  [CoinSubType.DIME]: 10, // 3
  [CoinSubType.DOUBLE_PACK]: 2, // 4
  [CoinSubType.LUCKY_PENNY]: 1, // 5
  [CoinSubType.STICKY_NICKEL]: 5, // 6
  [CoinSubType.GOLDEN]: 1, // 7
} as const satisfies Record<CoinSubType, int>;

----
objects\collectibleDescriptions.ts
/* cspell:disable */

import { CollectibleType } from "isaac-typescript-definitions";

export const DEFAULT_COLLECTIBLE_DESCRIPTION = "Unknown";

/** Maps collectible types to the real English descriptions from the "stringtable.sta" file. */
export const COLLECTIBLE_DESCRIPTIONS = {
  [CollectibleType.NULL]: DEFAULT_COLLECTIBLE_DESCRIPTION, // 0
  [CollectibleType.SAD_ONION]: "Tears up", // 1
  [CollectibleType.INNER_EYE]: "Triple shot", // 2
  [CollectibleType.SPOON_BENDER]: "Homing shots", // 3
  [CollectibleType.CRICKETS_HEAD]: "DMG up", // 4
  [CollectibleType.MY_REFLECTION]: "Boomerang tears", // 5
  [CollectibleType.NUMBER_ONE]: "Tears up + range down", // 6
  [CollectibleType.BLOOD_OF_THE_MARTYR]: "DMG up", // 7
  [CollectibleType.BROTHER_BOBBY]: "Friends 'till the end", // 8
  [CollectibleType.SKATOLE]: "Fly love", // 9
  [CollectibleType.HALO_OF_FLIES]: "Projectile protection", // 10
  [CollectibleType.ONE_UP]: "Extra life", // 11
  [CollectibleType.MAGIC_MUSHROOM]: "All stats up!", // 12
  [CollectibleType.VIRUS]: "Poison touch + speed up", // 13
  [CollectibleType.ROID_RAGE]: "Speed and range up", // 14
  [CollectibleType.HEART]: "HP up", // 15
  [CollectibleType.RAW_LIVER]: "HP up", // 16
  [CollectibleType.SKELETON_KEY]: "99 keys", // 17
  [CollectibleType.DOLLAR]: "$$$", // 18
  [CollectibleType.BOOM]: "10 bombs", // 19
  [CollectibleType.TRANSCENDENCE]: "We all float down here...", // 20
  [CollectibleType.COMPASS]: "The end is near", // 21
  [CollectibleType.LUNCH]: "HP up", // 22
  [CollectibleType.DINNER]: "HP up", // 23
  [CollectibleType.DESSERT]: "HP up", // 24
  [CollectibleType.BREAKFAST]: "HP up", // 25
  [CollectibleType.ROTTEN_MEAT]: "HP up", // 26
  [CollectibleType.WOODEN_SPOON]: "Speed up", // 27
  [CollectibleType.BELT]: "Speed up", // 28
  [CollectibleType.MOMS_UNDERWEAR]: "Range up", // 29
  [CollectibleType.MOMS_HEELS]: "Range up", // 30
  [CollectibleType.MOMS_LIPSTICK]: "Range up", // 31
  [CollectibleType.WIRE_COAT_HANGER]: "Tears up", // 32
  [CollectibleType.BIBLE]: "Temporary flight", // 33
  [CollectibleType.BOOK_OF_BELIAL]: "Temporary DMG up", // 34
  [CollectibleType.NECRONOMICON]: "Mass room damage", // 35
  [CollectibleType.POOP]: "Plop!", // 36
  [CollectibleType.MR_BOOM]: "Reusable bomb buddy", // 37
  [CollectibleType.TAMMYS_HEAD]: "Reusable tear burst", // 38
  [CollectibleType.MOMS_BRA]: "Mass paralysis", // 39
  [CollectibleType.KAMIKAZE]: "Become the bomb!", // 40
  [CollectibleType.MOMS_PAD]: "Mass fear", // 41
  [CollectibleType.BOBS_ROTTEN_HEAD]: "Reusable ranged bomb", // 42
  // There is no `CollectibleType` with a value of 43.
  [CollectibleType.TELEPORT]: "Teleport!", // 44
  [CollectibleType.YUM_HEART]: "Reusable regeneration", // 45
  [CollectibleType.LUCKY_FOOT]: "Luck up", // 46
  [CollectibleType.DOCTORS_REMOTE]: "Reusable air strike", // 47
  [CollectibleType.CUPIDS_ARROW]: "Piercing shots", // 48
  [CollectibleType.SHOOP_DA_WHOOP]: "BLLLARRRRGGG!", // 49
  [CollectibleType.STEVEN]: "DMG up", // 50
  [CollectibleType.PENTAGRAM]: "DMG up", // 51
  [CollectibleType.DR_FETUS]: "???", // 52
  [CollectibleType.MAGNETO]: "Item snatcher", // 53
  [CollectibleType.TREASURE_MAP]: "Full visible map", // 54
  [CollectibleType.MOMS_EYE]: "Eye in the back of your head", // 55
  [CollectibleType.LEMON_MISHAP]: "Oops...", // 56
  [CollectibleType.DISTANT_ADMIRATION]: "Attack fly", // 57
  [CollectibleType.BOOK_OF_SHADOWS]: "Temporary invincibility", // 58
  [CollectibleType.BOOK_OF_BELIAL_BIRTHRIGHT]: "Temporary DMG up", // 59
  [CollectibleType.LADDER]: "Building bridges", // 60
  // There is no `CollectibleType` with a value of 61.
  [CollectibleType.CHARM_OF_THE_VAMPIRE]: "Kills heal", // 62
  [CollectibleType.BATTERY]: "Stores energy", // 63
  [CollectibleType.STEAM_SALE]: "50% off", // 64
  [CollectibleType.ANARCHIST_COOKBOOK]: "Summon bombs", // 65
  [CollectibleType.HOURGLASS]: "Temporary enemy slowdown", // 66
  [CollectibleType.SISTER_MAGGY]: "Friends 'till the end", // 67
  [CollectibleType.TECHNOLOGY]: "Laser tears", // 68
  [CollectibleType.CHOCOLATE_MILK]: "Charge shots", // 69
  [CollectibleType.GROWTH_HORMONES]: "Speed + DMG up", // 70
  [CollectibleType.MINI_MUSH]: "Speed + range up", // 71
  [CollectibleType.ROSARY]: "Tears + faith up", // 72
  [CollectibleType.CUBE_OF_MEAT]: "Gotta meat 'em all", // 73
  [CollectibleType.QUARTER]: "+25 coins", // 74
  [CollectibleType.PHD]: "Better pills", // 75
  [CollectibleType.XRAY_VISION]: "I've seen everything", // 76
  [CollectibleType.MY_LITTLE_UNICORN]: "Temporary badass", // 77
  [CollectibleType.BOOK_OF_REVELATIONS]: "Reusable soul protection", // 78
  [CollectibleType.MARK]: "DMG + speed up", // 79
  [CollectibleType.PACT]: "DMG + tears up", // 80
  [CollectibleType.DEAD_CAT]: "9 lives", // 81
  [CollectibleType.LORD_OF_THE_PIT]: "Demon wings", // 82
  [CollectibleType.NAIL]: "Temporary demon form", // 83
  [CollectibleType.WE_NEED_TO_GO_DEEPER]: "Reusable level skip", // 84
  [CollectibleType.DECK_OF_CARDS]: "Reusable card generator ", // 85
  [CollectibleType.MONSTROS_TOOTH]: "Summon Monstro", // 86
  [CollectibleType.LOKIS_HORNS]: "Cross tears", // 87
  [CollectibleType.LITTLE_CHUBBY]: "Attack buddy", // 88
  [CollectibleType.SPIDER_BITE]: "Slow effect", // 89
  [CollectibleType.SMALL_ROCK]: "DMG up", // 90
  [CollectibleType.SPELUNKER_HAT]: "See-through doors", // 91
  [CollectibleType.SUPER_BANDAGE]: "+2 hearts", // 92
  [CollectibleType.GAMEKID]: "Temporary Man-Pac", // 93
  [CollectibleType.SACK_OF_PENNIES]: "Gives money", // 94
  [CollectibleType.ROBO_BABY]: "Friends 'till the bbbbzzzt", // 95
  [CollectibleType.LITTLE_CHAD]: "Gives kisses", // 96
  [CollectibleType.BOOK_OF_SIN]: "Reusable item generator", // 97
  [CollectibleType.RELIC]: "Soul generator", // 98
  [CollectibleType.LITTLE_GISH]: "Sticky friend", // 99
  [CollectibleType.LITTLE_STEVEN]: "Psychic friend", // 100
  [CollectibleType.HALO]: "All stats up", // 101
  [CollectibleType.MOMS_BOTTLE_OF_PILLS]: "Reusable pill generator", // 102
  [CollectibleType.COMMON_COLD]: "Poison damage", // 103
  [CollectibleType.PARASITE]: "Split shot", // 104
  [CollectibleType.D6]: "Reroll your destiny", // 105
  [CollectibleType.MR_MEGA]: "Bigger boom", // 106
  [CollectibleType.PINKING_SHEARS]: "Cut and run", // 107
  [CollectibleType.WAFER]: "Damage resistance", // 108
  [CollectibleType.MONEY_EQUALS_POWER]: "$$$ = DMG", // 109
  [CollectibleType.MOMS_CONTACTS]: "Freeze effect", // 110
  [CollectibleType.BEAN]: "Toot on command", // 111
  [CollectibleType.GUARDIAN_ANGEL]: "Extra protection", // 112
  [CollectibleType.DEMON_BABY]: "Auto-turret friend", // 113
  [CollectibleType.MOMS_KNIFE]: "Stab stab stab", // 114
  [CollectibleType.OUIJA_BOARD]: "Spectral tears", // 115
  [CollectibleType.NINE_VOLT]: "Quicker charge", // 116
  [CollectibleType.DEAD_BIRD]: "Protective buddy", // 117
  [CollectibleType.BRIMSTONE]: "Blood laser barrage", // 118
  [CollectibleType.BLOOD_BAG]: "HP up", // 119
  [CollectibleType.ODD_MUSHROOM_THIN]: "Tears + speed up, DMG down", // 120
  [CollectibleType.ODD_MUSHROOM_LARGE]: "HP + DMG up, speed down", // 121
  [CollectibleType.WHORE_OF_BABYLON]: "Curse up", // 122
  [CollectibleType.MONSTER_MANUAL]: "Temporary buddy generator", // 123
  [CollectibleType.DEAD_SEA_SCROLLS]: "It's a mystery", // 124
  [CollectibleType.BOBBY_BOMB]: "Homing bombs", // 125
  [CollectibleType.RAZOR_BLADE]: "Feel my pain", // 126
  [CollectibleType.FORGET_ME_NOW]: "I don't remember...", // 127
  [CollectibleType.FOREVER_ALONE]: "Attack fly", // 128
  [CollectibleType.BUCKET_OF_LARD]: "HP up", // 129
  [CollectibleType.PONY]: "Flight + dash attack", // 130
  [CollectibleType.BOMB_BAG]: "Gives bombs", // 131
  [CollectibleType.LUMP_OF_COAL]: "My Xmas present", // 132
  [CollectibleType.GUPPYS_PAW]: "Soul converter", // 133
  [CollectibleType.GUPPYS_TAIL]: "Cursed?", // 134
  [CollectibleType.IV_BAG]: "Portable blood bank", // 135
  [CollectibleType.BEST_FRIEND]: "Friends 'till the end", // 136
  [CollectibleType.REMOTE_DETONATOR]: "Remote bomb detonation", // 137
  [CollectibleType.STIGMATA]: "DMG + HP up", // 138
  [CollectibleType.MOMS_PURSE]: "More trinket room", // 139
  [CollectibleType.BOBS_CURSE]: "+5 poison bombs", // 140
  [CollectibleType.PAGEANT_BOY]: "Ultimate grand supreme", // 141
  [CollectibleType.SCAPULAR]: "Pray for a miracle", // 142
  [CollectibleType.SPEED_BALL]: "Speed + shot speed up", // 143
  [CollectibleType.BUM_FRIEND]: "He's greedy", // 144
  [CollectibleType.GUPPYS_HEAD]: "Reusable fly hive", // 145
  [CollectibleType.PRAYER_CARD]: "Reusable eternity ", // 146
  [CollectibleType.NOTCHED_AXE]: "Rocks don't stand a chance", // 147
  [CollectibleType.INFESTATION]: "Fly revenge", // 148
  [CollectibleType.IPECAC]: "Explosive shots", // 149
  [CollectibleType.TOUGH_LOVE]: "Tooth shot", // 150
  [CollectibleType.MULLIGAN]: "They grow inside", // 151
  [CollectibleType.TECHNOLOGY_2]: "Extra laser", // 152
  [CollectibleType.MUTANT_SPIDER]: "Quad shot", // 153
  [CollectibleType.CHEMICAL_PEEL]: "DMG up", // 154
  [CollectibleType.PEEPER]: "Plop!", // 155
  [CollectibleType.HABIT]: "Item martyr", // 156
  [CollectibleType.BLOODY_LUST]: "RAGE!", // 157
  [CollectibleType.CRYSTAL_BALL]: "I see my future", // 158
  [CollectibleType.SPIRIT_OF_THE_NIGHT]: "Scary", // 159
  [CollectibleType.CRACK_THE_SKY]: "Holy white death", // 160
  [CollectibleType.ANKH]: "Eternal life?", // 161
  [CollectibleType.CELTIC_CROSS]: "Blessing of protection", // 162
  [CollectibleType.GHOST_BABY]: "Spectral buddy", // 163
  [CollectibleType.CANDLE]: "Reusable flames", // 164
  [CollectibleType.CAT_O_NINE_TAILS]: "Shot speed + damage up", // 165
  [CollectibleType.D20]: "Reroll the basics", // 166
  [CollectibleType.HARLEQUIN_BABY]: "Double shot buddy", // 167
  [CollectibleType.EPIC_FETUS]: "On-demand air strike", // 168
  [CollectibleType.POLYPHEMUS]: "Mega tears", // 169
  [CollectibleType.DADDY_LONGLEGS]: "Daddy's love", // 170
  [CollectibleType.SPIDER_BUTT]: "Mass enemy slowdown + damage", // 171
  [CollectibleType.SACRIFICIAL_DAGGER]: "My fate protects me", // 172
  [CollectibleType.MITRE]: "Blessing of purity", // 173
  [CollectibleType.RAINBOW_BABY]: "Random buddy", // 174
  [CollectibleType.DADS_KEY]: "Opens all doors...", // 175
  [CollectibleType.STEM_CELLS]: "HP + shot speed up", // 176
  [CollectibleType.PORTABLE_SLOT]: "Gamble 24/7", // 177
  [CollectibleType.HOLY_WATER]: "Splash!", // 178
  [CollectibleType.FATE]: "Flight eternal", // 179
  [CollectibleType.BLACK_BEAN]: "Toot on touch", // 180
  [CollectibleType.WHITE_PONY]: "Flight + holy death", // 181
  [CollectibleType.SACRED_HEART]: "Homing shots + DMG up", // 182
  [CollectibleType.TOOTH_PICKS]: "Tears + shot speed up", // 183
  [CollectibleType.HOLY_GRAIL]: "Flight + HP up", // 184
  [CollectibleType.DEAD_DOVE]: "Flight + spectral tears", // 185
  [CollectibleType.BLOOD_RIGHTS]: "Mass enemy damage at a cost", // 186
  [CollectibleType.GUPPYS_HAIRBALL]: "Swing it", // 187
  [CollectibleType.ABEL]: "Mirrored buddy", // 188
  [CollectibleType.SMB_SUPER_FAN]: "All stats up", // 189
  [CollectibleType.PYRO]: "99 bombs", // 190
  [CollectibleType.THREE_DOLLAR_BILL]: "Rainbow tears", // 191
  [CollectibleType.TELEPATHY_BOOK]: "Temporary psychic shot", // 192
  [CollectibleType.MEAT]: "DMG + HP up", // 193
  [CollectibleType.MAGIC_8_BALL]: "Shot speed up", // 194
  [CollectibleType.MOMS_COIN_PURSE]: "What's all this...?", // 195
  [CollectibleType.SQUEEZY]: "Tears up", // 196
  [CollectibleType.JESUS_JUICE]: "Damage + range up", // 197
  [CollectibleType.BOX]: "Stuff", // 198
  [CollectibleType.MOMS_KEY]: "Better chest loot +2 keys", // 199
  [CollectibleType.MOMS_EYESHADOW]: "Charm tears", // 200
  [CollectibleType.IRON_BAR]: "DMG up + concussive tears", // 201
  [CollectibleType.MIDAS_TOUCH]: "Golden touch", // 202
  [CollectibleType.HUMBLEING_BUNDLE]: "1+1 free 4Evar", // 203
  [CollectibleType.FANNY_PACK]: "Filled with goodies", // 204
  [CollectibleType.SHARP_PLUG]: "Infinite charge... at a cost", // 205
  [CollectibleType.GUILLOTINE]: "DMG + tears up. An out-of-body experience!", // 206
  [CollectibleType.BALL_OF_BANDAGES]: "Gotta lick 'em all!", // 207
  [CollectibleType.CHAMPION_BELT]: "DMG + challenge up", // 208
  [CollectibleType.BUTT_BOMBS]: "Toxic blast +5 bombs", // 209
  [CollectibleType.GNAWED_LEAF]: "Unbreakable", // 210
  [CollectibleType.SPIDERBABY]: "Spider revenge", // 211
  [CollectibleType.GUPPYS_COLLAR]: "Eternal life?", // 212
  [CollectibleType.LOST_CONTACT]: "Shielded tears", // 213
  [CollectibleType.ANEMIC]: "Toxic blood", // 214
  [CollectibleType.GOAT_HEAD]: "He accepts your offering", // 215
  [CollectibleType.CEREMONIAL_ROBES]: "DMG + evil up", // 216
  [CollectibleType.MOMS_WIG]: "You feel itchy...", // 217
  [CollectibleType.PLACENTA]: "Regeneration + HP up", // 218
  [CollectibleType.OLD_BANDAGE]: "HP up", // 219
  [CollectibleType.SAD_BOMBS]: "Tear blasts +5 bombs", // 220
  [CollectibleType.RUBBER_CEMENT]: "Bouncing tears", // 221
  [CollectibleType.ANTI_GRAVITY]: "Anti-gravity tears + tears up", // 222
  [CollectibleType.PYROMANIAC]: "It hurts so good +5 bombs", // 223
  [CollectibleType.CRICKETS_BODY]: "Bursting shots + tears up", // 224
  [CollectibleType.GIMPY]: "Sweet suffering", // 225
  [CollectibleType.BLACK_LOTUS]: "HP up x3", // 226
  [CollectibleType.PIGGY_BANK]: "My life savings", // 227
  [CollectibleType.MOMS_PERFUME]: "Fear shot + tears up", // 228
  [CollectibleType.MONSTROS_LUNG]: "Charged burst attack", // 229
  [CollectibleType.ABADDON]: "Evil + DMG up + fear shot", // 230
  [CollectibleType.BALL_OF_TAR]: "Sticky feet...", // 231
  [CollectibleType.STOP_WATCH]: "Let's slow this down a bit...", // 232
  [CollectibleType.TINY_PLANET]: "Orbiting tears + range up", // 233
  [CollectibleType.INFESTATION_2]: "Infestation shot", // 234
  // There is no `CollectibleType` with a value of 235.
  [CollectibleType.E_COLI]: "Turdy touch", // 236
  [CollectibleType.DEATHS_TOUCH]: "Piercing shots + DMG up", // 237
  [CollectibleType.KEY_PIECE_1]: "???", // 238
  [CollectibleType.KEY_PIECE_2]: "???", // 239
  [CollectibleType.EXPERIMENTAL_TREATMENT]: "Some stats up, some stats down", // 240
  [CollectibleType.CONTRACT_FROM_BELOW]: "Wealth... but at what cost?", // 241
  [CollectibleType.INFAMY]: "Blocks damage... sometimes", // 242
  [CollectibleType.TRINITY_SHIELD]: "You feel guarded", // 243
  [CollectibleType.TECH_5]: "It's still being tested...", // 244
  [CollectibleType.TWENTY_TWENTY]: "Double shot", // 245
  [CollectibleType.BLUE_MAP]: "Secrets", // 246
  [CollectibleType.BFFS]: "Your friends rule", // 247
  [CollectibleType.HIVE_MIND]: "Giant spiders and flies", // 248
  [CollectibleType.THERES_OPTIONS]: "More options", // 249
  [CollectibleType.BOGO_BOMBS]: "1+1 BOOM!", // 250
  [CollectibleType.STARTER_DECK]: "Extra card room", // 251
  [CollectibleType.LITTLE_BAGGY]: "Extra pill room", // 252
  [CollectibleType.MAGIC_SCAB]: "HP + luck up", // 253
  [CollectibleType.BLOOD_CLOT]: "DMG + range up", // 254
  [CollectibleType.SCREW]: "Tears + shot speed up", // 255
  [CollectibleType.HOT_BOMBS]: "Burning blast +5 bombs", // 256
  [CollectibleType.FIRE_MIND]: "Flaming tears", // 257
  [CollectibleType.MISSING_NO]: "Syntax error", // 258
  [CollectibleType.DARK_MATTER]: "DMG up + fear shot", // 259
  [CollectibleType.BLACK_CANDLE]: "Curse immunity + evil up", // 260
  [CollectibleType.PROPTOSIS]: "Short range mega tears", // 261
  [CollectibleType.MISSING_PAGE_2]: "Evil up. Your enemies will pay!", // 262
  [CollectibleType.CLEAR_RUNE]: "Rune mimic", // 263
  [CollectibleType.SMART_FLY]: "Revenge fly", // 264
  [CollectibleType.DRY_BABY]: "Immortal friend", // 265
  [CollectibleType.JUICY_SACK]: "Sticky babies", // 266
  [CollectibleType.ROBO_BABY_2]: "We worked out all the kinks", // 267
  [CollectibleType.ROTTEN_BABY]: "Infested friend", // 268
  [CollectibleType.HEADLESS_BABY]: "Bloody friend", // 269
  [CollectibleType.LEECH]: "Blood sucker", // 270
  [CollectibleType.MYSTERY_SACK]: "?", // 271
  [CollectibleType.BBF]: "Big Beautiful Fly", // 272
  [CollectibleType.BOBS_BRAIN]: "Explosive thoughts", // 273
  [CollectibleType.BEST_BUD]: "Sworn protector", // 274
  [CollectibleType.LIL_BRIMSTONE]: "Evil friend", // 275
  [CollectibleType.ISAACS_HEART]: "Protect it", // 276
  [CollectibleType.LIL_HAUNT]: "Fear him", // 277
  [CollectibleType.DARK_BUM]: "He wants to take your life", // 278
  [CollectibleType.BIG_FAN]: "Fat protector", // 279
  [CollectibleType.SISSY_LONGLEGS]: "She loves you", // 280
  [CollectibleType.PUNCHING_BAG]: "Scape goat", // 281
  [CollectibleType.HOW_TO_JUMP]: "It's time you learned how", // 282
  [CollectibleType.D100]: "REEROLLLLL!", // 283
  [CollectibleType.D4]: "Reroll into something else", // 284
  [CollectibleType.D10]: "Reroll enemies", // 285
  [CollectibleType.BLANK_CARD]: "Card mimic", // 286
  [CollectibleType.BOOK_OF_SECRETS]: "Tome of knowledge", // 287
  [CollectibleType.BOX_OF_SPIDERS]: "It's a box of spiders", // 288
  [CollectibleType.RED_CANDLE]: "Flame on", // 289
  [CollectibleType.JAR]: "Save your life", // 290
  [CollectibleType.FLUSH]: "...", // 291
  [CollectibleType.SATANIC_BIBLE]: "Reusable evil... but at what cost?", // 292
  [CollectibleType.HEAD_OF_KRAMPUS]: "Krampus rage", // 293
  [CollectibleType.BUTTER_BEAN]: "Reusable knock-back", // 294
  [CollectibleType.MAGIC_FINGERS]: "Pay to win", // 295
  [CollectibleType.CONVERTER]: "Convert your soul", // 296
  [CollectibleType.BLUE_BOX]: "? ?", // 297
  [CollectibleType.UNICORN_STUMP]: "You feel stumped", // 298
  [CollectibleType.TAURUS]: "Speed down + rage is building", // 299
  [CollectibleType.ARIES]: "Ramming speed", // 300
  [CollectibleType.CANCER]: "HP up + you feel protected", // 301
  [CollectibleType.LEO]: "Stompy", // 302
  [CollectibleType.VIRGO]: "You feel refreshed and protected", // 303
  [CollectibleType.LIBRA]: "You feel balanced", // 304
  [CollectibleType.SCORPIO]: "Poison tears", // 305
  [CollectibleType.SAGITTARIUS]: "Piercing shots + speed up", // 306
  [CollectibleType.CAPRICORN]: "All stats up", // 307
  [CollectibleType.AQUARIUS]: "Trail of tears", // 308
  [CollectibleType.PISCES]: "Tears up + knock-back shot", // 309
  [CollectibleType.EVES_MASCARA]: "DMG up, tears + shot speed down", // 310
  [CollectibleType.JUDAS_SHADOW]: "Sweet revenge", // 311
  [CollectibleType.MAGGYS_BOW]: "HP up + you feel healthy", // 312
  [CollectibleType.HOLY_MANTLE]: "Holy shield", // 313
  [CollectibleType.THUNDER_THIGHS]: "HP up + speed down + you feel stompy", // 314
  [CollectibleType.STRANGE_ATTRACTOR]: "Magnetic tears", // 315
  [CollectibleType.CURSED_EYE]: "Cursed charge shot", // 316
  [CollectibleType.MYSTERIOUS_LIQUID]: "Toxic splash damage", // 317
  [CollectibleType.GEMINI]: "Conjoined friend", // 318
  [CollectibleType.CAINS_OTHER_EYE]: "Near-sighted friend", // 319
  [CollectibleType.BLUE_BABYS_ONLY_FRIEND]: "Controlled friend", // 320
  [CollectibleType.SAMSONS_CHAINS]: "The ol' ball and chain", // 321
  [CollectibleType.MONGO_BABY]: "Mongo friend", // 322
  [CollectibleType.ISAACS_TEARS]: "Collected tears", // 323
  [CollectibleType.UNDEFINED]: "Undefined", // 324
  [CollectibleType.SCISSORS]: "Lose your head", // 325
  [CollectibleType.BREATH_OF_LIFE]: "Invincibility at a cost", // 326
  [CollectibleType.POLAROID]: "Fate chosen", // 327
  [CollectibleType.NEGATIVE]: "Fate chosen", // 328
  [CollectibleType.LUDOVICO_TECHNIQUE]: "Controlled tears", // 329
  [CollectibleType.SOY_MILK]: "DMG down + tears way up", // 330
  [CollectibleType.GODHEAD]: "God tears", // 331
  [CollectibleType.LAZARUS_RAGS]: "Eternal life?", // 332
  [CollectibleType.MIND]: "I know all", // 333
  [CollectibleType.BODY]: "I feel all", // 334
  [CollectibleType.SOUL]: "I am all", // 335
  [CollectibleType.DEAD_ONION]: "Toxic aura tears", // 336
  [CollectibleType.BROKEN_WATCH]: "I think it's broken", // 337
  [CollectibleType.BOOMERANG]: "It will never leave you", // 338
  [CollectibleType.SAFETY_PIN]: "Evil + range + shot speed up", // 339
  [CollectibleType.CAFFEINE_PILL]: "Speed up + size down", // 340
  [CollectibleType.TORN_PHOTO]: "Tears + shot speed up", // 341
  [CollectibleType.BLUE_CAP]: "HP + tears up + shot speed down", // 342
  [CollectibleType.LATCH_KEY]: "Luck up", // 343
  [CollectibleType.MATCH_BOOK]: "Evil up", // 344
  [CollectibleType.SYNTHOIL]: "DMG + range up", // 345
  [CollectibleType.SNACK]: "HP up", // 346
  [CollectibleType.DIPLOPIA]: "Double item vision", // 347
  [CollectibleType.PLACEBO]: "Pill mimic", // 348
  [CollectibleType.WOODEN_NICKEL]: "Flip a coin", // 349
  [CollectibleType.TOXIC_SHOCK]: "Mass poison", // 350
  [CollectibleType.MEGA_BEAN]: "Giga fart!", // 351
  [CollectibleType.GLASS_CANNON]: "Be gentle...", // 352
  [CollectibleType.BOMBER_BOY]: "Cross blast + 5 bombs", // 353
  [CollectibleType.CRACK_JACKS]: "HP up. Don't swallow the prize!", // 354
  [CollectibleType.MOMS_PEARLS]: "Range + luck up", // 355
  [CollectibleType.CAR_BATTERY]: "Active power up", // 356
  [CollectibleType.BOX_OF_FRIENDS]: "Double your friends", // 357
  [CollectibleType.WIZ]: "Double wiz shot!", // 358
  [CollectibleType.EIGHT_INCH_NAILS]: "Stick it to 'em!", // 359
  [CollectibleType.INCUBUS]: "Dark friend", // 360
  [CollectibleType.FATES_REWARD]: "Your fate beside you", // 361
  [CollectibleType.LIL_CHEST]: "What's in the box?", // 362
  [CollectibleType.SWORN_PROTECTOR]: "Protective friend", // 363
  [CollectibleType.FRIEND_ZONE]: "Friendly fly", // 364
  [CollectibleType.LOST_FLY]: "Lost protector", // 365
  [CollectibleType.SCATTER_BOMBS]: "We put bombs in your bombs!", // 366
  [CollectibleType.STICKY_BOMBS]: "Egg sack bombs!", // 367
  [CollectibleType.EPIPHORA]: "Intensifying tears", // 368
  [CollectibleType.CONTINUUM]: "Transcendent tears", // 369
  [CollectibleType.MR_DOLLY]: "Range + tears up", // 370
  [CollectibleType.CURSE_OF_THE_TOWER]: "Embrace chaos", // 371
  [CollectibleType.CHARGED_BABY]: "Bbbzzzzzt! ", // 372
  [CollectibleType.DEAD_EYE]: "Accuracy brings power", // 373
  [CollectibleType.HOLY_LIGHT]: "Holy death shot", // 374
  [CollectibleType.HOST_HAT]: "Blast resistance", // 375
  [CollectibleType.RESTOCK]: "Never ending stores!", // 376
  [CollectibleType.BURSTING_SACK]: "Spider love", // 377
  [CollectibleType.NUMBER_TWO]: "Uh oh...", // 378
  [CollectibleType.PUPULA_DUPLEX]: "Wide shot", // 379
  [CollectibleType.PAY_TO_PLAY]: "Money talks", // 380
  [CollectibleType.EDENS_BLESSING]: "Tears up + your future shines brighter", // 381
  [CollectibleType.FRIEND_BALL]: "Gotta fetch 'em all!", // 382
  [CollectibleType.TEAR_DETONATOR]: "Remote tear detonation", // 383
  [CollectibleType.LIL_GURDY]: "A gurd of your own!", // 384
  [CollectibleType.BUMBO]: "Bumbo want coin!", // 385
  [CollectibleType.D12]: "Rerolls rocks", // 386
  [CollectibleType.CENSER]: "Peace be with you", // 387
  [CollectibleType.KEY_BUM]: "He wants your keys!", // 388
  [CollectibleType.RUNE_BAG]: "Rune generator", // 389
  [CollectibleType.SERAPHIM]: "Sworn friend", // 390
  [CollectibleType.BETRAYAL]: "Turn your enemy", // 391
  [CollectibleType.ZODIAC]: "The heavens will change you", // 392
  [CollectibleType.SERPENTS_KISS]: "The kiss of death", // 393
  [CollectibleType.MARKED]: "Directed tears", // 394
  [CollectibleType.TECH_X]: "Laser ring tears", // 395
  [CollectibleType.VENTRICLE_RAZOR]: "Short cutter", // 396
  [CollectibleType.TRACTOR_BEAM]: "Controlled tears", // 397
  [CollectibleType.GODS_FLESH]: "Shrink shot!", // 398
  [CollectibleType.MAW_OF_THE_VOID]: "Consume thy enemy!", // 399
  [CollectibleType.SPEAR_OF_DESTINY]: "Your destiny", // 400
  [CollectibleType.EXPLOSIVO]: "Sticky bomb shot", // 401
  [CollectibleType.CHAOS]: "!!!", // 402
  [CollectibleType.SPIDER_MOD]: "Mod buddy", // 403
  [CollectibleType.FARTING_BABY]: "He farts", // 404
  [CollectibleType.GB_BUG]: "Double tap glitch", // 405
  [CollectibleType.D8]: "Reroll stats", // 406
  [CollectibleType.PURITY]: "Aura stat boost", // 407
  [CollectibleType.ATHAME]: "Call to the void", // 408
  [CollectibleType.EMPTY_VESSEL]: "I reward an empty vessel", // 409
  [CollectibleType.EVIL_EYE]: "Eye shot", // 410
  [CollectibleType.LUSTY_BLOOD]: "Their blood brings rage!", // 411
  [CollectibleType.CAMBION_CONCEPTION]: "Feed them hate", // 412
  [CollectibleType.IMMACULATE_CONCEPTION]: "Feed them love", // 413
  [CollectibleType.MORE_OPTIONS]: "There's options", // 414
  [CollectibleType.CROWN_OF_LIGHT]: "The untainted gain power", // 415
  [CollectibleType.DEEP_POCKETS]: "More money!", // 416
  [CollectibleType.SUCCUBUS]: "Damage booster", // 417
  [CollectibleType.FRUIT_CAKE]: "Rainbow effects!", // 418
  [CollectibleType.TELEPORT_2]: "I-Teleport!", // 419
  [CollectibleType.BLACK_POWDER]: "Spin the black circle!", // 420
  [CollectibleType.KIDNEY_BEAN]: "Love toots", // 421
  [CollectibleType.GLOWING_HOUR_GLASS]: "Turn back time", // 422
  [CollectibleType.CIRCLE_OF_PROTECTION]: "Protect me from myself", // 423
  [CollectibleType.SACK_HEAD]: "More sacks!", // 424
  [CollectibleType.NIGHT_LIGHT]: "Scared of the dark?", // 425
  [CollectibleType.OBSESSED_FAN]: "Follows my every move...", // 426
  [CollectibleType.MINE_CRAFTER]: "Booom!", // 427
  [CollectibleType.PJS]: "You feel cozy", // 428
  [CollectibleType.HEAD_OF_THE_KEEPER]: "Penny tears", // 429
  [CollectibleType.PAPA_FLY]: "Turret follower", // 430
  [CollectibleType.MULTIDIMENSIONAL_BABY]: "ydduB Buddy", // 431
  [CollectibleType.GLITTER_BOMBS]: "Prize bombs", // 432
  [CollectibleType.MY_SHADOW]: "Me! And my shaaaadow!", // 433
  [CollectibleType.JAR_OF_FLIES]: "Bug catcher", // 434
  [CollectibleType.LIL_LOKI]: "4-way buddy!", // 435
  [CollectibleType.MILK]: "Don't cry over it...", // 436
  [CollectibleType.D7]: "Roll again", // 437
  [CollectibleType.BINKY]: "Tears up", // 438
  [CollectibleType.MOMS_BOX]: "What's inside?", // 439
  [CollectibleType.KIDNEY_STONE]: "Matt's kidney stone", // 440
  [CollectibleType.MEGA_BLAST]: "Laser breath", // 441
  [CollectibleType.DARK_PRINCES_CROWN]: "Loss is power", // 442
  [CollectibleType.APPLE]: "Trick or treat?", // 443
  [CollectibleType.LEAD_PENCIL]: "He's a bleeder!", // 444
  [CollectibleType.DOG_TOOTH]: "Bark at the moon!", // 445
  [CollectibleType.DEAD_TOOTH]: "Toxic breath", // 446
  [CollectibleType.LINGER_BEAN]: "Crying makes me toot", // 447
  [CollectibleType.SHARD_OF_GLASS]: "Blood and guts!", // 448
  [CollectibleType.METAL_PLATE]: "It itches...", // 449
  [CollectibleType.EYE_OF_GREED]: "Gold tears!", // 450
  [CollectibleType.TAROT_CLOTH]: "I see the future", // 451
  [CollectibleType.VARICOSE_VEINS]: "I'm leaking...", // 452
  [CollectibleType.COMPOUND_FRACTURE]: "Bone tears!", // 453
  [CollectibleType.POLYDACTYLY]: "Hold me!", // 454
  [CollectibleType.DADS_LOST_COIN]: "I remember this...", // 455
  [CollectibleType.MIDNIGHT_SNACK]: "HP up", // 456
  [CollectibleType.CONE_HEAD]: "Hard headed!", // 457
  [CollectibleType.BELLY_BUTTON]: "What's in there?", // 458
  [CollectibleType.SINUS_INFECTION]: "Booger tears!", // 459
  [CollectibleType.GLAUCOMA]: "Blind tears!", // 460
  [CollectibleType.PARASITOID]: "Egg tears!", // 461
  [CollectibleType.EYE_OF_BELIAL]: "Possessed tears!", // 462
  [CollectibleType.SULFURIC_ACID]: "Acid tears!", // 463
  [CollectibleType.GLYPH_OF_BALANCE]: "A gift from above", // 464
  [CollectibleType.ANALOG_STICK]: "360 tears!", // 465
  [CollectibleType.CONTAGION]: "Outbreak!", // 466
  [CollectibleType.FINGER]: "Watch where you point that!", // 467
  [CollectibleType.SHADE]: "It follows", // 468
  [CollectibleType.DEPRESSION]: ":(", // 469
  [CollectibleType.HUSHY]: "Lil hush!", // 470
  [CollectibleType.LIL_MONSTRO]: "Ain't he cute?", // 471
  [CollectibleType.KING_BABY]: "Hail to the king baby", // 472
  [CollectibleType.BIG_CHUBBY]: "Chub chub", // 473
  [CollectibleType.BROKEN_GLASS_CANNON]: "You broke it!", // 474
  [CollectibleType.PLAN_C]: "My last resort", // 475
  [CollectibleType.D1]: "What will it be?", // 476
  [CollectibleType.VOID]: "Consume", // 477
  [CollectibleType.PAUSE]: "Stop!", // 478
  [CollectibleType.SMELTER]: "Trinket melter!", // 479
  [CollectibleType.COMPOST]: "Gain more friends!", // 480
  [CollectibleType.DATAMINER]: "109", // 481
  [CollectibleType.CLICKER]: "Change", // 482
  [CollectibleType.MAMA_MEGA]: "BOOOOOOOOOM!", // 483
  [CollectibleType.WAIT_WHAT]: "I can't believe it's not butter bean!", // 484
  [CollectibleType.CROOKED_PENNY]: "50/50", // 485
  [CollectibleType.DULL_RAZOR]: "I feel numb...", // 486
  [CollectibleType.POTATO_PEELER]: "A pound of flesh...", // 487
  [CollectibleType.METRONOME]: "Waggles a finger", // 488
  [CollectibleType.D_INFINITY]: "Reroll forever", // 489
  [CollectibleType.EDENS_SOUL]: "...", // 490
  [CollectibleType.ACID_BABY]: "Pills pills pills!", // 491
  [CollectibleType.YO_LISTEN]: "Yo listen!", // 492
  [CollectibleType.ADRENALINE]: "Panic = power", // 493
  [CollectibleType.JACOBS_LADDER]: "Electric tears", // 494
  [CollectibleType.GHOST_PEPPER]: "Flame tears", // 495
  [CollectibleType.EUTHANASIA]: "Needle shot", // 496
  [CollectibleType.CAMO_UNDIES]: "Camo kid", // 497
  [CollectibleType.DUALITY]: "You feel very balanced", // 498
  [CollectibleType.EUCHARIST]: "Peace be with you", // 499
  [CollectibleType.SACK_OF_SACKS]: "Gives sacks", // 500
  [CollectibleType.GREEDS_GULLET]: "Money = health!", // 501
  [CollectibleType.LARGE_ZIT]: "Creep shots", // 502
  [CollectibleType.LITTLE_HORN]: "Big brother is watching", // 503
  [CollectibleType.BROWN_NUGGET]: "Friendly fly", // 504
  [CollectibleType.POKE_GO]: "Gotta catch em...", // 505
  [CollectibleType.BACKSTABBER]: "Watch your back!", // 506
  [CollectibleType.SHARP_STRAW]: "More blood!", // 507
  [CollectibleType.MOMS_RAZOR]: "It's sharp!", // 508
  [CollectibleType.BLOODSHOT_EYE]: "Bloody friend", // 509
  [CollectibleType.DELIRIOUS]: "Unleash the power!", // 510
  [CollectibleType.ANGRY_FLY]: "He's violent", // 511
  [CollectibleType.BLACK_HOLE]: "Nothing can escape", // 512
  [CollectibleType.BOZO]: "Party time!", // 513
  [CollectibleType.BROKEN_MODEM]: "Lag!", // 514
  [CollectibleType.MYSTERY_GIFT]: "Wrapped up nice for you!", // 515
  [CollectibleType.SPRINKLER]: "Sprinkles.", // 516
  [CollectibleType.FAST_BOMBS]: "Rapid bomb drops", // 517
  [CollectibleType.BUDDY_IN_A_BOX]: "What could it be?!", // 518
  [CollectibleType.LIL_DELIRIUM]: "Delirious friend", // 519
  [CollectibleType.JUMPER_CABLES]: "Bloody recharge", // 520
  [CollectibleType.COUPON]: "Allow 6 weeks for delivery", // 521
  [CollectibleType.TELEKINESIS]: "Power of the mind", // 522
  [CollectibleType.MOVING_BOX]: "Pack and unpack", // 523
  [CollectibleType.TECHNOLOGY_ZERO]: "Static tears", // 524
  [CollectibleType.LEPROSY]: "You're tearing me apart!", // 525
  [CollectibleType.SEVEN_SEALS]: "Lil harbingers!", // 526
  [CollectibleType.MR_ME]: "Caaan do!", // 527
  [CollectibleType.ANGELIC_PRISM]: "Eclipsed by the moon", // 528
  [CollectibleType.POP]: "Eyeball tears", // 529
  [CollectibleType.DEATHS_LIST]: "Just hope you're not next...", // 530
  [CollectibleType.HAEMOLACRIA]: "I'm seeing red...", // 531
  [CollectibleType.LACHRYPHAGY]: "Feed them!", // 532
  [CollectibleType.TRISAGION]: "Smite thy enemy", // 533
  [CollectibleType.SCHOOLBAG]: "Extra active item room", // 534
  [CollectibleType.BLANKET]: "You feel safe", // 535
  [CollectibleType.SACRIFICIAL_ALTAR]: "He demands a sacrifice", // 536
  [CollectibleType.LIL_SPEWER]: "Puking buddy", // 537
  [CollectibleType.MARBLES]: "Choking hazard", // 538
  [CollectibleType.MYSTERY_EGG]: "Sacrificial insemination", // 539
  [CollectibleType.FLAT_STONE]: "Skipping tears", // 540
  [CollectibleType.MARROW]: "HP up?", // 541
  [CollectibleType.SLIPPED_RIB]: "Projectile shield", // 542
  [CollectibleType.HALLOWED_GROUND]: "Portable sanctuary", // 543
  [CollectibleType.POINTY_RIB]: "Stabbing time", // 544
  [CollectibleType.BOOK_OF_THE_DEAD]: "Rise from the grave", // 545
  [CollectibleType.DADS_RING]: "Father's blessing", // 546
  [CollectibleType.DIVORCE_PAPERS]: "Tears up + you feel empty", // 547
  [CollectibleType.JAW_BONE]: "Fetch!", // 548
  [CollectibleType.BRITTLE_BONES]: "Everything hurts", // 549
  [CollectibleType.BROKEN_SHOVEL_1]: "It feels cursed", // 550
  [CollectibleType.BROKEN_SHOVEL_2]: "It feels cursed", // 551
  [CollectibleType.MOMS_SHOVEL]: "Lost but not forgotten", // 552
  [CollectibleType.MUCORMYCOSIS]: "Spore shot", // 553
  [CollectibleType.TWO_SPOOKY]: "4me", // 554
  [CollectibleType.GOLDEN_RAZOR]: "Pain from gain", // 555
  [CollectibleType.SULFUR]: "Temporary demon form", // 556
  [CollectibleType.FORTUNE_COOKIE]: "Reusable fortunes", // 557
  [CollectibleType.EYE_SORE]: "More eyes", // 558
  [CollectibleType.ONE_HUNDRED_TWENTY_VOLT]: "Zap!", // 559
  [CollectibleType.IT_HURTS]: "No it doesn't...", // 560
  [CollectibleType.ALMOND_MILK]: "DMG down + tears up + you feel nutty", // 561
  [CollectibleType.ROCK_BOTTOM]: "It's only up from there", // 562
  [CollectibleType.NANCY_BOMBS]: "Random blast +5 bombs", // 563
  [CollectibleType.BAR_OF_SOAP]: "Tears + shot speed up", // 564
  [CollectibleType.BLOOD_PUPPY]: "What a cute little thing!", // 565
  [CollectibleType.DREAM_CATCHER]: "Sweet dreams", // 566
  [CollectibleType.PASCHAL_CANDLE]: "Keep the flame burning", // 567
  [CollectibleType.DIVINE_INTERVENTION]: "Double tap shield", // 568
  [CollectibleType.BLOOD_OATH]: "Bleed me dry", // 569
  [CollectibleType.PLAYDOUGH_COOKIE]: "Tasty rainbow", // 570
  [CollectibleType.ORPHAN_SOCKS]: "Speed up + your feet feel stronger", // 571
  [CollectibleType.EYE_OF_THE_OCCULT]: "DMG up + range up + controlled tears", // 572
  [CollectibleType.IMMACULATE_HEART]: "Halo of tears", // 573
  [CollectibleType.MONSTRANCE]: "Purifying light", // 574
  [CollectibleType.INTRUDER]: "Invasive friend", // 575
  [CollectibleType.DIRTY_MIND]: "Filthy friends", // 576
  [CollectibleType.DAMOCLES]: "A king's fortune... but at what cost?", // 577
  [CollectibleType.FREE_LEMONADE]: "Party time!", // 578
  [CollectibleType.SPIRIT_SWORD]: "Divine blade", // 579
  [CollectibleType.RED_KEY]: "Explore the other side", // 580
  [CollectibleType.PSY_FLY]: "Flamboyant protector", // 581
  [CollectibleType.WAVY_CAP]: "Tears up. A mind changing experience!", // 582
  [CollectibleType.ROCKET_IN_A_JAR]: "Rocket propulsion +5 bombs", // 583
  [CollectibleType.BOOK_OF_VIRTUES]: "Spiritual companionship", // 584
  [CollectibleType.ALABASTER_BOX]: "A sacred offering", // 585
  [CollectibleType.STAIRWAY]: "May you get what you came for", // 586
  // There is no `CollectibleType` with a value of 587.
  [CollectibleType.SOL]: "Radiant victory", // 588
  [CollectibleType.LUNA]: "The moon's blessing shines upon you", // 589
  [CollectibleType.MERCURIUS]: "Speed up + you feel elusive", // 590
  [CollectibleType.VENUS]: "HP up + you feel pretty", // 591
  [CollectibleType.TERRA]: "Born to rock", // 592
  [CollectibleType.MARS]: "Double tap dash", // 593
  [CollectibleType.JUPITER]: "You're a gas giant!", // 594
  [CollectibleType.SATURNUS]: "Ring of tears", // 595
  [CollectibleType.URANUS]: "Ice tears", // 596
  [CollectibleType.NEPTUNUS]: "Open the floodgates", // 597
  [CollectibleType.PLUTO]: "Size down", // 598
  [CollectibleType.VOODOO_HEAD]: "Extra curse rooms", // 599
  [CollectibleType.EYE_DROPS]: "Tears up", // 600
  [CollectibleType.ACT_OF_CONTRITION]: "Tears up, you feel forgiven", // 601
  [CollectibleType.MEMBER_CARD]: "Exclusive access!", // 602
  [CollectibleType.BATTERY_PACK]: "Instant energy!", // 603
  [CollectibleType.MOMS_BRACELET]: "Mother's strength", // 604
  [CollectibleType.SCOOPER]: "Plop!", // 605
  [CollectibleType.OCULAR_RIFT]: "Stare into the abyss", // 606
  [CollectibleType.BOILED_BABY]: "Messy friend", // 607
  [CollectibleType.FREEZER_BABY]: "Iced iced baby", // 608
  [CollectibleType.ETERNAL_D6]: "???", // 609
  [CollectibleType.BIRD_CAGE]: "Fat buddy", // 610
  [CollectibleType.LARYNX]: "Hear my pain", // 611
  [CollectibleType.LOST_SOUL]: "Protect him", // 612
  // There is no `CollectibleType` with a value of 613.
  [CollectibleType.BLOOD_BOMBS]: "Bloody blast + HP up", // 614
  [CollectibleType.LIL_DUMPY]: "Puffy buddy", // 615
  [CollectibleType.BIRDS_EYE]: "It burns", // 616
  [CollectibleType.LODESTONE]: "Magnetizing tears", // 617
  [CollectibleType.ROTTEN_TOMATO]: "Delicious!", // 618
  [CollectibleType.BIRTHRIGHT]: "???", // 619
  // There is no `CollectibleType` with a value of 620.
  [CollectibleType.RED_STEW]: "Full HP + temporary DMG up", // 621
  [CollectibleType.GENESIS]: "In the beginning", // 622
  [CollectibleType.SHARP_KEY]: "Open your enemies", // 623
  [CollectibleType.BOOSTER_PACK]: "Collect them all!", // 624
  [CollectibleType.MEGA_MUSH]: "I'm a big boy now!", // 625
  [CollectibleType.KNIFE_PIECE_1]: "???", // 626
  [CollectibleType.KNIFE_PIECE_2]: "???", // 627
  [CollectibleType.DEATH_CERTIFICATE]: "Where am I?", // 628
  [CollectibleType.BOT_FLY]: "Defense drone", // 629
  // There is no `CollectibleType` with a value of 630.
  [CollectibleType.MEAT_CLEAVER]: "Slice but no dice", // 631
  [CollectibleType.EVIL_CHARM]: "Luck up + you feel protected", // 632
  [CollectibleType.DOGMA]: "Ascended", // 633
  [CollectibleType.PURGATORY]: "Help from beyond", // 634
  [CollectibleType.STITCHES]: "Bait and switch", // 635
  [CollectibleType.R_KEY]: "Time to start over", // 636
  [CollectibleType.KNOCKOUT_DROPS]: "They pack a punch!", // 637
  [CollectibleType.ERASER]: "Erase thy enemy", // 638
  [CollectibleType.YUCK_HEART]: "Gross!", // 639
  [CollectibleType.URN_OF_SOULS]: "Unleash their sorrow", // 640
  [CollectibleType.AKELDAMA]: "Spill your guts", // 641
  [CollectibleType.MAGIC_SKIN]: "All your desires fulfilled", // 642
  [CollectibleType.REVELATION]: "Awaken your faith", // 643
  [CollectibleType.CONSOLATION_PRIZE]: "+1 to lowest stat", // 644
  [CollectibleType.TINYTOMA]: "Itching for revenge", // 645
  [CollectibleType.BRIMSTONE_BOMBS]: "Demon blast +5 bombs", // 646
  [CollectibleType.FOUR_FIVE_VOLT]: "Beat the juice out of them!", // 647
  // There is no `CollectibleType` with a value of 648.
  [CollectibleType.FRUITY_PLUM]: "Bouncy friend", // 649
  [CollectibleType.PLUM_FLUTE]: "Play time!", // 650
  [CollectibleType.STAR_OF_BETHLEHEM]: "Follow the light", // 651
  [CollectibleType.CUBE_BABY]: "Kick it!", // 652
  [CollectibleType.VADE_RETRO]: "Begone!", // 653
  [CollectibleType.FALSE_PHD]: "Worse pills + evil up", // 654
  [CollectibleType.SPIN_TO_WIN]: "Let it rip!", // 655
  [CollectibleType.DAMOCLES_PASSIVE]: "A king's fortune... but at what cost?", // 656
  [CollectibleType.VASCULITIS]: "Clogged enemies", // 657
  [CollectibleType.GIANT_CELL]: "Micro friends", // 658
  [CollectibleType.TROPICAMIDE]: "Tear size + range up", // 659
  [CollectibleType.CARD_READING]: "A link to your future", // 660
  [CollectibleType.QUINTS]: "They lurk inside", // 661
  // There is no `CollectibleType` with a value of 662.
  [CollectibleType.TOOTH_AND_NAIL]: "You feel prickly", // 663
  [CollectibleType.BINGE_EATER]: "All you can eat", // 664
  [CollectibleType.GUPPYS_EYE]: "An eye for secrets", // 665
  // There is no `CollectibleType` with a value of 666.
  [CollectibleType.STRAWMAN]: "A helping hand", // 667
  [CollectibleType.DADS_NOTE]: "...", // 668
  [CollectibleType.SAUSAGE]: "All stats up", // 669
  [CollectibleType.OPTIONS]: "There might be options", // 670
  [CollectibleType.CANDY_HEART]: "Power of love", // 671
  [CollectibleType.POUND_OF_FLESH]: "Blood money", // 672
  [CollectibleType.REDEMPTION]: "Deliver me from evil", // 673
  [CollectibleType.SPIRIT_SHACKLES]: "Unfinished business", // 674
  [CollectibleType.CRACKED_ORB]: "Shards of knowledge", // 675
  [CollectibleType.EMPTY_HEART]: "It multiplies", // 676
  [CollectibleType.ASTRAL_PROJECTION]: "The true out-of-body experience!", // 677
  [CollectibleType.C_SECTION]: "Fetus shots", // 678
  [CollectibleType.LIL_ABADDON]: "Abyssal friend", // 679
  [CollectibleType.MONTEZUMAS_REVENGE]: "Oh no...", // 680
  [CollectibleType.LIL_PORTAL]: "It hungers", // 681
  [CollectibleType.WORM_FRIEND]: "Clingy buddy", // 682
  [CollectibleType.BONE_SPURS]: "Break your enemies", // 683
  [CollectibleType.HUNGRY_SOUL]: "Out for blood", // 684
  [CollectibleType.JAR_OF_WISPS]: "Your faith grows", // 685
  [CollectibleType.SOUL_LOCKET]: "Power of faith", // 686
  [CollectibleType.FRIEND_FINDER]: "Best friends forever!", // 687
  [CollectibleType.INNER_CHILD]: "Let him free", // 688
  [CollectibleType.GLITCHED_CROWN]: "?????", // 689
  [CollectibleType.JELLY_BELLY]: "Bounce away!", // 690
  [CollectibleType.SACRED_ORB]: "Destined for greatness", // 691
  [CollectibleType.SANGUINE_BOND]: "He awaits your offering", // 692
  [CollectibleType.SWARM]: "Infest", // 693
  [CollectibleType.HEARTBREAK]: "Eternal sorrow", // 694
  [CollectibleType.BLOODY_GUST]: "May your rage bring haste", // 695
  [CollectibleType.SALVATION]: "Divine protection", // 696
  [CollectibleType.VANISHING_TWIN]: "He wants revenge", // 697
  [CollectibleType.TWISTED_PAIR]: "Double trouble!", // 698
  [CollectibleType.AZAZELS_RAGE]: "Ancient power", // 699
  [CollectibleType.ECHO_CHAMBER]: "I can see see the future future future", // 700
  [CollectibleType.ISAACS_TOMB]: "Buried memories", // 701
  [CollectibleType.VENGEFUL_SPIRIT]: "Hot blooded", // 702
  [CollectibleType.ESAU_JR]: "Lost brother", // 703
  [CollectibleType.BERSERK]: "Rip and tear", // 704
  [CollectibleType.DARK_ARTS]: "One with the shadows", // 705
  [CollectibleType.ABYSS]: "Come forth from the depths", // 706
  [CollectibleType.SUPPER]: "HP up", // 707
  [CollectibleType.STAPLER]: "DMG up", // 708
  [CollectibleType.SUPLEX]: "Angel breaker", // 709
  [CollectibleType.BAG_OF_CRAFTING]: "Make your destiny", // 710
  [CollectibleType.FLIP]: "Life and death", // 711
  [CollectibleType.LEMEGETON]: "Item summoner", // 712
  [CollectibleType.SUMPTORIUM]: "Return", // 713
  [CollectibleType.RECALL]: "Come back", // 714
  [CollectibleType.HOLD]: "Saved for later", // 715
  [CollectibleType.KEEPERS_SACK]: "Spending power", // 716
  [CollectibleType.KEEPERS_KIN]: "Under a rock", // 717
  // There is no `CollectibleType` with a value of 718.
  [CollectibleType.KEEPERS_BOX]: "Portable shop", // 719
  [CollectibleType.EVERYTHING_JAR]: "Anything is possible", // 720
  [CollectibleType.TMTRAINER]:
    "Isaac and his mother lived alone in a small house on a hill", // 721
  [CollectibleType.ANIMA_SOLA]: "Repent", // 722
  [CollectibleType.SPINDOWN_DICE]: "-1", // 723
  [CollectibleType.HYPERCOAGULATION]: "Thick blooded", // 724
  [CollectibleType.IBS]: "Your stomach rumbles", // 725
  [CollectibleType.HEMOPTYSIS]: "Double tap sneeze", // 726
  [CollectibleType.GHOST_BOMBS]: "Spooky blast +5 bombs", // 727
  [CollectibleType.GELLO]: "Demonic gestation", // 728
  [CollectibleType.DECAP_ATTACK]: "Chuck away!", // 729
  [CollectibleType.GLASS_EYE]: "DMG + luck up", // 730
  [CollectibleType.STYE]: "DMG + range up", // 731
  [CollectibleType.MOMS_RING]: "DMG up", // 732
} as const satisfies Record<CollectibleType, string>;

----
objects\collectibleNames.ts
import { CollectibleType } from "isaac-typescript-definitions";

export const DEFAULT_COLLECTIBLE_NAME = "Unknown";

/**
 * Maps collectible types to the real English names from the "stringtable.sta" file.
 *
 * For a mapping of name to `CollectibleType`, see `COLLECTIBLE_NAME_TO_TYPE_MAP`.
 */
export const COLLECTIBLE_NAMES = {
  [CollectibleType.NULL]: DEFAULT_COLLECTIBLE_NAME, // 0
  [CollectibleType.SAD_ONION]: "The Sad Onion", // 1
  [CollectibleType.INNER_EYE]: "The Inner Eye", // 2
  [CollectibleType.SPOON_BENDER]: "Spoon Bender", // 3
  [CollectibleType.CRICKETS_HEAD]: "Cricket's Head", // 4
  [CollectibleType.MY_REFLECTION]: "My Reflection", // 5
  [CollectibleType.NUMBER_ONE]: "Number One", // 6
  [CollectibleType.BLOOD_OF_THE_MARTYR]: "Blood of the Martyr", // 7
  [CollectibleType.BROTHER_BOBBY]: "Brother Bobby", // 8
  [CollectibleType.SKATOLE]: "Skatole", // 9
  [CollectibleType.HALO_OF_FLIES]: "Halo of Flies", // 10
  [CollectibleType.ONE_UP]: "1up!", // 11
  [CollectibleType.MAGIC_MUSHROOM]: "Magic Mushroom", // 12
  [CollectibleType.VIRUS]: "The Virus", // 13
  [CollectibleType.ROID_RAGE]: "Roid Rage", // 14
  [CollectibleType.HEART]: "<3", // 15
  [CollectibleType.RAW_LIVER]: "Raw Liver", // 16
  [CollectibleType.SKELETON_KEY]: "Skeleton Key", // 17
  [CollectibleType.DOLLAR]: "A Dollar", // 18
  [CollectibleType.BOOM]: "Boom!", // 19
  [CollectibleType.TRANSCENDENCE]: "Transcendence", // 20
  [CollectibleType.COMPASS]: "The Compass", // 21
  [CollectibleType.LUNCH]: "Lunch", // 22
  [CollectibleType.DINNER]: "Dinner", // 23
  [CollectibleType.DESSERT]: "Dessert", // 24
  [CollectibleType.BREAKFAST]: "Breakfast", // 25
  [CollectibleType.ROTTEN_MEAT]: "Rotten Meat", // 26
  [CollectibleType.WOODEN_SPOON]: "Wooden Spoon", // 27
  [CollectibleType.BELT]: "The Belt", // 28
  [CollectibleType.MOMS_UNDERWEAR]: "Mom's Underwear", // 29
  [CollectibleType.MOMS_HEELS]: "Mom's Heels", // 30
  [CollectibleType.MOMS_LIPSTICK]: "Mom's Lipstick", // 31
  [CollectibleType.WIRE_COAT_HANGER]: "Wire Coat Hanger", // 32
  [CollectibleType.BIBLE]: "The Bible", // 33
  [CollectibleType.BOOK_OF_BELIAL]: "The Book of Belial", // 34
  [CollectibleType.NECRONOMICON]: "The Necronomicon", // 35
  [CollectibleType.POOP]: "The Poop", // 36
  [CollectibleType.MR_BOOM]: "Mr. Boom", // 37
  [CollectibleType.TAMMYS_HEAD]: "Tammy's Head", // 38
  [CollectibleType.MOMS_BRA]: "Mom's Bra", // 39
  [CollectibleType.KAMIKAZE]: "Kamikaze!", // 40
  [CollectibleType.MOMS_PAD]: "Mom's Pad", // 41
  [CollectibleType.BOBS_ROTTEN_HEAD]: "Bob's Rotten Head", // 42
  // There is no `CollectibleType` with a value of 43.
  [CollectibleType.TELEPORT]: "Teleport!", // 44
  [CollectibleType.YUM_HEART]: "Yum Heart", // 45
  [CollectibleType.LUCKY_FOOT]: "Lucky Foot", // 46
  [CollectibleType.DOCTORS_REMOTE]: "Doctor's Remote", // 47
  [CollectibleType.CUPIDS_ARROW]: "Cupid's Arrow", // 48
  [CollectibleType.SHOOP_DA_WHOOP]: "Shoop da Whoop!", // 49
  [CollectibleType.STEVEN]: "Steven", // 50
  [CollectibleType.PENTAGRAM]: "Pentagram", // 51
  [CollectibleType.DR_FETUS]: "Dr. Fetus", // 52
  [CollectibleType.MAGNETO]: "Magneto", // 53
  [CollectibleType.TREASURE_MAP]: "Treasure Map", // 54
  [CollectibleType.MOMS_EYE]: "Mom's Eye", // 55
  [CollectibleType.LEMON_MISHAP]: "Lemon Mishap", // 56
  [CollectibleType.DISTANT_ADMIRATION]: "Distant Admiration", // 57
  [CollectibleType.BOOK_OF_SHADOWS]: "Book of Shadows", // 58
  [CollectibleType.BOOK_OF_BELIAL_BIRTHRIGHT]: "The Book of Belial", // 59
  [CollectibleType.LADDER]: "The Ladder", // 60
  // There is no `CollectibleType` with a value of 61.
  [CollectibleType.CHARM_OF_THE_VAMPIRE]: "Charm of the Vampire", // 62
  [CollectibleType.BATTERY]: "The Battery", // 63
  [CollectibleType.STEAM_SALE]: "Steam Sale", // 64
  [CollectibleType.ANARCHIST_COOKBOOK]: "Anarchist Cookbook", // 65
  [CollectibleType.HOURGLASS]: "The Hourglass", // 66
  [CollectibleType.SISTER_MAGGY]: "Sister Maggy", // 67
  [CollectibleType.TECHNOLOGY]: "Technology", // 68
  [CollectibleType.CHOCOLATE_MILK]: "Chocolate Milk", // 69
  [CollectibleType.GROWTH_HORMONES]: "Growth Hormones", // 70
  [CollectibleType.MINI_MUSH]: "Mini Mush", // 71
  [CollectibleType.ROSARY]: "Rosary", // 72
  [CollectibleType.CUBE_OF_MEAT]: "Cube of Meat", // 73
  [CollectibleType.QUARTER]: "A Quarter", // 74
  [CollectibleType.PHD]: "PHD", // 75
  [CollectibleType.XRAY_VISION]: "X-Ray Vision", // 76
  [CollectibleType.MY_LITTLE_UNICORN]: "My Little Unicorn", // 77
  [CollectibleType.BOOK_OF_REVELATIONS]: "Book of Revelations", // 78
  [CollectibleType.MARK]: "The Mark", // 79
  [CollectibleType.PACT]: "The Pact", // 80
  [CollectibleType.DEAD_CAT]: "Dead Cat", // 81
  [CollectibleType.LORD_OF_THE_PIT]: "Lord of the Pit", // 82
  [CollectibleType.NAIL]: "The Nail", // 83
  [CollectibleType.WE_NEED_TO_GO_DEEPER]: "We Need To Go Deeper!", // 84
  [CollectibleType.DECK_OF_CARDS]: "Deck of Cards", // 85
  [CollectibleType.MONSTROS_TOOTH]: "Monstro's Tooth", // 86
  [CollectibleType.LOKIS_HORNS]: "Loki's Horns", // 87
  [CollectibleType.LITTLE_CHUBBY]: "Little Chubby", // 88
  [CollectibleType.SPIDER_BITE]: "Spider Bite", // 89
  [CollectibleType.SMALL_ROCK]: "The Small Rock", // 90
  [CollectibleType.SPELUNKER_HAT]: "Spelunker Hat", // 91
  [CollectibleType.SUPER_BANDAGE]: "Super Bandage", // 92
  [CollectibleType.GAMEKID]: "The Gamekid", // 93
  [CollectibleType.SACK_OF_PENNIES]: "Sack of Pennies", // 94
  [CollectibleType.ROBO_BABY]: "Robo-Baby", // 95
  [CollectibleType.LITTLE_CHAD]: "Little C.H.A.D.", // 96
  [CollectibleType.BOOK_OF_SIN]: "The Book of Sin", // 97
  [CollectibleType.RELIC]: "The Relic", // 98
  [CollectibleType.LITTLE_GISH]: "Little Gish", // 99
  [CollectibleType.LITTLE_STEVEN]: "Little Steven", // 100
  [CollectibleType.HALO]: "The Halo", // 101
  [CollectibleType.MOMS_BOTTLE_OF_PILLS]: "Mom's Bottle of Pills", // 102
  [CollectibleType.COMMON_COLD]: "The Common Cold", // 103
  [CollectibleType.PARASITE]: "The Parasite", // 104
  [CollectibleType.D6]: "The D6", // 105
  [CollectibleType.MR_MEGA]: "Mr. Mega", // 106
  [CollectibleType.PINKING_SHEARS]: "The Pinking Shears", // 107
  [CollectibleType.WAFER]: "The Wafer", // 108
  [CollectibleType.MONEY_EQUALS_POWER]: "Money = Power", // 109
  [CollectibleType.MOMS_CONTACTS]: "Mom's Contacts", // 110
  [CollectibleType.BEAN]: "The Bean", // 111
  [CollectibleType.GUARDIAN_ANGEL]: "Guardian Angel", // 112
  [CollectibleType.DEMON_BABY]: "Demon Baby", // 113
  [CollectibleType.MOMS_KNIFE]: "Mom's Knife", // 114
  [CollectibleType.OUIJA_BOARD]: "Ouija Board", // 115
  [CollectibleType.NINE_VOLT]: "9 Volt", // 116
  [CollectibleType.DEAD_BIRD]: "Dead Bird", // 117
  [CollectibleType.BRIMSTONE]: "Brimstone", // 118
  [CollectibleType.BLOOD_BAG]: "Blood Bag", // 119
  [CollectibleType.ODD_MUSHROOM_THIN]: "Odd Mushroom", // 120
  [CollectibleType.ODD_MUSHROOM_LARGE]: "Odd Mushroom", // 121
  [CollectibleType.WHORE_OF_BABYLON]: "Whore of Babylon", // 122
  [CollectibleType.MONSTER_MANUAL]: "Monster Manual", // 123
  [CollectibleType.DEAD_SEA_SCROLLS]: "Dead Sea Scrolls", // 124
  [CollectibleType.BOBBY_BOMB]: "Bobby-Bomb", // 125
  [CollectibleType.RAZOR_BLADE]: "Razor Blade", // 126
  [CollectibleType.FORGET_ME_NOW]: "Forget Me Now", // 127
  [CollectibleType.FOREVER_ALONE]: "Forever Alone", // 128
  [CollectibleType.BUCKET_OF_LARD]: "Bucket of Lard", // 129
  [CollectibleType.PONY]: "A Pony", // 130
  [CollectibleType.BOMB_BAG]: "Bomb Bag", // 131
  [CollectibleType.LUMP_OF_COAL]: "A Lump of Coal", // 132
  [CollectibleType.GUPPYS_PAW]: "Guppy's Paw", // 133
  [CollectibleType.GUPPYS_TAIL]: "Guppy's Tail", // 134
  [CollectibleType.IV_BAG]: "IV Bag", // 135
  [CollectibleType.BEST_FRIEND]: "Best Friend", // 136
  [CollectibleType.REMOTE_DETONATOR]: "Remote Detonator", // 137
  [CollectibleType.STIGMATA]: "Stigmata", // 138
  [CollectibleType.MOMS_PURSE]: "Mom's Purse", // 139
  [CollectibleType.BOBS_CURSE]: "Bob's Curse", // 140
  [CollectibleType.PAGEANT_BOY]: "Pageant Boy", // 141
  [CollectibleType.SCAPULAR]: "Scapular", // 142
  [CollectibleType.SPEED_BALL]: "Speed Ball", // 143
  [CollectibleType.BUM_FRIEND]: "Bum Friend", // 144
  [CollectibleType.GUPPYS_HEAD]: "Guppy's Head", // 145
  [CollectibleType.PRAYER_CARD]: "Prayer Card", // 146
  [CollectibleType.NOTCHED_AXE]: "Notched Axe", // 147
  [CollectibleType.INFESTATION]: "Infestation", // 148
  [CollectibleType.IPECAC]: "Ipecac", // 149
  [CollectibleType.TOUGH_LOVE]: "Tough Love", // 150
  [CollectibleType.MULLIGAN]: "The Mulligan", // 151
  [CollectibleType.TECHNOLOGY_2]: "Technology 2", // 152
  [CollectibleType.MUTANT_SPIDER]: "Mutant Spider", // 153
  [CollectibleType.CHEMICAL_PEEL]: "Chemical Peel", // 154
  [CollectibleType.PEEPER]: "The Peeper", // 155
  [CollectibleType.HABIT]: "Habit", // 156
  [CollectibleType.BLOODY_LUST]: "Bloody Lust", // 157
  [CollectibleType.CRYSTAL_BALL]: "Crystal Ball", // 158
  [CollectibleType.SPIRIT_OF_THE_NIGHT]: "Spirit of the Night", // 159
  [CollectibleType.CRACK_THE_SKY]: "Crack the Sky", // 160
  [CollectibleType.ANKH]: "Ankh", // 161
  [CollectibleType.CELTIC_CROSS]: "Celtic Cross", // 162
  [CollectibleType.GHOST_BABY]: "Ghost Baby", // 163
  [CollectibleType.CANDLE]: "The Candle", // 164
  [CollectibleType.CAT_O_NINE_TAILS]: "Cat-o-nine-tails", // 165
  [CollectibleType.D20]: "D20", // 166
  [CollectibleType.HARLEQUIN_BABY]: "Harlequin Baby", // 167
  [CollectibleType.EPIC_FETUS]: "Epic Fetus", // 168
  [CollectibleType.POLYPHEMUS]: "Polyphemus", // 169
  [CollectibleType.DADDY_LONGLEGS]: "Daddy Longlegs", // 170
  [CollectibleType.SPIDER_BUTT]: "Spider Butt", // 171
  [CollectibleType.SACRIFICIAL_DAGGER]: "Sacrificial Dagger", // 172
  [CollectibleType.MITRE]: "Mitre", // 173
  [CollectibleType.RAINBOW_BABY]: "Rainbow Baby", // 174
  [CollectibleType.DADS_KEY]: "Dad's Key", // 175
  [CollectibleType.STEM_CELLS]: "Stem Cells", // 176
  [CollectibleType.PORTABLE_SLOT]: "Portable Slot", // 177
  [CollectibleType.HOLY_WATER]: "Holy Water", // 178
  [CollectibleType.FATE]: "Fate", // 179
  [CollectibleType.BLACK_BEAN]: "The Black Bean", // 180
  [CollectibleType.WHITE_PONY]: "White Pony", // 181
  [CollectibleType.SACRED_HEART]: "Sacred Heart", // 182
  [CollectibleType.TOOTH_PICKS]: "Tooth Picks", // 183
  [CollectibleType.HOLY_GRAIL]: "Holy Grail", // 184
  [CollectibleType.DEAD_DOVE]: "Dead Dove", // 185
  [CollectibleType.BLOOD_RIGHTS]: "Blood Rights", // 186
  [CollectibleType.GUPPYS_HAIRBALL]: "Guppy's Hairball", // 187
  [CollectibleType.ABEL]: "Abel", // 188
  [CollectibleType.SMB_SUPER_FAN]: "SMB Super Fan", // 189
  [CollectibleType.PYRO]: "Pyro", // 190
  [CollectibleType.THREE_DOLLAR_BILL]: "3 Dollar Bill", // 191
  [CollectibleType.TELEPATHY_BOOK]: "Telepathy For Dummies", // 192
  [CollectibleType.MEAT]: "MEAT!", // 193
  [CollectibleType.MAGIC_8_BALL]: "Magic 8 Ball", // 194
  [CollectibleType.MOMS_COIN_PURSE]: "Mom's Coin Purse", // 195
  [CollectibleType.SQUEEZY]: "Squeezy", // 196
  [CollectibleType.JESUS_JUICE]: "Jesus Juice", // 197
  [CollectibleType.BOX]: "Box", // 198
  [CollectibleType.MOMS_KEY]: "Mom's Key", // 199
  [CollectibleType.MOMS_EYESHADOW]: "Mom's Eyeshadow", // 200
  [CollectibleType.IRON_BAR]: "Iron Bar", // 201
  [CollectibleType.MIDAS_TOUCH]: "Midas' Touch", // 202
  [CollectibleType.HUMBLEING_BUNDLE]: "Humbleing Bundle", // 203
  [CollectibleType.FANNY_PACK]: "Fanny Pack", // 204
  [CollectibleType.SHARP_PLUG]: "Sharp Plug", // 205
  [CollectibleType.GUILLOTINE]: "Guillotine", // 206
  [CollectibleType.BALL_OF_BANDAGES]: "Ball of Bandages", // 207
  [CollectibleType.CHAMPION_BELT]: "Champion Belt", // 208
  [CollectibleType.BUTT_BOMBS]: "Butt Bombs", // 209
  [CollectibleType.GNAWED_LEAF]: "Gnawed Leaf", // 210
  [CollectibleType.SPIDERBABY]: "Spiderbaby", // 211
  [CollectibleType.GUPPYS_COLLAR]: "Guppy's Collar", // 212
  [CollectibleType.LOST_CONTACT]: "Lost Contact", // 213
  [CollectibleType.ANEMIC]: "Anemic", // 214
  [CollectibleType.GOAT_HEAD]: "Goat Head", // 215
  [CollectibleType.CEREMONIAL_ROBES]: "Ceremonial Robes", // 216
  [CollectibleType.MOMS_WIG]: "Mom's Wig", // 217
  [CollectibleType.PLACENTA]: "Placenta", // 218
  [CollectibleType.OLD_BANDAGE]: "Old Bandage", // 219
  [CollectibleType.SAD_BOMBS]: "Sad Bombs", // 220
  [CollectibleType.RUBBER_CEMENT]: "Rubber Cement", // 221
  [CollectibleType.ANTI_GRAVITY]: "Anti-Gravity", // 222
  [CollectibleType.PYROMANIAC]: "Pyromaniac", // 223
  [CollectibleType.CRICKETS_BODY]: "Cricket's Body", // 224
  [CollectibleType.GIMPY]: "Gimpy", // 225
  [CollectibleType.BLACK_LOTUS]: "Black Lotus", // 226
  [CollectibleType.PIGGY_BANK]: "Piggy Bank", // 227
  [CollectibleType.MOMS_PERFUME]: "Mom's Perfume", // 228
  [CollectibleType.MONSTROS_LUNG]: "Monstro's Lung", // 229
  [CollectibleType.ABADDON]: "Abaddon", // 230
  [CollectibleType.BALL_OF_TAR]: "Ball of Tar", // 231
  [CollectibleType.STOP_WATCH]: "Stop Watch", // 232
  [CollectibleType.TINY_PLANET]: "Tiny Planet", // 233
  [CollectibleType.INFESTATION_2]: "Infestation 2", // 234
  // There is no `CollectibleType` with a value of 235.
  [CollectibleType.E_COLI]: "E. Coli", // 236
  [CollectibleType.DEATHS_TOUCH]: "Death's Touch", // 237
  [CollectibleType.KEY_PIECE_1]: "Key Piece 1", // 238
  [CollectibleType.KEY_PIECE_2]: "Key Piece 2", // 239
  [CollectibleType.EXPERIMENTAL_TREATMENT]: "Experimental Treatment", // 240
  [CollectibleType.CONTRACT_FROM_BELOW]: "Contract from Below", // 241
  [CollectibleType.INFAMY]: "Infamy", // 242
  [CollectibleType.TRINITY_SHIELD]: "Trinity Shield", // 243
  [CollectibleType.TECH_5]: "Tech.5", // 244
  [CollectibleType.TWENTY_TWENTY]: "20/20", // 245
  [CollectibleType.BLUE_MAP]: "Blue Map", // 246
  [CollectibleType.BFFS]: "BFFS!", // 247
  [CollectibleType.HIVE_MIND]: "Hive Mind", // 248
  [CollectibleType.THERES_OPTIONS]: "There's Options", // 249
  [CollectibleType.BOGO_BOMBS]: "BOGO Bombs", // 250
  [CollectibleType.STARTER_DECK]: "Starter Deck", // 251
  [CollectibleType.LITTLE_BAGGY]: "Little Baggy", // 252
  [CollectibleType.MAGIC_SCAB]: "Magic Scab", // 253
  [CollectibleType.BLOOD_CLOT]: "Blood Clot", // 254
  [CollectibleType.SCREW]: "Screw", // 255
  [CollectibleType.HOT_BOMBS]: "Hot Bombs", // 256
  [CollectibleType.FIRE_MIND]: "Fire Mind", // 257
  [CollectibleType.MISSING_NO]: "Missing No.", // 258
  [CollectibleType.DARK_MATTER]: "Dark Matter", // 259
  [CollectibleType.BLACK_CANDLE]: "Black Candle", // 260
  [CollectibleType.PROPTOSIS]: "Proptosis", // 261
  [CollectibleType.MISSING_PAGE_2]: "Missing Page 2", // 262
  [CollectibleType.CLEAR_RUNE]: "Clear Rune", // 263
  [CollectibleType.SMART_FLY]: "Smart Fly", // 264
  [CollectibleType.DRY_BABY]: "Dry Baby", // 265
  [CollectibleType.JUICY_SACK]: "Juicy Sack", // 266
  [CollectibleType.ROBO_BABY_2]: "Robo-Baby 2.0", // 267
  [CollectibleType.ROTTEN_BABY]: "Rotten Baby", // 268
  [CollectibleType.HEADLESS_BABY]: "Headless Baby", // 269
  [CollectibleType.LEECH]: "Leech", // 270
  [CollectibleType.MYSTERY_SACK]: "Mystery Sack", // 271
  [CollectibleType.BBF]: "BBF", // 272
  [CollectibleType.BOBS_BRAIN]: "Bob's Brain", // 273
  [CollectibleType.BEST_BUD]: "Best Bud", // 274
  [CollectibleType.LIL_BRIMSTONE]: "Lil Brimstone", // 275
  [CollectibleType.ISAACS_HEART]: "Isaac's Heart", // 276
  [CollectibleType.LIL_HAUNT]: "Lil Haunt", // 277
  [CollectibleType.DARK_BUM]: "Dark Bum", // 278
  [CollectibleType.BIG_FAN]: "Big Fan", // 279
  [CollectibleType.SISSY_LONGLEGS]: "Sissy Longlegs", // 280
  [CollectibleType.PUNCHING_BAG]: "Punching Bag", // 281
  [CollectibleType.HOW_TO_JUMP]: "How to Jump", // 282
  [CollectibleType.D100]: "D100", // 283
  [CollectibleType.D4]: "D4", // 284
  [CollectibleType.D10]: "D10", // 285
  [CollectibleType.BLANK_CARD]: "Blank Card", // 286
  [CollectibleType.BOOK_OF_SECRETS]: "Book of Secrets", // 287
  [CollectibleType.BOX_OF_SPIDERS]: "Box of Spiders", // 288
  [CollectibleType.RED_CANDLE]: "Red Candle", // 289
  [CollectibleType.JAR]: "The Jar", // 290
  [CollectibleType.FLUSH]: "Flush!", // 291
  [CollectibleType.SATANIC_BIBLE]: "Satanic Bible", // 292
  [CollectibleType.HEAD_OF_KRAMPUS]: "Head of Krampus", // 293
  [CollectibleType.BUTTER_BEAN]: "Butter Bean", // 294
  [CollectibleType.MAGIC_FINGERS]: "Magic Fingers", // 295
  [CollectibleType.CONVERTER]: "Converter", // 296
  [CollectibleType.BLUE_BOX]: "Pandora's Box", // 297
  [CollectibleType.UNICORN_STUMP]: "Unicorn Stump", // 298
  [CollectibleType.TAURUS]: "Taurus", // 299
  [CollectibleType.ARIES]: "Aries", // 300
  [CollectibleType.CANCER]: "Cancer", // 301
  [CollectibleType.LEO]: "Leo", // 302
  [CollectibleType.VIRGO]: "Virgo", // 303
  [CollectibleType.LIBRA]: "Libra", // 304
  [CollectibleType.SCORPIO]: "Scorpio", // 305
  [CollectibleType.SAGITTARIUS]: "Sagittarius", // 306
  [CollectibleType.CAPRICORN]: "Capricorn", // 307
  [CollectibleType.AQUARIUS]: "Aquarius", // 308
  [CollectibleType.PISCES]: "Pisces", // 309
  [CollectibleType.EVES_MASCARA]: "Eve's Mascara", // 310
  [CollectibleType.JUDAS_SHADOW]: "Judas' Shadow", // 311
  [CollectibleType.MAGGYS_BOW]: "Maggy's Bow", // 312
  [CollectibleType.HOLY_MANTLE]: "Holy Mantle", // 313
  [CollectibleType.THUNDER_THIGHS]: "Thunder Thighs", // 314
  [CollectibleType.STRANGE_ATTRACTOR]: "Strange Attractor", // 315
  [CollectibleType.CURSED_EYE]: "Cursed Eye", // 316
  [CollectibleType.MYSTERIOUS_LIQUID]: "Mysterious Liquid", // 317
  [CollectibleType.GEMINI]: "Gemini", // 318
  [CollectibleType.CAINS_OTHER_EYE]: "Cain's Other Eye", // 319
  [CollectibleType.BLUE_BABYS_ONLY_FRIEND]: "???'s Only Friend", // 320
  [CollectibleType.SAMSONS_CHAINS]: "Samson's Chains", // 321
  [CollectibleType.MONGO_BABY]: "Mongo Baby", // 322
  [CollectibleType.ISAACS_TEARS]: "Isaac's Tears", // 323
  [CollectibleType.UNDEFINED]: "Undefined", // 324
  [CollectibleType.SCISSORS]: "Scissors", // 325
  [CollectibleType.BREATH_OF_LIFE]: "Breath of Life", // 326
  [CollectibleType.POLAROID]: "The Polaroid", // 327
  [CollectibleType.NEGATIVE]: "The Negative", // 328
  [CollectibleType.LUDOVICO_TECHNIQUE]: "The Ludovico Technique", // 329
  [CollectibleType.SOY_MILK]: "Soy Milk", // 330
  [CollectibleType.GODHEAD]: "Godhead", // 331
  [CollectibleType.LAZARUS_RAGS]: "Lazarus' Rags", // 332
  [CollectibleType.MIND]: "The Mind", // 333
  [CollectibleType.BODY]: "The Body", // 334
  [CollectibleType.SOUL]: "The Soul", // 335
  [CollectibleType.DEAD_ONION]: "Dead Onion", // 336
  [CollectibleType.BROKEN_WATCH]: "Broken Watch", // 337
  [CollectibleType.BOOMERANG]: "The Boomerang", // 338
  [CollectibleType.SAFETY_PIN]: "Safety Pin", // 339
  [CollectibleType.CAFFEINE_PILL]: "Caffeine Pill", // 340
  [CollectibleType.TORN_PHOTO]: "Torn Photo", // 341
  [CollectibleType.BLUE_CAP]: "Blue Cap", // 342
  [CollectibleType.LATCH_KEY]: "Latch Key", // 343
  [CollectibleType.MATCH_BOOK]: "Match Book", // 344
  [CollectibleType.SYNTHOIL]: "Synthoil", // 345
  [CollectibleType.SNACK]: "A Snack", // 346
  [CollectibleType.DIPLOPIA]: "Diplopia", // 347
  [CollectibleType.PLACEBO]: "Placebo", // 348
  [CollectibleType.WOODEN_NICKEL]: "Wooden Nickel", // 349
  [CollectibleType.TOXIC_SHOCK]: "Toxic Shock", // 350
  [CollectibleType.MEGA_BEAN]: "Mega Bean", // 351
  [CollectibleType.GLASS_CANNON]: "Glass Cannon", // 352
  [CollectibleType.BOMBER_BOY]: "Bomber Boy", // 353
  [CollectibleType.CRACK_JACKS]: "Crack Jacks", // 354
  [CollectibleType.MOMS_PEARLS]: "Mom's Pearls", // 355
  [CollectibleType.CAR_BATTERY]: "Car Battery", // 356
  [CollectibleType.BOX_OF_FRIENDS]: "Box of Friends", // 357
  [CollectibleType.WIZ]: "The Wiz", // 358
  [CollectibleType.EIGHT_INCH_NAILS]: "8 Inch Nails", // 359
  [CollectibleType.INCUBUS]: "Incubus", // 360
  [CollectibleType.FATES_REWARD]: "Fate's Reward", // 361
  [CollectibleType.LIL_CHEST]: "Lil Chest", // 362
  [CollectibleType.SWORN_PROTECTOR]: "Sworn Protector", // 363
  [CollectibleType.FRIEND_ZONE]: "Friend Zone", // 364
  [CollectibleType.LOST_FLY]: "Lost Fly", // 365
  [CollectibleType.SCATTER_BOMBS]: "Scatter Bombs", // 366
  [CollectibleType.STICKY_BOMBS]: "Sticky Bombs", // 367
  [CollectibleType.EPIPHORA]: "Epiphora", // 368
  [CollectibleType.CONTINUUM]: "Continuum", // 369
  [CollectibleType.MR_DOLLY]: "Mr. Dolly", // 370
  [CollectibleType.CURSE_OF_THE_TOWER]: "Curse of the Tower", // 371
  [CollectibleType.CHARGED_BABY]: "Charged Baby", // 372
  [CollectibleType.DEAD_EYE]: "Dead Eye", // 373
  [CollectibleType.HOLY_LIGHT]: "Holy Light", // 374
  [CollectibleType.HOST_HAT]: "Host Hat", // 375
  [CollectibleType.RESTOCK]: "Restock", // 376
  [CollectibleType.BURSTING_SACK]: "Bursting Sack", // 377
  [CollectibleType.NUMBER_TWO]: "Number Two", // 378
  [CollectibleType.PUPULA_DUPLEX]: "Pupula Duplex", // 379
  [CollectibleType.PAY_TO_PLAY]: "Pay To Play", // 380
  [CollectibleType.EDENS_BLESSING]: "Eden's Blessing", // 381
  [CollectibleType.FRIEND_BALL]: "Friendly Ball", // 382
  [CollectibleType.TEAR_DETONATOR]: "Tear Detonator", // 383
  [CollectibleType.LIL_GURDY]: "Lil Gurdy", // 384
  [CollectibleType.BUMBO]: "Bumbo", // 385
  [CollectibleType.D12]: "D12", // 386
  [CollectibleType.CENSER]: "Censer", // 387
  [CollectibleType.KEY_BUM]: "Key Bum", // 388
  [CollectibleType.RUNE_BAG]: "Rune Bag", // 389
  [CollectibleType.SERAPHIM]: "Seraphim", // 390
  [CollectibleType.BETRAYAL]: "Betrayal", // 391
  [CollectibleType.ZODIAC]: "Zodiac", // 392
  [CollectibleType.SERPENTS_KISS]: "Serpent's Kiss", // 393
  [CollectibleType.MARKED]: "Marked", // 394
  [CollectibleType.TECH_X]: "Tech X", // 395
  [CollectibleType.VENTRICLE_RAZOR]: "Ventricle Razor", // 396
  [CollectibleType.TRACTOR_BEAM]: "Tractor Beam", // 397
  [CollectibleType.GODS_FLESH]: "God's Flesh", // 398
  [CollectibleType.MAW_OF_THE_VOID]: "Maw of the Void", // 399
  [CollectibleType.SPEAR_OF_DESTINY]: "Spear of Destiny", // 400
  [CollectibleType.EXPLOSIVO]: "Explosivo", // 401
  [CollectibleType.CHAOS]: "Chaos", // 402
  [CollectibleType.SPIDER_MOD]: "Spider Mod", // 403
  [CollectibleType.FARTING_BABY]: "Farting Baby", // 404
  [CollectibleType.GB_BUG]: "GB Bug", // 405
  [CollectibleType.D8]: "D8", // 406
  [CollectibleType.PURITY]: "Purity", // 407
  [CollectibleType.ATHAME]: "Athame", // 408
  [CollectibleType.EMPTY_VESSEL]: "Empty Vessel", // 409
  [CollectibleType.EVIL_EYE]: "Evil Eye", // 410
  [CollectibleType.LUSTY_BLOOD]: "Lusty Blood", // 411
  [CollectibleType.CAMBION_CONCEPTION]: "Cambion Conception", // 412
  [CollectibleType.IMMACULATE_CONCEPTION]: "Immaculate Conception", // 413
  [CollectibleType.MORE_OPTIONS]: "More Options", // 414
  [CollectibleType.CROWN_OF_LIGHT]: "Crown of Light", // 415
  [CollectibleType.DEEP_POCKETS]: "Deep Pockets", // 416
  [CollectibleType.SUCCUBUS]: "Succubus", // 417
  [CollectibleType.FRUIT_CAKE]: "Fruit Cake", // 418
  [CollectibleType.TELEPORT_2]: "Teleport 2.0", // 419
  [CollectibleType.BLACK_POWDER]: "Black Powder", // 420
  [CollectibleType.KIDNEY_BEAN]: "Kidney Bean", // 421
  [CollectibleType.GLOWING_HOUR_GLASS]: "Glowing Hourglass", // 422
  [CollectibleType.CIRCLE_OF_PROTECTION]: "Circle of Protection", // 423
  [CollectibleType.SACK_HEAD]: "Sack Head", // 424
  [CollectibleType.NIGHT_LIGHT]: "Night Light", // 425
  [CollectibleType.OBSESSED_FAN]: "Obsessed Fan", // 426
  [CollectibleType.MINE_CRAFTER]: "Mine Crafter", // 427
  [CollectibleType.PJS]: "PJs", // 428
  [CollectibleType.HEAD_OF_THE_KEEPER]: "Head of the Keeper", // 429
  [CollectibleType.PAPA_FLY]: "Papa Fly", // 430
  [CollectibleType.MULTIDIMENSIONAL_BABY]: "Multidimensional Baby", // 431
  [CollectibleType.GLITTER_BOMBS]: "Glitter Bombs", // 432
  [CollectibleType.MY_SHADOW]: "My Shadow", // 433
  [CollectibleType.JAR_OF_FLIES]: "Jar of Flies", // 434
  [CollectibleType.LIL_LOKI]: "Lil Loki", // 435
  [CollectibleType.MILK]: "Milk!", // 436
  [CollectibleType.D7]: "D7", // 437
  [CollectibleType.BINKY]: "Binky", // 438
  [CollectibleType.MOMS_BOX]: "Mom's Box", // 439
  [CollectibleType.KIDNEY_STONE]: "Kidney Stone", // 440
  [CollectibleType.MEGA_BLAST]: "Mega Blast", // 441
  [CollectibleType.DARK_PRINCES_CROWN]: "Dark Prince's Crown", // 442
  [CollectibleType.APPLE]: "Apple!", // 443
  [CollectibleType.LEAD_PENCIL]: "Lead Pencil", // 444
  [CollectibleType.DOG_TOOTH]: "Dog Tooth", // 445
  [CollectibleType.DEAD_TOOTH]: "Dead Tooth", // 446
  [CollectibleType.LINGER_BEAN]: "Linger Bean", // 447
  [CollectibleType.SHARD_OF_GLASS]: "Shard of Glass", // 448
  [CollectibleType.METAL_PLATE]: "Metal Plate", // 449
  [CollectibleType.EYE_OF_GREED]: "Eye of Greed", // 450
  [CollectibleType.TAROT_CLOTH]: "Tarot Cloth", // 451
  [CollectibleType.VARICOSE_VEINS]: "Varicose Veins", // 452
  [CollectibleType.COMPOUND_FRACTURE]: "Compound Fracture", // 453
  [CollectibleType.POLYDACTYLY]: "Polydactyly", // 454
  [CollectibleType.DADS_LOST_COIN]: "Dad's Lost Coin", // 455
  [CollectibleType.MIDNIGHT_SNACK]: "Midnight Snack", // 456
  [CollectibleType.CONE_HEAD]: "Cone Head", // 457
  [CollectibleType.BELLY_BUTTON]: "Belly Button", // 458
  [CollectibleType.SINUS_INFECTION]: "Sinus Infection", // 459
  [CollectibleType.GLAUCOMA]: "Glaucoma", // 460
  [CollectibleType.PARASITOID]: "Parasitoid", // 461
  [CollectibleType.EYE_OF_BELIAL]: "Eye of Belial", // 462
  [CollectibleType.SULFURIC_ACID]: "Sulfuric Acid", // 463
  [CollectibleType.GLYPH_OF_BALANCE]: "Glyph of Balance", // 464
  [CollectibleType.ANALOG_STICK]: "Analog Stick", // 465
  [CollectibleType.CONTAGION]: "Contagion", // 466
  [CollectibleType.FINGER]: "Finger!", // 467
  [CollectibleType.SHADE]: "Shade", // 468
  [CollectibleType.DEPRESSION]: "Depression", // 469
  [CollectibleType.HUSHY]: "Hushy", // 470
  [CollectibleType.LIL_MONSTRO]: "Lil Monstro", // 471
  [CollectibleType.KING_BABY]: "King Baby", // 472
  [CollectibleType.BIG_CHUBBY]: "Big Chubby", // 473
  [CollectibleType.BROKEN_GLASS_CANNON]: "Broken Glass Cannon", // 474
  [CollectibleType.PLAN_C]: "Plan C", // 475
  [CollectibleType.D1]: "D1", // 476
  [CollectibleType.VOID]: "Void", // 477
  [CollectibleType.PAUSE]: "Pause", // 478
  [CollectibleType.SMELTER]: "Smelter", // 479
  [CollectibleType.COMPOST]: "Compost", // 480
  [CollectibleType.DATAMINER]: "Dataminer", // 481
  [CollectibleType.CLICKER]: "Clicker", // 482
  [CollectibleType.MAMA_MEGA]: "Mama Mega!", // 483
  [CollectibleType.WAIT_WHAT]: "Wait What?", // 484
  [CollectibleType.CROOKED_PENNY]: "Crooked Penny", // 485
  [CollectibleType.DULL_RAZOR]: "Dull Razor", // 486
  [CollectibleType.POTATO_PEELER]: "Potato Peeler", // 487
  [CollectibleType.METRONOME]: "Metronome", // 488
  [CollectibleType.D_INFINITY]: "D infinity", // 489
  [CollectibleType.EDENS_SOUL]: "Eden's Soul", // 490
  [CollectibleType.ACID_BABY]: "Acid Baby", // 491
  [CollectibleType.YO_LISTEN]: "YO LISTEN!", // 492
  [CollectibleType.ADRENALINE]: "Adrenaline", // 493
  [CollectibleType.JACOBS_LADDER]: "Jacob's Ladder", // 494
  [CollectibleType.GHOST_PEPPER]: "Ghost Pepper", // 495
  [CollectibleType.EUTHANASIA]: "Euthanasia", // 496
  [CollectibleType.CAMO_UNDIES]: "Camo Undies", // 497
  [CollectibleType.DUALITY]: "Duality", // 498
  [CollectibleType.EUCHARIST]: "Eucharist", // 499
  [CollectibleType.SACK_OF_SACKS]: "Sack of Sacks", // 500
  [CollectibleType.GREEDS_GULLET]: "Greed's Gullet", // 501
  [CollectibleType.LARGE_ZIT]: "Large Zit", // 502
  [CollectibleType.LITTLE_HORN]: "Little Horn", // 503
  [CollectibleType.BROWN_NUGGET]: "Brown Nugget", // 504
  [CollectibleType.POKE_GO]: "Poke Go", // 505
  [CollectibleType.BACKSTABBER]: "Backstabber", // 506
  [CollectibleType.SHARP_STRAW]: "Sharp Straw", // 507
  [CollectibleType.MOMS_RAZOR]: "Mom's Razor", // 508
  [CollectibleType.BLOODSHOT_EYE]: "Bloodshot Eye", // 509
  [CollectibleType.DELIRIOUS]: "Delirious", // 510
  [CollectibleType.ANGRY_FLY]: "Angry Fly", // 511
  [CollectibleType.BLACK_HOLE]: "Black Hole", // 512
  [CollectibleType.BOZO]: "Bozo", // 513
  [CollectibleType.BROKEN_MODEM]: "Broken Modem", // 514
  [CollectibleType.MYSTERY_GIFT]: "Mystery Gift", // 515
  [CollectibleType.SPRINKLER]: "Sprinkler", // 516
  [CollectibleType.FAST_BOMBS]: "Fast Bombs", // 517
  [CollectibleType.BUDDY_IN_A_BOX]: "Buddy in a Box", // 518
  [CollectibleType.LIL_DELIRIUM]: "Lil Delirium", // 519
  [CollectibleType.JUMPER_CABLES]: "Jumper Cables", // 520
  [CollectibleType.COUPON]: "Coupon", // 521
  [CollectibleType.TELEKINESIS]: "Telekinesis", // 522
  [CollectibleType.MOVING_BOX]: "Moving Box", // 523
  [CollectibleType.TECHNOLOGY_ZERO]: "Technology Zero", // 524
  [CollectibleType.LEPROSY]: "Leprosy", // 525
  [CollectibleType.SEVEN_SEALS]: "7 Seals", // 526
  [CollectibleType.MR_ME]: "Mr. ME!", // 527
  [CollectibleType.ANGELIC_PRISM]: "Angelic Prism", // 528
  [CollectibleType.POP]: "Pop!", // 529
  [CollectibleType.DEATHS_LIST]: "Death's List", // 530
  [CollectibleType.HAEMOLACRIA]: "Haemolacria", // 531
  [CollectibleType.LACHRYPHAGY]: "Lachryphagy", // 532
  [CollectibleType.TRISAGION]: "Trisagion", // 533
  [CollectibleType.SCHOOLBAG]: "Schoolbag", // 534
  [CollectibleType.BLANKET]: "Blanket", // 535
  [CollectibleType.SACRIFICIAL_ALTAR]: "Sacrificial Altar", // 536
  [CollectibleType.LIL_SPEWER]: "Lil Spewer", // 537
  [CollectibleType.MARBLES]: "Marbles", // 538
  [CollectibleType.MYSTERY_EGG]: "Mystery Egg", // 539
  [CollectibleType.FLAT_STONE]: "Flat Stone", // 540
  [CollectibleType.MARROW]: "Marrow", // 541
  [CollectibleType.SLIPPED_RIB]: "Slipped Rib", // 542
  [CollectibleType.HALLOWED_GROUND]: "Hallowed Ground", // 543
  [CollectibleType.POINTY_RIB]: "Pointy Rib", // 544
  [CollectibleType.BOOK_OF_THE_DEAD]: "Book of the Dead", // 545
  [CollectibleType.DADS_RING]: "Dad's Ring", // 546
  [CollectibleType.DIVORCE_PAPERS]: "Divorce Papers", // 547
  [CollectibleType.JAW_BONE]: "Jaw Bone", // 548
  [CollectibleType.BRITTLE_BONES]: "Brittle Bones", // 549
  [CollectibleType.BROKEN_SHOVEL_1]: "Broken Shovel", // 550
  [CollectibleType.BROKEN_SHOVEL_2]: "Broken Shovel", // 551
  [CollectibleType.MOMS_SHOVEL]: "Mom's Shovel", // 552
  [CollectibleType.MUCORMYCOSIS]: "Mucormycosis", // 553
  [CollectibleType.TWO_SPOOKY]: "2Spooky", // 554
  [CollectibleType.GOLDEN_RAZOR]: "Golden Razor", // 555
  [CollectibleType.SULFUR]: "Sulfur", // 556
  [CollectibleType.FORTUNE_COOKIE]: "Fortune Cookie", // 557
  [CollectibleType.EYE_SORE]: "Eye Sore", // 558
  [CollectibleType.ONE_HUNDRED_TWENTY_VOLT]: "120 Volt", // 559
  [CollectibleType.IT_HURTS]: "It Hurts", // 560
  [CollectibleType.ALMOND_MILK]: "Almond Milk", // 561
  [CollectibleType.ROCK_BOTTOM]: "Rock Bottom", // 562
  [CollectibleType.NANCY_BOMBS]: "Nancy Bombs", // 563
  [CollectibleType.BAR_OF_SOAP]: "A Bar of Soap", // 564
  [CollectibleType.BLOOD_PUPPY]: "Blood Puppy", // 565
  [CollectibleType.DREAM_CATCHER]: "Dream Catcher", // 566
  [CollectibleType.PASCHAL_CANDLE]: "Paschal Candle", // 567
  [CollectibleType.DIVINE_INTERVENTION]: "Divine Intervention", // 568
  [CollectibleType.BLOOD_OATH]: "Blood Oath", // 569
  [CollectibleType.PLAYDOUGH_COOKIE]: "Playdough Cookie", // 570
  [CollectibleType.ORPHAN_SOCKS]: "Orphan Socks", // 571
  [CollectibleType.EYE_OF_THE_OCCULT]: "Eye of the Occult", // 572
  [CollectibleType.IMMACULATE_HEART]: "Immaculate Heart", // 573
  [CollectibleType.MONSTRANCE]: "Monstrance", // 574
  [CollectibleType.INTRUDER]: "The Intruder", // 575
  [CollectibleType.DIRTY_MIND]: "Dirty Mind", // 576
  [CollectibleType.DAMOCLES]: "Damocles", // 577
  [CollectibleType.FREE_LEMONADE]: "Free Lemonade", // 578
  [CollectibleType.SPIRIT_SWORD]: "Spirit Sword", // 579
  [CollectibleType.RED_KEY]: "Red Key", // 580
  [CollectibleType.PSY_FLY]: "Psy Fly", // 581
  [CollectibleType.WAVY_CAP]: "Wavy Cap", // 582
  [CollectibleType.ROCKET_IN_A_JAR]: "Rocket in a Jar", // 583
  [CollectibleType.BOOK_OF_VIRTUES]: "Book of Virtues", // 584
  [CollectibleType.ALABASTER_BOX]: "Alabaster Box", // 585
  [CollectibleType.STAIRWAY]: "The Stairway", // 586
  // There is no `CollectibleType` with a value of 587.
  [CollectibleType.SOL]: "Sol", // 588
  [CollectibleType.LUNA]: "Luna", // 589
  [CollectibleType.MERCURIUS]: "Mercurius", // 590
  [CollectibleType.VENUS]: "Venus", // 591
  [CollectibleType.TERRA]: "Terra", // 592
  [CollectibleType.MARS]: "Mars", // 593
  [CollectibleType.JUPITER]: "Jupiter", // 594
  [CollectibleType.SATURNUS]: "Saturnus", // 595
  [CollectibleType.URANUS]: "Uranus", // 596
  [CollectibleType.NEPTUNUS]: "Neptunus", // 597
  [CollectibleType.PLUTO]: "Pluto", // 598
  [CollectibleType.VOODOO_HEAD]: "Voodoo Head", // 599
  [CollectibleType.EYE_DROPS]: "Eye Drops", // 600
  [CollectibleType.ACT_OF_CONTRITION]: "Act of Contrition", // 601
  [CollectibleType.MEMBER_CARD]: "Member Card", // 602
  [CollectibleType.BATTERY_PACK]: "Battery Pack", // 603
  [CollectibleType.MOMS_BRACELET]: "Mom's Bracelet", // 604
  [CollectibleType.SCOOPER]: "The Scooper", // 605
  [CollectibleType.OCULAR_RIFT]: "Ocular Rift", // 606
  [CollectibleType.BOILED_BABY]: "Boiled Baby", // 607
  [CollectibleType.FREEZER_BABY]: "Freezer Baby", // 608
  [CollectibleType.ETERNAL_D6]: "Eternal D6", // 609
  [CollectibleType.BIRD_CAGE]: "Bird Cage", // 610
  [CollectibleType.LARYNX]: "Larynx", // 611
  [CollectibleType.LOST_SOUL]: "Lost Soul", // 612
  // There is no `CollectibleType` with a value of 613.
  [CollectibleType.BLOOD_BOMBS]: "Blood Bombs", // 614
  [CollectibleType.LIL_DUMPY]: "Lil Dumpy", // 615
  [CollectibleType.BIRDS_EYE]: "Bird's Eye", // 616
  [CollectibleType.LODESTONE]: "Lodestone", // 617
  [CollectibleType.ROTTEN_TOMATO]: "Rotten Tomato", // 618
  [CollectibleType.BIRTHRIGHT]: "Birthright", // 619
  // There is no `CollectibleType` with a value of 620.
  [CollectibleType.RED_STEW]: "Red Stew", // 621
  [CollectibleType.GENESIS]: "Genesis", // 622
  [CollectibleType.SHARP_KEY]: "Sharp Key", // 623
  [CollectibleType.BOOSTER_PACK]: "Booster Pack", // 624
  [CollectibleType.MEGA_MUSH]: "Mega Mush", // 625
  [CollectibleType.KNIFE_PIECE_1]: "Knife Piece 1", // 626
  [CollectibleType.KNIFE_PIECE_2]: "Knife Piece 2", // 627
  [CollectibleType.DEATH_CERTIFICATE]: "Death Certificate", // 628
  [CollectibleType.BOT_FLY]: "Bot Fly", // 629
  // There is no `CollectibleType` with a value of 630.
  [CollectibleType.MEAT_CLEAVER]: "Meat Cleaver", // 631
  [CollectibleType.EVIL_CHARM]: "Evil Charm", // 632
  [CollectibleType.DOGMA]: "Dogma", // 633
  [CollectibleType.PURGATORY]: "Purgatory", // 634
  [CollectibleType.STITCHES]: "Stitches", // 635
  [CollectibleType.R_KEY]: "R Key", // 636
  [CollectibleType.KNOCKOUT_DROPS]: "Knockout Drops", // 637
  [CollectibleType.ERASER]: "Eraser", // 638
  [CollectibleType.YUCK_HEART]: "Yuck Heart", // 639
  [CollectibleType.URN_OF_SOULS]: "Urn of Souls", // 640
  [CollectibleType.AKELDAMA]: "Akeldama", // 641
  [CollectibleType.MAGIC_SKIN]: "Magic Skin", // 642
  [CollectibleType.REVELATION]: "Revelation", // 643
  [CollectibleType.CONSOLATION_PRIZE]: "Consolation Prize", // 644
  [CollectibleType.TINYTOMA]: "Tinytoma", // 645
  [CollectibleType.BRIMSTONE_BOMBS]: "Brimstone Bombs", // 646
  [CollectibleType.FOUR_FIVE_VOLT]: "4.5 Volt", // 647
  // There is no `CollectibleType` with a value of 648.
  [CollectibleType.FRUITY_PLUM]: "Fruity Plum", // 649
  [CollectibleType.PLUM_FLUTE]: "Plum Flute", // 650
  [CollectibleType.STAR_OF_BETHLEHEM]: "Star of Bethlehem", // 651
  [CollectibleType.CUBE_BABY]: "Cube Baby", // 652
  [CollectibleType.VADE_RETRO]: "Vade Retro", // 653
  [CollectibleType.FALSE_PHD]: "False PHD", // 654
  [CollectibleType.SPIN_TO_WIN]: "Spin to Win", // 655
  [CollectibleType.DAMOCLES_PASSIVE]: "Damocles (Passive)", // 656
  [CollectibleType.VASCULITIS]: "Vasculitis", // 657
  [CollectibleType.GIANT_CELL]: "Giant Cell", // 658
  [CollectibleType.TROPICAMIDE]: "Tropicamide", // 659
  [CollectibleType.CARD_READING]: "Card Reading", // 660
  [CollectibleType.QUINTS]: "Quints", // 661
  // There is no `CollectibleType` with a value of 662.
  [CollectibleType.TOOTH_AND_NAIL]: "Tooth and Nail", // 663
  [CollectibleType.BINGE_EATER]: "Binge Eater", // 664
  [CollectibleType.GUPPYS_EYE]: "Guppy's Eye", // 665
  // There is no `CollectibleType` with a value of 666.
  [CollectibleType.STRAWMAN]: "Strawman", // 667
  [CollectibleType.DADS_NOTE]: "Dad's Note", // 668
  [CollectibleType.SAUSAGE]: "Sausage", // 669
  [CollectibleType.OPTIONS]: "Options?", // 670
  [CollectibleType.CANDY_HEART]: "Candy Heart", // 671
  [CollectibleType.POUND_OF_FLESH]: "A Pound of Flesh", // 672
  [CollectibleType.REDEMPTION]: "Redemption", // 673
  [CollectibleType.SPIRIT_SHACKLES]: "Spirit Shackles", // 674
  [CollectibleType.CRACKED_ORB]: "Cracked Orb", // 675
  [CollectibleType.EMPTY_HEART]: "Empty Heart", // 676
  [CollectibleType.ASTRAL_PROJECTION]: "Astral Projection", // 677
  [CollectibleType.C_SECTION]: "C Section", // 678
  [CollectibleType.LIL_ABADDON]: "Lil Abaddon", // 679
  [CollectibleType.MONTEZUMAS_REVENGE]: "Montezuma's Revenge", // 680
  [CollectibleType.LIL_PORTAL]: "Lil Portal", // 681
  [CollectibleType.WORM_FRIEND]: "Worm Friend", // 682
  [CollectibleType.BONE_SPURS]: "Bone Spurs", // 683
  [CollectibleType.HUNGRY_SOUL]: "Hungry Soul", // 684
  [CollectibleType.JAR_OF_WISPS]: "Jar of Wisps", // 685
  [CollectibleType.SOUL_LOCKET]: "Soul Locket", // 686
  [CollectibleType.FRIEND_FINDER]: "Friend Finder", // 687
  [CollectibleType.INNER_CHILD]: "Inner Child", // 688
  [CollectibleType.GLITCHED_CROWN]: "Glitched Crown", // 689
  [CollectibleType.JELLY_BELLY]: "Belly Jelly", // 690
  [CollectibleType.SACRED_ORB]: "Sacred Orb", // 691
  [CollectibleType.SANGUINE_BOND]: "Sanguine Bond", // 692
  [CollectibleType.SWARM]: "The Swarm", // 693
  [CollectibleType.HEARTBREAK]: "Heartbreak", // 694
  [CollectibleType.BLOODY_GUST]: "Bloody Gust", // 695
  [CollectibleType.SALVATION]: "Salvation", // 696
  [CollectibleType.VANISHING_TWIN]: "Vanishing Twin", // 697
  [CollectibleType.TWISTED_PAIR]: "Twisted Pair", // 698
  [CollectibleType.AZAZELS_RAGE]: "Azazel's Rage", // 699
  [CollectibleType.ECHO_CHAMBER]: "Echo Chamber", // 700
  [CollectibleType.ISAACS_TOMB]: "Isaac's Tomb", // 701
  [CollectibleType.VENGEFUL_SPIRIT]: "Vengeful Spirit", // 702
  [CollectibleType.ESAU_JR]: "Esau Jr.", // 703
  [CollectibleType.BERSERK]: "Berserk!", // 704
  [CollectibleType.DARK_ARTS]: "Dark Arts", // 705
  [CollectibleType.ABYSS]: "Abyss", // 706
  [CollectibleType.SUPPER]: "Supper", // 707
  [CollectibleType.STAPLER]: "Stapler", // 708
  [CollectibleType.SUPLEX]: "Suplex!", // 709
  [CollectibleType.BAG_OF_CRAFTING]: "Bag of Crafting", // 710
  [CollectibleType.FLIP]: "Flip", // 711
  [CollectibleType.LEMEGETON]: "Lemegeton", // 712
  [CollectibleType.SUMPTORIUM]: "Sumptorium", // 713
  [CollectibleType.RECALL]: "Recall", // 714
  [CollectibleType.HOLD]: "Hold", // 715
  [CollectibleType.KEEPERS_SACK]: "Keeper's Sack", // 716
  [CollectibleType.KEEPERS_KIN]: "Keeper's Kin", // 717
  // There is no `CollectibleType` with a value of 718.
  [CollectibleType.KEEPERS_BOX]: "Keeper's Box", // 719
  [CollectibleType.EVERYTHING_JAR]: "Everything Jar", // 720
  [CollectibleType.TMTRAINER]: "TMTRAINER", // 721
  [CollectibleType.ANIMA_SOLA]: "Anima Sola", // 722
  [CollectibleType.SPINDOWN_DICE]: "Spindown Dice", // 723
  [CollectibleType.HYPERCOAGULATION]: "Hypercoagulation", // 724
  [CollectibleType.IBS]: "IBS", // 725
  [CollectibleType.HEMOPTYSIS]: "Hemoptysis", // 726
  [CollectibleType.GHOST_BOMBS]: "Ghost Bombs", // 727
  [CollectibleType.GELLO]: "Gello", // 728
  [CollectibleType.DECAP_ATTACK]: "Decap Attack", // 729
  [CollectibleType.GLASS_EYE]: "Glass Eye", // 730
  [CollectibleType.STYE]: "Stye", // 731
  [CollectibleType.MOMS_RING]: "Mom's Ring", // 732
} as const satisfies Record<CollectibleType, string>;

----
objects\colors.ts
/**
 * A collection of common colors that can be reused.
 *
 * Note that if you want to further modify these colors, you should copy them first with the
 * `copyColor` function.
 *
 * The non-standard colors come from:
 * https://htmlcolorcodes.com/color-names/
 */
export const COLORS = {
  Black: Color(0, 0, 0) as Readonly<Color>,
  Red: Color(1, 0, 0) as Readonly<Color>,
  Green: Color(0, 1, 0) as Readonly<Color>,
  Blue: Color(0, 0, 1) as Readonly<Color>,
  Yellow: Color(1, 1, 0) as Readonly<Color>,
  Cyan: Color(0, 1, 1) as Readonly<Color>,
  Magenta: Color(1, 0, 1) as Readonly<Color>,
  White: Color(1, 1, 1) as Readonly<Color>,

  Brown: Color(0.588, 0.294, 0) as Readonly<Color>,
  Gray: Color(0.5, 0.5, 0.5) as Readonly<Color>,
  Orange: Color(1, 0.647, 0) as Readonly<Color>,
  Purple: Color(0.5, 0, 0.5) as Readonly<Color>,
} as const;

----
objects\directionNames.ts
import { Direction } from "isaac-typescript-definitions";

export const DIRECTION_NAMES = {
  [Direction.NO_DIRECTION]: undefined, // -1
  [Direction.LEFT]: "left", // 0
  [Direction.UP]: "up", // 1
  [Direction.RIGHT]: "right", // 2
  [Direction.DOWN]: "down", // 3
} as const satisfies Record<Direction, string | undefined>;

----
objects\directionToDegrees.ts
import { Direction } from "isaac-typescript-definitions";

export const DIRECTION_TO_DEGREES = {
  [Direction.NO_DIRECTION]: 0, // -1
  [Direction.LEFT]: 180, // 0
  [Direction.UP]: 270, // 1
  [Direction.RIGHT]: 0, // 2
  [Direction.DOWN]: 90, // 3
} as const satisfies Record<Direction, int>;

----
objects\directionToMoveAction.ts
import { ButtonAction, Direction } from "isaac-typescript-definitions";

export const DIRECTION_TO_MOVE_ACTION = {
  [Direction.NO_DIRECTION]: undefined, // -1
  [Direction.LEFT]: ButtonAction.LEFT, // 0
  [Direction.UP]: ButtonAction.UP, // 1
  [Direction.RIGHT]: ButtonAction.RIGHT, // 2
  [Direction.DOWN]: ButtonAction.DOWN, // 3
} as const satisfies Record<Direction, ButtonAction | undefined>;

----
objects\directionToShootAction.ts
import { ButtonAction, Direction } from "isaac-typescript-definitions";

export const DIRECTION_TO_SHOOT_ACTION = {
  [Direction.NO_DIRECTION]: undefined, // -1
  [Direction.LEFT]: ButtonAction.SHOOT_LEFT, // 0
  [Direction.UP]: ButtonAction.SHOOT_UP, // 1
  [Direction.RIGHT]: ButtonAction.SHOOT_RIGHT, // 2
  [Direction.DOWN]: ButtonAction.SHOOT_DOWN, // 3
} as const satisfies Record<Direction, ButtonAction | undefined>;

----
objects\directionToVector.ts
import { Direction } from "isaac-typescript-definitions";
import { VectorZero } from "../core/constants";
import { newReadonlyVector } from "../functions/readOnly";

export const DIRECTION_TO_VECTOR = {
  [Direction.NO_DIRECTION]: VectorZero, // -1
  [Direction.LEFT]: newReadonlyVector(-1, 0), // 0
  [Direction.UP]: newReadonlyVector(0, -1), // 1
  [Direction.RIGHT]: newReadonlyVector(1, 0), // 2
  [Direction.DOWN]: newReadonlyVector(0, 1), // 3
} as const satisfies Record<Direction, Readonly<Vector>>;

----
objects\doorSlotFlagToDoorSlot.ts
import { DoorSlot, DoorSlotFlag } from "isaac-typescript-definitions";

export const DEFAULT_DOOR_SLOT = DoorSlot.NO_DOOR_SLOT;

export const DOOR_SLOT_FLAG_TO_DOOR_SLOT = {
  [DoorSlotFlag.LEFT_0]: DoorSlot.LEFT_0, // 0
  [DoorSlotFlag.UP_0]: DoorSlot.UP_0, // 1
  [DoorSlotFlag.RIGHT_0]: DoorSlot.RIGHT_0, // 2
  [DoorSlotFlag.DOWN_0]: DoorSlot.DOWN_0, // 3
  [DoorSlotFlag.LEFT_1]: DoorSlot.LEFT_1, // 4
  [DoorSlotFlag.UP_1]: DoorSlot.UP_1, // 5
  [DoorSlotFlag.RIGHT_1]: DoorSlot.RIGHT_1, // 6
  [DoorSlotFlag.DOWN_1]: DoorSlot.DOWN_1, // 7
} as const satisfies Record<DoorSlotFlag, DoorSlot>;

----
objects\doorSlotToDirection.ts
import { Direction, DoorSlot } from "isaac-typescript-definitions";

export const DOOR_SLOT_TO_DIRECTION = {
  [DoorSlot.NO_DOOR_SLOT]: Direction.NO_DIRECTION, // -1
  [DoorSlot.LEFT_0]: Direction.LEFT, // 0
  [DoorSlot.UP_0]: Direction.UP, // 1
  [DoorSlot.RIGHT_0]: Direction.RIGHT, // 2
  [DoorSlot.DOWN_0]: Direction.DOWN, // 3
  [DoorSlot.LEFT_1]: Direction.LEFT, // 4
  [DoorSlot.UP_1]: Direction.UP, // 5
  [DoorSlot.RIGHT_1]: Direction.RIGHT, // 6
  [DoorSlot.DOWN_1]: Direction.DOWN, // 7
} as const satisfies Record<DoorSlot, Direction>;

----
objects\doorSlotToDoorSlotFlag.ts
import {
  DoorSlot,
  DoorSlotFlag,
  DoorSlotFlagZero,
} from "isaac-typescript-definitions";

export const DOOR_SLOT_TO_DOOR_SLOT_FLAG = {
  [DoorSlot.NO_DOOR_SLOT]: DoorSlotFlagZero, // -1
  [DoorSlot.LEFT_0]: DoorSlotFlag.LEFT_0, // 0
  [DoorSlot.UP_0]: DoorSlotFlag.UP_0, // 1
  [DoorSlot.RIGHT_0]: DoorSlotFlag.RIGHT_0, // 2
  [DoorSlot.DOWN_0]: DoorSlotFlag.DOWN_0, // 3
  [DoorSlot.LEFT_1]: DoorSlotFlag.LEFT_1, // 4
  [DoorSlot.UP_1]: DoorSlotFlag.UP_1, // 5
  [DoorSlot.RIGHT_1]: DoorSlotFlag.RIGHT_1, // 6
  [DoorSlot.DOWN_1]: DoorSlotFlag.DOWN_1, // 7
} as const satisfies Record<DoorSlot, DoorSlotFlag>;

----
objects\gridEntityTypeToANM2Name.ts
import { GridEntityType } from "isaac-typescript-definitions";

// cspell:disable

/** These files exist in the "gfx/grid" directory. */
export const GRID_ENTITY_TYPE_TO_ANM2_NAME = {
  [GridEntityType.NULL]: undefined, // 0
  // There are more decoration ANM2 files; see the `getGridEntityANM2Path` function.
  [GridEntityType.DECORATION]: "Props_01_Basement.anm2", // 1
  [GridEntityType.ROCK]: "grid_rock.anm2", // 2
  [GridEntityType.BLOCK]: "grid_rock.anm2", // 3
  [GridEntityType.ROCK_TINTED]: "grid_rock.anm2", // 4
  [GridEntityType.ROCK_BOMB]: "grid_rock.anm2", // 5
  [GridEntityType.ROCK_ALT]: "grid_rock.anm2", // 6
  [GridEntityType.PIT]: "grid_pit.anm2", // 7
  [GridEntityType.SPIKES]: "grid_spikes.anm2", // 8
  [GridEntityType.SPIKES_ON_OFF]: "grid_spikes.anm2", // 9
  [GridEntityType.SPIDER_WEB]: "grid_web.anm2", // 10
  [GridEntityType.LOCK]: "grid_locks.anm2", // 11
  [GridEntityType.TNT]: "grid_tnt.anm2", // 12
  [GridEntityType.FIREPLACE]: "grid_fireplace.anm2", // 13
  [GridEntityType.POOP]: "grid_poop.anm2", // 14
  [GridEntityType.WALL]: undefined, // 15
  [GridEntityType.DOOR]: undefined, // 16
  [GridEntityType.TRAPDOOR]: "Door_11_TrapDoor.anm2", // 17
  [GridEntityType.CRAWL_SPACE]: "door_20_secrettrapdoor.anm2", // 18
  [GridEntityType.GRAVITY]: undefined, // 19
  [GridEntityType.PRESSURE_PLATE]: "grid_pressureplate.anm2", // 20
  [GridEntityType.STATUE]: undefined, // 21
  [GridEntityType.ROCK_SUPER_SPECIAL]: "grid_rock.anm2", // 22
  [GridEntityType.TELEPORTER]: "grid_teleporter.anm2", // 23
  [GridEntityType.PILLAR]: "grid_rock.anm2", // 24
  [GridEntityType.ROCK_SPIKED]: "grid_rock.anm2", // 25
  [GridEntityType.ROCK_ALT_2]: "grid_rock.anm2", // 26
  [GridEntityType.ROCK_GOLD]: "grid_rock.anm2", // 27
} as const satisfies Record<GridEntityType, string | undefined>;

----
objects\heartNames.ts
import { HeartSubType } from "isaac-typescript-definitions";

export const DEFAULT_HEART_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const HEART_NAMES = {
  [HeartSubType.NULL]: DEFAULT_HEART_NAME, // 0
  [HeartSubType.FULL]: "Heart", // 1
  [HeartSubType.HALF]: "Heart (half)", // 2
  [HeartSubType.SOUL]: "Heart (soul)", // 3
  [HeartSubType.ETERNAL]: "Heart (eternal)", // 4
  [HeartSubType.DOUBLE_PACK]: "Heart (double)", // 5
  [HeartSubType.BLACK]: "Black Heart", // 6
  [HeartSubType.GOLDEN]: "Gold Heart", // 7
  [HeartSubType.HALF_SOUL]: "Heart (half soul)", // 8
  [HeartSubType.SCARED]: "Scared Heart", // 9
  [HeartSubType.BLENDED]: "Blended Heart", // 10
  [HeartSubType.BONE]: "Bone Heart", // 11
  [HeartSubType.ROTTEN]: "Rotten Heart", // 12
} as const satisfies Record<HeartSubType, string>;

----
objects\isaacAPIClassTypeToBrand.ts
import { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import { SerializationBrand } from "../enums/private/SerializationBrand";

export const ISAAC_API_CLASS_TYPE_TO_BRAND = {
  [CopyableIsaacAPIClassType.BIT_SET_128]: SerializationBrand.BIT_SET_128,
  [CopyableIsaacAPIClassType.COLOR]: SerializationBrand.COLOR,
  [CopyableIsaacAPIClassType.K_COLOR]: SerializationBrand.K_COLOR,
  [CopyableIsaacAPIClassType.RNG]: SerializationBrand.RNG,
  [CopyableIsaacAPIClassType.VECTOR]: SerializationBrand.VECTOR,
} as const satisfies Record<CopyableIsaacAPIClassType, SerializationBrand>;

----
objects\isaacAPIClassTypeToFunctions.ts
import { CopyableIsaacAPIClassType } from "isaac-typescript-definitions";
import type { SerializedBitSet128 } from "../functions/bitSet128";
import {
  copyBitSet128,
  deserializeBitSet128,
  isBitSet128,
  isSerializedBitSet128,
  serializeBitSet128,
} from "../functions/bitSet128";
import type { SerializedColor } from "../functions/color";
import {
  copyColor,
  deserializeColor,
  isColor,
  isSerializedColor,
  serializeColor,
} from "../functions/color";
import type { SerializedKColor } from "../functions/kColor";
import {
  copyKColor,
  deserializeKColor,
  isKColor,
  isSerializedKColor,
  serializeKColor,
} from "../functions/kColor";
import type { SerializedRNG } from "../functions/rng";
import {
  copyRNG,
  deserializeRNG,
  isRNG,
  isSerializedRNG,
  serializeRNG,
} from "../functions/rng";
import type { SerializedVector } from "../functions/vector";
import {
  copyVector,
  deserializeVector,
  isSerializedVector,
  isVector,
  serializeVector,
} from "../functions/vector";

/** A type representing an Isaac API class that can be safely copied or serialized. */
export type CopyableIsaacAPIClass = BitSet128 | Color | KColor | RNG | Vector;

/**
 * A type representing an Isaac API class like `Color` or `RNG` that has been written to the
 * "save#.dat" file. It is used by the save data manager when reading and writing to that file.
 *
 * For the list of supported classes, see the `CopyableIsaacAPIClassType` enum.
 */
export type SerializedIsaacAPIClass =
  | SerializedBitSet128
  | SerializedColor
  | SerializedKColor
  | SerializedRNG
  | SerializedVector;

export interface IsaacAPIClassTypeToType {
  [CopyableIsaacAPIClassType.BIT_SET_128]: BitSet128;
  [CopyableIsaacAPIClassType.COLOR]: Color;
  [CopyableIsaacAPIClassType.K_COLOR]: KColor;
  [CopyableIsaacAPIClassType.RNG]: RNG;
  [CopyableIsaacAPIClassType.VECTOR]: Vector;
}

export interface IsaacAPIClassTypeToSerializedType {
  [CopyableIsaacAPIClassType.BIT_SET_128]: SerializedBitSet128;
  [CopyableIsaacAPIClassType.COLOR]: SerializedColor;
  [CopyableIsaacAPIClassType.K_COLOR]: SerializedKColor;
  [CopyableIsaacAPIClassType.RNG]: SerializedRNG;
  [CopyableIsaacAPIClassType.VECTOR]: SerializedVector;
}

export interface IsaacAPIClassTypeFunctions<T, SerializedT> {
  is: (object: unknown) => object is T;
  isSerialized: (object: unknown) => object is SerializedT;
  copy: (object: T) => T;
  serialize: (object: T) => SerializedT;
  deserialize: (object: SerializedT) => T;
}

type IsaacAPIClassTypeToFunctions = {
  readonly [K in CopyableIsaacAPIClassType]: IsaacAPIClassTypeFunctions<
    IsaacAPIClassTypeToType[K],
    IsaacAPIClassTypeToSerializedType[K]
  >;
};

export const ISAAC_API_CLASS_TYPE_TO_FUNCTIONS = {
  [CopyableIsaacAPIClassType.BIT_SET_128]: {
    is: isBitSet128,
    isSerialized: isSerializedBitSet128,
    copy: copyBitSet128,
    serialize: serializeBitSet128,
    deserialize: deserializeBitSet128,
  },
  [CopyableIsaacAPIClassType.COLOR]: {
    is: isColor,
    isSerialized: isSerializedColor,
    copy: copyColor,
    serialize: serializeColor,
    deserialize: deserializeColor,
  },
  [CopyableIsaacAPIClassType.K_COLOR]: {
    is: isKColor,
    isSerialized: isSerializedKColor,
    copy: copyKColor,
    serialize: serializeKColor,
    deserialize: deserializeKColor,
  },
  [CopyableIsaacAPIClassType.RNG]: {
    is: isRNG,
    isSerialized: isSerializedRNG,
    copy: copyRNG,
    serialize: serializeRNG,
    deserialize: deserializeRNG,
  },
  [CopyableIsaacAPIClassType.VECTOR]: {
    is: isVector,
    isSerialized: isSerializedVector,
    copy: copyVector,
    serialize: serializeVector,
    deserialize: deserializeVector,
  },
} as const satisfies IsaacAPIClassTypeToFunctions;

----
objects\itemPoolTypeToCollectibleTypesSet.ts
import type {
  CollectibleType,
  ItemPoolType,
} from "isaac-typescript-definitions";
import { ITEM_POOL_TYPE_VALUES } from "../cachedEnumValues";
import * as itemPoolsJSON from "../data/itempools.json";
import { asCollectibleType, parseIntSafe } from "../functions/types";
import { ITEM_POOL_TYPE_TO_ITEM_POOL_NAME } from "../maps/itemPoolTypeToItemPoolName";

export const ITEM_POOL_TYPE_TO_COLLECTIBLE_TYPES_SET: Readonly<
  Record<ItemPoolType, ReadonlySet<CollectibleType>>
> = (() => {
  const itemPoolTypeToCollectibleTypes: Partial<
    Record<ItemPoolType, ReadonlySet<CollectibleType>>
  > = {};

  for (const itemPoolType of ITEM_POOL_TYPE_VALUES) {
    const itemPoolJSON = getItemPoolJSON(itemPoolType);
    if (itemPoolJSON === undefined) {
      itemPoolTypeToCollectibleTypes[itemPoolType] = new Set();
    } else {
      const collectibleTypesSet = new Set<CollectibleType>();

      for (const itemPoolJSONElement of itemPoolJSON.Item) {
        const collectibleTypeInt = parseIntSafe(itemPoolJSONElement.$.Id);
        if (collectibleTypeInt === undefined) {
          error(
            `Failed to parse a collectible type in the "itempools.json" file: ${itemPoolJSONElement.$.Id}`,
          );
        }

        const collectibleType = asCollectibleType(collectibleTypeInt);
        collectibleTypesSet.add(collectibleType);
      }

      itemPoolTypeToCollectibleTypes[itemPoolType] = collectibleTypesSet;
    }
  }

  return itemPoolTypeToCollectibleTypes as Record<
    ItemPoolType,
    ReadonlySet<CollectibleType>
  >;
})();

function getItemPoolJSON(itemPoolType: ItemPoolType) {
  const itemPoolName = ITEM_POOL_TYPE_TO_ITEM_POOL_NAME[itemPoolType];

  const itemPoolsJSONArray = itemPoolsJSON.ItemPools.Pool;

  return itemPoolsJSONArray.find(
    (itemPoolJSON) => itemPoolJSON.$.Name === itemPoolName,
  );
}

----
objects\kColors.ts
/**
 * A collection of common colors that can be reused.
 *
 * Note that if you want to further modify these colors, you should copy them first with the
 * `copyColor` function.
 *
 * The non-standard colors come from:
 * https://htmlcolorcodes.com/color-names/
 */
export const K_COLORS = {
  Black: KColor(0, 0, 0, 1) as Readonly<KColor>,
  Red: KColor(1, 0, 0, 1) as Readonly<KColor>,
  Green: KColor(0, 1, 0, 1) as Readonly<KColor>,
  Blue: KColor(0, 0, 1, 1) as Readonly<KColor>,
  Yellow: KColor(1, 1, 0, 1) as Readonly<KColor>,
  Cyan: KColor(0, 1, 1, 1) as Readonly<KColor>,
  Magenta: KColor(1, 0, 1, 1) as Readonly<KColor>,
  White: KColor(1, 1, 1, 1) as Readonly<KColor>,
  Transparent: KColor(0, 0, 0, 0) as Readonly<KColor>,

  Brown: KColor(0.588, 0.294, 0, 1) as Readonly<KColor>,
  Gray: KColor(0.5, 0.5, 0.5, 1) as Readonly<KColor>,
  Orange: KColor(1, 0.647, 0, 1) as Readonly<KColor>,
  Purple: KColor(0.5, 0, 0.5, 1) as Readonly<KColor>,
} as const;

----
objects\keyNames.ts
import { KeySubType } from "isaac-typescript-definitions";

export const DEFAULT_KEY_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const KEY_NAMES = {
  [KeySubType.NULL]: DEFAULT_KEY_NAME, // 0
  [KeySubType.NORMAL]: "Key", // 1
  [KeySubType.GOLDEN]: "Golden Key", // 2
  [KeySubType.DOUBLE_PACK]: "Key Ring", // 3
  [KeySubType.CHARGED]: "Charged Key", // 4
} as const satisfies Record<KeySubType, string>;

----
objects\languageNames.ts
import { LanguageAbbreviation } from "isaac-typescript-definitions";

export const LANGUAGE_NAMES = {
  [LanguageAbbreviation.ENGLISH]: "English", // "en"
  [LanguageAbbreviation.JAPANESE]: "Japanese", // "jp"
  [LanguageAbbreviation.KOREAN]: "Korean", // "kr"
  [LanguageAbbreviation.CHINESE_SIMPLE]: "Chinese (Simple)", // "zh"
  [LanguageAbbreviation.RUSSIAN]: "Russian", // "ru"
  [LanguageAbbreviation.GERMAN]: "German", // "de"
  [LanguageAbbreviation.SPANISH]: "Spanish", // "es"
} as const satisfies Record<LanguageAbbreviation, string>;

----
objects\oppositeDoorSlots.ts
import { DoorSlot } from "isaac-typescript-definitions";

export const OPPOSITE_DOOR_SLOTS = {
  [DoorSlot.NO_DOOR_SLOT]: undefined, // -1
  [DoorSlot.LEFT_0]: DoorSlot.RIGHT_0, // 0
  [DoorSlot.UP_0]: DoorSlot.DOWN_0, // 1
  [DoorSlot.RIGHT_0]: DoorSlot.LEFT_0, // 2
  [DoorSlot.DOWN_0]: DoorSlot.UP_0, // 3
  [DoorSlot.LEFT_1]: DoorSlot.RIGHT_1, // 4
  [DoorSlot.UP_1]: DoorSlot.DOWN_1, // 5
  [DoorSlot.RIGHT_1]: DoorSlot.LEFT_1, // 6
  [DoorSlot.DOWN_1]: DoorSlot.UP_1, // 7
} as const satisfies Record<DoorSlot, DoorSlot | undefined>;

----
objects\pillEffectClasses.ts
import {
  ItemConfigPillEffectClass,
  PillEffect,
} from "isaac-typescript-definitions";

export const DEFAULT_PILL_EFFECT_CLASS = ItemConfigPillEffectClass.MODDED;

export const PILL_EFFECT_CLASSES = {
  [PillEffect.BAD_GAS]: ItemConfigPillEffectClass.MINOR, // 0
  [PillEffect.BAD_TRIP]: ItemConfigPillEffectClass.MEDIUM, // 1
  [PillEffect.BALLS_OF_STEEL]: ItemConfigPillEffectClass.MEDIUM, // 2
  [PillEffect.BOMBS_ARE_KEYS]: ItemConfigPillEffectClass.MEDIUM, // 3
  [PillEffect.EXPLOSIVE_DIARRHEA]: ItemConfigPillEffectClass.MINOR, // 4
  [PillEffect.FULL_HEALTH]: ItemConfigPillEffectClass.MEDIUM, // 5
  [PillEffect.HEALTH_DOWN]: ItemConfigPillEffectClass.MAJOR, // 6
  [PillEffect.HEALTH_UP]: ItemConfigPillEffectClass.MAJOR, // 7
  [PillEffect.I_FOUND_PILLS]: ItemConfigPillEffectClass.JOKE, // 8
  [PillEffect.PUBERTY]: ItemConfigPillEffectClass.JOKE, // 9
  [PillEffect.PRETTY_FLY]: ItemConfigPillEffectClass.MEDIUM, // 10
  [PillEffect.RANGE_DOWN]: ItemConfigPillEffectClass.MAJOR, // 11
  [PillEffect.RANGE_UP]: ItemConfigPillEffectClass.MAJOR, // 12
  [PillEffect.SPEED_DOWN]: ItemConfigPillEffectClass.MAJOR, // 13
  [PillEffect.SPEED_UP]: ItemConfigPillEffectClass.MAJOR, // 14
  [PillEffect.TEARS_DOWN]: ItemConfigPillEffectClass.MAJOR, // 15
  [PillEffect.TEARS_UP]: ItemConfigPillEffectClass.MAJOR, // 16
  [PillEffect.LUCK_DOWN]: ItemConfigPillEffectClass.MAJOR, // 17
  [PillEffect.LUCK_UP]: ItemConfigPillEffectClass.MAJOR, // 18
  [PillEffect.TELEPILLS]: ItemConfigPillEffectClass.MAJOR, // 19
  [PillEffect.FORTY_EIGHT_HOUR_ENERGY]: ItemConfigPillEffectClass.MEDIUM, // 20
  [PillEffect.HEMATEMESIS]: ItemConfigPillEffectClass.MEDIUM, // 21
  [PillEffect.PARALYSIS]: ItemConfigPillEffectClass.MINOR, // 22
  [PillEffect.I_CAN_SEE_FOREVER]: ItemConfigPillEffectClass.MEDIUM, // 23
  [PillEffect.PHEROMONES]: ItemConfigPillEffectClass.MINOR, // 24
  [PillEffect.AMNESIA]: ItemConfigPillEffectClass.MEDIUM, // 25
  [PillEffect.LEMON_PARTY]: ItemConfigPillEffectClass.MINOR, // 26
  [PillEffect.R_U_A_WIZARD]: ItemConfigPillEffectClass.MINOR, // 27
  [PillEffect.PERCS]: ItemConfigPillEffectClass.MINOR, // 28
  [PillEffect.ADDICTED]: ItemConfigPillEffectClass.MINOR, // 29
  [PillEffect.RELAX]: ItemConfigPillEffectClass.JOKE, // 30
  [PillEffect.QUESTION_MARKS]: ItemConfigPillEffectClass.MINOR, // 31
  [PillEffect.ONE_MAKES_YOU_LARGER]: ItemConfigPillEffectClass.MINOR, // 32
  [PillEffect.ONE_MAKES_YOU_SMALL]: ItemConfigPillEffectClass.MINOR, // 33
  [PillEffect.INFESTED_EXCLAMATION]: ItemConfigPillEffectClass.MINOR, // 34
  [PillEffect.INFESTED_QUESTION]: ItemConfigPillEffectClass.MINOR, // 35
  [PillEffect.POWER]: ItemConfigPillEffectClass.MINOR, // 36
  [PillEffect.RETRO_VISION]: ItemConfigPillEffectClass.MINOR, // 37
  [PillEffect.FRIENDS_TILL_THE_END]: ItemConfigPillEffectClass.MINOR, // 38
  [PillEffect.X_LAX]: ItemConfigPillEffectClass.MINOR, // 39
  [PillEffect.SOMETHINGS_WRONG]: ItemConfigPillEffectClass.JOKE, // 40
  [PillEffect.IM_DROWSY]: ItemConfigPillEffectClass.MINOR, // 41
  [PillEffect.IM_EXCITED]: ItemConfigPillEffectClass.MINOR, // 42
  [PillEffect.GULP]: ItemConfigPillEffectClass.MEDIUM, // 43
  [PillEffect.HORF]: ItemConfigPillEffectClass.JOKE, // 44
  [PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE]:
    ItemConfigPillEffectClass.MINOR, // 45
  [PillEffect.VURP]: ItemConfigPillEffectClass.MEDIUM, // 46
  [PillEffect.SHOT_SPEED_DOWN]: ItemConfigPillEffectClass.MAJOR, // 47
  [PillEffect.SHOT_SPEED_UP]: ItemConfigPillEffectClass.MAJOR, // 48
  [PillEffect.EXPERIMENTAL]: ItemConfigPillEffectClass.MAJOR, // 49
} as const satisfies Record<PillEffect, ItemConfigPillEffectClass>;

----
objects\pillEffectNames.ts
import { PillEffect } from "isaac-typescript-definitions";

export const DEFAULT_PILL_EFFECT_NAME = "Unknown";

export const PILL_EFFECT_NAMES = {
  [PillEffect.BAD_GAS]: "Bad Gas", // 0
  [PillEffect.BAD_TRIP]: "Bad Trip", // 1
  [PillEffect.BALLS_OF_STEEL]: "Balls of Steel", // 2
  [PillEffect.BOMBS_ARE_KEYS]: "Bombs Are Key", // 3
  [PillEffect.EXPLOSIVE_DIARRHEA]: "Explosive Diarrhea", // 4
  [PillEffect.FULL_HEALTH]: "Full Health", // 5
  [PillEffect.HEALTH_DOWN]: "Health Down", // 6
  [PillEffect.HEALTH_UP]: "Health Up", // 7
  [PillEffect.I_FOUND_PILLS]: "I Found Pills", // 8
  [PillEffect.PUBERTY]: "Puberty", // 9
  [PillEffect.PRETTY_FLY]: "Pretty Fly", // 10
  [PillEffect.RANGE_DOWN]: "Range Down", // 11
  [PillEffect.RANGE_UP]: "Range Up", // 12
  [PillEffect.SPEED_DOWN]: "Speed Down", // 13
  [PillEffect.SPEED_UP]: "Speed Up", // 14
  [PillEffect.TEARS_DOWN]: "Tears Down", // 15
  [PillEffect.TEARS_UP]: "Tears Up", // 16
  [PillEffect.LUCK_DOWN]: "Luck Down", // 17
  [PillEffect.LUCK_UP]: "Luck Up", // 18
  [PillEffect.TELEPILLS]: "Telepills", // 19
  [PillEffect.FORTY_EIGHT_HOUR_ENERGY]: "48 Hour Energy", // 20
  [PillEffect.HEMATEMESIS]: "Hematemesis", // 21
  [PillEffect.PARALYSIS]: "Paralysis", // 22
  [PillEffect.I_CAN_SEE_FOREVER]: "I can see forever!", // 23
  [PillEffect.PHEROMONES]: "Pheromones", // 24
  [PillEffect.AMNESIA]: "Amnesia", // 25
  [PillEffect.LEMON_PARTY]: "Lemon Party", // 26
  [PillEffect.R_U_A_WIZARD]: "R U a Wizard?", // 27
  [PillEffect.PERCS]: "Percs!", // 28
  [PillEffect.ADDICTED]: "Addicted!", // 29
  [PillEffect.RELAX]: "Re-Lax", // 30
  [PillEffect.QUESTION_MARKS]: "???", // 31
  [PillEffect.ONE_MAKES_YOU_LARGER]: "One makes you larger", // 32
  [PillEffect.ONE_MAKES_YOU_SMALL]: "One makes you small", // 33
  [PillEffect.INFESTED_EXCLAMATION]: "Infested!", // 34
  [PillEffect.INFESTED_QUESTION]: "Infested?", // 35
  [PillEffect.POWER]: "Power Pill!", // 36
  [PillEffect.RETRO_VISION]: "Retro Vision", // 37
  [PillEffect.FRIENDS_TILL_THE_END]: "Friends Till The End!", // 38
  [PillEffect.X_LAX]: "X-Lax", // 39
  [PillEffect.SOMETHINGS_WRONG]: "Something's wrong...", // 40
  [PillEffect.IM_DROWSY]: "I'm Drowsy...", // 41
  [PillEffect.IM_EXCITED]: "I'm Excited!!!", // 42
  [PillEffect.GULP]: "Gulp!", // 43
  [PillEffect.HORF]: "Horf!", // 44
  [PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE]:
    "Feels like I'm walking on sunshine!", // 45
  [PillEffect.VURP]: "Vurp!", // 46
  [PillEffect.SHOT_SPEED_DOWN]: "Shot Speed Down", // 47
  [PillEffect.SHOT_SPEED_UP]: "Shot Speed Up", // 48
  [PillEffect.EXPERIMENTAL]: "Experimental Pill", // 49
} as const satisfies Record<PillEffect, string>;

----
objects\pillEffectTypeToPillEffects.ts
import type { PillEffect } from "isaac-typescript-definitions";
import { ItemConfigPillEffectType } from "isaac-typescript-definitions";
import { VANILLA_PILL_EFFECTS } from "../core/constantsVanilla";
import { filterMap } from "../functions/array";
import { PILL_EFFECT_TYPES } from "./pillEffectTypes";

export const PILL_EFFECT_TYPE_TO_PILL_EFFECTS = {
  // 0
  [ItemConfigPillEffectType.POSITIVE]: getPillEffectsOfType(
    ItemConfigPillEffectType.POSITIVE,
  ),

  // 1
  [ItemConfigPillEffectType.NEGATIVE]: getPillEffectsOfType(
    ItemConfigPillEffectType.NEGATIVE,
  ),

  // 2
  [ItemConfigPillEffectType.NEUTRAL]: getPillEffectsOfType(
    ItemConfigPillEffectType.NEUTRAL,
  ),

  // 3
  [ItemConfigPillEffectType.MODDED]: getPillEffectsOfType(
    ItemConfigPillEffectType.MODDED,
  ),
} as const satisfies Record<ItemConfigPillEffectType, readonly PillEffect[]>;

function getPillEffectsOfType(
  matchingPillEffectType: ItemConfigPillEffectType,
): readonly PillEffect[] {
  return filterMap(VANILLA_PILL_EFFECTS, (pillEffect) => {
    const pillEffectType = PILL_EFFECT_TYPES[pillEffect];
    return pillEffectType === matchingPillEffectType ? pillEffect : undefined;
  });
}

----
objects\pillEffectTypes.ts
import {
  ItemConfigPillEffectType,
  PillEffect,
} from "isaac-typescript-definitions";

export const DEFAULT_PILL_EFFECT_TYPE = ItemConfigPillEffectType.MODDED;

export const PILL_EFFECT_TYPES = {
  [PillEffect.BAD_GAS]: ItemConfigPillEffectType.POSITIVE, // 0
  [PillEffect.BAD_TRIP]: ItemConfigPillEffectType.NEGATIVE, // 1
  [PillEffect.BALLS_OF_STEEL]: ItemConfigPillEffectType.POSITIVE, // 2
  [PillEffect.BOMBS_ARE_KEYS]: ItemConfigPillEffectType.NEUTRAL, // 3
  [PillEffect.EXPLOSIVE_DIARRHEA]: ItemConfigPillEffectType.NEUTRAL, // 4
  [PillEffect.FULL_HEALTH]: ItemConfigPillEffectType.POSITIVE, // 5
  [PillEffect.HEALTH_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 6
  [PillEffect.HEALTH_UP]: ItemConfigPillEffectType.POSITIVE, // 7
  [PillEffect.I_FOUND_PILLS]: ItemConfigPillEffectType.NEUTRAL, // 8
  [PillEffect.PUBERTY]: ItemConfigPillEffectType.NEUTRAL, // 9
  [PillEffect.PRETTY_FLY]: ItemConfigPillEffectType.POSITIVE, // 10
  [PillEffect.RANGE_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 11
  [PillEffect.RANGE_UP]: ItemConfigPillEffectType.POSITIVE, // 12
  [PillEffect.SPEED_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 13
  [PillEffect.SPEED_UP]: ItemConfigPillEffectType.POSITIVE, // 14
  [PillEffect.TEARS_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 15
  [PillEffect.TEARS_UP]: ItemConfigPillEffectType.POSITIVE, // 16
  [PillEffect.LUCK_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 17
  [PillEffect.LUCK_UP]: ItemConfigPillEffectType.POSITIVE, // 18
  [PillEffect.TELEPILLS]: ItemConfigPillEffectType.NEUTRAL, // 19
  [PillEffect.FORTY_EIGHT_HOUR_ENERGY]: ItemConfigPillEffectType.POSITIVE, // 20
  [PillEffect.HEMATEMESIS]: ItemConfigPillEffectType.NEUTRAL, // 21
  [PillEffect.PARALYSIS]: ItemConfigPillEffectType.NEGATIVE, // 22
  [PillEffect.I_CAN_SEE_FOREVER]: ItemConfigPillEffectType.POSITIVE, // 23
  [PillEffect.PHEROMONES]: ItemConfigPillEffectType.POSITIVE, // 24
  [PillEffect.AMNESIA]: ItemConfigPillEffectType.NEGATIVE, // 25
  [PillEffect.LEMON_PARTY]: ItemConfigPillEffectType.POSITIVE, // 26
  [PillEffect.R_U_A_WIZARD]: ItemConfigPillEffectType.NEGATIVE, // 27
  [PillEffect.PERCS]: ItemConfigPillEffectType.POSITIVE, // 28
  [PillEffect.ADDICTED]: ItemConfigPillEffectType.NEGATIVE, // 29
  [PillEffect.RELAX]: ItemConfigPillEffectType.NEUTRAL, // 30
  [PillEffect.QUESTION_MARKS]: ItemConfigPillEffectType.NEGATIVE, // 31
  [PillEffect.ONE_MAKES_YOU_LARGER]: ItemConfigPillEffectType.NEUTRAL, // 32
  [PillEffect.ONE_MAKES_YOU_SMALL]: ItemConfigPillEffectType.NEUTRAL, // 33
  [PillEffect.INFESTED_EXCLAMATION]: ItemConfigPillEffectType.POSITIVE, // 34
  [PillEffect.INFESTED_QUESTION]: ItemConfigPillEffectType.POSITIVE, // 35
  [PillEffect.POWER]: ItemConfigPillEffectType.POSITIVE, // 36
  [PillEffect.RETRO_VISION]: ItemConfigPillEffectType.NEGATIVE, // 37
  [PillEffect.FRIENDS_TILL_THE_END]: ItemConfigPillEffectType.POSITIVE, // 38
  [PillEffect.X_LAX]: ItemConfigPillEffectType.NEGATIVE, // 39
  [PillEffect.SOMETHINGS_WRONG]: ItemConfigPillEffectType.POSITIVE, // 40
  [PillEffect.IM_DROWSY]: ItemConfigPillEffectType.NEUTRAL, // 41
  [PillEffect.IM_EXCITED]: ItemConfigPillEffectType.NEUTRAL, // 42
  [PillEffect.GULP]: ItemConfigPillEffectType.POSITIVE, // 43
  [PillEffect.HORF]: ItemConfigPillEffectType.NEUTRAL, // 44
  [PillEffect.FEELS_LIKE_IM_WALKING_ON_SUNSHINE]:
    ItemConfigPillEffectType.POSITIVE, // 45
  [PillEffect.VURP]: ItemConfigPillEffectType.POSITIVE, // 46
  [PillEffect.SHOT_SPEED_DOWN]: ItemConfigPillEffectType.NEGATIVE, // 47
  [PillEffect.SHOT_SPEED_UP]: ItemConfigPillEffectType.POSITIVE, // 48
  [PillEffect.EXPERIMENTAL]: ItemConfigPillEffectType.NEUTRAL, // 49
} as const satisfies Record<PillEffect, ItemConfigPillEffectType>;

----
objects\playerNamePNGFileNames.ts
// cspell:disable

import { PlayerType } from "isaac-typescript-definitions";

/** Used when rendering the "versusscreen.anm2" sprite. */
export const PLAYER_NAME_PNG_FILE_NAMES = {
  [PlayerType.POSSESSOR]: undefined, // -1
  [PlayerType.ISAAC]: "playername_01_isaac.png", // 0
  [PlayerType.MAGDALENE]: "playername_02_magdalene.png", // 1
  [PlayerType.CAIN]: "playername_03_cain.png", // 2
  [PlayerType.JUDAS]: "playername_04_judas.png", // 3
  [PlayerType.BLUE_BABY]: "playername_06_bluebaby.png", // 4
  [PlayerType.EVE]: "playername_05_eve.png", // 5
  [PlayerType.SAMSON]: "playername_07_samson.png", // 6
  [PlayerType.AZAZEL]: "playername_08_azazel.png", // 7
  [PlayerType.LAZARUS]: "playername_10_lazarus.png", // 8
  [PlayerType.EDEN]: "playername_09_eden.png", // 9
  [PlayerType.LOST]: "playername_12_thelost.png", // 10
  // Lazarus 2 uses the same name as Lazarus 1.
  [PlayerType.LAZARUS_2]: "playername_10_lazarus.png", // 11
  // Dark Judas uses the same name as Judas.
  [PlayerType.DARK_JUDAS]: "playername_04_judas.png", // 12
  [PlayerType.LILITH]: "playername_13_lilith.png", // 13
  [PlayerType.KEEPER]: "playername_14_thekeeper.png", // 14
  [PlayerType.APOLLYON]: "playername_15_apollyon.png", // 15
  [PlayerType.FORGOTTEN]: "playername_16_theforgotten.png", // 16
  // The Soul the same name as The Forgotten.
  [PlayerType.SOUL]: "playername_16_theforgotten.png", // 17
  [PlayerType.BETHANY]: "playername_01x_bethany.png", // 18
  [PlayerType.JACOB]: "playername_02x_jacob_esau.png", // 19
  // Esau uses the same name as Jacob & Esau.
  [PlayerType.ESAU]: "playername_02x_jacob_esau.png", // 20
  [PlayerType.ISAAC_B]: "playername_01_isaac.png", // 21
  [PlayerType.MAGDALENE_B]: "playername_02_magdalene.png", // 22
  [PlayerType.CAIN_B]: "playername_03_cain.png", // 23
  [PlayerType.JUDAS_B]: "playername_04_judas.png", // 24
  [PlayerType.BLUE_BABY_B]: "playername_06_bluebaby.png", // 25
  [PlayerType.EVE_B]: "playername_05_eve.png", // 26
  [PlayerType.SAMSON_B]: "playername_07_samson.png", // 27
  [PlayerType.AZAZEL_B]: "playername_08_azazel.png", // 28
  [PlayerType.LAZARUS_B]: "playername_10_lazarus.png", // 29
  [PlayerType.EDEN_B]: "playername_09_eden.png", // 30
  [PlayerType.LOST_B]: "playername_12_thelost.png", // 31
  [PlayerType.LILITH_B]: "playername_13_lilith.png", // 32
  [PlayerType.KEEPER_B]: "playername_14_thekeeper.png", // 33
  [PlayerType.APOLLYON_B]: "playername_15_apollyon.png", // 34
  [PlayerType.FORGOTTEN_B]: "playername_16_theforgotten.png", // 35
  [PlayerType.BETHANY_B]: "playername_01x_bethany.png", // 36
  [PlayerType.JACOB_B]: "playername_02x_jacob.png", // 37
  // Dead Tainted Lazarus uses the same name as Tainted Lazarus.
  [PlayerType.LAZARUS_2_B]: "playername_10_lazarus.png", // 38
  // Tainted Jacob in "Lost" form uses the same name as Tainted Jacob.
  [PlayerType.JACOB_2_B]: "playername_02x_jacob.png", // 39
  // Tainted The Soul uses the same name as Tainted Forgotten.
  [PlayerType.SOUL_B]: "playername_16_theforgotten.png", // 40
} as const satisfies Record<PlayerType, string | undefined>;

----
objects\playerPortraitPNGFileNames.ts
// cspell:disable

import { PlayerType } from "isaac-typescript-definitions";

/** Used when rendering the "versusscreen.anm2" sprite. */
export const PLAYER_PORTRAIT_PNG_FILE_NAMES = {
  [PlayerType.POSSESSOR]: undefined, // -1
  [PlayerType.ISAAC]: "playerportrait_isaac.png", // 0
  [PlayerType.MAGDALENE]: "playerportrait_magdalene.png", // 1
  [PlayerType.CAIN]: "playerportrait_cain.png", // 2
  [PlayerType.JUDAS]: "playerportrait_judas.png", // 3
  [PlayerType.BLUE_BABY]: "playerportrait_bluebaby.png", // 4
  [PlayerType.EVE]: "playerportrait_eve.png", // 5
  [PlayerType.SAMSON]: "playerportrait_samson.png", // 6
  [PlayerType.AZAZEL]: "playerportrait_azazel.png", // 7
  [PlayerType.LAZARUS]: "playerportrait_lazarus.png", // 8
  [PlayerType.EDEN]: "playerportrait_eden.png", // 9
  [PlayerType.LOST]: "playerportrait_thelost.png", // 10
  [PlayerType.LAZARUS_2]: "playerportrait_lazarus2.png", // 11
  [PlayerType.DARK_JUDAS]: "playerportrait_darkjudas.png", // 12
  [PlayerType.LILITH]: "playerportrait_lilith.png", // 13
  [PlayerType.KEEPER]: "playerportrait_keeper.png", // 14
  [PlayerType.APOLLYON]: "playerportrait_apollyon.png", // 15
  [PlayerType.FORGOTTEN]: "playerportrait_theforgotten.png", // 16
  // The Soul the same name as The Forgotten.
  [PlayerType.SOUL]: "playerportrait_theforgotten.png", // 17
  [PlayerType.BETHANY]: "playerportrait_bethany.png", // 18
  [PlayerType.JACOB]: "playerportrait_jacob.png", // 19
  // Esau uses the same name as Jacob & Esau.
  [PlayerType.ESAU]: "playerportrait_jacob.png", // 20
  [PlayerType.ISAAC_B]: "playerportrait_isaac_b.png", // 21
  [PlayerType.MAGDALENE_B]: "playerportrait_magdalene_b.png", // 22
  [PlayerType.CAIN_B]: "playerportrait_cain_b.png", // 23
  [PlayerType.JUDAS_B]: "playerportrait_judas_b.png", // 24
  [PlayerType.BLUE_BABY_B]: "playerportrait_bluebaby_b.png", // 25
  [PlayerType.EVE_B]: "playerportrait_eve_b.png", // 26
  [PlayerType.SAMSON_B]: "playerportrait_samson_b.png", // 27
  [PlayerType.AZAZEL_B]: "playerportrait_azazel_b.png", // 28
  [PlayerType.LAZARUS_B]: "playerportrait_lazarus_b.png", // 29
  [PlayerType.EDEN_B]: "playerportrait_eden_b.png", // 30
  [PlayerType.LOST_B]: "playerportrait_thelost_b.png", // 31
  [PlayerType.LILITH_B]: "playerportrait_lilith_b.png", // 32
  [PlayerType.KEEPER_B]: "playerportrait_keeper_b.png", // 33
  [PlayerType.APOLLYON_B]: "playerportrait_apollyon_b.png", // 34
  [PlayerType.FORGOTTEN_B]: "playerportrait_theforgotten_b.png", // 35
  [PlayerType.BETHANY_B]: "playerportrait_bethany_b.png", // 36
  [PlayerType.JACOB_B]: "playerportrait_jacob_b.png", // 37
  [PlayerType.LAZARUS_2_B]: "playerportrait_lazarus_b_dead.png", // 38
  // Tainted Jacob in "Lost" form uses the same name as Tainted Jacob.
  [PlayerType.JACOB_2_B]: "playerportrait_jacob_b.png", // 39
  // Tainted The Soul uses the same name as Tainted Forgotten.
  [PlayerType.SOUL_B]: "playerportrait_theforgotten_b.png", // 40
} as const satisfies Record<PlayerType, string | undefined>;

----
objects\roomShapeBounds.ts
import { RoomShape } from "isaac-typescript-definitions";
import {
  NARROW_CONTENTS_HEIGHT,
  NARROW_CONTENTS_WIDTH,
  ONE_BY_ONE_CONTENTS_HEIGHT,
  ONE_BY_ONE_CONTENTS_WIDTH,
} from "./roomShapeVolumes";

const TWO_BY_TWO_BOUNDS = [
  ONE_BY_ONE_CONTENTS_WIDTH * 2,
  ONE_BY_ONE_CONTENTS_HEIGHT * 2,
] as const;

/**
 * The size of a room shape's contents. This does not include the tiles that the walls are on. L
 * rooms use the same bounds as a 2x2 room.
 */
export const ROOM_SHAPE_BOUNDS = {
  // 1
  [RoomShape.SHAPE_1x1]: [
    ONE_BY_ONE_CONTENTS_WIDTH,
    ONE_BY_ONE_CONTENTS_HEIGHT,
  ],

  // 2
  [RoomShape.IH]: [ONE_BY_ONE_CONTENTS_WIDTH, NARROW_CONTENTS_HEIGHT],

  // 3
  [RoomShape.IV]: [NARROW_CONTENTS_WIDTH, ONE_BY_ONE_CONTENTS_HEIGHT],

  // 4
  [RoomShape.SHAPE_1x2]: [
    ONE_BY_ONE_CONTENTS_WIDTH,
    ONE_BY_ONE_CONTENTS_HEIGHT * 2,
  ],

  // 5
  [RoomShape.IIV]: [NARROW_CONTENTS_WIDTH, ONE_BY_ONE_CONTENTS_HEIGHT * 2],

  // 6
  [RoomShape.SHAPE_2x1]: [
    ONE_BY_ONE_CONTENTS_WIDTH * 2,
    ONE_BY_ONE_CONTENTS_HEIGHT,
  ],

  // 7
  [RoomShape.IIH]: [ONE_BY_ONE_CONTENTS_WIDTH * 2, NARROW_CONTENTS_HEIGHT],

  // 8
  [RoomShape.SHAPE_2x2]: TWO_BY_TWO_BOUNDS,

  // 9
  [RoomShape.LTL]: TWO_BY_TWO_BOUNDS,

  // 10
  [RoomShape.LTR]: TWO_BY_TWO_BOUNDS,

  // 11
  [RoomShape.LBL]: TWO_BY_TWO_BOUNDS,

  // 12
  [RoomShape.LBR]: TWO_BY_TWO_BOUNDS,
} as const satisfies Record<RoomShape, readonly [int, int]>;

----
objects\roomShapeCorners.ts
import { RoomShape } from "isaac-typescript-definitions";
import { CornerType } from "../enums/CornerType";
import { newReadonlyVector } from "../functions/readOnly";
import type { Corner } from "../interfaces/Corner";

/**
 * The locations of the corners for each room shape.
 *
 * Note that these corner locations are not accurate for the Mother Boss Room and the Home closet
 * rooms. (Those rooms have custom shapes.)
 */
export const ROOM_SHAPE_CORNERS = {
  // 1
  [RoomShape.SHAPE_1x1]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 14,
      position: newReadonlyVector(580, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 120,
      position: newReadonlyVector(60, 420),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 134,
      position: newReadonlyVector(580, 420),
    },
  ],

  // 2
  [RoomShape.IH]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 30,
      position: newReadonlyVector(60, 220),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 44,
      position: newReadonlyVector(580, 220),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 90,
      position: newReadonlyVector(60, 340),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 104,
      position: newReadonlyVector(580, 340),
    },
  ],

  // 3
  [RoomShape.IV]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 4,
      position: newReadonlyVector(220, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 10,
      position: newReadonlyVector(420, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 124,
      position: newReadonlyVector(220, 420),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 130,
      position: newReadonlyVector(420, 420),
    },
  ],

  // 4
  [RoomShape.SHAPE_1x2]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 14,
      position: newReadonlyVector(580, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 225,
      position: newReadonlyVector(60, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 239,
      position: newReadonlyVector(580, 700),
    },
  ],

  // 5
  [RoomShape.IIV]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 4,
      position: newReadonlyVector(220, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 10,
      position: newReadonlyVector(420, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 229,
      position: newReadonlyVector(220, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 235,
      position: newReadonlyVector(420, 700),
    },
  ],

  // 6
  [RoomShape.SHAPE_2x1]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 27,
      position: newReadonlyVector(1100, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 224,
      position: newReadonlyVector(60, 420),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 251,
      position: newReadonlyVector(1100, 420),
    },
  ],

  // 7
  [RoomShape.IIH]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 56,
      position: newReadonlyVector(60, 220),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 83,
      position: newReadonlyVector(1100, 220),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 168,
      position: newReadonlyVector(60, 340),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 195,
      position: newReadonlyVector(1100, 340),
    },
  ],

  // 8
  [RoomShape.SHAPE_2x2]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 27,
      position: newReadonlyVector(1100, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 420,
      position: newReadonlyVector(60, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 447,
      position: newReadonlyVector(1100, 700),
    },
  ],

  // 9
  [RoomShape.LTL]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 13,
      position: newReadonlyVector(580, 140), // Center
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 27,
      position: newReadonlyVector(1100, 140),
    },
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 196,
      position: newReadonlyVector(60, 420), // Left
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 209,
      position: newReadonlyVector(580, 420), // Center
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 420,
      position: newReadonlyVector(60, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 447,
      position: newReadonlyVector(1100, 700),
    },
  ],

  // 10
  [RoomShape.LTR]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 14,
      position: newReadonlyVector(580, 140), // Center
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 210,
      position: newReadonlyVector(580, 420), // Center
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 223,
      position: newReadonlyVector(1100, 420), // Right
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 420,
      position: newReadonlyVector(60, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 447,
      position: newReadonlyVector(1100, 700),
    },
  ],

  // 11
  [RoomShape.LBL]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 27,
      position: newReadonlyVector(1100, 140),
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 224,
      position: newReadonlyVector(580, 140), // Left
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 237,
      position: newReadonlyVector(580, 420), // Center
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 433,
      position: newReadonlyVector(580, 700), // Center
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 447,
      position: newReadonlyVector(1100, 700),
    },
  ],

  // 12
  [RoomShape.LBR]: [
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 0,
      position: newReadonlyVector(60, 140),
    },
    {
      type: CornerType.TOP_RIGHT,
      gridIndex: 27,
      position: newReadonlyVector(1100, 140),
    },
    {
      type: CornerType.TOP_LEFT,
      gridIndex: 238,
      position: newReadonlyVector(580, 420), // Center
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 251,
      position: newReadonlyVector(1100, 420), // Right
    },
    {
      type: CornerType.BOTTOM_LEFT,
      gridIndex: 420,
      position: newReadonlyVector(60, 700),
    },
    {
      type: CornerType.BOTTOM_RIGHT,
      gridIndex: 434,
      position: newReadonlyVector(580, 700), // Right
    },
  ],
} as const satisfies Record<RoomShape, readonly Corner[]>;

----
objects\roomShapeLayoutSizes.ts
import { RoomShape } from "isaac-typescript-definitions";
import {
  ONE_BY_ONE_CONTENTS_HEIGHT,
  ONE_BY_ONE_CONTENTS_WIDTH,
} from "./roomShapeVolumes";

const ONE_BY_ONE_LAYOUT_SIZE = [
  ONE_BY_ONE_CONTENTS_WIDTH,
  ONE_BY_ONE_CONTENTS_HEIGHT,
] as const;
const TWO_BY_ONE_VERTICAL_LAYOUT_SIZE = [
  ONE_BY_ONE_CONTENTS_WIDTH,
  ONE_BY_ONE_CONTENTS_HEIGHT * 2,
] as const;
const TWO_BY_ONE_HORIZONTAL_LAYOUT_SIZE = [
  ONE_BY_ONE_CONTENTS_WIDTH * 2,
  ONE_BY_ONE_CONTENTS_HEIGHT,
] as const;
const TWO_BY_TWO_LAYOUT_SIZE = [
  ONE_BY_ONE_CONTENTS_WIDTH * 2,
  ONE_BY_ONE_CONTENTS_HEIGHT * 2,
] as const;

/**
 * The dimensions of a room shape's layout. This is NOT the size of the room's actual contents! For
 * that, use `ROOM_SHAPE_BOUNDS`.
 *
 * For example, a horizontal narrow room has a layout size of equal to that of a 1x1 room.
 */
export const ROOM_SHAPE_LAYOUT_SIZES = {
  [RoomShape.SHAPE_1x1]: ONE_BY_ONE_LAYOUT_SIZE, // 1
  [RoomShape.IH]: ONE_BY_ONE_LAYOUT_SIZE, // 2
  [RoomShape.IV]: ONE_BY_ONE_LAYOUT_SIZE, // 3
  [RoomShape.SHAPE_1x2]: TWO_BY_ONE_VERTICAL_LAYOUT_SIZE, // 4
  [RoomShape.IIV]: TWO_BY_ONE_VERTICAL_LAYOUT_SIZE, // 5
  [RoomShape.SHAPE_2x1]: TWO_BY_ONE_HORIZONTAL_LAYOUT_SIZE, // 6
  [RoomShape.IIH]: TWO_BY_ONE_HORIZONTAL_LAYOUT_SIZE, // 7
  [RoomShape.SHAPE_2x2]: TWO_BY_TWO_LAYOUT_SIZE, // 8
  [RoomShape.LTL]: TWO_BY_TWO_LAYOUT_SIZE, // 9
  [RoomShape.LTR]: TWO_BY_TWO_LAYOUT_SIZE, // 10
  [RoomShape.LBL]: TWO_BY_TWO_LAYOUT_SIZE, // 11
  [RoomShape.LBR]: TWO_BY_TWO_LAYOUT_SIZE, // 12
} as const satisfies Record<RoomShape, readonly [int, int]>;

----
objects\roomShapeToBottomRightPosition.ts
import { RoomShape } from "isaac-typescript-definitions";
import { newReadonlyVector } from "../functions/readOnly";

const TWO_BY_TWO_BOTTOM_RIGHT_POSITION = newReadonlyVector(25, 13);
const ONE_BY_TWO_VERTICAL_BOTTOM_RIGHT_POSITION = newReadonlyVector(12, 13);

/**
 * "Vector(0, 0)" corresponds to the top left tile of a room, not including the walls. (The top-left
 * wall would be at "Vector(-1, -1)".)
 */
export const ROOM_SHAPE_TO_BOTTOM_RIGHT_POSITION = {
  [RoomShape.SHAPE_1x1]: newReadonlyVector(12, 6), // 1
  [RoomShape.IH]: newReadonlyVector(12, 4), // 2
  [RoomShape.IV]: newReadonlyVector(8, 6), // 3
  [RoomShape.SHAPE_1x2]: ONE_BY_TWO_VERTICAL_BOTTOM_RIGHT_POSITION, // 4
  [RoomShape.IIV]: newReadonlyVector(8, 13), // 5
  [RoomShape.SHAPE_2x1]: newReadonlyVector(25, 6), // 6
  [RoomShape.IIH]: newReadonlyVector(25, 4), // 7
  [RoomShape.SHAPE_2x2]: TWO_BY_TWO_BOTTOM_RIGHT_POSITION, // 8
  [RoomShape.LTL]: TWO_BY_TWO_BOTTOM_RIGHT_POSITION, // 9
  [RoomShape.LTR]: TWO_BY_TWO_BOTTOM_RIGHT_POSITION, // 10
  [RoomShape.LBL]: TWO_BY_TWO_BOTTOM_RIGHT_POSITION, // 11
  [RoomShape.LBR]: ONE_BY_TWO_VERTICAL_BOTTOM_RIGHT_POSITION, // 12
} as const satisfies Record<RoomShape, Readonly<Vector>>;

----
objects\roomShapeToDoorSlotCoordinates.ts
import { DoorSlot, RoomShape } from "isaac-typescript-definitions";

/**
 * The coordinates correspond to the x and y values that are present in a room's XML file.
 *
 * e.g. `<door exists="False" x="-1" y="3" />`
 */
export const ROOM_SHAPE_TO_DOOR_SLOT_COORDINATES = {
  // 1
  [RoomShape.SHAPE_1x1]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [13, 3], // 2
    [DoorSlot.DOWN_0]: [6, 7], // 3
  },

  // 2
  [RoomShape.IH]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.RIGHT_0]: [13, 3], // 2
  },

  // 3
  [RoomShape.IV]: {
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.DOWN_0]: [6, 7], // 3
  },

  // 4
  [RoomShape.SHAPE_1x2]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [13, 3], // 2
    [DoorSlot.DOWN_0]: [6, 14], // 3
    [DoorSlot.LEFT_1]: [-1, 10], // 4
    [DoorSlot.RIGHT_1]: [13, 10], // 6
  },

  // 5
  [RoomShape.IIV]: {
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.DOWN_0]: [6, 14], // 3
  },

  // 6
  [RoomShape.SHAPE_2x1]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [26, 3], // 2
    [DoorSlot.DOWN_0]: [6, 7], // 3
    [DoorSlot.UP_1]: [19, -1], // 5
    [DoorSlot.DOWN_1]: [19, 7], // 7
  },

  // 7
  [RoomShape.IIH]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.RIGHT_0]: [26, 3], // 2
  },

  // 8
  [RoomShape.SHAPE_2x2]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [26, 3], // 2
    [DoorSlot.DOWN_0]: [6, 14], // 3
    [DoorSlot.LEFT_1]: [-1, 10], // 4
    [DoorSlot.UP_1]: [19, -1], // 5
    [DoorSlot.RIGHT_1]: [26, 10], // 6
    [DoorSlot.DOWN_1]: [19, 14], // 7
  },

  // 9
  [RoomShape.LTL]: {
    [DoorSlot.LEFT_0]: [12, 3], // 0
    [DoorSlot.UP_0]: [6, 6], // 1
    [DoorSlot.RIGHT_0]: [26, 3], // 2
    [DoorSlot.DOWN_0]: [6, 14], // 3
    [DoorSlot.LEFT_1]: [-1, 10], // 4
    [DoorSlot.UP_1]: [19, -1], // 5
    [DoorSlot.RIGHT_1]: [26, 10], // 6
    [DoorSlot.DOWN_1]: [19, 14], // 7
  },

  // 10
  [RoomShape.LTR]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [13, 3], // 2
    [DoorSlot.DOWN_0]: [6, 14], // 3
    [DoorSlot.LEFT_1]: [-1, 10], // 4
    [DoorSlot.UP_1]: [19, 6], // 5
    [DoorSlot.RIGHT_1]: [26, 10], // 6
    [DoorSlot.DOWN_1]: [19, 14], // 7
  },

  // 11
  [RoomShape.LBL]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [26, 3], // 2
    [DoorSlot.DOWN_0]: [6, 7], // 3
    [DoorSlot.LEFT_1]: [12, 10], // 4
    [DoorSlot.UP_1]: [19, -1], // 5
    [DoorSlot.RIGHT_1]: [26, 10], // 6
    [DoorSlot.DOWN_1]: [19, 14], // 7
  },

  // 12
  [RoomShape.LBR]: {
    [DoorSlot.LEFT_0]: [-1, 3], // 0
    [DoorSlot.UP_0]: [6, -1], // 1
    [DoorSlot.RIGHT_0]: [26, 3], // 2
    [DoorSlot.DOWN_0]: [6, 14], // 3
    [DoorSlot.LEFT_1]: [-1, 10], // 4
    [DoorSlot.UP_1]: [19, -1], // 5
    [DoorSlot.RIGHT_1]: [13, 10], // 6
    [DoorSlot.DOWN_1]: [19, 7], // 7
  },
} as const satisfies Record<
  RoomShape,
  Partial<Record<DoorSlot, readonly [x: int, y: int]>>
>;

----
objects\roomShapeToDoorSlots.ts
import { DoorSlot, RoomShape } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

const ALL_DOOR_SLOTS_SET = new ReadonlySet<DoorSlot>([
  DoorSlot.LEFT_0, // 0
  DoorSlot.UP_0, // 1
  DoorSlot.RIGHT_0, // 2
  DoorSlot.DOWN_0, // 3
  DoorSlot.LEFT_1, // 4
  DoorSlot.UP_1, // 5
  DoorSlot.RIGHT_1, // 6
  DoorSlot.DOWN_1, // 7
]);

export const ROOM_SHAPE_TO_DOOR_SLOTS = {
  // 1
  [RoomShape.SHAPE_1x1]: new ReadonlySet([
    DoorSlot.LEFT_0, // 0
    DoorSlot.UP_0, // 1
    DoorSlot.RIGHT_0, // 2
    DoorSlot.DOWN_0, // 3
  ]),

  // 2
  [RoomShape.IH]: new ReadonlySet([
    DoorSlot.LEFT_0, // 0
    DoorSlot.RIGHT_0, // 2
  ]),

  // 3
  [RoomShape.IV]: new ReadonlySet([
    DoorSlot.UP_0, // 1
    DoorSlot.DOWN_0, // 3
  ]),

  // 4
  [RoomShape.SHAPE_1x2]: new ReadonlySet([
    DoorSlot.LEFT_0, // 0
    DoorSlot.UP_0, // 1
    DoorSlot.RIGHT_0, // 2
    DoorSlot.DOWN_0, // 3
    DoorSlot.LEFT_1, // 4
    DoorSlot.RIGHT_1, // 6
  ]),

  // 5
  [RoomShape.IIV]: new ReadonlySet([
    DoorSlot.UP_0, // 1
    DoorSlot.DOWN_0, // 3
  ]),

  // 6
  [RoomShape.SHAPE_2x1]: new ReadonlySet([
    DoorSlot.LEFT_0, // 0
    DoorSlot.UP_0, // 1
    DoorSlot.RIGHT_0, // 2
    DoorSlot.DOWN_0, // 3
    DoorSlot.UP_1, // 5
    DoorSlot.DOWN_1, // 7
  ]),

  // 7
  [RoomShape.IIH]: new ReadonlySet([
    DoorSlot.LEFT_0, // 0
    DoorSlot.RIGHT_0, // 2
  ]),

  // 8
  [RoomShape.SHAPE_2x2]: ALL_DOOR_SLOTS_SET,

  // 9
  [RoomShape.LTL]: ALL_DOOR_SLOTS_SET,

  // 10
  [RoomShape.LTR]: ALL_DOOR_SLOTS_SET,

  // 11
  [RoomShape.LBL]: ALL_DOOR_SLOTS_SET,

  // 12
  [RoomShape.LBR]: ALL_DOOR_SLOTS_SET,
} as const satisfies Record<RoomShape, ReadonlySet<DoorSlot>>;

----
objects\roomShapeToDoorSlotsToGridIndexDelta.ts
import { DoorSlot, RoomShape } from "isaac-typescript-definitions";
import { LEVEL_GRID_ROW_WIDTH } from "../core/constants";
import { ReadonlyMap } from "../types/ReadonlyMap";

const LEFT = -1;
const UP = -LEVEL_GRID_ROW_WIDTH;
const RIGHT = 1;
const DOWN = LEVEL_GRID_ROW_WIDTH;

/**
 * Deltas are considered to be from the safe grid index of the room (i.e. the top left corner, or
 * top right corner in the case of `RoomShape.LTL`).
 */
// We don't use `as const` since we need the map to be indexable by all `DoorSlot`.
// eslint-disable-next-line isaacscript/require-capital-const-assertions
export const ROOM_SHAPE_TO_DOOR_SLOTS_TO_GRID_INDEX_DELTA: Readonly<
  Record<RoomShape, ReadonlyMap<DoorSlot, int>>
> = {
  // 1
  [RoomShape.SHAPE_1x1]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN], // 3
  ]),

  // 2
  [RoomShape.IH]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.RIGHT_0, RIGHT], // 2
  ]),

  // 3
  [RoomShape.IV]: new ReadonlyMap([
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.DOWN_0, DOWN], // 3
  ]),

  // 4
  [RoomShape.SHAPE_1x2]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN + DOWN], // 3
    [DoorSlot.LEFT_1, DOWN + LEFT], // 4
    [DoorSlot.RIGHT_1, DOWN + RIGHT], // 6
  ]),

  // 5
  [RoomShape.IIV]: new ReadonlyMap([
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.DOWN_0, DOWN + DOWN], // 3
  ]),

  // 6
  [RoomShape.SHAPE_2x1]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT + RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN], // 3
    [DoorSlot.UP_1, RIGHT + UP], // 5
    [DoorSlot.DOWN_1, RIGHT + DOWN], // 7
  ]),

  // 7
  [RoomShape.IIH]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.RIGHT_0, RIGHT + RIGHT], // 2
  ]),

  // 8
  [RoomShape.SHAPE_2x2]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT + RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN + DOWN], // 3
    [DoorSlot.LEFT_1, DOWN + LEFT], // 4
    [DoorSlot.UP_1, RIGHT + UP], // 5
    [DoorSlot.RIGHT_1, RIGHT + DOWN + RIGHT], // 6
    [DoorSlot.DOWN_1, RIGHT + DOWN + DOWN], // 7
  ]),

  // 9
  [RoomShape.LTL]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, DOWN + LEFT + UP], // 1
    [DoorSlot.RIGHT_0, RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN + LEFT + DOWN], // 3
    [DoorSlot.LEFT_1, DOWN + LEFT + LEFT], // 4
    [DoorSlot.UP_1, UP], // 5
    [DoorSlot.RIGHT_1, DOWN + RIGHT], // 6
    [DoorSlot.DOWN_1, DOWN + DOWN], // 7
  ]),

  // 10
  [RoomShape.LTR]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN + DOWN], // 3
    [DoorSlot.LEFT_1, DOWN + LEFT], // 4
    [DoorSlot.UP_1, DOWN + RIGHT + UP], // 5
    [DoorSlot.RIGHT_1, DOWN + RIGHT + RIGHT], // 6
    [DoorSlot.DOWN_1, DOWN + RIGHT + DOWN], // 7
  ]),

  // 11
  [RoomShape.LBL]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT + RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN], // 3
    [DoorSlot.LEFT_1, RIGHT + DOWN + LEFT], // 4
    [DoorSlot.UP_1, RIGHT + UP], // 5
    [DoorSlot.RIGHT_1, RIGHT + DOWN + RIGHT], // 6
    [DoorSlot.DOWN_1, RIGHT + DOWN + DOWN], // 7
  ]),

  // 12
  [RoomShape.LBR]: new ReadonlyMap([
    [DoorSlot.LEFT_0, LEFT], // 0
    [DoorSlot.UP_0, UP], // 1
    [DoorSlot.RIGHT_0, RIGHT + RIGHT], // 2
    [DoorSlot.DOWN_0, DOWN + DOWN], // 3
    [DoorSlot.LEFT_1, DOWN + LEFT], // 4
    [DoorSlot.UP_1, RIGHT + UP], // 5
    [DoorSlot.RIGHT_1, DOWN + RIGHT], // 6
    [DoorSlot.DOWN_1, RIGHT + DOWN], // 7
  ]),
};

----
objects\roomShapeToGridWidth.ts
import { RoomShape } from "isaac-typescript-definitions";

const ONE_BY_ONE_WIDTH = 15;
const TWO_BY_ONE_WIDTH = 28;

export const ROOM_SHAPE_TO_GRID_WIDTH = {
  [RoomShape.SHAPE_1x1]: ONE_BY_ONE_WIDTH, // 1
  [RoomShape.IH]: ONE_BY_ONE_WIDTH, // 2
  [RoomShape.IV]: ONE_BY_ONE_WIDTH, // 3
  [RoomShape.SHAPE_1x2]: ONE_BY_ONE_WIDTH, // 4
  [RoomShape.IIV]: ONE_BY_ONE_WIDTH, // 5
  [RoomShape.SHAPE_2x1]: TWO_BY_ONE_WIDTH, // 6
  [RoomShape.IIH]: TWO_BY_ONE_WIDTH, // 7
  [RoomShape.SHAPE_2x2]: TWO_BY_ONE_WIDTH, // 8
  [RoomShape.LTL]: TWO_BY_ONE_WIDTH, // 9
  [RoomShape.LTR]: TWO_BY_ONE_WIDTH, // 10
  [RoomShape.LBL]: TWO_BY_ONE_WIDTH, // 11
  [RoomShape.LBR]: TWO_BY_ONE_WIDTH, // 12
} as const satisfies Record<RoomShape, int>;

----
objects\roomShapeToTopLeftPosition.ts
import { RoomShape } from "isaac-typescript-definitions";
import { VectorZero } from "../core/constants";
import { newReadonlyVector } from "../functions/readOnly";

const NARROW_HORIZONTAL_TOP_LEFT_POSITION = newReadonlyVector(0, 2);
const NARROW_VERTICAL_TOP_LEFT_POSITION = newReadonlyVector(4, 0);

/**
 * "Vector(0, 0)" corresponds to the top left tile of a room, not including the walls. (The top-left
 * wall would be at "Vector(-1, -1)".)
 */
export const ROOM_SHAPE_TO_TOP_LEFT_POSITION = {
  [RoomShape.SHAPE_1x1]: VectorZero, // 1
  [RoomShape.IH]: NARROW_HORIZONTAL_TOP_LEFT_POSITION, // 2
  [RoomShape.IV]: NARROW_VERTICAL_TOP_LEFT_POSITION, // 3
  [RoomShape.SHAPE_1x2]: VectorZero, // 4
  [RoomShape.IIV]: NARROW_VERTICAL_TOP_LEFT_POSITION, // 5
  [RoomShape.SHAPE_2x1]: VectorZero, // 6
  [RoomShape.IIH]: NARROW_HORIZONTAL_TOP_LEFT_POSITION, // 7
  [RoomShape.SHAPE_2x2]: VectorZero, // 8
  [RoomShape.LTL]: newReadonlyVector(13, 0), // 9
  [RoomShape.LTR]: VectorZero, // 10
  [RoomShape.LBL]: VectorZero, // 11
  [RoomShape.LBR]: VectorZero, // 12
} as const satisfies Record<RoomShape, Readonly<Vector>>;

----
objects\roomShapeVolumes.ts
import { RoomShape } from "isaac-typescript-definitions";

export const ONE_BY_ONE_CONTENTS_WIDTH = 13;
export const ONE_BY_ONE_CONTENTS_HEIGHT = 7;
const ONE_BY_ONE_VOLUME =
  ONE_BY_ONE_CONTENTS_HEIGHT * ONE_BY_ONE_CONTENTS_WIDTH;

export const NARROW_CONTENTS_WIDTH = 5;
export const NARROW_CONTENTS_HEIGHT = 3;
const NARROW_HORIZONTAL_VOLUME =
  ONE_BY_ONE_CONTENTS_WIDTH * NARROW_CONTENTS_HEIGHT;
const NARROW_VERTICAL_VOLUME =
  NARROW_CONTENTS_WIDTH * ONE_BY_ONE_CONTENTS_HEIGHT;

const ONE_BY_TWO_VOLUME = ONE_BY_ONE_VOLUME * 2;
const L_ROOM_VOLUME = ONE_BY_ONE_VOLUME * 3;

/**
 * Volume is the amount of tiles that are inside the room shape.
 *
 * (This cannot be directly calculated from the bounds since L rooms are a special case.)
 */
export const ROOM_SHAPE_VOLUMES = {
  [RoomShape.SHAPE_1x1]: ONE_BY_ONE_VOLUME, // 1
  [RoomShape.IH]: NARROW_HORIZONTAL_VOLUME, // 2
  [RoomShape.IV]: NARROW_VERTICAL_VOLUME, // 3
  [RoomShape.SHAPE_1x2]: ONE_BY_TWO_VOLUME, // 4
  [RoomShape.IIV]: NARROW_VERTICAL_VOLUME * 2, // 5
  [RoomShape.SHAPE_2x1]: ONE_BY_TWO_VOLUME, // 6
  [RoomShape.IIH]: NARROW_HORIZONTAL_VOLUME * 2, // 7
  [RoomShape.SHAPE_2x2]: ONE_BY_ONE_VOLUME * 4, // 8
  [RoomShape.LTL]: L_ROOM_VOLUME, // 9
  [RoomShape.LTR]: L_ROOM_VOLUME, // 10
  [RoomShape.LBL]: L_ROOM_VOLUME, // 11
  [RoomShape.LBR]: L_ROOM_VOLUME, // 12
} as const satisfies Record<RoomShape, int>;

----
objects\roomTypeNames.ts
import { RoomType } from "isaac-typescript-definitions";

export const ROOM_TYPE_NAMES = {
  [RoomType.DEFAULT]: "Default Room", // 1
  [RoomType.SHOP]: "Shop", // 2
  [RoomType.ERROR]: "I AM ERROR Room", // 3
  [RoomType.TREASURE]: "Treasure Room", // 4
  [RoomType.BOSS]: "Boss Room", // 5
  [RoomType.MINI_BOSS]: "Miniboss Room", // 6
  [RoomType.SECRET]: "Secret Room", // 7
  [RoomType.SUPER_SECRET]: "Super Secret Room", // 8
  [RoomType.ARCADE]: "Arcade", // 9
  [RoomType.CURSE]: "Curse Room", // 10
  [RoomType.CHALLENGE]: "Challenge Room", // 11
  [RoomType.LIBRARY]: "Library", // 12
  [RoomType.SACRIFICE]: "Sacrifice Room", // 13
  [RoomType.DEVIL]: "Devil Room", // 14
  [RoomType.ANGEL]: "Angel Room", // 15
  [RoomType.DUNGEON]: "Crawl Space", // 16
  [RoomType.BOSS_RUSH]: "Boss Rush", // 17
  [RoomType.CLEAN_BEDROOM]: "Clean Bedroom", // 18
  [RoomType.DIRTY_BEDROOM]: "Dirty Bedroom", // 19
  [RoomType.VAULT]: "Vault", // 20
  [RoomType.DICE]: "Dice Room", // 21
  [RoomType.BLACK_MARKET]: "Black Market", // 22
  [RoomType.GREED_EXIT]: "Greed Exit Room", // 23
  [RoomType.PLANETARIUM]: "Planetarium", // 24
  [RoomType.TELEPORTER]: "Teleporter Room", // 25
  [RoomType.TELEPORTER_EXIT]: "Teleporter Exit Room", // 26
  [RoomType.SECRET_EXIT]: "Secret Exit", // 27
  [RoomType.BLUE]: "Blue Room", // 28
  [RoomType.ULTRA_SECRET]: "Ultra Secret Room", // 29
} as const satisfies Record<RoomType, string>;

----
objects\roomTypeSpecialGotoPrefixes.ts
import { RoomType } from "isaac-typescript-definitions";

export const ROOM_TYPE_SPECIAL_GOTO_PREFIXES = {
  [RoomType.DEFAULT]: "default", // 1
  [RoomType.SHOP]: "shop", // 2
  [RoomType.ERROR]: "error", // 3
  [RoomType.TREASURE]: "treasure", // 4
  [RoomType.BOSS]: "boss", // 5
  [RoomType.MINI_BOSS]: "miniboss", // 6
  [RoomType.SECRET]: "secret", // 7
  [RoomType.SUPER_SECRET]: "supersecret", // 8
  [RoomType.ARCADE]: "arcade", // 9
  [RoomType.CURSE]: "curse", // 10
  [RoomType.CHALLENGE]: "challenge", // 11
  [RoomType.LIBRARY]: "library", // 12
  [RoomType.SACRIFICE]: "sacrifice", // 13
  [RoomType.DEVIL]: "devil", // 14
  [RoomType.ANGEL]: "angel", // 15
  [RoomType.DUNGEON]: "itemdungeon", // 16
  [RoomType.BOSS_RUSH]: "bossrush", // 17
  [RoomType.CLEAN_BEDROOM]: "isaacs", // 18
  [RoomType.DIRTY_BEDROOM]: "barren", // 19
  [RoomType.VAULT]: "chest", // 20
  [RoomType.DICE]: "dice", // 21
  [RoomType.BLACK_MARKET]: "blackmarket", // 22
  [RoomType.GREED_EXIT]: "greedexit", // 23
  [RoomType.PLANETARIUM]: "planetarium", // 24
  [RoomType.TELEPORTER]: "teleporter", // 25
  [RoomType.TELEPORTER_EXIT]: "teleporterexit", // 26
  [RoomType.SECRET_EXIT]: "secretexit", // 27
  [RoomType.BLUE]: "blue", // 28
  [RoomType.ULTRA_SECRET]: "ultrasecret", // 29
} as const satisfies Record<RoomType, string>;

----
objects\sackNames.ts
import { SackSubType } from "isaac-typescript-definitions";

export const DEFAULT_SACK_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const SACK_NAMES = {
  [SackSubType.NULL]: DEFAULT_SACK_NAME, // 0
  [SackSubType.NORMAL]: "Grab Bag", // 1
  [SackSubType.BLACK]: "Black Sack", // 2
} as const satisfies Record<SackSubType, string>;

----
objects\slotNames.ts
import { SlotVariant } from "isaac-typescript-definitions";

export const DEFAULT_SLOT_NAME = "Unknown";

/** Taken from "entities2.xml". */
export const SLOT_NAMES = {
  [SlotVariant.SLOT_MACHINE]: "Slot Machine", // 1
  [SlotVariant.BLOOD_DONATION_MACHINE]: "Blood Donation Machine", // 2
  [SlotVariant.FORTUNE_TELLING_MACHINE]: "Fortune Telling Machine", // 3
  [SlotVariant.BEGGAR]: "Beggar", // 4
  [SlotVariant.DEVIL_BEGGAR]: "Devil Beggar", // 5
  [SlotVariant.SHELL_GAME]: "Shell Game", // 6
  [SlotVariant.KEY_MASTER]: "Key Master", // 7
  [SlotVariant.DONATION_MACHINE]: "Donation Machine", // 8
  [SlotVariant.BOMB_BUM]: "Bomb Bum", // 9
  [SlotVariant.SHOP_RESTOCK_MACHINE]: "Shop Restock Machine", // 10
  [SlotVariant.GREED_DONATION_MACHINE]: "Greed Donation Machine", // 11
  [SlotVariant.MOMS_DRESSING_TABLE]: "Mom's Dressing Table", // 12
  [SlotVariant.BATTERY_BUM]: "Battery Bum", // 13
  [SlotVariant.ISAAC_SECRET]: "Isaac (secret)", // 14
  [SlotVariant.HELL_GAME]: "Hell Game", // 15
  [SlotVariant.CRANE_GAME]: "Crane Game", // 16
  [SlotVariant.CONFESSIONAL]: "Confessional", // 17
  [SlotVariant.ROTTEN_BEGGAR]: "Rotten Beggar", // 18
} as const satisfies Record<SlotVariant, string>;

----
objects\stageIDNames.ts
import { StageID } from "isaac-typescript-definitions";

/**
 * Derived from "stages.xml". Note that unlike "stages.xml":
 *
 * - `StageID.BLUE_WOMB` (13) is specified with a name of "Blue Womb" instead of "???".
 * - `StageID.StageID.BACKWARDS` (36) is specified with a name of "The Ascent" instead of "???".
 */
export const STAGE_ID_NAMES = {
  [StageID.SPECIAL_ROOMS]: "Special Rooms", // 0
  [StageID.BASEMENT]: "Basement", // 1
  [StageID.CELLAR]: "Cellar", // 2
  [StageID.BURNING_BASEMENT]: "Burning Basement", // 3
  [StageID.CAVES]: "Caves", // 4
  [StageID.CATACOMBS]: "Catacombs", // 5
  [StageID.FLOODED_CAVES]: "Flooded Caves", // 6
  [StageID.DEPTHS]: "Depths", // 7
  [StageID.NECROPOLIS]: "Necropolis", // 8
  [StageID.DANK_DEPTHS]: "Dank Depths", // 9
  [StageID.WOMB]: "Womb", // 10
  [StageID.UTERO]: "Utero", // 11
  [StageID.SCARRED_WOMB]: "Scarred Womb", // 12
  [StageID.BLUE_WOMB]: "Blue Womb", // 13
  [StageID.SHEOL]: "Sheol", // 14
  [StageID.CATHEDRAL]: "Cathedral", // 15
  [StageID.DARK_ROOM]: "Dark Room", // 16
  [StageID.CHEST]: "Chest", // 17
  [StageID.SHOP]: "The Shop", // 24
  [StageID.ULTRA_GREED]: "Ultra Greed", // 25
  [StageID.VOID]: "The Void", // 26
  [StageID.DOWNPOUR]: "Downpour", // 27
  [StageID.DROSS]: "Dross", // 28
  [StageID.MINES]: "Mines", // 29
  [StageID.ASHPIT]: "Ashpit", // 30
  [StageID.MAUSOLEUM]: "Mausoleum", // 31
  [StageID.GEHENNA]: "Gehenna", // 32
  [StageID.CORPSE]: "Corpse", // 33
  [StageID.MORTIS]: "Mortis", // 34
  [StageID.HOME]: "Home", // 35
  [StageID.BACKWARDS]: "The Ascent", // 36
} as const satisfies Record<StageID, string>;

----
objects\stageToMusic.ts
import { LevelStage, Music, StageType } from "isaac-typescript-definitions";

const BASEMENT_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.BASEMENT, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.CELLAR, // 1
  [StageType.AFTERBIRTH]: Music.BURNING_BASEMENT, // 2
  [StageType.GREED_MODE]: Music.BASEMENT, // 3
  [StageType.REPENTANCE]: Music.DOWNPOUR, // 4
  [StageType.REPENTANCE_B]: Music.DROSS, // 5
} as const satisfies Record<StageType, Music>;

const CAVES_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.CAVES, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.CATACOMBS, // 1
  [StageType.AFTERBIRTH]: Music.FLOODED_CAVES, // 2
  [StageType.GREED_MODE]: Music.CAVES, // 3
  [StageType.REPENTANCE]: Music.MINES, // 4
  [StageType.REPENTANCE_B]: Music.ASHPIT, // 5
} as const satisfies Record<StageType, Music>;

const DEPTHS_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.DEPTHS, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.NECROPOLIS, // 1
  [StageType.AFTERBIRTH]: Music.DANK_DEPTHS, // 2
  [StageType.GREED_MODE]: Music.DEPTHS, // 3
  [StageType.REPENTANCE]: Music.MAUSOLEUM, // 4
  [StageType.REPENTANCE_B]: Music.GEHENNA, // 5
} as const satisfies Record<StageType, Music>;

const WOMB_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.WOMB, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.UTERO, // 1
  [StageType.AFTERBIRTH]: Music.SCARRED_WOMB, // 2
  [StageType.GREED_MODE]: Music.WOMB, // 3
  [StageType.REPENTANCE]: Music.CORPSE, // 4
  [StageType.REPENTANCE_B]: Music.MORTIS, // 5
} as const satisfies Record<StageType, Music>;

const BLUE_WOMB_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.BLUE_WOMB, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.BLUE_WOMB, // 1
  [StageType.AFTERBIRTH]: Music.BLUE_WOMB, // 2
  [StageType.GREED_MODE]: Music.BLUE_WOMB, // 3
  [StageType.REPENTANCE]: Music.BLUE_WOMB, // 4
  [StageType.REPENTANCE_B]: Music.BLUE_WOMB, // 5
} as const satisfies Record<StageType, Music>;

const SHEOL_CATHEDRAL_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.SHEOL, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.CATHEDRAL, // 1
  [StageType.AFTERBIRTH]: Music.SHEOL, // 2
  [StageType.GREED_MODE]: Music.SHEOL, // 3
  [StageType.REPENTANCE]: Music.SHEOL, // 4
  [StageType.REPENTANCE_B]: Music.SHEOL, // 5
} as const satisfies Record<StageType, Music>;

const DARK_ROOM_CHEST_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.DARK_ROOM, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.CHEST, // 1
  [StageType.AFTERBIRTH]: Music.DARK_ROOM, // 2
  [StageType.GREED_MODE]: Music.DARK_ROOM, // 3
  [StageType.REPENTANCE]: Music.DARK_ROOM, // 4
  [StageType.REPENTANCE_B]: Music.DARK_ROOM, // 5
} as const satisfies Record<StageType, Music>;

const VOID_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.VOID, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.VOID, // 1
  [StageType.AFTERBIRTH]: Music.VOID, // 2
  [StageType.GREED_MODE]: Music.VOID, // 3
  [StageType.REPENTANCE]: Music.VOID, // 4
  [StageType.REPENTANCE_B]: Music.VOID, // 5
} as const satisfies Record<StageType, Music>;

const HOME_TO_MUSIC = {
  [StageType.ORIGINAL]: Music.ISAACS_HOUSE, // 0
  [StageType.WRATH_OF_THE_LAMB]: Music.ISAACS_HOUSE, // 1
  [StageType.AFTERBIRTH]: Music.ISAACS_HOUSE, // 2
  [StageType.GREED_MODE]: Music.ISAACS_HOUSE, // 3
  [StageType.REPENTANCE]: Music.ISAACS_HOUSE, // 4
  [StageType.REPENTANCE_B]: Music.ISAACS_HOUSE, // 5
} as const satisfies Record<StageType, Music>;

export const STAGE_TO_MUSIC = {
  [LevelStage.BASEMENT_1]: BASEMENT_TO_MUSIC, // 1
  [LevelStage.BASEMENT_2]: BASEMENT_TO_MUSIC, // 2
  [LevelStage.CAVES_1]: CAVES_TO_MUSIC, // 3
  [LevelStage.CAVES_2]: CAVES_TO_MUSIC, // 4
  [LevelStage.DEPTHS_1]: DEPTHS_TO_MUSIC, // 5
  [LevelStage.DEPTHS_2]: DEPTHS_TO_MUSIC, // 6
  [LevelStage.WOMB_1]: WOMB_TO_MUSIC, // 7
  [LevelStage.WOMB_2]: WOMB_TO_MUSIC, // 8
  [LevelStage.BLUE_WOMB]: BLUE_WOMB_TO_MUSIC, // 9
  [LevelStage.SHEOL_CATHEDRAL]: SHEOL_CATHEDRAL_TO_MUSIC, // 10
  [LevelStage.DARK_ROOM_CHEST]: DARK_ROOM_CHEST_TO_MUSIC, // 11
  [LevelStage.VOID]: VOID_TO_MUSIC, // 12
  [LevelStage.HOME]: HOME_TO_MUSIC, // 13
} as const satisfies Record<LevelStage, Record<StageType, Music>>;

----
objects\stageToStageID.ts
import { LevelStage, StageID, StageType } from "isaac-typescript-definitions";
import { ReadonlyMap } from "../types/ReadonlyMap";

const BASEMENT_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.BASEMENT, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.CELLAR, // 1
  [StageType.AFTERBIRTH]: StageID.BURNING_BASEMENT, // 2
  [StageType.GREED_MODE]: StageID.BASEMENT, // 3
  [StageType.REPENTANCE]: StageID.DOWNPOUR, // 4
  [StageType.REPENTANCE_B]: StageID.DROSS, // 5
} as const satisfies Record<StageType, StageID>;

const CAVES_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.CAVES, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.CATACOMBS, // 1
  [StageType.AFTERBIRTH]: StageID.FLOODED_CAVES, // 2
  [StageType.GREED_MODE]: StageID.CAVES, // 3
  [StageType.REPENTANCE]: StageID.MINES, // 4
  [StageType.REPENTANCE_B]: StageID.ASHPIT, // 5
} as const satisfies Record<StageType, StageID>;

const DEPTHS_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.DEPTHS, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.NECROPOLIS, // 1
  [StageType.AFTERBIRTH]: StageID.DANK_DEPTHS, // 2
  [StageType.GREED_MODE]: StageID.DEPTHS, // 3
  [StageType.REPENTANCE]: StageID.MAUSOLEUM, // 4
  [StageType.REPENTANCE_B]: StageID.GEHENNA, // 5
} as const satisfies Record<StageType, StageID>;

const WOMB_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.WOMB, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.UTERO, // 1
  [StageType.AFTERBIRTH]: StageID.SCARRED_WOMB, // 2
  [StageType.GREED_MODE]: StageID.WOMB, // 3
  [StageType.REPENTANCE]: StageID.CORPSE, // 4
  [StageType.REPENTANCE_B]: StageID.MORTIS, // 5
} as const satisfies Record<StageType, StageID>;

const BLUE_WOMB_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.BLUE_WOMB, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.BLUE_WOMB, // 1
  [StageType.AFTERBIRTH]: StageID.BLUE_WOMB, // 2
  [StageType.GREED_MODE]: StageID.BLUE_WOMB, // 3
  [StageType.REPENTANCE]: StageID.BLUE_WOMB, // 4
  [StageType.REPENTANCE_B]: StageID.BLUE_WOMB, // 5
} as const satisfies Record<StageType, StageID>;

const SHEOL_CATHEDRAL_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.SHEOL, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.CATHEDRAL, // 1
  [StageType.AFTERBIRTH]: StageID.SHEOL, // 2
  [StageType.GREED_MODE]: StageID.SHEOL, // 3
  [StageType.REPENTANCE]: StageID.SHEOL, // 4
  [StageType.REPENTANCE_B]: StageID.SHEOL, // 5
} as const satisfies Record<StageType, StageID>;

const DARK_ROOM_CHEST_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.DARK_ROOM, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.CHEST, // 1
  [StageType.AFTERBIRTH]: StageID.DARK_ROOM, // 2
  [StageType.GREED_MODE]: StageID.DARK_ROOM, // 3
  [StageType.REPENTANCE]: StageID.DARK_ROOM, // 4
  [StageType.REPENTANCE_B]: StageID.DARK_ROOM, // 5
} as const satisfies Record<StageType, StageID>;

const VOID_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.VOID, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.VOID, // 1
  [StageType.AFTERBIRTH]: StageID.VOID, // 2
  [StageType.GREED_MODE]: StageID.VOID, // 3
  [StageType.REPENTANCE]: StageID.VOID, // 4
  [StageType.REPENTANCE_B]: StageID.VOID, // 5
} as const satisfies Record<StageType, StageID>;

const HOME_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.HOME, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.HOME, // 1
  [StageType.AFTERBIRTH]: StageID.HOME, // 2
  [StageType.GREED_MODE]: StageID.HOME, // 3
  [StageType.REPENTANCE]: StageID.HOME, // 4
  [StageType.REPENTANCE_B]: StageID.HOME, // 5
} as const satisfies Record<StageType, StageID>;

export const STAGE_TO_STAGE_ID = {
  [LevelStage.BASEMENT_1]: BASEMENT_TO_STAGE_ID, // 1
  [LevelStage.BASEMENT_2]: BASEMENT_TO_STAGE_ID, // 2
  [LevelStage.CAVES_1]: CAVES_TO_STAGE_ID, // 3
  [LevelStage.CAVES_2]: CAVES_TO_STAGE_ID, // 4
  [LevelStage.DEPTHS_1]: DEPTHS_TO_STAGE_ID, // 5
  [LevelStage.DEPTHS_2]: DEPTHS_TO_STAGE_ID, // 6
  [LevelStage.WOMB_1]: WOMB_TO_STAGE_ID, // 7
  [LevelStage.WOMB_2]: WOMB_TO_STAGE_ID, // 8
  [LevelStage.BLUE_WOMB]: BLUE_WOMB_TO_STAGE_ID, // 9
  [LevelStage.SHEOL_CATHEDRAL]: SHEOL_CATHEDRAL_TO_STAGE_ID, // 10
  [LevelStage.DARK_ROOM_CHEST]: DARK_ROOM_CHEST_TO_STAGE_ID, // 11
  [LevelStage.VOID]: VOID_TO_STAGE_ID, // 12
  [LevelStage.HOME]: HOME_TO_STAGE_ID, // 13
} as const satisfies Record<LevelStage, Record<StageType, StageID>>;

const SHOP_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.SHOP, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.SHOP, // 1
  [StageType.AFTERBIRTH]: StageID.SHOP, // 2
  [StageType.GREED_MODE]: StageID.SHOP, // 3
  [StageType.REPENTANCE]: StageID.SHOP, // 4
  [StageType.REPENTANCE_B]: StageID.SHOP, // 5
} as const satisfies Record<StageType, StageID>;

const ULTRA_GREED_TO_STAGE_ID = {
  [StageType.ORIGINAL]: StageID.ULTRA_GREED, // 0
  [StageType.WRATH_OF_THE_LAMB]: StageID.ULTRA_GREED, // 1
  [StageType.AFTERBIRTH]: StageID.ULTRA_GREED, // 2
  [StageType.GREED_MODE]: StageID.ULTRA_GREED, // 3
  [StageType.REPENTANCE]: StageID.ULTRA_GREED, // 4
  [StageType.REPENTANCE_B]: StageID.ULTRA_GREED, // 5
} as const satisfies Record<StageType, StageID>;

export const STAGE_TO_STAGE_ID_GREED_MODE = new ReadonlyMap<
  LevelStage,
  Record<StageType, StageID>
>([
  [LevelStage.BASEMENT_GREED_MODE, BASEMENT_TO_STAGE_ID], // 1
  [LevelStage.CAVES_GREED_MODE, CAVES_TO_STAGE_ID], // 2
  [LevelStage.DEPTHS_GREED_MODE, DEPTHS_TO_STAGE_ID], // 3
  [LevelStage.WOMB_GREED_MODE, WOMB_TO_STAGE_ID], // 4
  [LevelStage.SHEOL_GREED_MODE, SHEOL_CATHEDRAL_TO_STAGE_ID], // 5
  [LevelStage.SHOP_GREED_MODE, SHOP_TO_STAGE_ID], // 6
  [LevelStage.ULTRA_GREED_GREED_MODE, ULTRA_GREED_TO_STAGE_ID], // 7
]);

----
objects\stageTypeSuffixes.ts
import { StageType } from "isaac-typescript-definitions";

export const STAGE_TYPE_SUFFIXES = {
  // For example, to go to Basement 2, the command is simply "stage 2" without a letter suffix.
  [StageType.ORIGINAL]: "", // 0

  [StageType.WRATH_OF_THE_LAMB]: "a", // 1
  [StageType.AFTERBIRTH]: "b", // 2

  // There is no corresponding suffix for Greed Mode.
  [StageType.GREED_MODE]: "", // 3

  [StageType.REPENTANCE]: "c", // 4
  [StageType.REPENTANCE_B]: "d", // 5
} as const satisfies Record<StageType, string>;

----
objects\transformationNames.ts
import { PlayerForm } from "isaac-typescript-definitions";

export const TRANSFORMATION_NAMES = {
  [PlayerForm.GUPPY]: "Guppy", // 0
  [PlayerForm.BEELZEBUB]: "Beelzebub", // 1
  [PlayerForm.FUN_GUY]: "Fun Guy", // 2
  [PlayerForm.SERAPHIM]: "Seraphim", // 3
  [PlayerForm.BOB]: "Bob", // 4
  [PlayerForm.SPUN]: "Spun", // 5
  [PlayerForm.YES_MOTHER]: "Yes Mother?", // 6
  [PlayerForm.CONJOINED]: "Conjoined", // 7
  [PlayerForm.LEVIATHAN]: "Leviathan", // 8
  [PlayerForm.OH_CRAP]: "Oh Crap", // 9
  [PlayerForm.BOOKWORM]: "Bookworm", // 10
  [PlayerForm.ADULT]: "Adult", // 11
  [PlayerForm.SPIDER_BABY]: "Spider Baby", // 12
  [PlayerForm.STOMPY]: "Stompy", // 13
} as const satisfies Record<PlayerForm, string>;

----
objects\trinketDescriptions.ts
/* cspell:disable */

import { TrinketType } from "isaac-typescript-definitions";

export const DEFAULT_TRINKET_DESCRIPTION = "Unknown";

/** Maps trinket types to the real English descriptions from the "stringtable.sta" file. */
export const TRINKET_DESCRIPTIONS = {
  [TrinketType.NULL]: DEFAULT_TRINKET_DESCRIPTION, // 0
  [TrinketType.SWALLOWED_PENNY]: "Gulp!", // 1
  [TrinketType.PETRIFIED_POOP]: "It feels lucky?", // 2
  [TrinketType.AAA_BATTERY]: "Trickle charge", // 3
  [TrinketType.BROKEN_REMOTE]: "It's broken", // 4
  [TrinketType.PURPLE_HEART]: "Challenge up", // 5
  [TrinketType.BROKEN_MAGNET]: "It kinda works", // 6
  [TrinketType.ROSARY_BEAD]: "Faith up", // 7
  [TrinketType.CARTRIDGE]: "I remember these", // 8
  [TrinketType.PULSE_WORM]: "Wub wub!", // 9
  [TrinketType.WIGGLE_WORM]: "Wiggle waggle!", // 10
  [TrinketType.RING_WORM]: "Woop woop!", // 11
  [TrinketType.FLAT_WORM]: "Blub blub!", // 12
  [TrinketType.STORE_CREDIT]: "YES!", // 13
  [TrinketType.CALLUS]: "Your feet feel stronger", // 14
  [TrinketType.LUCKY_ROCK]: "There's something inside it", // 15
  [TrinketType.MOMS_TOENAIL]: "???", // 16
  [TrinketType.BLACK_LIPSTICK]: "Evil up", // 17
  [TrinketType.BIBLE_TRACT]: "Faith up", // 18
  [TrinketType.PAPER_CLIP]: "Master of lockpicking", // 19
  [TrinketType.MONKEY_PAW]: "Wish granted", // 20
  [TrinketType.MYSTERIOUS_PAPER]: "???", // 21
  [TrinketType.DAEMONS_TAIL]: "Evil up", // 22
  [TrinketType.MISSING_POSTER]: "???", // 23
  [TrinketType.BUTT_PENNY]: "Wealth of gas", // 24
  [TrinketType.MYSTERIOUS_CANDY]: "Uh-oh!", // 25
  [TrinketType.HOOK_WORM]: "Zip zoop!", // 26
  [TrinketType.WHIP_WORM]: "Wooosh!", // 27
  [TrinketType.BROKEN_ANKH]: "Eternal life?", // 28
  [TrinketType.FISH_HEAD]: "It stinks", // 29
  [TrinketType.PINKY_EYE]: "Poison shots", // 30
  [TrinketType.PUSH_PIN]: "Piercing shots", // 31
  [TrinketType.LIBERTY_CAP]: "Touch fuzzy, get dizzy", // 32
  [TrinketType.UMBILICAL_CORD]: "Fetal protection", // 33
  [TrinketType.CHILDS_HEART]: "It calls out to its brothers", // 34
  [TrinketType.CURVED_HORN]: "DMG up", // 35
  [TrinketType.RUSTED_KEY]: "It feels lucky?", // 36
  [TrinketType.GOAT_HOOF]: "Speed up", // 37
  [TrinketType.MOMS_PEARL]: "It emanates purity ", // 38
  [TrinketType.CANCER]: "Yay, cancer!", // 39
  [TrinketType.RED_PATCH]: "Your rage grows", // 40
  [TrinketType.MATCH_STICK]: "Tastes like burning", // 41
  [TrinketType.LUCKY_TOE]: "Luck up!", // 42
  [TrinketType.CURSED_SKULL]: "Cursed?", // 43
  [TrinketType.SAFETY_CAP]: "Don't swallow it", // 44
  [TrinketType.ACE_OF_SPADES]: "Luck of the draw", // 45
  [TrinketType.ISAACS_FORK]: "Consume thy enemy", // 46
  // There is no `TrinketType` with a value of 47.
  [TrinketType.MISSING_PAGE]: "It glows with power", // 48
  [TrinketType.BLOODY_PENNY]: "Wealth of health", // 49
  [TrinketType.BURNT_PENNY]: "Wealth of chaos", // 50
  [TrinketType.FLAT_PENNY]: "Wealth of answers", // 51
  [TrinketType.COUNTERFEIT_PENNY]: "Wealth of wealth", // 52
  [TrinketType.TICK]: "Well, that's not coming off", // 53
  [TrinketType.ISAACS_HEAD]: "Dead friend", // 54
  [TrinketType.MAGGYS_FAITH]: "Faith's reward", // 55
  [TrinketType.JUDAS_TONGUE]: "Payment received ", // 56
  [TrinketType.BLUE_BABYS_SOUL]: "Imaginary friend", // 57
  [TrinketType.SAMSONS_LOCK]: "Your rage grows", // 58
  [TrinketType.CAINS_EYE]: "May you see your destination", // 59
  [TrinketType.EVES_BIRD_FOOT]: "Revenge from beyond", // 60
  [TrinketType.LEFT_HAND]: "The left-hand path reaps dark rewards", // 61
  [TrinketType.SHINY_ROCK]: "It shines for its brothers", // 62
  [TrinketType.SAFETY_SCISSORS]: "Fuse cutter", // 63
  [TrinketType.RAINBOW_WORM]: "Bleep bloop blop", // 64
  [TrinketType.TAPE_WORM]: "Floooooooooop!", // 65
  [TrinketType.LAZY_WORM]: "Pft", // 66
  [TrinketType.CRACKED_DICE]: "You feel cursed... kinda.", // 67
  [TrinketType.SUPER_MAGNET]: "It pulls", // 68
  [TrinketType.FADED_POLAROID]: "You feel faded", // 69
  [TrinketType.LOUSE]: "Itchy, tasty...", // 70
  [TrinketType.BOBS_BLADDER]: "Creepy bombs", // 71
  [TrinketType.WATCH_BATTERY]: "Lil charge", // 72
  [TrinketType.BLASTING_CAP]: "Pop! Pop!", // 73
  [TrinketType.STUD_FINDER]: "The ground below feels hollow...", // 74
  [TrinketType.ERROR]: "Effect not found?", // 75
  [TrinketType.POKER_CHIP]: "It's double down time!", // 76
  [TrinketType.BLISTER]: "Bounce back!", // 77
  [TrinketType.SECOND_HAND]: "Extended stat effect time!", // 78
  [TrinketType.ENDLESS_NAMELESS]: "I'm stuck in a loop...", // 79
  [TrinketType.BLACK_FEATHER]: "With darkness comes power", // 80
  [TrinketType.BLIND_RAGE]: "Blind to damage", // 81
  [TrinketType.GOLDEN_HORSE_SHOE]: "Feel lucky?", // 82
  [TrinketType.STORE_KEY]: "Stores are open", // 83
  [TrinketType.RIB_OF_GREED]: "Feels greedy", // 84
  [TrinketType.KARMA]: "Karma up", // 85
  [TrinketType.LIL_LARVA]: "The poop is moving...", // 86
  [TrinketType.MOMS_LOCKET]: "You feel her love", // 87
  [TrinketType.NO]: "Never again!", // 88
  [TrinketType.CHILD_LEASH]: "Keep your friends close...", // 89
  [TrinketType.BROWN_CAP]: "Fartoom!", // 90
  [TrinketType.MECONIUM]: "Eww", // 91
  [TrinketType.CRACKED_CROWN]: "Stat booster", // 92
  [TrinketType.USED_DIAPER]: "You stink", // 93
  [TrinketType.FISH_TAIL]: "It also stinks!", // 94
  [TrinketType.BLACK_TOOTH]: "It looks dead", // 95
  [TrinketType.OUROBOROS_WORM]: "Foop foop!", // 96
  [TrinketType.TONSIL]: "Sick...", // 97
  [TrinketType.NOSE_GOBLIN]: "Seems magic...", // 98
  [TrinketType.SUPER_BALL]: "Boing!", // 99
  [TrinketType.VIBRANT_BULB]: "It needs power", // 100
  [TrinketType.DIM_BULB]: "I think it's broken", // 101
  [TrinketType.FRAGMENTED_CARD]: "Double moon", // 102
  [TrinketType.EQUALITY]: "=", // 103
  [TrinketType.WISH_BONE]: "Make a wish", // 104
  [TrinketType.BAG_LUNCH]: "I wonder what it is", // 105
  [TrinketType.LOST_CORK]: "Uncorked", // 106
  [TrinketType.CROW_HEART]: "Drain me", // 107
  [TrinketType.WALNUT]: "That's a hard nut to crack!", // 108
  [TrinketType.DUCT_TAPE]: "Stuck!", // 109
  [TrinketType.SILVER_DOLLAR]: "Feels lucky...", // 110
  [TrinketType.BLOODY_CROWN]: "Drips with blood...", // 111
  [TrinketType.PAY_TO_WIN]: "...", // 112
  [TrinketType.LOCUST_OF_WRATH]: "I bring War", // 113
  [TrinketType.LOCUST_OF_PESTILENCE]: "I bring Pestilence", // 114
  [TrinketType.LOCUST_OF_FAMINE]: "I bring Famine", // 115
  [TrinketType.LOCUST_OF_DEATH]: "I bring Death", // 116
  [TrinketType.LOCUST_OF_CONQUEST]: "I bring Conquest", // 117
  [TrinketType.BAT_WING]: "They are growing...", // 118
  [TrinketType.STEM_CELL]: "Regen!", // 119
  [TrinketType.HAIRPIN]: "Danger charge", // 120
  [TrinketType.WOODEN_CROSS]: "My faith protects me", // 121
  [TrinketType.BUTTER]: "Can't hold it!", // 122
  [TrinketType.FILIGREE_FEATHERS]: "Angelic spoils", // 123
  [TrinketType.DOOR_STOP]: "Hold the door", // 124
  [TrinketType.EXTENSION_CORD]: "Charged friends", // 125
  [TrinketType.ROTTEN_PENNY]: "Wealth of flies", // 126
  [TrinketType.BABY_BENDER]: "Feed them magic!", // 127
  [TrinketType.FINGER_BONE]: "It looks brittle", // 128
  [TrinketType.JAW_BREAKER]: "Don't chew on it", // 129
  [TrinketType.CHEWED_PEN]: "It's leaking", // 130
  [TrinketType.BLESSED_PENNY]: "Wealth of purity", // 131
  [TrinketType.BROKEN_SYRINGE]: "Mystery medicine", // 132
  [TrinketType.SHORT_FUSE]: "Faster explosions", // 133
  [TrinketType.GIGANTE_BEAN]: "Mega farts", // 134
  [TrinketType.LIGHTER]: "Watch the world burn", // 135
  [TrinketType.BROKEN_PADLOCK]: "Bombs are key", // 136
  [TrinketType.MYOSOTIS]: "Forget me not...", // 137
  [TrinketType.M]: "t's broken9Reroll your dest       ", // 138
  [TrinketType.TEARDROP_CHARM]: "It feels lucky", // 139
  [TrinketType.APPLE_OF_SODOM]: "It feels empty", // 140
  [TrinketType.FORGOTTEN_LULLABY]: "Sing for your friends", // 141
  [TrinketType.BETHS_FAITH]: "My faith protects me", // 142
  [TrinketType.OLD_CAPACITOR]: "Voltage starving", // 143
  [TrinketType.BRAIN_WORM]: "Ding!", // 144
  [TrinketType.PERFECTION]: "Luck way up. Don't lose it!", // 145
  [TrinketType.DEVILS_CROWN]: "His special customer", // 146
  [TrinketType.CHARGED_PENNY]: "Wealth of power", // 147
  [TrinketType.FRIENDSHIP_NECKLACE]: "Gather round", // 148
  [TrinketType.PANIC_BUTTON]: "Push in case of emergency", // 149
  [TrinketType.BLUE_KEY]: "Look between the rooms", // 150
  [TrinketType.FLAT_FILE]: "No more spikes", // 151
  [TrinketType.TELESCOPE_LENS]: "Seek the stars", // 152
  [TrinketType.MOMS_LOCK]: "A piece of her love", // 153
  [TrinketType.DICE_BAG]: "Bonus roll", // 154
  [TrinketType.HOLY_CROWN]: "Walk the path of the saint", // 155
  [TrinketType.MOTHERS_KISS]: "HP up", // 156
  [TrinketType.TORN_CARD]: "Death awaits", // 157
  [TrinketType.TORN_POCKET]: "A hole in your pocket", // 158
  [TrinketType.GILDED_KEY]: "Less is more", // 159
  [TrinketType.LUCKY_SACK]: "Free goodies!", // 160
  [TrinketType.WICKED_CROWN]: "Walk the path of the wicked", // 161
  [TrinketType.AZAZELS_STUMP]: "Unleash your inner demon", // 162
  [TrinketType.DINGLE_BERRY]: "Oops!", // 163
  [TrinketType.RING_CAP]: "Twice the bang!", // 164
  [TrinketType.NUH_UH]: "Don't want!", // 165
  [TrinketType.MODELING_CLAY]: "???", // 166
  [TrinketType.POLISHED_BONE]: "Friends from beyond", // 167
  [TrinketType.HOLLOW_HEART]: "A brittle blessing", // 168
  [TrinketType.KIDS_DRAWING]: "Looks familiar...", // 169
  [TrinketType.CRYSTAL_KEY]: "Call to the other side", // 170
  [TrinketType.KEEPERS_BARGAIN]: "Money talks", // 171
  [TrinketType.CURSED_PENNY]: "Wealth of misery", // 172
  [TrinketType.YOUR_SOUL]: "Give it to me", // 173
  [TrinketType.NUMBER_MAGNET]: "6", // 174
  [TrinketType.STRANGE_KEY]: "What could it open?", // 175
  [TrinketType.LIL_CLOT]: "Mini friend", // 176
  [TrinketType.TEMPORARY_TATTOO]: "You feel braver", // 177
  [TrinketType.SWALLOWED_M80]: "Bang!", // 178
  [TrinketType.RC_REMOTE]: "Controllable buddies!", // 179
  [TrinketType.FOUND_SOUL]: "Finally!", // 180
  [TrinketType.EXPANSION_PACK]: "Fun extras", // 181
  [TrinketType.BETHS_ESSENCE]: "Virtue's reward", // 182
  [TrinketType.TWINS]: "I'm seeing double...", // 183
  [TrinketType.ADOPTION_PAPERS]: "Give them a home", // 184
  [TrinketType.CRICKET_LEG]: "Infested", // 185
  [TrinketType.APOLLYONS_BEST_FRIEND]: "Attack buddy", // 186
  [TrinketType.BROKEN_GLASSES]: "Double vision?", // 187
  [TrinketType.ICE_CUBE]: "Stay frosty", // 188
  [TrinketType.SIGIL_OF_BAPHOMET]: "Revel in death", // 189
} as const satisfies Record<TrinketType, string>;

----
objects\trinketNames.ts
import { TrinketType } from "isaac-typescript-definitions";

export const DEFAULT_TRINKET_NAME = "Unknown";

/**
 * Maps trinket types to the real English names from the "stringtable.sta" file.
 *
 * For a mapping of name to `TrinketType`, see `TRINKET_NAME_TO_TYPE_MAP`.
 */
export const TRINKET_NAMES = {
  [TrinketType.NULL]: DEFAULT_TRINKET_NAME, // 0
  [TrinketType.SWALLOWED_PENNY]: "Swallowed Penny", // 1
  [TrinketType.PETRIFIED_POOP]: "Petrified Poop", // 2
  [TrinketType.AAA_BATTERY]: "AAA Battery", // 3
  [TrinketType.BROKEN_REMOTE]: "Broken Remote", // 4
  [TrinketType.PURPLE_HEART]: "Purple Heart", // 5
  [TrinketType.BROKEN_MAGNET]: "Broken Magnet", // 6
  [TrinketType.ROSARY_BEAD]: "Rosary Bead", // 7
  [TrinketType.CARTRIDGE]: "Cartridge", // 8
  [TrinketType.PULSE_WORM]: "Pulse Worm", // 9
  [TrinketType.WIGGLE_WORM]: "Wiggle Worm", // 10
  [TrinketType.RING_WORM]: "Ring Worm", // 11
  [TrinketType.FLAT_WORM]: "Flat Worm", // 12
  [TrinketType.STORE_CREDIT]: "Store Credit", // 13
  [TrinketType.CALLUS]: "Callus", // 14
  [TrinketType.LUCKY_ROCK]: "Lucky Rock", // 15
  [TrinketType.MOMS_TOENAIL]: "Mom's Toenail", // 16
  [TrinketType.BLACK_LIPSTICK]: "Black Lipstick", // 17
  [TrinketType.BIBLE_TRACT]: "Bible Tract", // 18
  [TrinketType.PAPER_CLIP]: "Paper Clip", // 19
  [TrinketType.MONKEY_PAW]: "Monkey Paw", // 20
  [TrinketType.MYSTERIOUS_PAPER]: "Mysterious Paper", // 21
  [TrinketType.DAEMONS_TAIL]: "Daemon's Tail", // 22
  [TrinketType.MISSING_POSTER]: "Missing Poster", // 23
  [TrinketType.BUTT_PENNY]: "Butt Penny", // 24
  [TrinketType.MYSTERIOUS_CANDY]: "Mysterious Candy", // 25
  [TrinketType.HOOK_WORM]: "Hook Worm", // 26
  [TrinketType.WHIP_WORM]: "Whip Worm", // 27
  [TrinketType.BROKEN_ANKH]: "Broken Ankh", // 28
  [TrinketType.FISH_HEAD]: "Fish Head", // 29
  [TrinketType.PINKY_EYE]: "Pinky Eye", // 30
  [TrinketType.PUSH_PIN]: "Push Pin", // 31
  [TrinketType.LIBERTY_CAP]: "Liberty Cap", // 32
  [TrinketType.UMBILICAL_CORD]: "Umbilical Cord", // 33
  [TrinketType.CHILDS_HEART]: "Child's Heart", // 34
  [TrinketType.CURVED_HORN]: "Curved Horn", // 35
  [TrinketType.RUSTED_KEY]: "Rusted Key", // 36
  [TrinketType.GOAT_HOOF]: "Goat Hoof", // 37
  [TrinketType.MOMS_PEARL]: "Mom's Pearl", // 38
  [TrinketType.CANCER]: "Cancer", // 39
  [TrinketType.RED_PATCH]: "Red Patch", // 40
  [TrinketType.MATCH_STICK]: "Match Stick", // 41
  [TrinketType.LUCKY_TOE]: "Lucky Toe", // 42
  [TrinketType.CURSED_SKULL]: "Cursed Skull", // 43
  [TrinketType.SAFETY_CAP]: "Safety Cap", // 44
  [TrinketType.ACE_OF_SPADES]: "Ace of Spades", // 45
  [TrinketType.ISAACS_FORK]: "Isaac's Fork", // 46
  // There is no `TrinketType` with a value of 47.
  [TrinketType.MISSING_PAGE]: "A Missing Page", // 48
  [TrinketType.BLOODY_PENNY]: "Bloody Penny", // 49
  [TrinketType.BURNT_PENNY]: "Burnt Penny", // 50
  [TrinketType.FLAT_PENNY]: "Flat Penny", // 51
  [TrinketType.COUNTERFEIT_PENNY]: "Counterfeit Penny", // 52
  [TrinketType.TICK]: "Tick", // 53
  [TrinketType.ISAACS_HEAD]: "Isaac's Head", // 54
  [TrinketType.MAGGYS_FAITH]: "Maggy's Faith", // 55
  [TrinketType.JUDAS_TONGUE]: "Judas' Tongue", // 56
  [TrinketType.BLUE_BABYS_SOUL]: "???'s Soul", // 57
  [TrinketType.SAMSONS_LOCK]: "Samson's Lock", // 58
  [TrinketType.CAINS_EYE]: "Cain's Eye", // 59
  [TrinketType.EVES_BIRD_FOOT]: "Eve's Bird Foot", // 60
  [TrinketType.LEFT_HAND]: "The Left Hand", // 61
  [TrinketType.SHINY_ROCK]: "Shiny Rock", // 62
  [TrinketType.SAFETY_SCISSORS]: "Safety Scissors", // 63
  [TrinketType.RAINBOW_WORM]: "Rainbow Worm", // 64
  [TrinketType.TAPE_WORM]: "Tape Worm", // 65
  [TrinketType.LAZY_WORM]: "Lazy Worm", // 66
  [TrinketType.CRACKED_DICE]: "Cracked Dice", // 67
  [TrinketType.SUPER_MAGNET]: "Super Magnet", // 68
  [TrinketType.FADED_POLAROID]: "Faded Polaroid", // 69
  [TrinketType.LOUSE]: "Louse", // 70
  [TrinketType.BOBS_BLADDER]: "Bob's Bladder", // 71
  [TrinketType.WATCH_BATTERY]: "Watch Battery", // 72
  [TrinketType.BLASTING_CAP]: "Blasting Cap", // 73
  [TrinketType.STUD_FINDER]: "Stud Finder", // 74
  [TrinketType.ERROR]: "Error", // 75
  [TrinketType.POKER_CHIP]: "Poker Chip", // 76
  [TrinketType.BLISTER]: "Blister", // 77
  [TrinketType.SECOND_HAND]: "Second Hand", // 78
  [TrinketType.ENDLESS_NAMELESS]: "Endless Nameless", // 79
  [TrinketType.BLACK_FEATHER]: "Black Feather", // 80
  [TrinketType.BLIND_RAGE]: "Blind Rage", // 81
  [TrinketType.GOLDEN_HORSE_SHOE]: "Golden Horse Shoe", // 82
  [TrinketType.STORE_KEY]: "Store Key", // 83
  [TrinketType.RIB_OF_GREED]: "Rib of Greed", // 84
  [TrinketType.KARMA]: "Karma", // 85
  [TrinketType.LIL_LARVA]: "Lil Larva", // 86
  [TrinketType.MOMS_LOCKET]: "Mom's Locket", // 87
  [TrinketType.NO]: "NO!", // 88
  [TrinketType.CHILD_LEASH]: "Child Leash", // 89
  [TrinketType.BROWN_CAP]: "Brown Cap", // 90
  [TrinketType.MECONIUM]: "Meconium", // 91
  [TrinketType.CRACKED_CROWN]: "Cracked Crown", // 92
  [TrinketType.USED_DIAPER]: "Used Diaper", // 93
  [TrinketType.FISH_TAIL]: "Fish Tail", // 94
  [TrinketType.BLACK_TOOTH]: "Black Tooth", // 95
  [TrinketType.OUROBOROS_WORM]: "Ouroboros Worm", // 96
  [TrinketType.TONSIL]: "Tonsil", // 97
  [TrinketType.NOSE_GOBLIN]: "Nose Goblin", // 98
  [TrinketType.SUPER_BALL]: "Super Ball", // 99
  [TrinketType.VIBRANT_BULB]: "Vibrant Bulb", // 100
  [TrinketType.DIM_BULB]: "Dim Bulb", // 101
  [TrinketType.FRAGMENTED_CARD]: "Fragmented Card", // 102
  [TrinketType.EQUALITY]: "Equality!", // 103
  [TrinketType.WISH_BONE]: "Wish Bone", // 104
  [TrinketType.BAG_LUNCH]: "Bag Lunch", // 105
  [TrinketType.LOST_CORK]: "Lost Cork", // 106
  [TrinketType.CROW_HEART]: "Crow Heart", // 107
  [TrinketType.WALNUT]: "Walnut", // 108
  [TrinketType.DUCT_TAPE]: "Duct Tape", // 109
  [TrinketType.SILVER_DOLLAR]: "Silver Dollar", // 110
  [TrinketType.BLOODY_CROWN]: "Bloody Crown", // 111
  [TrinketType.PAY_TO_WIN]: "Pay To Win", // 112
  [TrinketType.LOCUST_OF_WRATH]: "Locust of War", // 113
  [TrinketType.LOCUST_OF_PESTILENCE]: "Locust of Pestilence", // 114
  [TrinketType.LOCUST_OF_FAMINE]: "Locust of Famine", // 115
  [TrinketType.LOCUST_OF_DEATH]: "Locust of Death", // 116
  [TrinketType.LOCUST_OF_CONQUEST]: "Locust of Conquest", // 117
  [TrinketType.BAT_WING]: "Bat Wing", // 118
  [TrinketType.STEM_CELL]: "Stem Cell", // 119
  [TrinketType.HAIRPIN]: "Hairpin", // 120
  [TrinketType.WOODEN_CROSS]: "Wooden Cross", // 121
  [TrinketType.BUTTER]: "Butter!", // 122
  [TrinketType.FILIGREE_FEATHERS]: "Filigree Feather", // 123
  [TrinketType.DOOR_STOP]: "Door Stop", // 124
  [TrinketType.EXTENSION_CORD]: "Extension Cord", // 125
  [TrinketType.ROTTEN_PENNY]: "Rotten Penny", // 126
  [TrinketType.BABY_BENDER]: "Baby-Bender", // 127
  [TrinketType.FINGER_BONE]: "Finger Bone", // 128
  [TrinketType.JAW_BREAKER]: "Jawbreaker", // 129
  [TrinketType.CHEWED_PEN]: "Chewed Pen", // 130
  [TrinketType.BLESSED_PENNY]: "Blessed Penny", // 131
  [TrinketType.BROKEN_SYRINGE]: "Broken Syringe", // 132
  [TrinketType.SHORT_FUSE]: "Short Fuse", // 133
  [TrinketType.GIGANTE_BEAN]: "Gigante Bean", // 134
  [TrinketType.LIGHTER]: "A Lighter", // 135
  [TrinketType.BROKEN_PADLOCK]: "Broken Padlock", // 136
  [TrinketType.MYOSOTIS]: "Myosotis", // 137
  [TrinketType.M]: " 'M", // 138
  [TrinketType.TEARDROP_CHARM]: "Teardrop Charm", // 139
  [TrinketType.APPLE_OF_SODOM]: "Apple of Sodom", // 140
  [TrinketType.FORGOTTEN_LULLABY]: "Forgotten Lullaby", // 141
  [TrinketType.BETHS_FAITH]: "Beth's Faith", // 142
  [TrinketType.OLD_CAPACITOR]: "Old Capacitor", // 143
  [TrinketType.BRAIN_WORM]: "Brain Worm", // 144
  [TrinketType.PERFECTION]: "Perfection", // 145
  [TrinketType.DEVILS_CROWN]: "Devil's Crown", // 146
  [TrinketType.CHARGED_PENNY]: "Charged Penny", // 147
  [TrinketType.FRIENDSHIP_NECKLACE]: "Friendship Necklace", // 148
  [TrinketType.PANIC_BUTTON]: "Panic Button", // 149
  [TrinketType.BLUE_KEY]: "Blue Key", // 150
  [TrinketType.FLAT_FILE]: "Flat File", // 151
  [TrinketType.TELESCOPE_LENS]: "Telescope Lens", // 152
  [TrinketType.MOMS_LOCK]: "Mom's Lock", // 153
  [TrinketType.DICE_BAG]: "Dice Bag", // 154
  [TrinketType.HOLY_CROWN]: "Holy Crown", // 155
  [TrinketType.MOTHERS_KISS]: "Mother's Kiss", // 156
  [TrinketType.TORN_CARD]: "Torn Card", // 157
  [TrinketType.TORN_POCKET]: "Torn Pocket", // 158
  [TrinketType.GILDED_KEY]: "Gilded Key", // 159
  [TrinketType.LUCKY_SACK]: "Lucky Sack", // 160
  [TrinketType.WICKED_CROWN]: "Wicked Crown", // 161
  [TrinketType.AZAZELS_STUMP]: "Azazel's Stump", // 162
  [TrinketType.DINGLE_BERRY]: "Dingle Berry", // 163
  [TrinketType.RING_CAP]: "Ring Cap", // 164
  [TrinketType.NUH_UH]: "Nuh Uh!", // 165
  [TrinketType.MODELING_CLAY]: "Modeling Clay", // 166
  [TrinketType.POLISHED_BONE]: "Polished Bone", // 167
  [TrinketType.HOLLOW_HEART]: "Hollow Heart", // 168
  [TrinketType.KIDS_DRAWING]: "Kid's Drawing", // 169
  [TrinketType.CRYSTAL_KEY]: "Crystal Key", // 170
  [TrinketType.KEEPERS_BARGAIN]: "Keeper's Bargain", // 171
  [TrinketType.CURSED_PENNY]: "Cursed Penny", // 172
  [TrinketType.YOUR_SOUL]: "Your Soul", // 173
  [TrinketType.NUMBER_MAGNET]: "Number Magnet", // 174
  [TrinketType.STRANGE_KEY]: "Strange Key", // 175
  [TrinketType.LIL_CLOT]: "Lil Clot", // 176
  [TrinketType.TEMPORARY_TATTOO]: "Temporary Tattoo", // 177
  [TrinketType.SWALLOWED_M80]: "Swallowed M80", // 178
  [TrinketType.RC_REMOTE]: "RC Remote", // 179
  [TrinketType.FOUND_SOUL]: "Found Soul", // 180
  [TrinketType.EXPANSION_PACK]: "Expansion Pack", // 181
  [TrinketType.BETHS_ESSENCE]: "Beth's Essence", // 182
  [TrinketType.TWINS]: "The Twins", // 183
  [TrinketType.ADOPTION_PAPERS]: "Adoption Papers", // 184
  [TrinketType.CRICKET_LEG]: "Cricket Leg", // 185
  [TrinketType.APOLLYONS_BEST_FRIEND]: "Apollyon's Best Friend", // 186
  [TrinketType.BROKEN_GLASSES]: "Broken Glasses", // 187
  [TrinketType.ICE_CUBE]: "Ice Cube", // 188
  [TrinketType.SIGIL_OF_BAPHOMET]: "Sigil of Baphomet", // 189
} as const satisfies Record<TrinketType, string>;

----
objects\versusScreenBackgroundColors.ts
import { StageID } from "isaac-typescript-definitions";
import { newReadonlyColor } from "../functions/readOnly";

const BASEMENT_COLOR = newReadonlyColor(26 / 255, 14 / 255, 12 / 255);
const CAVES_COLOR = newReadonlyColor(18 / 255, 13 / 255, 8 / 255);
const DEPTHS_COLOR = newReadonlyColor(8 / 255, 8 / 255, 8 / 255);
const WOMB_COLOR = newReadonlyColor(27 / 255, 3 / 255, 3 / 255);
const SHEOL_COLOR = newReadonlyColor(6 / 255, 6 / 255, 6 / 255);

/** We arbitrarily specify a default color equal to that of Basement. */
const DEFAULT_COLOR = BASEMENT_COLOR;

/** These values are taken from StageAPI. */
export const VERSUS_SCREEN_BACKGROUND_COLORS = {
  [StageID.SPECIAL_ROOMS]: DEFAULT_COLOR, // 0
  [StageID.BASEMENT]: BASEMENT_COLOR, // 1
  [StageID.CELLAR]: newReadonlyColor(26 / 255, 17 / 255, 13 / 255), // 2
  [StageID.BURNING_BASEMENT]: newReadonlyColor(28 / 255, 12 / 255, 10 / 255), // 3
  [StageID.CAVES]: CAVES_COLOR, // 4
  [StageID.CATACOMBS]: newReadonlyColor(15 / 255, 10 / 255, 8 / 255), // 5
  [StageID.FLOODED_CAVES]: newReadonlyColor(21 / 255, 28 / 255, 35 / 255), // 6
  [StageID.DEPTHS]: DEPTHS_COLOR, // 7
  [StageID.NECROPOLIS]: newReadonlyColor(10 / 255, 6 / 255, 6 / 255), // 8
  [StageID.DANK_DEPTHS]: DEPTHS_COLOR, // 9
  [StageID.WOMB]: WOMB_COLOR, // 10
  [StageID.UTERO]: newReadonlyColor(22 / 255, 6 / 255, 5 / 255), // 11
  [StageID.SCARRED_WOMB]: newReadonlyColor(42 / 255, 19 / 255, 10 / 255), // 12
  [StageID.BLUE_WOMB]: newReadonlyColor(26 / 255, 32 / 255, 40 / 255), // 13
  [StageID.SHEOL]: SHEOL_COLOR, // 14
  [StageID.CATHEDRAL]: newReadonlyColor(6 / 255, 13 / 255, 17 / 255), // 15
  [StageID.DARK_ROOM]: newReadonlyColor(9 / 255, 4 / 255, 3 / 255), // 16
  [StageID.CHEST]: newReadonlyColor(15 / 255, 9 / 255, 6 / 255), // 17
  [StageID.SHOP]: DEFAULT_COLOR, // 24
  [StageID.ULTRA_GREED]: DEFAULT_COLOR, // 25
  [StageID.VOID]: newReadonlyColor(0, 0, 0), // 26
  [StageID.DOWNPOUR]: newReadonlyColor(29 / 255, 30 / 255, 32 / 255), // 27
  [StageID.DROSS]: newReadonlyColor(35 / 255, 35 / 255, 29 / 255), // 28
  [StageID.MINES]: newReadonlyColor(17 / 255, 15 / 255, 12 / 255), // 29
  [StageID.ASHPIT]: newReadonlyColor(12 / 255, 10 / 255, 10 / 255), // 30
  [StageID.MAUSOLEUM]: newReadonlyColor(14 / 255, 10 / 255, 14 / 255), // 31
  [StageID.GEHENNA]: newReadonlyColor(15 / 255, 4 / 255, 4 / 255), // 32
  [StageID.CORPSE]: newReadonlyColor(13 / 255, 14 / 255, 12 / 255), // 33
  [StageID.MORTIS]: newReadonlyColor(13 / 255, 14 / 255, 12 / 255), // 34
  [StageID.HOME]: DEFAULT_COLOR, // 35
  [StageID.BACKWARDS]: DEFAULT_COLOR, // 36
} as const satisfies Record<StageID, Readonly<Color>>;

----
objects\versusScreenDirtSpotColors.ts
import { StageID } from "isaac-typescript-definitions";
import { newReadonlyColor } from "../functions/readOnly";

const BASEMENT_COLOR = newReadonlyColor(201 / 255, 114 / 255, 96 / 255);
const CAVES_COLOR = newReadonlyColor(167 / 255, 111 / 255, 75 / 255);
const DEPTHS_COLOR = newReadonlyColor(70 / 255, 70 / 255, 72 / 255);
const WOMB_COLOR = newReadonlyColor(241 / 255, 28 / 255, 28 / 255);
const SHEOL_COLOR = newReadonlyColor(60 / 255, 54 / 255, 54 / 255);

/** We arbitrarily specify a default color equal to that of Basement. */
const DEFAULT_COLOR = BASEMENT_COLOR;

/** These values are taken from StageAPI. */
export const VERSUS_SCREEN_DIRT_SPOT_COLORS = {
  [StageID.SPECIAL_ROOMS]: DEFAULT_COLOR, // 0
  [StageID.BASEMENT]: BASEMENT_COLOR, // 1
  [StageID.CELLAR]: newReadonlyColor(229 / 255, 157 / 255, 111 / 255), // 2
  [StageID.BURNING_BASEMENT]: newReadonlyColor(252 / 255, 108 / 255, 90 / 255), // 3
  [StageID.CAVES]: CAVES_COLOR, // 4
  [StageID.CATACOMBS]: newReadonlyColor(135 / 255, 90 / 255, 80 / 255), // 5
  [StageID.FLOODED_CAVES]: newReadonlyColor(111 / 255, 147 / 255, 180 / 255), // 6
  [StageID.DEPTHS]: DEPTHS_COLOR, // 7
  [StageID.NECROPOLIS]: newReadonlyColor(88 / 255, 67 / 255, 54 / 255), // 8
  [StageID.DANK_DEPTHS]: DEPTHS_COLOR, // 9
  [StageID.WOMB]: WOMB_COLOR, // 10
  [StageID.UTERO]: newReadonlyColor(199 / 255, 60 / 255, 48 / 255), // 11
  [StageID.SCARRED_WOMB]: newReadonlyColor(247 / 255, 152 / 255, 88 / 255), // 12
  [StageID.BLUE_WOMB]: newReadonlyColor(157 / 255, 209 / 255, 255 / 255), // 13
  [StageID.SHEOL]: SHEOL_COLOR, // 14
  [StageID.CATHEDRAL]: newReadonlyColor(44 / 255, 100 / 255, 111 / 255), // 15
  [StageID.DARK_ROOM]: newReadonlyColor(80 / 255, 38 / 255, 20 / 255), // 16
  [StageID.CHEST]: newReadonlyColor(175 / 255, 108 / 255, 72 / 255), // 17
  [StageID.SHOP]: DEFAULT_COLOR, // 24
  [StageID.ULTRA_GREED]: DEFAULT_COLOR, // 25
  [StageID.VOID]: newReadonlyColor(70 / 255, 5 / 255, 5 / 255), // 26
  [StageID.DOWNPOUR]: newReadonlyColor(149 / 255, 157 / 255, 167 / 255), // 27
  [StageID.DROSS]: newReadonlyColor(179 / 255, 179 / 255, 143 / 255), // 28
  [StageID.MINES]: newReadonlyColor(93 / 255, 85 / 255, 72 / 255), // 29
  [StageID.ASHPIT]: newReadonlyColor(106 / 255, 102 / 255, 94 / 255), // 30
  [StageID.MAUSOLEUM]: newReadonlyColor(70 / 255, 59 / 255, 72 / 255), // 31
  [StageID.GEHENNA]: newReadonlyColor(59 / 255, 41 / 255, 41 / 255), // 32
  [StageID.CORPSE]: newReadonlyColor(124 / 255, 134 / 255, 111 / 255), // 33
  [StageID.MORTIS]: newReadonlyColor(124 / 255, 134 / 255, 111 / 255), // 34
  [StageID.HOME]: DEFAULT_COLOR, // 35
  [StageID.BACKWARDS]: DEFAULT_COLOR, // 36
} as const satisfies Record<StageID, Readonly<Color>>;

----
patchErrorFunctions.ts
import { getTraceback, isLuaDebugEnabled } from "./functions/debugFunctions";

declare let error: ErrorFunction;
declare let __PATCHED_ERROR: boolean | undefined; // eslint-disable-line

type ErrorFunction = (this: void, message: string, level?: number) => never;

const LINE_SEPARATOR = "\n";

/**
 * These must be listed in order from how they appear in the traceback from top to bottom, or they
 * won't be properly removed.
 */
const USELESS_TRACEBACK_MESSAGES = [
  // The second line of the traceback will always be the "getTraceback" function.
  "in upvalue 'getTraceback'",
  "in function 'sandbox.GetTraceback'",

  // The third line of the traceback will always be a line within the "errorWithTraceback" function.
  "in function 'error'",
] as const;

let vanillaError: ErrorFunction | undefined;

/**
 * In Lua, the `error` function will tell you the line number of the error, but not give you a full
 * traceback of the parent functions, which is unlike how JavaScript works. This function monkey
 * patches the `error` function to add this functionality.
 *
 * Traceback functionality can only be added if the "--luadebug" flag is turned on, so this function
 * does nothing if the "--luadebug" flag is disabled.
 */
export function patchErrorFunction(): void {
  // Only replace the function if the "--luadebug" launch flag is enabled.
  if (!isLuaDebugEnabled()) {
    return;
  }

  // Do nothing if the function was already patched.
  if (__PATCHED_ERROR !== undefined) {
    return;
  }
  __PATCHED_ERROR = true;

  vanillaError = error;
  error = errorWithTraceback;
}

function errorWithTraceback(this: void, message: string, level = 1): never {
  if (vanillaError === undefined) {
    error(message, level);
  }

  const tracebackOutput = getTraceback();
  const slimmedTracebackOutput = slimTracebackOutput(tracebackOutput);
  message += "\n";
  message += slimmedTracebackOutput;

  // We add one to the level so that the error message appears to originate at the parent function.
  return vanillaError(message, level + 1);
}

/**
 * Some lines of the traceback output will not be relevant to the error that just occurred. Thus, to
 * reduce noise, we can always remove these lines.
 */
function slimTracebackOutput(tracebackOutput: string) {
  for (const msg of USELESS_TRACEBACK_MESSAGES) {
    tracebackOutput = removeLinesContaining(tracebackOutput, msg);
  }

  return tracebackOutput;
}

function removeLinesContaining(msg: string, containsMsg: string) {
  const lines = msg.split(LINE_SEPARATOR);
  const linesThatDontContain = lines.filter(
    (line) => !line.includes(containsMsg),
  );

  return linesThatDontContain.join(LINE_SEPARATOR);
}

----
serialization.ts
import { SERIALIZATION_BRAND_VALUES } from "./cachedEnumValues";
import { isString } from "./functions/types";
import { ReadonlySet } from "./types/ReadonlySet";

const SERIALIZATION_BRAND_SET = new ReadonlySet<string>(
  SERIALIZATION_BRAND_VALUES,
);

/**
 * Helper function to check if a key of a table in the "save#.dat" file is a serialization brand
 * inserted by the save data manager (i.e. the `deepCopy` function).
 *
 * This is separated from the other serialization functions because end-users would not normally be
 * iterating through a serialized object directly.
 */
export function isSerializationBrand(key: unknown): boolean {
  if (!isString(key)) {
    return false;
  }

  return SERIALIZATION_BRAND_SET.has(key);
}

----
sets\LRoomShapesSet.ts
import { RoomShape } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const L_ROOM_SHAPES_SET = new ReadonlySet<RoomShape>([
  RoomShape.LTL, // 9
  RoomShape.LTR, // 10
  RoomShape.LBL, // 11
  RoomShape.LBR, // 12
]);

----
sets\bigRoomShapesSet.ts
import { RoomShape } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const BIG_ROOM_SHAPES_SET = new ReadonlySet<RoomShape>([
  RoomShape.SHAPE_1x2, // 4
  RoomShape.SHAPE_2x1, // 6
  RoomShape.SHAPE_2x2, // 8
  RoomShape.LTL, // 9
  RoomShape.LTR, // 10
  RoomShape.LBL, // 11
  RoomShape.LBR, // 12
]);

----
sets\bossSets.ts
import { BossID, LevelStage, StageID } from "isaac-typescript-definitions";
import { BOSS_ID_VALUES } from "../cachedEnumValues";
import { isStoryBossID } from "../functions/storyBosses";
import { ReadonlyMap } from "../types/ReadonlyMap";
import { ReadonlySet } from "../types/ReadonlySet";

// The "bosspools.xml" file does not actually correspond to the real boss pools, so these data
// structures were determined through experimentation on v1.7.8a.

// We use sets of strings instead of tuples for these data structures because TypeScript/Lua does
// not have real tuples. If we store bosses as tuples, then we cannot do a set lookup in O(1).

/** For `StageID.BASEMENT` (1). */
const BASEMENT_BOSSES = [
  BossID.MONSTRO, // 1
  BossID.LARRY_JR, // 2
  BossID.FAMINE, // 9
  BossID.DUKE_OF_FLIES, // 13
  BossID.GEMINI, // 17
  BossID.STEVEN, // 20
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.DINGLE, // 44
  BossID.GURGLING, // 56
  BossID.LITTLE_HORN, // 60
  // - `BossID.RAG_MAN` (61) was removed in Repentance.
  BossID.DANGLE, // 64
  BossID.TURDLING, // 65
  BossID.BABY_PLUM, // 84 (added in Repentance)
] as const;

/** For `StageID.CELLAR` (2). */
const CELLAR_BOSSES = [
  BossID.FAMINE, // 9
  BossID.DUKE_OF_FLIES, // 13
  // - `BossID.FISTULA` (18) was removed in Repentance.
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.BLIGHTED_OVUM, // 32
  BossID.WIDOW, // 34
  BossID.PIN, // 37
  BossID.HAUNT, // 43
  BossID.LITTLE_HORN, // 60
  BossID.RAG_MAN, // 61
  BossID.BABY_PLUM, // 84 (added in Repentance)
] as const;

/** For `StageID.BURNING_BASEMENT` (3). */
const BURNING_BASEMENT_BOSSES = [
  BossID.MONSTRO, // 1
  BossID.LARRY_JR, // 2
  BossID.FAMINE, // 9
  BossID.DUKE_OF_FLIES, // 13
  BossID.GEMINI, // 17 (added in Repentance)
  BossID.STEVEN, // 20 (added in Repentance)
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  // - `BossID.HAUNT` (43) was removed in Repentance.
  BossID.DINGLE, // 44 (added in Repentance)
  BossID.GURGLING, // 56 (added in Repentance)
  BossID.LITTLE_HORN, // 60
  BossID.RAG_MAN, // 61
  BossID.DANGLE, // 64 (added in Repentance)
  BossID.TURDLING, // 65 (added in Repentance)
  BossID.BABY_PLUM, // 84 (added in Repentance)
] as const;

/** For `StageID.DOWNPOUR` (27). */
const DOWNPOUR_BOSSES = [
  BossID.LIL_BLUB, // 75
  BossID.WORMWOOD, // 76
  BossID.RAINMAKER, // 77
  BossID.MIN_MIN, // 91
] as const;

/** For `StageID.DROSS` (28). */
const DROSS_BOSSES = [
  BossID.LIL_BLUB, // 75
  BossID.WORMWOOD, // 76
  BossID.CLOG, // 92
  BossID.COLOSTOMIA, // 95
  BossID.TURDLET, // 97
] as const;

/** The set of unique bosses for Basement, Cellar, Burning Basement, Downpour, and Dross. */
const ALL_BASEMENT_BOSSES_SET = new ReadonlySet<BossID>([
  ...BASEMENT_BOSSES,
  ...CELLAR_BOSSES,
  ...BURNING_BASEMENT_BOSSES,
  ...DOWNPOUR_BOSSES,
  ...DROSS_BOSSES,
]);

/** For `StageID.CAVES` (4). */
const CAVES_BOSSES = [
  BossID.CHUB, // 3
  BossID.GURDY, // 4
  BossID.PESTILENCE, // 10
  BossID.PEEP, // 14
  BossID.FISTULA, // 18 (added in Repentance)
  BossID.CHAD, // 21
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.GURDY_JR, // 28
  BossID.MEGA_FATTY, // 47
  BossID.MEGA_MAW, // 45
  // - `BossID.DARK_ONE` (50) was removed in Repentance.
  BossID.FALLEN, // 23
  BossID.STAIN, // 57
  // - `BossID.FORSAKEN` (59) was removed in Repentance.
  // - `BossID.FRAIL` (66) was removed in Repentance.
  BossID.RAG_MEGA, // 67
  BossID.BIG_HORN, // 69
  BossID.BUMBINO, // 94 (added in Repentance)
] as const;

/** For `StageID.CATACOMBS` (5). */
const CATACOMBS_BOSSES = [
  BossID.PESTILENCE, // 10
  BossID.PEEP, // 14
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.HOLLOW, // 26
  BossID.CARRION_QUEEN, // 27
  BossID.GURDY_JR, // 28
  BossID.HUSK, // 29
  BossID.WRETCHED, // 36
  BossID.DARK_ONE, // 50
  BossID.POLYCEPHALUS, // 52
  // - `BossID.STAIN` (57) was removed in Repentance.
  BossID.FORSAKEN, // 59
  BossID.FRAIL, // 66
  BossID.RAG_MEGA, // 67
  BossID.BIG_HORN, // 69
  BossID.BUMBINO, // 94 (added in Repentance)
] as const;

/** For `StageID.FLOODED_CAVES` (6). */
const FLOODED_CAVES_BOSSES = [
  BossID.CHUB, // 3
  BossID.GURDY, // 4
  BossID.PESTILENCE, // 10
  BossID.PEEP, // 14
  BossID.FISTULA, // 18 (added in Repentance)
  BossID.CHAD, // 21
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.GURDY_JR, // 28
  BossID.MEGA_MAW, // 45 (added in Repentance)
  BossID.MEGA_FATTY, // 47 (added in Repentance)
  // - `BossID.DARK_ONE` (50) was removed in Repentance.
  // - `BossID.POLYCEPHALUS` (52) was removed in Repentance.
  BossID.STAIN, // 57
  BossID.FORSAKEN, // 59
  BossID.FRAIL, // 66
  BossID.RAG_MEGA, // 67
  BossID.BIG_HORN, // 69
  BossID.BUMBINO, // 94 (added in Repentance)
] as const;

/** For `StageID.MINES` (29). */
const MINES_BOSSES = [
  BossID.REAP_CREEP, // 74
  BossID.TUFF_TWINS, // 80
  BossID.HORNFEL, // 82
  BossID.GREAT_GIDEON, // 83
] as const;

/** For `StageID.ASHPIT` (30). */
const ASHPIT_BOSSES = [
  BossID.PILE, // 73
  BossID.GREAT_GIDEON, // 83
  BossID.SINGE, // 93
  BossID.SHELL, // 96
  BossID.CLUTCH, // 102
] as const;

/** The set of unique bosses for Caves, Catacombs, Flooded Caves, Mines, and Ashpit. */
const ALL_CAVES_BOSSES_SET = new ReadonlySet<BossID>([
  ...CAVES_BOSSES,
  ...CATACOMBS_BOSSES,
  ...FLOODED_CAVES_BOSSES,
  ...MINES_BOSSES,
  ...ASHPIT_BOSSES,
]);

/**
 * For `StageID.DEPTHS` (7).
 *
 * Note that this set includes Mom, even though they are not technically in the boss pool.
 */
const DEPTHS_BOSSES = [
  BossID.MONSTRO_2, // 5
  BossID.MOM, // 6
  BossID.WAR, // 11
  BossID.LOKI, // 15
  BossID.GISH, // 19
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.GATE, // 46
  BossID.CAGE, // 48
  // - `BossID.ADVERSARY` (51) was removed in Repentance.
  BossID.BROWNIE, // 58
  BossID.SISTERS_VIS, // 68
  BossID.REAP_CREEP, // 74 (added in Repentance)
] as const;

/**
 * For `StageID.NECROPOLIS` (8).
 *
 * Note that this set includes Mom, even though they are not technically in the boss pool.
 */
const NECROPOLIS_BOSSES = [
  BossID.MOM, // 6
  BossID.WAR, // 11
  BossID.LOKI, // 15
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.BLOAT, // 30
  BossID.MASK_OF_INFAMY, // 35
  // - `BossID.GATE` (46) was removed in Repentance.
  BossID.ADVERSARY, // 51
  BossID.BROWNIE, // 58
  BossID.SISTERS_VIS, // 68
  BossID.PILE, // 73 (added in Repentance)
] as const;

/**
 * For `StageID.DANK_DEPTHS` (9).
 *
 * Note that this set includes Mom, even though they are not technically in the boss pool.
 */
const DANK_DEPTHS_BOSSES = [
  BossID.MONSTRO_2, // 5
  BossID.MOM, // 6
  BossID.WAR, // 11
  BossID.LOKI, // 15
  BossID.GISH, // 19
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.GATE, // 46 (added in Repentance)
  BossID.CAGE, // 48 (added in Repentance)
  // - `BossID.ADVERSARY` (51) was removed in Repentance.
  BossID.BROWNIE, // 58
  BossID.SISTERS_VIS, // 68
  BossID.REAP_CREEP, // 74 (added in Repentance)
] as const;

/**
 * For `StageID.MAUSOLEUM` (31).
 *
 * Note that this set includes Mausoleum Mom, even though they are not technically in the boss pool.
 */
const MAUSOLEUM_BOSSES = [
  BossID.SIREN, // 79
  BossID.HERETIC, // 81
  BossID.MAUSOLEUM_MOM, // 89
] as const;

/**
 * For `StageID.GEHENNA` (32).
 *
 * Note that this set includes Mausoleum Mom, even though they are not technically in the boss pool.
 */
const GEHENNA_BOSSES = [
  BossID.VISAGE, // 78
  BossID.MAUSOLEUM_MOM, // 89
  BossID.HORNY_BOYS, // 101
] as const;

/** The set of unique bosses for Depths, Necropolis, Dank Depths, Mausoleum, and Gehenna. */
const ALL_DEPTHS_BOSSES_SET = new ReadonlySet<BossID>([
  ...DEPTHS_BOSSES,
  ...NECROPOLIS_BOSSES,
  ...DANK_DEPTHS_BOSSES,
  ...MAUSOLEUM_BOSSES,
  ...GEHENNA_BOSSES,
]);

/**
 * For `StageID.WOMB` (10).
 *
 * Note that this set includes Mom's Heart & It Lives, even though they are not technically in the
 * boss pool.
 */
const WOMB_BOSSES = [
  BossID.SCOLEX, // 7
  BossID.MOMS_HEART, // 8
  BossID.DEATH, // 12
  BossID.BLASTOCYST, // 16
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.IT_LIVES, // 25
  // - `BossID.BLOAT` (30) was removed in Repentance.
  BossID.LOKII, // 31
  // - `BossID.TERATOMA` (33) was removed in Repentance.
  BossID.CONQUEST, // 38
  // - `BossID.DADDY_LONG_LEGS` (41) was removed in Repentance.
  // - `BossID.TRIACHNID` (42) was removed in Repentance.
  BossID.MAMA_GURDY, // 49
  BossID.MR_FRED, // 53
  // - `BossID.SISTERS_VIS` (68) was removed in Repentance.
  BossID.MATRIARCH, // 72
] as const;

/**
 * For `StageID.UTERO` (11).
 *
 * Note that this set includes Mom's Heart & It Lives, even though they are not technically in the
 * boss pool.
 */
const UTERO_BOSSES = [
  BossID.MOMS_HEART, // 8
  BossID.DEATH, // 12
  // - `BossID.BLASTOCYST` (16) was removed in Repentance.
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.IT_LIVES, // 25
  BossID.BLOAT, // 30
  BossID.LOKII, // 31
  BossID.TERATOMA, // 33
  BossID.CONQUEST, // 38
  BossID.DADDY_LONG_LEGS, // 41
  BossID.TRIACHNID, // 42
  // - `BossID.MAMA_GURDY` (49) was removed in Repentance.
  // - `BossID.MR_FRED` (52) was removed in Repentance.
  // - `BossID.SISTERS_VIS` (68) was removed in Repentance.
  // - `BossID.MATRIARCH` (72) was removed in Repentance.
] as const;

/**
 * For `StageID.SCARRED_WOMB` (12).
 *
 * Note that this set includes Mom's Heart & It Lives, even though they are not technically in the
 * boss pool.
 */
const SCARRED_WOMB_BOSSES = [
  BossID.SCOLEX, // 7
  BossID.MOMS_HEART, // 8
  BossID.DEATH, // 12
  BossID.BLASTOCYST, // 16
  BossID.HEADLESS_HORSEMAN, // 22
  BossID.FALLEN, // 23
  BossID.IT_LIVES, // 25
  // - `BossID.BLOAT` (30) was removed in Repentance.
  BossID.LOKII, // 31 (added in Repentance)
  // - `BossID.TERATOMA` (33) was removed in Repentance.
  BossID.CONQUEST, // 38
  // - `BossID.DADDY_LONG_LEGS` (41) was removed in Repentance.
  BossID.TRIACHNID, // 42
  BossID.MAMA_GURDY, // 49
  BossID.MR_FRED, // 53 (added in Repentance)
  // - `BossID.SISTERS_VIS` (68) was removed in Repentance.
  BossID.MATRIARCH, // 72
] as const;

/**
 * For `StageID.CORPSE` (33).
 *
 * Note that this set includes Mother, even though she is not technically in the boss pool.
 */
const CORPSE_BOSSES = [
  BossID.SCOURGE, // 85
  BossID.CHIMERA, // 86
  BossID.ROTGUT, // 87
  BossID.MOTHER, // 88
] as const;

/** The set of unique bosses for Womb, Utero, Scarred Womb, and Corpse. */
const ALL_WOMB_BOSSES_SET = new ReadonlySet([
  ...WOMB_BOSSES,
  ...UTERO_BOSSES,
  ...SCARRED_WOMB_BOSSES,
  ...CORPSE_BOSSES,
]);

const BLUE_WOMB_BOSSES = [
  BossID.HUSH, // 63
] as const;

const ALL_BLUE_WOMB_BOSSES_SET = new ReadonlySet<BossID>([...BLUE_WOMB_BOSSES]);

const SHEOL_BOSSES = [
  BossID.SATAN, // 24
] as const;

const CATHEDRAL_BOSSES = [
  BossID.ISAAC, // 39
] as const;

const ALL_STAGE_10_BOSSES_SET = new ReadonlySet<BossID>([
  ...SHEOL_BOSSES,
  ...CATHEDRAL_BOSSES,
]);

/**
 * Note that this set includes Mega Satan, even though they are not technically in the boss pool.
 */
const DARK_ROOM_BOSSES = [
  BossID.LAMB, // 54
  BossID.MEGA_SATAN, // 55
] as const;

/**
 * Note that this set includes Mega Satan, even though they are not technically in the boss pool.
 */
const CHEST_BOSSES = [
  BossID.BLUE_BABY, // 40
  BossID.MEGA_SATAN, // 55
] as const;

const ALL_STAGE_11_BOSSES_SET = new ReadonlySet<BossID>([
  ...DARK_ROOM_BOSSES,
  ...CHEST_BOSSES,
]);

const VOID_BOSSES = [
  BossID.DELIRIUM, // 70
] as const;

const ALL_VOID_BOSSES_SET = new ReadonlySet<BossID>([...VOID_BOSSES]);

/**
 * Includes Dogma and The Beast. Does not include Ultra Famine, Ultra Pestilence, Ultra War, and
 * Ultra Death (since they do not have boss IDs).
 */
const HOME_BOSSES = [
  BossID.DOGMA, // 99
  BossID.BEAST, // 100
] as const;

const ALL_HOME_BOSSES_SET = new ReadonlySet<BossID>([...HOME_BOSSES]);

export const STAGE_ID_TO_BOSS_IDS = new ReadonlyMap<StageID, readonly BossID[]>(
  [
    [StageID.BASEMENT, BASEMENT_BOSSES], // 1
    [StageID.CELLAR, CELLAR_BOSSES], // 2
    [StageID.BURNING_BASEMENT, BURNING_BASEMENT_BOSSES], // 3
    [StageID.DOWNPOUR, DOWNPOUR_BOSSES], // 27
    [StageID.DROSS, DROSS_BOSSES], // 28

    [StageID.CAVES, CAVES_BOSSES], // 4
    [StageID.CATACOMBS, CATACOMBS_BOSSES], // 5
    [StageID.FLOODED_CAVES, FLOODED_CAVES_BOSSES], // 6
    [StageID.MINES, MINES_BOSSES], // 29
    [StageID.ASHPIT, ASHPIT_BOSSES], // 30

    [StageID.DEPTHS, DEPTHS_BOSSES], // 7
    [StageID.NECROPOLIS, NECROPOLIS_BOSSES], // 8
    [StageID.DANK_DEPTHS, DANK_DEPTHS_BOSSES], // 9
    [StageID.MAUSOLEUM, MAUSOLEUM_BOSSES], // 31
    [StageID.GEHENNA, GEHENNA_BOSSES], // 32

    [StageID.WOMB, WOMB_BOSSES], // 10
    [StageID.UTERO, UTERO_BOSSES], // 11
    [StageID.SCARRED_WOMB, SCARRED_WOMB_BOSSES], // 12
    [StageID.CORPSE, CORPSE_BOSSES], // 33

    [StageID.BLUE_WOMB, BLUE_WOMB_BOSSES], // 13
    [StageID.SHEOL, SHEOL_BOSSES], // 14
    [StageID.CATHEDRAL, CATHEDRAL_BOSSES], // 15
    [StageID.DARK_ROOM, DARK_ROOM_BOSSES], // 16
    [StageID.CHEST, CHEST_BOSSES], // 17
    [StageID.VOID, VOID_BOSSES], // 26
    [StageID.HOME, HOME_BOSSES], // 35
  ],
);

export const STAGE_TO_COMBINED_BOSS_SET_MAP = new ReadonlyMap<
  LevelStage,
  ReadonlySet<BossID>
>([
  [LevelStage.BASEMENT_1, ALL_BASEMENT_BOSSES_SET], // 1
  [LevelStage.BASEMENT_2, ALL_BASEMENT_BOSSES_SET], // 2
  [LevelStage.CAVES_1, ALL_CAVES_BOSSES_SET], // 3
  [LevelStage.CAVES_2, ALL_CAVES_BOSSES_SET], // 4
  [LevelStage.DEPTHS_1, ALL_DEPTHS_BOSSES_SET], // 5
  [LevelStage.DEPTHS_2, ALL_DEPTHS_BOSSES_SET], // 6
  [LevelStage.WOMB_1, ALL_WOMB_BOSSES_SET], // 7
  [LevelStage.WOMB_2, ALL_WOMB_BOSSES_SET], // 8
  [LevelStage.BLUE_WOMB, ALL_BLUE_WOMB_BOSSES_SET], // 9
  [LevelStage.SHEOL_CATHEDRAL, ALL_STAGE_10_BOSSES_SET], // 10
  [LevelStage.DARK_ROOM_CHEST, ALL_STAGE_11_BOSSES_SET], // 11
  [LevelStage.VOID, ALL_VOID_BOSSES_SET], // 12
  [LevelStage.HOME, ALL_HOME_BOSSES_SET], // 13
]);

export const ALL_BOSSES: readonly BossID[] = BOSS_ID_VALUES.filter(
  (bossID) => bossID !== BossID.RAGLICH,
);

export const NON_STORY_BOSSES: readonly BossID[] = ALL_BOSSES.filter(
  (bossID) => !isStoryBossID(bossID),
);

export const BOSS_ID_TO_STAGE_IDS = (() => {
  const partialBossIDsToStageIDs: Partial<Record<BossID, Set<StageID>>> = {};

  for (const bossID of BOSS_ID_VALUES) {
    const stageIDs = new Set<StageID>();
    for (const [stageID, bossIDs] of STAGE_ID_TO_BOSS_IDS) {
      if (bossIDs.includes(bossID)) {
        stageIDs.add(stageID);
      }
    }

    partialBossIDsToStageIDs[bossID] = stageIDs;
  }

  const bossIDsToStageIDs = partialBossIDsToStageIDs as Record<
    BossID,
    Set<StageID>
  >;

  // In Repentance, the following bosses will have empty sets:
  // - BossID.ULTRA_GREED (62)
  // - BossID.ULTRA_GREEDIER (71)
  // - BossID.MAUSOLEUM_MOMS_HEART (90)
  // - BossID.RAGLICH (98)

  bossIDsToStageIDs[BossID.ULTRA_GREED].add(StageID.ULTRA_GREED); // 62
  bossIDsToStageIDs[BossID.ULTRA_GREEDIER].add(StageID.ULTRA_GREED); // 71
  bossIDsToStageIDs[BossID.MAUSOLEUM_MOMS_HEART].add(StageID.MAUSOLEUM); // 90
  bossIDsToStageIDs[BossID.MAUSOLEUM_MOMS_HEART].add(StageID.GEHENNA); // 90

  return bossIDsToStageIDs as Readonly<Record<BossID, ReadonlySet<StageID>>>;
})();

----
sets\charactersThatStartWithAnActiveItemSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const CHARACTERS_THAT_START_WITH_AN_ACTIVE_ITEM_SET =
  new ReadonlySet<PlayerType>([
    PlayerType.ISAAC, // 0
    PlayerType.MAGDALENE, // 1
    PlayerType.JUDAS, // 3
    PlayerType.BLUE_BABY, // 4
    PlayerType.EVE, // 5
    PlayerType.EDEN, // 9
    PlayerType.LOST, // 10
    PlayerType.LILITH, // 13
    PlayerType.KEEPER, // 14
    PlayerType.APOLLYON, // 15
    PlayerType.EDEN_B, // 30
  ]);

----
sets\charactersWithBlackHeartFromEternalHeartSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const CHARACTERS_WITH_BLACK_HEART_FROM_ETERNAL_HEART_SET =
  new ReadonlySet<PlayerType>([
    PlayerType.DARK_JUDAS, // 12
    PlayerType.JUDAS_B, // 24
  ]);

----
sets\charactersWithFreeDevilDealsSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const CHARACTERS_WITH_FREE_DEVIL_DEALS_SET = new ReadonlySet<PlayerType>(
  [PlayerType.LOST, PlayerType.LOST_B, PlayerType.JACOB_2_B],
);

----
sets\charactersWithNoRedHeartsSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

/**
 * The set of characters where red heart containers will be turned into soul hearts (e.g. Blue
 * Baby). This includes The Lost and Tainted Lost. This does not include Keeper or Tainted Keeper.
 */
export const CHARACTERS_WITH_NO_RED_HEARTS_SET = new ReadonlySet<PlayerType>([
  PlayerType.BLUE_BABY, // 4
  PlayerType.LOST, // 10
  PlayerType.DARK_JUDAS, // 12
  PlayerType.JUDAS_B, // 24
  PlayerType.BLUE_BABY_B, // 25
  PlayerType.LOST_B, // 31
  PlayerType.FORGOTTEN_B, // 35
  PlayerType.BETHANY_B, // 36
]);

----
sets\charactersWithNoSoulHeartsSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

/**
 * The set of characters where soul hearts will be automatically stripped away (e.g. Bethany). This
 * includes The Lost and Tainted Lost.
 */
export const CHARACTERS_WITH_NO_SOUL_HEARTS_SET = new ReadonlySet<PlayerType>([
  PlayerType.LOST, // 10
  PlayerType.KEEPER, // 14
  PlayerType.BETHANY, // 18
  PlayerType.LOST_B, // 31
  PlayerType.KEEPER_B, // 33
]);

----
sets\consoleCommandsSet.ts
import { ReadonlySet } from "../types/ReadonlySet";

/**
 * The set of vanilla console commands, as documented here:
 * https://bindingofisaacrebirth.fandom.com/wiki/Debug_Console
 */
export const CONSOLE_COMMANDS_SET = new ReadonlySet<string>([
  // Listed commands
  "achievement",
  "challenge",
  "clear",
  "clearcache",
  "clearseeds",
  "combo",
  "copy",
  "costumetest",
  "curse",
  "cutscene",
  "debug",
  "delirious",
  "eggs",
  "giveitem",
  "g",
  "goto",
  "gridspawn",
  "listcollectibles",
  "lua",
  "l",
  "luamem",
  "luamod",
  "luarun",
  "macro",
  "m",
  "metro",
  "playsfx",
  "prof",
  "profstop",
  "remove",
  "r",
  "reloadfx",
  "reloadshaders",
  "repeat",
  "reseed",
  "restart",
  "seed",
  "spawn",
  "stage",
  "time",

  // Unlisted commands
  "addplayer",
  "forceroom",
  "giveitem2",
  "g2",
  "netdelay",
  "netstart",
  "remove2",
  "r2",
  "reloadwisps",
  "restock",
  "rewind",
  "testbosspool",
]);

----
sets\entitiesWithArmorSet.ts
import {
  BeastVariant,
  BloodPuppyVariant,
  BoomFlyVariant,
  Charger2Variant,
  DogmaVariant,
  EntityType,
  FacelessVariant,
  Gaper2Variant,
  GuttyFattyVariant,
  HiveVariant,
  HopperVariant,
  IsaacVariant,
  MegaSatanVariant,
  MoleVariant,
  MotherVariant,
  PooterVariant,
  RoundWormVariant,
  SubHorfVariant,
  SuckerVariant,
  UltraGreedVariant,
  WallCreepVariant,
} from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

/**
 * "Armor" refers to the damage scaling mechanic. The following list corresponds to the entities
 * that have the "shieldStrength" field in the "entities2.xml" file, with some exceptions.
 * (Invulnerable enemies are not included. Furthermore, Ultra Greed, Ultra Greedier, and Delirium
 * all have damage scaling, but do not have a corresponding "shieldStrength" field.)
 *
 * Also see:
 * https://bindingofisaacrebirth.fandom.com/wiki/Damage_Scaling#Entities_with_Armor_Values
 *
 * We use strings instead of a type + variant tuple so that we can have O(1) lookups.
 */
export const ENTITIES_WITH_ARMOR_SET = new ReadonlySet<string>([
  `${EntityType.POOTER}.${PooterVariant.TAINTED_POOTER}`, // 14.2
  `${EntityType.HIVE}.${HiveVariant.TAINTED_MULLIGAN}`, // 22.3
  `${EntityType.BOOM_FLY}.${BoomFlyVariant.TAINTED_BOOM_FLY}`, // 25.6
  `${EntityType.HOPPER}.${HopperVariant.TAINTED_HOPPER}`, // 29.3
  `${EntityType.SPITTY}`, // 31.1
  `${EntityType.SUCKER}.${SuckerVariant.TAINTED_SUCKER}`, // 61.7
  `${EntityType.ISAAC}.${IsaacVariant.BLUE_BABY_HUSH}`, // 102.2
  `${EntityType.WALL_CREEP}.${WallCreepVariant.TAINTED_SOY_CREEP}`, // 240.3
  `${EntityType.ROUND_WORM}.${RoundWormVariant.TAINTED_ROUND_WORM}`, // 244.2
  `${EntityType.ROUND_WORM}.${RoundWormVariant.TAINTED_TUBE_WORM}`, // 244.3
  `${EntityType.MEGA_SATAN}.${MegaSatanVariant.MEGA_SATAN}`, // 274.0
  `${EntityType.MEGA_SATAN}.${MegaSatanVariant.MEGA_SATAN_RIGHT_HAND}`, // 274.1
  `${EntityType.MEGA_SATAN}.${MegaSatanVariant.MEGA_SATAN_LEFT_HAND}`, // 274.2
  `${EntityType.MEGA_SATAN_2}.${MegaSatanVariant.MEGA_SATAN}`, // 275.0
  `${EntityType.MEGA_SATAN_2}.${MegaSatanVariant.MEGA_SATAN_RIGHT_HAND}`, // 275.1
  `${EntityType.MEGA_SATAN_2}.${MegaSatanVariant.MEGA_SATAN_LEFT_HAND}`, // 275.2
  `${EntityType.ULTRA_GREED}.${UltraGreedVariant.ULTRA_GREED}`, // 406.0
  `${EntityType.ULTRA_GREED}.${UltraGreedVariant.ULTRA_GREEDIER}`, // 406.1
  `${EntityType.HUSH}.0`, // 407.0
  `${EntityType.DELIRIUM}.0`, // 412.0
  `${EntityType.BLOOD_PUPPY}.${BloodPuppyVariant.SMALL}`, // 802.0
  `${EntityType.BLOOD_PUPPY}.${BloodPuppyVariant.LARGE}`, // 802.1
  `${EntityType.SUB_HORF}.${SubHorfVariant.TAINTED_SUB_HORF}`, // 812.1
  `${EntityType.FACELESS}.${FacelessVariant.TAINTED_FACELESS}`, // 827.1
  `${EntityType.MOLE}.${MoleVariant.TAINTED_MOLE}`, // 829.1
  `${EntityType.GUTTED_FATTY}.${GuttyFattyVariant.GUTTED_FATTY}`, // 831.0
  `${EntityType.GAPER_LVL_2}.${Gaper2Variant.GAPER}`, // 850.0
  `${EntityType.GAPER_LVL_2}.${Gaper2Variant.HORF}`, // 850.1
  `${EntityType.GAPER_LVL_2}.${Gaper2Variant.GUSHER}`, // 850.2
  `${EntityType.CHARGER_LVL_2}.${Charger2Variant.CHARGER}`, // 855.0
  `${EntityType.CHARGER_LVL_2}.${Charger2Variant.ELLEECH}`, // 855.1
  `${EntityType.SHADY}.0`, // 888.0
  `${EntityType.MOTHER}.${MotherVariant.MOTHER_1}`, // 912.0
  `${EntityType.MOTHER}.${MotherVariant.MOTHER_2}`, // 912.10
  `${EntityType.DOGMA}.${DogmaVariant.TV}`, // 950.1
  `${EntityType.DOGMA}.${DogmaVariant.ANGEL_PHASE_2}`, // 950.2
  `${EntityType.BEAST}.${BeastVariant.BEAST}`, // 951.0
  `${EntityType.BEAST}.${BeastVariant.ULTRA_FAMINE}`, // 951.10
  `${EntityType.BEAST}.${BeastVariant.ULTRA_PESTILENCE}`, // 951.20
  `${EntityType.BEAST}.${BeastVariant.ULTRA_WAR}`, // 951.30
  `${EntityType.BEAST}.${BeastVariant.ULTRA_DEATH}`, // 951.40
]);

----
sets\familiarsThatShootPlayerTearsSet.ts
import { FamiliarVariant } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const FAMILIARS_THAT_SHOOT_PLAYER_TEARS_SET =
  new ReadonlySet<FamiliarVariant>([
    FamiliarVariant.SCISSORS,
    FamiliarVariant.INCUBUS,
    FamiliarVariant.FATES_REWARD,
    FamiliarVariant.SPRINKLER,
    FamiliarVariant.LOST_SOUL,
    FamiliarVariant.TWISTED_BABY,
    FamiliarVariant.BLOOD_BABY,
    FamiliarVariant.DECAP_ATTACK,
  ]);

----
sets\itemConfigCardTypesForCards.ts
import { ItemConfigCardType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

/** The set of all `ItemConfigCardType` values that are not a rune or special object. */
export const ITEM_CONFIG_CARD_TYPES_FOR_CARDS =
  new ReadonlySet<ItemConfigCardType>([
    ItemConfigCardType.TAROT, // 0
    ItemConfigCardType.SUIT, // 1
    // - ItemConfigCardType.RUNE (2)
    ItemConfigCardType.SPECIAL, // 3
    // - ItemConfigCardType.SPECIAL_OBJECT (4)
    ItemConfigCardType.TAROT_REVERSE, // 5
  ]);

----
sets\lostStyleCharactersSet.ts
import { PlayerType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

/**
 * This is the set of characters that look like The Lost and play the "LostDeath" animation when
 * they die.
 */
export const LOST_STYLE_CHARACTERS_SET = new ReadonlySet<PlayerType>([
  PlayerType.LOST, // 10
  PlayerType.SOUL, // 17
  PlayerType.LOST_B, // 31
  PlayerType.JACOB_2_B, // 39
  PlayerType.SOUL_B, // 40
]);

----
sets\mineShaftRoomSubTypesSet.ts
import { MinesRoomSubType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const MINE_SHAFT_ROOM_SUB_TYPE_SET = new ReadonlySet<MinesRoomSubType>([
  MinesRoomSubType.MINESHAFT_ENTRANCE,
  MinesRoomSubType.MINESHAFT_LOBBY,
  MinesRoomSubType.MINESHAFT_KNIFE_PIECE,
  MinesRoomSubType.MINESHAFT_ROOM_PRE_CHASE,
  MinesRoomSubType.MINESHAFT_ROOM_POST_CHASE,
]);

----
sets\narrowRoomShapesSet.ts
import { RoomShape } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const NARROW_ROOM_SHAPES_SET = new ReadonlySet<RoomShape>([
  RoomShape.IH, // 2
  RoomShape.IV, // 3
  RoomShape.IIV, // 5
  RoomShape.IIH, // 7
]);

----
sets\poopGridEntityXMLTypesSet.ts
import { GridEntityXMLType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const POOP_GRID_ENTITY_XML_TYPES_SET =
  new ReadonlySet<GridEntityXMLType>([
    GridEntityXMLType.POOP_RED, // 1490
    GridEntityXMLType.POOP_RAINBOW, // 1494
    GridEntityXMLType.POOP_CORNY, // 1495
    GridEntityXMLType.POOP_GOLDEN, // 1496
    GridEntityXMLType.POOP_BLACK, // 1497
    GridEntityXMLType.POOP_WHITE, // 1498
    GridEntityXMLType.POOP_GIGA, // 1499
    GridEntityXMLType.POOP, // 1500
    GridEntityXMLType.POOP_CHARMING, // 1501
  ]);

----
sets\redHeartSubTypesSet.ts
import { HeartSubType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const RED_HEART_SUB_TYPES_SET = new ReadonlySet<HeartSubType>([
  HeartSubType.FULL, // 1
  HeartSubType.HALF, // 2
  HeartSubType.DOUBLE_PACK, // 5
]);

----
sets\repentanceBossIDsSet.ts
import { BossID } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const REPENTANCE_ONLY_BOSS_IDS_SET = new ReadonlySet<BossID>([
  BossID.LIL_BLUB, // 75
  BossID.WORMWOOD, // 76
  BossID.RAINMAKER, // 77
  BossID.VISAGE, // 78
  BossID.SIREN, // 79
  BossID.TUFF_TWINS, // 80
  BossID.HERETIC, // 81
  BossID.HORNFEL, // 82
  BossID.GREAT_GIDEON, // 83
  BossID.SCOURGE, // 85
  BossID.CHIMERA, // 86
  BossID.ROTGUT, // 87
  BossID.MOTHER, // 88
  BossID.MAUSOLEUM_MOM, // 89
  BossID.MAUSOLEUM_MOMS_HEART, // 90
  BossID.MIN_MIN, // 91
  BossID.CLOG, // 92
  BossID.SINGE, // 93
  BossID.COLOSTOMIA, // 95
  BossID.SHELL, // 96
  BossID.TURDLET, // 97
  BossID.HORNY_BOYS, // 101
  BossID.CLUTCH, // 102
]);

----
sets\sinEntityTypesSet.ts
import { EntityType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const SIN_ENTITY_TYPES_SET = new ReadonlySet<EntityType>([
  EntityType.SLOTH, // 46
  EntityType.LUST, // 47
  EntityType.WRATH, // 48
  EntityType.GLUTTONY, // 49
  EntityType.GREED, // 50
  EntityType.ENVY, // 51
  EntityType.PRIDE, // 52
]);

----
sets\singleUseActiveCollectibleTypesSet.ts
import { CollectibleType } from "isaac-typescript-definitions";
import { ReadonlySet } from "../types/ReadonlySet";

export const SINGLE_USE_ACTIVE_COLLECTIBLE_TYPES_SET =
  new ReadonlySet<CollectibleType>([
    CollectibleType.FORGET_ME_NOW, // 127
    CollectibleType.EDENS_SOUL, // 490
    CollectibleType.ALABASTER_BOX, // 585
    CollectibleType.PLAN_C, // 475
    CollectibleType.MAMA_MEGA, // 483
    CollectibleType.SACRIFICIAL_ALTAR, // 536
    CollectibleType.DEATH_CERTIFICATE, // 628
    CollectibleType.R_KEY, // 636
  ]);

----
shaderCrashFix.ts
import { EntityType, ModCallback } from "isaac-typescript-definitions";

/**
 * Using the "luamod" console command with a mod that has custom shaders can crash the game. A
 * simple fix for this is automatically applied to any upgraded mods. This method was originally
 * discovered by AgentCucco.
 *
 * This code is not put inside of a feature class because we want it to apply to every upgraded mod,
 * but we do not want to have any mandatory features. Mandatory features are confusing for end-users
 * since the type of their upgraded mod would contain features that they did not explicitly enable.
 */
export function applyShaderCrashFix(mod: Mod): void {
  mod.AddCallback(ModCallback.POST_PLAYER_INIT, postPlayerInit); // 9
}

// ModCallback.POST_PLAYER_INIT (9)
function postPlayerInit(_player: EntityPlayer) {
  const players = Isaac.FindByType(EntityType.PLAYER);
  if (players.length === 0) {
    Isaac.ExecuteCommand("reloadshaders");
  }
}

----
shouldFire.ts
/*
eslint sort-exports/sort-exports: [
  "error",
  {
    sortDir: "asc",
  },
]
*/

// These are validation functions for specific types of callbacks. (End-users can provide optional
// arguments during callback registration such that their function should only fire when certain
// conditions are met.)

// Since multiple callbacks can have the same kinds of filtration, we prevent repetition by
// abstracting the validation logic into separate functions here.

import type {
  BombVariant,
  CollectibleType,
  DamageFlag,
  DoorVariant,
  EffectVariant,
  EntityType,
  FamiliarVariant,
  GridEntityType,
  ItemType,
  KnifeVariant,
  LaserVariant,
  LevelStage,
  PickupVariant,
  PitVariant,
  PlayerType,
  PlayerVariant,
  PoopGridEntityVariant,
  PressurePlateVariant,
  ProjectileVariant,
  RoomType,
  SlotVariant,
  StageType,
  TearVariant,
  TrinketType,
} from "isaac-typescript-definitions";
import type { AmbushType } from "./enums/AmbushType";
import type { HealthType } from "./enums/HealthType";
import type { PlayerStat } from "./enums/PlayerStat";
import type { SlotDestructionType } from "./enums/SlotDestructionType";
import type { PickingUpItem } from "./types/PickingUpItem";
import type { PossibleStatType } from "./types/PossibleStatType";

export function shouldFireAmbush(
  fireArgs: [ambushType: AmbushType],
  optionalArgs: [ambushType?: AmbushType],
): boolean {
  const [ambushType] = fireArgs;
  const [callbackAmbushType] = optionalArgs;

  return callbackAmbushType === undefined || callbackAmbushType === ambushType;
}

export function shouldFireBomb(
  fireArgs:
    | [bomb: EntityBomb]
    | [bomb: EntityBomb, renderOffset: Vector]
    | [bomb: EntityBomb, collider: Entity, low: boolean],
  optionalArgs: [bombVariant?: BombVariant, subType?: int],
): boolean {
  const [bomb] = fireArgs;
  const [callbackBombVariant, callbackSubType] = optionalArgs;

  return (
    (callbackBombVariant === undefined ||
      callbackBombVariant === bomb.Variant) &&
    (callbackSubType === undefined || callbackSubType === bomb.SubType)
  );
}

export function shouldFireBoolean(
  fireArgs: [fireArg: boolean],
  optionalArgs: [optionalArg?: boolean],
): boolean {
  const [fireArg] = fireArgs;
  const [optionalArg] = optionalArgs;

  return optionalArg === undefined || optionalArg === fireArg;
}

export function shouldFireCollectibleType(
  fireArgs: [player: EntityPlayer, collectibleType: CollectibleType],
  optionalArgs: [collectibleType?: CollectibleType],
): boolean {
  const [_player, collectibleType] = fireArgs;
  const [callbackCollectibleType] = optionalArgs;

  return (
    callbackCollectibleType === undefined ||
    callbackCollectibleType === collectibleType
  );
}

export function shouldFireDoor(
  fireArgs: [rock: GridEntityDoor],
  optionalArgs: [doorVariant?: DoorVariant],
): boolean {
  const [door] = fireArgs;
  const [callbackDoorVariant] = optionalArgs;

  const doorVariant = door.GetVariant();

  return (
    callbackDoorVariant === undefined || callbackDoorVariant === doorVariant
  );
}

export function shouldFireEffect(
  fireArgs:
    | [effect: EntityEffect]
    | [effect: EntityEffect, renderOffset: Vector]
    | [effect: EntityEffect, previousState: int, currentState: int],
  optionalArgs: [effectVariant?: EffectVariant, subType?: int],
): boolean {
  const [effect] = fireArgs;
  const [callbackEffectVariant, callbackSubType] = optionalArgs;

  return (
    (callbackEffectVariant === undefined ||
      callbackEffectVariant === effect.Variant) &&
    (callbackSubType === undefined || callbackSubType === effect.SubType)
  );
}

export function shouldFireEntity(
  fireArgs:
    | [entity: Entity]
    | [
        entity: Entity,
        amount: number,
        damageFlags: BitFlags<DamageFlag>,
        source: EntityRef,
        countdownFrames: number,
      ],
  optionalArgs: [entityType?: EntityType, variant?: int, subType?: int],
): boolean {
  const [entity] = fireArgs;
  const [callbackEntityType, callbackVariant, callbackSubType] = optionalArgs;

  return (
    (callbackEntityType === undefined || callbackEntityType === entity.Type) &&
    (callbackVariant === undefined || callbackVariant === entity.Variant) &&
    (callbackSubType === undefined || callbackSubType === entity.SubType)
  );
}

export function shouldFireFamiliar(
  fireArgs:
    | [familiar: EntityFamiliar]
    | [familiar: EntityFamiliar, renderOffset: Vector]
    | [familiar: EntityFamiliar, collider: Entity, low: boolean]
    | [familiar: EntityFamiliar, previousState: int, currentState: int],
  optionalArgs: [familiarVariant?: FamiliarVariant, subType?: int],
): boolean {
  const [familiar] = fireArgs;
  const [callbackFamiliarVariant, callbackSubType] = optionalArgs;

  return (
    (callbackFamiliarVariant === undefined ||
      callbackFamiliarVariant === familiar.Variant) &&
    (callbackSubType === undefined || callbackSubType === familiar.SubType)
  );
}

export function shouldFireGridEntity(
  fireArgs:
    | [gridEntity: GridEntity]
    | [gridEntity: GridEntity, oldState: int, newState: int],
  optionalArgs: [gridEntityType?: GridEntityType, variant?: int],
): boolean {
  const [gridEntity] = fireArgs;
  const [callbackGridEntityType, callbackVariant] = optionalArgs;

  const gridEntityType = gridEntity.GetType();
  const variant = gridEntity.GetVariant();

  return (
    (callbackGridEntityType === undefined ||
      callbackGridEntityType === gridEntityType) &&
    (callbackVariant === undefined || callbackVariant === variant)
  );
}

export function shouldFireGridEntityCustom(
  fireArgs:
    | [gridEntity: GridEntity, gridEntityTypeCustom: GridEntityType]
    | [
        gridEntity: GridEntity,
        gridEntityTypeCustom: GridEntityType,
        oldState: int,
        newState: int,
      ],
  optionalArgs: [gridEntityTypeCustom?: GridEntityType],
): boolean {
  const [_gridEntity, gridEntityTypeCustom] = fireArgs;
  const [callbackGridEntityTypeCustom] = optionalArgs;

  return (
    callbackGridEntityTypeCustom === undefined ||
    callbackGridEntityTypeCustom === gridEntityTypeCustom
  );
}

export function shouldFireItemPickup(
  fireArgs: [player: EntityPlayer, pickingUpItem: PickingUpItem],
  optionalArgs: [itemType?: ItemType, subType?: int],
): boolean {
  const [_player, pickingUpItem] = fireArgs;
  const [callbackItemType, callbackSubtype] = optionalArgs;

  return (
    (callbackItemType === undefined ||
      callbackItemType === pickingUpItem.itemType) &&
    (callbackSubtype === undefined || callbackSubtype === pickingUpItem.subType)
  );
}

export function shouldFireKnife(
  fireArgs:
    | [knife: EntityKnife]
    | [knife: EntityKnife, renderOffset: Vector]
    | [knife: EntityKnife, collider: Entity, low: boolean],
  optionalArgs: [knifeVariant?: KnifeVariant, subType?: int],
): boolean {
  const [knife] = fireArgs;
  const [callbackKnifeVariant, callbackSubType] = optionalArgs;

  return (
    (callbackKnifeVariant === undefined ||
      callbackKnifeVariant === knife.Variant) &&
    (callbackSubType === undefined || callbackSubType === knife.SubType)
  );
}

export function shouldFireLaser(
  fireArgs: [laser: EntityLaser] | [laser: EntityLaser, renderOffset: Vector],
  optionalArgs: [laserVariant?: LaserVariant, subType?: int],
): boolean {
  const [laser] = fireArgs;
  const [callbackLaserVariant, callbackSubType] = optionalArgs;

  return (
    (callbackLaserVariant === undefined ||
      callbackLaserVariant === laser.Variant) &&
    (callbackSubType === undefined || callbackSubType === laser.SubType)
  );
}

export function shouldFireLevel(
  fireArgs: [stage: LevelStage, stageType: StageType],
  optionalArgs: [stage?: LevelStage, stageType?: StageType],
): boolean {
  const [stage, stageType] = fireArgs;
  const [callbackStage, callbackStageType] = optionalArgs;

  return (
    (callbackStage === undefined || callbackStage === stage) &&
    (callbackStageType === undefined || callbackStageType === stageType)
  );
}

export function shouldFireNPC(
  fireArgs:
    | [npc: EntityNPC]
    | [npc: EntityNPC, previousState: int, currentState: int]
    | [npc: EntityNPC, renderOffset: Vector]
    | [npc: EntityNPC, collider: Entity, low: boolean],
  optionalArgs: [entityType?: EntityType, variant?: int, subType?: int],
): boolean {
  const [npc] = fireArgs;
  const [callbackEntityType, callbackVariant, callbackSubType] = optionalArgs;

  return (
    (callbackEntityType === undefined || callbackEntityType === npc.Type) &&
    (callbackVariant === undefined || callbackVariant === npc.Variant) &&
    (callbackSubType === undefined || callbackSubType === npc.SubType)
  );
}

export function shouldFirePickup(
  fireArgs:
    | [pickup: EntityPickup]
    | [pickup: EntityPickup, renderOffset: Vector]
    | [pickup: EntityPickup, player: EntityPlayer]
    | [pickup: EntityPickup, previousState: int, currentState: int]
    | [
        pickup: EntityPickup,
        oldVariant: PickupVariant,
        oldSubType: int,
        newVariant: PickupVariant,
        newSubType: int,
      ],
  optionalArgs: [pickupVariant?: PickupVariant, subType?: int],
): boolean {
  const [pickup] = fireArgs;
  const [callbackPickupVariant, callbackPickupSubType] = optionalArgs;

  return (
    (callbackPickupVariant === undefined ||
      callbackPickupVariant === pickup.Variant) &&
    (callbackPickupSubType === undefined ||
      callbackPickupSubType === pickup.SubType)
  );
}

export function shouldFirePit(
  fireArgs: [pit: GridEntityPit],
  optionalArgs: [pitVariant?: PitVariant],
): boolean {
  const [pit] = fireArgs;
  const [callbackPitVariant] = optionalArgs;

  const pitVariant = pit.GetVariant();

  return callbackPitVariant === undefined || callbackPitVariant === pitVariant;
}

export function shouldFirePlayer(
  fireArgs:
    | [player: EntityPlayer]
    | [player: EntityPlayer, renderOffset: Vector]
    | [player: EntityPlayer, numSacrifices: int]
    | [player: EntityPlayer, collectible: EntityPickupCollectible]
    | [player: EntityPlayer, oldCharacter: PlayerType, newCharacter: PlayerType]
    | [
        player: EntityPlayer,
        healthType: HealthType,
        difference: int,
        oldValue: int,
        newValue: int,
      ]
    | [
        player: EntityPlayer,
        amount: float,
        damageFlags: BitFlags<DamageFlag>,
        source: EntityRef,
        countdownFrames: int,
      ]
    | [
        player: EntityPlayer,
        playerStat: PlayerStat,
        difference: int,
        oldValue: PossibleStatType,
        newValue: PossibleStatType,
      ],
  optionalArgs: [playerVariant?: PlayerVariant, character?: PlayerType],
): boolean {
  const [player] = fireArgs;
  const [callbackPlayerVariant, callbackCharacter] = optionalArgs;

  const character = player.GetPlayerType();

  return (
    (callbackPlayerVariant === undefined ||
      callbackPlayerVariant === player.Variant) &&
    (callbackCharacter === undefined || callbackCharacter === character)
  );
}

export function shouldFirePoop(
  fireArgs: [poop: GridEntityPoop],
  optionalArgs: [poopGridEntityVariant?: PoopGridEntityVariant],
): boolean {
  const [poop] = fireArgs;
  const [callbackPoopGridEntityVariant] = optionalArgs;

  const poopGridEntityVariant = poop.GetVariant();

  return (
    callbackPoopGridEntityVariant === undefined ||
    callbackPoopGridEntityVariant === poopGridEntityVariant
  );
}

export function shouldFirePressurePlate(
  fireArgs: [pressurePlate: GridEntityPressurePlate],
  optionalArgs: [pressurePlateVariant?: PressurePlateVariant],
): boolean {
  const [pressurePlate] = fireArgs;
  const [callbackPressurePlateVariant] = optionalArgs;

  const pressurePlateVariant = pressurePlate.GetVariant();

  return (
    callbackPressurePlateVariant === undefined ||
    callbackPressurePlateVariant === pressurePlateVariant
  );
}

export function shouldFireProjectile(
  fireArgs:
    | [projectile: EntityProjectile]
    | [projectile: EntityProjectile, renderOffset: Vector]
    | [projectile: EntityProjectile, collider: Entity, low: boolean],
  optionalArgs: [projectileVariant?: ProjectileVariant, subType?: int],
): boolean {
  const [projectile] = fireArgs;
  const [callbackProjectileVariant, callbackSubType] = optionalArgs;

  return (
    (callbackProjectileVariant === undefined ||
      callbackProjectileVariant === projectile.Variant) &&
    (callbackSubType === undefined || callbackSubType === projectile.SubType)
  );
}

export function shouldFireRock(
  fireArgs: [rock: GridEntityRock],
  optionalArgs: [gridEntityType?: GridEntityType, variant?: int],
): boolean {
  const [rock] = fireArgs;
  const [callbackGridEntity, callbackVariant] = optionalArgs;

  const gridEntityType = rock.GetType();
  const variant = rock.GetVariant();

  return (
    (callbackGridEntity === undefined ||
      callbackGridEntity === gridEntityType) &&
    (callbackVariant === undefined || callbackVariant === variant)
  );
}

export function shouldFireRoom(
  fireArgs: [roomType: RoomType],
  optionalArgs: [roomType?: RoomType],
): boolean {
  const [roomType] = fireArgs;
  const [callbackRoomType] = optionalArgs;

  return callbackRoomType === undefined || callbackRoomType === roomType;
}

export function shouldFireSlot(
  fireArgs:
    | [slot: EntitySlot]
    | [slot: EntitySlot, player: EntityPlayer]
    | [slot: EntitySlot, slotDestructionType: SlotDestructionType]
    | [slot: EntitySlot, previousAnimation: string, currentAnimation: string],
  optionalArgs: [slotVariant?: SlotVariant, subType?: int],
): boolean {
  const [slot] = fireArgs;
  const [callbackSlotVariant, callbackSubType] = optionalArgs;

  return (
    (callbackSlotVariant === undefined ||
      callbackSlotVariant === slot.Variant) &&
    (callbackSubType === undefined || callbackSubType === slot.SubType)
  );
}

export function shouldFireSpikes(
  fireArgs: [spikes: GridEntitySpikes],
  optionalArgs: [variant?: int],
): boolean {
  const [spikes] = fireArgs;
  const [callbackVariant] = optionalArgs;

  const variant = spikes.GetVariant();

  return callbackVariant === undefined || callbackVariant === variant;
}

export function shouldFireTNT(
  fireArgs: [tnt: GridEntityTNT],
  optionalArgs: [variant?: int],
): boolean {
  const [tnt] = fireArgs;
  const [callbackVariant] = optionalArgs;

  const variant = tnt.GetVariant();

  return callbackVariant === undefined || callbackVariant === variant;
}

export function shouldFireTear(
  fireArgs:
    | [tear: EntityTear]
    | [tear: EntityTear, renderOffset: Vector]
    | [tear: EntityTear, collider: Entity, low: boolean],
  optionalArgs: [tearVariant?: TearVariant, subType?: int],
): boolean {
  const [tear] = fireArgs;
  const [callbackTearVariant, callbackSubType] = optionalArgs;

  return (
    (callbackTearVariant === undefined ||
      callbackTearVariant === tear.Variant) &&
    (callbackSubType === undefined || callbackSubType === tear.SubType)
  );
}

export function shouldFireTrinketType(
  fireArgs: [player: EntityPlayer, trinketType: TrinketType],
  optionalArgs: [trinketType?: TrinketType],
): boolean {
  const [_player, trinketType] = fireArgs;
  const [callbackTrinketType] = optionalArgs;

  return (
    callbackTrinketType === undefined || callbackTrinketType === trinketType
  );
}

----
types\AddSubtract.ts
/** From: https://gist.github.com/ryandabler/8b4ff4f36aed47bc09acc03174638468 */
export type Add<A extends number, B extends number> = Length<
  [...BuildTuple<A>, ...BuildTuple<B>]
>;

/** From: https://gist.github.com/ryandabler/8b4ff4f36aed47bc09acc03174638468 */
export type Subtract<A extends number, B extends number> = A extends A
  ? BuildTuple<A> extends [...infer U, ...BuildTuple<B>]
    ? Length<U>
    : never
  : never;

type BuildTuple<L extends number, T extends unknown[] = []> = T extends {
  length: L;
}
  ? T
  : BuildTuple<L, [...T, unknown]>;

type Length<T extends unknown[]> = T extends { length: infer L } ? L : never;

----
types\AllButFirst.ts
/** Helper type to create a new tuple containing all but the first element of another tuple. */
export type AllButFirst<T extends unknown[]> = T extends [
  unknown,
  ...infer Tail,
]
  ? Tail
  : unknown[];

----
types\AllButLast.ts
/** Helper type to create a new tuple containing all but the last element of another tuple. */
export type AllButLast<T extends unknown[]> = T extends [...infer Head, unknown]
  ? Head
  : unknown[];

----
types\AnyClass.ts
/** Helper type to represent any class. (This is the same type as any class constructor.) */
export type AnyClass = new () => object;

----
types\AnyEntity.ts
/**
 * A type union that matches `Entity`, `EntityBomb`, `EntityEffect`, and so on.
 *
 * This is useful for building generic functions that should accept any kind of entity.
 */
export type AnyEntity =
  | Entity
  | EntityBomb
  | EntityEffect
  | EntityFamiliar
  | EntityKnife
  | EntityLaser
  | EntityNPC
  | EntityPickup
  | EntityPlayer
  | EntityProjectile
  | EntityTear;

----
types\AnyFunction.ts
/**
 * Helper type to represent any function. This is safer than using the built-in `Function` type, as
 * it does not completely turn off all type safety.
 */
export type AnyFunction = (...args: readonly unknown[]) => unknown;

----
types\AnyGridEntity.ts
/**
 * A type union that matches `GridEntity`, `GridEntityDoor`, `GridEntityPit`, and so on.
 *
 * This is useful for building generic functions that should accept any kind of grid entity.
 */
export type AnyGridEntity =
  | GridEntity
  | GridEntityDoor
  | GridEntityPit
  | GridEntityPoop
  | GridEntityPressurePlate
  | GridEntityRock
  | GridEntitySpikes
  | GridEntityTNT;

----
types\CompositionTypeSatisfiesEnum.ts
/**
 * Helper type to validate that a union of interfaces with a field of `type` that is based on an
 * enum is complete.
 *
 * For example:
 *
 * ```ts
 * enum ObjectiveType {
 *   FOO,
 *   BAR,
 *   BAZ,
 * }
 *
 * interface FooObjective {
 *   type: ObjectiveType.FOO;
 *   fooThing: number;
 * }
 *
 * interface BarObjective {
 *   type: ObjectiveType.BAR;
 *   barThing: string;
 * }
 *
 * type Objective = FooObjective | BarObjective;
 * type _Test = CompositionTypeSatisfiesEnum<Objective, ObjectiveType>;
 * ```
 *
 * In this example, `Test` would be flagged by TypeScript because `Objective` does not contain an
 * entry for `BazObjective`.
 */
export type CompositionTypeSatisfiesEnum<
  T extends { type: unknown },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Enum extends T["type"],
> = unknown;

// -----
// Tests
// -----

enum ObjectiveType {
  FOO,
  BAR,
  BAZ,
}

interface FooObjective {
  type: ObjectiveType.FOO;
  fooThing: number;
}

interface BarObjective {
  type: ObjectiveType.BAR;
  barThing: string;
}

interface BazObjective {
  type: ObjectiveType.BAZ;
  bazThing: string;
}

type Objective1 = FooObjective | BarObjective | BazObjective;
type _Test1 = CompositionTypeSatisfiesEnum<Objective1, ObjectiveType>;

type Objective2 = FooObjective | BarObjective;
// @ts-expect-error Missing "Baz".
type _Test2 = CompositionTypeSatisfiesEnum<Objective2, ObjectiveType>;

----
types\ConversionHeartSubType.ts
import type { HeartSubType } from "isaac-typescript-definitions";

/**
 * This is the type that is fed to `registerCharacterHealthConversion` helper function to signify
 * the kind of health conversion that is desired.
 */
export type ConversionHeartSubType = HeartSubType.SOUL | HeartSubType.BLACK;

----
types\Decrement.ts
/**
 * Helper type to subtract one from a number type.
 *
 * From: https://stackoverflow.com/questions/54243431/typescript-increment-number-type
 */
export type Decrement<N extends number> =
  Arr<N> extends [unknown, ...infer U] ? U["length"] : never;

type Arr<N extends number, T extends unknown[] = []> = T["length"] extends N
  ? T
  : Arr<N, [...T, unknown]>;

----
types\ERange.ts
import type { NaturalNumbersLessThan } from "./NaturalNumbersLessThan";

/**
 * Helper type to get a range of integers. It is inclusive on the lower end and exclusive on the
 * high end. (The "E" in the type name stands for exclusive.)
 *
 * For example, `ERange<3, 5>` will return `3 | 4`.
 *
 * From:
 * https://stackoverflow.com/questions/39494689/is-it-possible-to-restrict-number-to-a-certain-range
 */
export type ERange<Low extends number, High extends number> = Exclude<
  NaturalNumbersLessThan<High>,
  NaturalNumbersLessThan<Low>
>;

----
types\EntityID.ts
/**
 * A string that represents an entity. This is the entity type, variant, and sub-type, all separated
 * by periods.
 *
 * This type is branded for extra type safety.
 */
export type EntityID = string & { readonly __entityIDBrand: symbol };

----
types\FunctionTuple.ts
import type { AnyFunction } from "./AnyFunction";

/** Helper type to represent a tuple containing the name of a function and the function itself. */
export type FunctionTuple = [name: string, func: AnyFunction];

----
types\GridEntityID.ts
/**
 * A string that represents a grid entity. This is the entity type and variant separated by a
 * period.
 *
 * This type is branded for extra type safety.
 */
export type GridEntityID = string & { readonly __gridEntityIDBrand: symbol };

----
types\HasFunction.ts
/** Helper type to check if an object or class has one or more functions/methods. */
export type HasFunction<T> =
  Record<string, unknown> extends {
    // eslint-disable-next-line @typescript-eslint/ban-types
    [K in keyof T as T[K] extends Function ? K : never]-?: 1;
  }
    ? never
    : T;

----
types\IRange.ts
import type { NaturalNumbersLessThan } from "./NaturalNumbersLessThan";
import type { NaturalNumbersLessThanOrEqualTo } from "./NaturalNumbersLessThanOrEqualTo";

/**
 * Helper type to get a range of integers. It is inclusive on both ends. (The "I" in the type name
 * stands for inclusive.)
 *
 * For example, `IRange<3, 5>` will return `3 | 4 | 5`.
 *
 * From:
 * https://stackoverflow.com/questions/39494689/is-it-possible-to-restrict-number-to-a-certain-range
 */
export type IRange<Low extends number, High extends number> = Exclude<
  NaturalNumbersLessThanOrEqualTo<High>,
  NaturalNumbersLessThan<Low>
>;

----
types\Immutable.ts
/**
 * Helper type to make the given array/map/set/object recursively read-only.
 *
 * You can use this type to easily build safe data structures.
 *
 * From: https://stackoverflow.com/questions/41879327/deepreadonly-object-typescript
 */
export type Immutable<T> = T extends ImmutablePrimitive
  ? T
  : T extends Array<infer U>
    ? ImmutableArray<U>
    : T extends Map<infer K, infer V>
      ? ImmutableMap<K, V>
      : T extends Set<infer M>
        ? ImmutableSet<M>
        : ImmutableObject<T>;

type ImmutablePrimitive =
  | undefined
  | null
  | boolean
  | string
  | number
  | Function; // eslint-disable-line @typescript-eslint/ban-types
type ImmutableArray<T> = ReadonlyArray<Immutable<T>>;
type ImmutableMap<K, V> = ReadonlyMap<Immutable<K>, Immutable<V>>;
type ImmutableSet<T> = ReadonlySet<Immutable<T>>;
type ImmutableObject<T> = { readonly [K in keyof T]: Immutable<T[K]> };

----
types\Increment.ts
/**
 * Helper type to add one to a number type.
 *
 * From: https://stackoverflow.com/questions/54243431/typescript-increment-number-type
 */
export type Increment<N extends number> = [...Arr<N>, unknown]["length"] &
  number;

type Arr<N extends number, T extends unknown[] = []> = T["length"] extends N
  ? T
  : Arr<N, [...T, unknown]>;

----
types\LowercaseKeys.ts
import type { StartsWithLowercase } from "./StartsWithLowercase";

/** Helper type to match all of the lowercase keys of an object. */
export type LowercaseKeys<T> = StartsWithLowercase<keyof T>;

----
types\NaturalNumbersLessThan.ts
/**
 * Helper type to get a range of integers between 0 and N - 1.
 *
 * From:
 * https://stackoverflow.com/questions/39494689/is-it-possible-to-restrict-number-to-a-certain-range
 */
export type NaturalNumbersLessThan<
  N extends number,
  Acc extends number[] = [],
> = Acc["length"] extends N
  ? Acc[number]
  : NaturalNumbersLessThan<N, [...Acc, Acc["length"]]>;

----
types\NaturalNumbersLessThanOrEqualTo.ts
/**
 * Helper type to get a range of integers between 0 and N.
 *
 * From:
 * https://stackoverflow.com/questions/39494689/is-it-possible-to-restrict-number-to-a-certain-range
 */
export type NaturalNumbersLessThanOrEqualTo<
  N extends number,
  Acc extends number[] = [],
> = Acc extends [unknown, ...infer Tail]
  ? Tail["length"] extends N
    ? Acc[number]
    : NaturalNumbersLessThanOrEqualTo<N, [...Acc, Acc["length"]]>
  : NaturalNumbersLessThanOrEqualTo<N, [...Acc, Acc["length"]]>;

----
types\PickingUpItem.ts
/**
 * This is the type that is fed to the `PRE_ITEM_PICKUP` and `POST_ITEM_PICKUP` custom callbacks.
 *
 * @module
 */

import type { TrinketType } from "isaac-typescript-definitions";
import { CollectibleType, ItemType } from "isaac-typescript-definitions";
import { ReadonlySet } from "./ReadonlySet";

export type PickingUpItem =
  | PickingUpItemNull
  | PickingUpItemCollectible
  | PickingUpItemTrinket;

/** Part of `PickingUpItem`. */
export interface PickingUpItemNull {
  /** Needed so that we can distinguish between picking up a collectible and a trinket. */
  itemType: ItemType.NULL;

  /** Equal to either the collectible type, the trinket type, or 0. */
  subType: 0;
}

/** Part of `PickingUpItem`. */
export interface PickingUpItemCollectible {
  /** Needed so that we can distinguish between picking up a collectible and a trinket. */
  itemType: ItemType.PASSIVE | ItemType.ACTIVE | ItemType.FAMILIAR;

  /** Equal to either the collectible type, the trinket type, or 0. */
  subType: CollectibleType;
}

/** Part of `PickingUpItem`. */
export interface PickingUpItemTrinket {
  /** Needed so that we can distinguish between picking up a collectible and a trinket. */
  itemType: ItemType.TRINKET;

  /** Equal to either the collectible type, the trinket type, or 0. */
  subType: TrinketType;
}

const DEFAULT_ITEM_TYPE = ItemType.NULL;
const DEFAULT_SUB_TYPE = CollectibleType.NULL;

export function newPickingUpItem(): PickingUpItem {
  return {
    itemType: DEFAULT_ITEM_TYPE,
    subType: DEFAULT_SUB_TYPE,
  };
}

export function resetPickingUpItem(pickingUpItem: PickingUpItem): void {
  pickingUpItem.itemType = DEFAULT_ITEM_TYPE;
  pickingUpItem.subType = DEFAULT_SUB_TYPE;
}

const COLLECTIBLE_ITEM_TYPES = new ReadonlySet<ItemType>([
  ItemType.PASSIVE, // 1
  ItemType.ACTIVE, // 3
  ItemType.FAMILIAR, // 4
]);

/** Helper function to narrow the type of `PickingUpItem`. */
export function isPickingUpItemNull(
  pickingUpItem: PickingUpItem,
): pickingUpItem is PickingUpItemTrinket {
  return pickingUpItem.itemType === ItemType.NULL;
}

/** Helper function to narrow the type of `PickingUpItem`. */
export function isPickingUpItemCollectible(
  pickingUpItem: PickingUpItem,
): pickingUpItem is PickingUpItemCollectible {
  return COLLECTIBLE_ITEM_TYPES.has(pickingUpItem.itemType);
}

/** Helper function to narrow the type of `PickingUpItem`. */
export function isPickingUpItemTrinket(
  pickingUpItem: PickingUpItem,
): pickingUpItem is PickingUpItemTrinket {
  return pickingUpItem.itemType === ItemType.TRINKET;
}

----
types\PickupIndex.ts
/**
 * `PickupIndex` is a specific type of number that represents a unique identifier for a pickup. Mods
 * can signify that data structures handle collectibles by using this type.
 *
 * For more information, see the documentation for the `getPickupIndex` function.
 *
 * For example:
 *
 * ```ts
 * const pickupNameMap = new Map<PickupIndex, string>();
 * ```
 *
 * This type is branded for extra type safety.
 */
export type PickupIndex = int & {
  readonly __pickupIndexBrand: symbol;
};

----
types\PlayerIndex.ts
/**
 * `PlayerIndex` is a specific type of number that represents a unique identifier for a player. Mods
 * can signify that data structures handle `EntityPlayer` by using this type.
 *
 * For more information, see the documentation for the `getPlayerIndex` function.
 *
 * For example:
 *
 * ```ts
 * const playersNameMap = new Map<PlayerIndex, string>();
 * ```
 *
 * This type is branded for extra type safety.
 */
export type PlayerIndex = int & { readonly __playerIndexBrand: symbol };

----
types\PossibleStatType.ts
import type { TearFlag } from "isaac-typescript-definitions";

/**
 * These are the possible types that player stats can be. For example, `EntityPlayer.Damage` is of
 * type `float`, `EntityPlayer.CanFly` is of type `boolean`, and so on.
 */
export type PossibleStatType =
  | number
  | boolean
  | BitFlags<TearFlag>
  | Color
  | Vector;

----
types\PublicInterface.ts
/** Helper type to extract only the public interface of a class. */
export type PublicInterface<T> = Pick<T, keyof T>;

----
types\ReadonlyMap.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

interface ReadonlyMapConstructor {
  new (): ReadonlyMap<any, any>;
  new <K, V>(
    entries?: ReadonlyArray<readonly [K, V]> | Iterable<readonly [K, V]> | null,
  ): ReadonlyMap<K, V>;
  readonly prototype: ReadonlyMap<any, any>;
}

/** An alias for the `Map` constructor that returns a read-only map. */
export const ReadonlyMap = Map as ReadonlyMapConstructor;

----
types\ReadonlyRecord.ts
export type ReadonlyRecord<K extends string | number | symbol, V> = Readonly<
  Record<K, V>
>;

----
types\ReadonlySet.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

interface ReadonlySetConstructor {
  new <T = any>(values?: readonly T[] | Iterable<T> | null): ReadonlySet<T>;
  readonly prototype: ReadonlySet<any>;
}

/** An alias for the `Set` constructor that returns a read-only set. */
export const ReadonlySet = Set as ReadonlySetConstructor;

----
types\StartsWithLowercase.ts
/** Helper type to ensure that the given string starts with an lowercase letter. */
export type StartsWithLowercase<S> = S extends string
  ? Extract<S, Uncapitalize<S>>
  : never;

----
types\StartsWithUppercase.ts
/** Helper type to ensure that the given string starts with an uppercase letter. */
export type StartsWithUppercase<S> = S extends string
  ? Extract<S, Capitalize<S>>
  : never;

----
types\TSTLClass.ts
/**
 * This is a type representing a user-created class from TypeScript code. (TypeScriptToLua
 * transpiles TypeScript classes to a Lua table with a specific kind of metatable.)
 *
 * This type is used by the save data manager to when copying, serializing, and deserializing.
 */
export type TSTLClass = LuaMap<AnyNotNil, unknown> & {
  readonly __tstlClassBrand: symbol;
};

----
types\Tuple.ts
/**
 * Helper type to represent a tuple of length N.
 *
 * From:
 * https://stackoverflow.com/questions/52489261/typescript-can-i-define-an-n-length-tuple-type/52490977#52490977
 */
export type Tuple<T, N extends number> = N extends N
  ? number extends N
    ? T[]
    : _TupleOf<T, N, []>
  : never;
type _TupleOf<T, N extends number, R extends unknown[]> = R["length"] extends N
  ? R
  : _TupleOf<T, N, [T, ...R]>;

----
types\TupleKeys.ts
import type { ERange } from "./ERange";

/**
 * Helper type to get the valid indexes for a tuple. For example, using a tuple of length 3 will
 * return `0 | 1 | 2`.
 */
export type TupleKeys<T extends { length: number }> = ERange<0, T["length"]>;

----
types\TupleToIntersection.ts
export type TupleToIntersection<T extends unknown[]> = T extends [
  infer F,
  ...infer R,
]
  ? F & TupleToIntersection<R>
  : unknown;

----
types\TupleToUnion.ts
/** Helper type to convert a tuple to a union. */
export type TupleToUnion<T extends unknown[]> = T[number];

----
types\TupleWithLengthBetween.ts
import type { IRange } from "./IRange";

/**
 * Helper type that validates that a tuple has a length between `MinLength` and `MaxLength`
 * (inclusive on both ends).
 *
 * For example, `TupleWithLengthBetween<string, 2, 4>` will allow string tuples of size 2, 3, or 4.
 */
export type TupleWithLengthBetween<
  T,
  MinLength extends number,
  MaxLength extends number,
> = readonly T[] & {
  length: IRange<MinLength, MaxLength>;
};

// -----
// Tests
// -----

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable isaacscript/require-unannotated-const-assertions */

// @ts-expect-error Tuple of length 0 with min length 1 and max length 2.
const zeroOneTwo: TupleWithLengthBetween<string, 1, 2> = [] as const;

// Tuple of length 1 with min length 1 and max length 2.
const oneOneTwo: TupleWithLengthBetween<string, 1, 2> = ["1"] as const;

// Tuple of length 2 with min length 1 and max length 2.
const twoOneTwo: TupleWithLengthBetween<string, 1, 2> = ["1", "2"] as const;

// @ts-expect-error Tuple of length 3 with min length 1 and max length 2.
const threeOneTwo: TupleWithLengthBetween<string, 1, 2> = [
  "1",
  "2",
  "3",
] as const;

/* eslint-enable @typescript-eslint/no-unused-vars */
/* eslint-enable isaacscript/require-unannotated-const-assertions */

// See "TupleWithMaxLength.ts" for more tests.

----
types\TupleWithMaxLength.ts
import type { IRange } from "./IRange";

/**
 * Helper type that validates that a tuple does not have a length greater than N.
 *
 * For example, `TupleWithMaxLength<string, 3>` will allow string tuples of size 0, 1, 2, or 3.
 */
export type TupleWithMaxLength<T, MaxLength extends number> = readonly T[] & {
  length: IRange<0, MaxLength>;
};

// -----
// Tests
// -----

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable isaacscript/require-unannotated-const-assertions */

// Tuple of length 0 with max length 0.
const zeroZero: TupleWithMaxLength<string, 0> = [] as const;

// @ts-expect-error Tuple of length 1 with max length 0.
const oneZero: TupleWithMaxLength<string, 0> = ["1"] as const;

// Tuple of length 0 with max length 1.
const zeroOne: TupleWithMaxLength<string, 1> = [] as const;

// Tuple of length 1 with max length 1.
const oneOne: TupleWithMaxLength<string, 1> = ["1"] as const;

// @ts-expect-error Tuple of length 2 with max length 1.
const twoOne: TupleWithMaxLength<string, 1> = ["1", "2"] as const;

// Tuple of length 0 with max length 2.
const zeroTwo: TupleWithMaxLength<string, 2> = [] as const;

// Tuple of length 1 with max length 2.
const oneTwo: TupleWithMaxLength<string, 2> = ["1"] as const;

// Tuple of length 2 with max length 2.
const twoTwo: TupleWithMaxLength<string, 2> = ["1", "2"] as const;

// @ts-expect-error Tuple of length 3 with max length 2.
const threeTwo: TupleWithMaxLength<string, 2> = ["1", "2", "3"] as const;

/* eslint-enable @typescript-eslint/no-unused-vars */
/* eslint-enable isaacscript/require-unannotated-const-assertions */

----
types\UnionToIntersection.ts
/** Helper type to convert a union to an intersection. */
export type UnionToIntersection<U> = (
  U extends U ? (u: U) => 0 : never
) extends (i: infer I) => 0
  ? Extract<I, U>
  : never;

----
types\UppercaseKeys.ts
import type { StartsWithUppercase } from "./StartsWithUppercase";

/** Helper type to match all of the uppercase keys of an object. */
export type UppercaseKeys<T> = StartsWithUppercase<keyof T>;

----
types\WeightedArray.ts
/** An array where each element is paired with a number indicating that element's weight. */
export type WeightedArray<T> = Array<[T, float]>;

----
types\WidenLiteral.ts
export type WidenLiteral<T> = T extends string
  ? string
  : T extends number
    ? number
    : T extends boolean
      ? boolean
      : T extends bigint
        ? bigint
        : T extends symbol
          ? symbol
          : T;

----
types\Writable.ts
/**
 * Helper type to convert a read-only object into a writable object.
 *
 * This is the opposite of the built-in `Readonly` utility type.
 */
export type Writeable<T> = { -readonly [P in keyof T]: T[P] };

----
types\private\CallbackTuple.ts
import type { ModCallback } from "isaac-typescript-definitions";
import type { ModCallbackCustom } from "../../enums/ModCallbackCustom";
import type { AddCallbackParametersCustom } from "../../interfaces/private/AddCallbackParametersCustom";
import type { AllButFirst } from "../AllButFirst";

/**
 * A mapping of the callback enum to the associated callback function and optional arguments. This
 * is so that the respective callback functions can be added/removed on demand as subscribers get
 * added/removed.
 */
export type CallbackTuple = {
  [K in ModCallback]: [
    modCallback: K,
    callbackFunc: AddCallbackParameters[K][0],
    optionalArgs?: AllButFirst<AddCallbackParameters[K]>,
  ];
}[ModCallback];

/**
 * A mapping of the custom callback enum to the associated callback function and optional arguments.
 * This is so that the respective callback functions can be added/removed on demand as subscribers
 * get added/removed.
 */
export type CustomCallbackTuple = {
  [K in ModCallbackCustom]: [
    modCallback: K,
    callbackFunc: AddCallbackParametersCustom[K][0],
    optionalArgs?: AllButFirst<AddCallbackParametersCustom[K]>,
  ];
}[ModCallbackCustom];

----
types\private\ModUpgradedWithFeatures.ts
import type { ModUpgraded } from "../../classes/ModUpgraded";
import type { Feature } from "../../classes/private/Feature";
import type { ISCFeature } from "../../enums/ISCFeature";
import type { ISCFeatureToClass } from "../../features";
import type { PublicInterface } from "../PublicInterface";
import type { TupleToIntersection } from "../TupleToIntersection";
import type { Writeable } from "../Writable";

/**
 * `isaacscript-common` has many custom callbacks that you can use in your mods. Instead of
 * hijacking the vanilla `Mod` object, we provide a `ModUpgraded` object for you to use, which
 * extends the base class and adds a new method of `AddCallbackCustom`.
 *
 * To upgrade your mod, use the `upgradeMod` helper function.
 *
 * By specifying one or more optional features, end-users will get a version of `ModUpgraded` that
 * has extra methods corresponding to the features that were specified.
 *
 * This type is in the private directory because if it was exported, it would cause all of the
 * internal feature classes to populate the auto-complete of end-user mods (which should never be
 * directly imported by end-users).
 */
export type ModUpgradedWithFeatures<T extends readonly ISCFeature[] = []> =
  ModUpgraded & ISCFeaturesToKeys<T>;

/**
 * We want to only extract the class public methods, so we omit the keys of the `Feature` base
 * class.
 */
type ISCFeaturesToKeys<T extends readonly ISCFeature[]> = Omit<
  TupleToIntersection<ISCFeatureTupleToClassTuple<Writeable<T>>>,
  keyof Feature
>;

/**
 * We need to use the `PublicInterface` helper type because an intersection of two classes with the
 * same private fields will cause a `never` type.
 */
type ISCFeatureTupleToClassTuple<T extends ISCFeature[]> = {
  [K in keyof T]: PublicInterface<ISCFeatureToClass[T[K]]>;
};

--END--