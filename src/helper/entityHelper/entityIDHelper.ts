import {
  getConstituentsFromEntityID,
  getEntities,
  getEntityIDFromConstituents,
  getEnumValues,
} from "isaacscript-common";
import type { EntityID } from "isaacscript-common";
import {
  EntityType,
  NPCID,
  PickupVariant,
  SlotVariant,
  TearVariant,
  BombVariant,
} from "isaac-typescript-definitions";
import { fprint } from "../printHelper";
import type { NameSubType } from "../../types/data/nameSubType";
import { EntityCategory } from "../../enums/general/EntityCategory";
import { PickupID } from "../../enums/data/ID/PickupID";
import { EffectID } from "../../enums/data/ID/EffectID";
import { PICKUP_VARIANTS_WITH_AUTOGENERATED_SUBTYPES } from "../../constants/pickupConstants";

/** Determine if a variable is an EntityID (e.g '123.0.0'). */
export function isEntityID(variable: unknown): variable is EntityID {
  if (typeof variable !== "string") {
    return false;
  }
  const constituents = variable.split(".");
  if (constituents.length !== 3) {
    return false;
  }
  const [type, variant, subType] = constituents;
  return (
    type !== undefined &&
    variant !== undefined &&
    subType !== undefined &&
    !Number.isNaN(Number(type)) &&
    !Number.isNaN(Number(variant)) &&
    !Number.isNaN(Number(subType))
  );
}

/** Get an EntityID from an Entity. */
export function getEntityIDFromEntity(entity: Entity): EntityID {
  return getEntityIDFromConstituents(
    entity.Type,
    entity.Variant,
    entity.SubType,
  );
}

/** Get a set of EntityID's from the base game that match the provided EntityCategory. */
export function getBaseEntityIDSetFromCategory(
  category: EntityCategory,
): ReadonlySet<EntityID> {
  switch (category) {
    case EntityCategory.NPC: {
      return new Set(getEnumValues(NPCID)) as Set<EntityID>;
    }

    case EntityCategory.PICKUP: {
      return new Set(getEnumValues(PickupID)) as Set<EntityID>;
    }

    case EntityCategory.EFFECT: {
      return new Set(getEnumValues(EffectID)) as Set<EntityID>;
    }

    case EntityCategory.SLOT: {
      // There is no SlotID enum, so we have to manually create the set using the SlotVariant enum.
      const slotVariantSet = new Set<EntityID>();
      for (const slotVariant of getEnumValues(SlotVariant)) {
        slotVariantSet.add(`${EntityType.SLOT}.${slotVariant}.0` as EntityID);
      }
      return slotVariantSet;
    }

    case EntityCategory.TEAR: {
      // There is no TearID enum, so we have to manually create the set using the TearVariant enum.
      const tearVariantSet = new Set<EntityID>();
      for (const tearVariant of getEnumValues(TearVariant)) {
        tearVariantSet.add(`${EntityType.TEAR}.${tearVariant}.0` as EntityID);
      }
      return tearVariantSet;
    }

    case EntityCategory.BOMB: {
      // There is no BombID enum, so we have to manually create the set using the BombVariant enum.
      const bombVariantSet = new Set<EntityID>();
      for (const bombVariant of getEnumValues(BombVariant)) {
        bombVariantSet.add(`${EntityType.BOMB}.${bombVariant}.0` as EntityID);
      }
      return bombVariantSet;
    }

    default: {
      fprint(`Invalid category: ${category}, not yet implemented.`);
      return new Set<EntityID>();
    }
  }
}

/**
 * Get the modded Entity's name and subType from its Name + SubType string (e.g "0.HoneyFox") would
 * return { subType: 0, name: "HoneyFox" }.
 */
export function getModdedEntityNameAndSubTypeFromNameSubType(
  nameSubType: NameSubType,
): { name: string; subType: number } {
  // We can't use 'split' as names may contain '.'.
  const subTypeIndex = nameSubType.indexOf(".");
  if (subTypeIndex === -1) {
    error(`Invalid nameSubType: ${nameSubType}`);
  }
  const subType = nameSubType.slice(0, subTypeIndex);
  const name = nameSubType.slice(subTypeIndex + 1);
  return { name, subType: Number(subType) };
}

/**
 * Get an EntityID from a NameSubType string. If the game cannot find the entity name and hence its
 * type or variant, this will return undefined.
 */
export function getEntityIDFromNameSubType(
  nameSubType: NameSubType,
): EntityID | undefined {
  const nameAndSubType =
    getModdedEntityNameAndSubTypeFromNameSubType(nameSubType);
  const { name, subType } = nameAndSubType;
  const type = Isaac.GetEntityTypeByName(name);
  const variant = Isaac.GetEntityVariantByName(name);
  if ((type as number) === -1 || variant === -1) {
    fprint(`Invalid nameSubType: ${nameSubType}`);
    return undefined;
  }
  // If the entity is a card, pill, trinket, collectible, then the subType may be different due to
  // the game's internal logic.
  if (
    type === EntityType.PICKUP &&
    PICKUP_VARIANTS_WITH_AUTOGENERATED_SUBTYPES.has(variant)
  ) {
    let newSubType = subType;
    switch (variant) {
      case PickupVariant.CARD: {
        newSubType = Isaac.GetCardIdByName(name);
        break;
      }

      case PickupVariant.PILL: {
        newSubType = Isaac.GetPillEffectByName(name);
        break;
      }

      case PickupVariant.TRINKET: {
        newSubType = Isaac.GetTrinketIdByName(name);
        break;
      }

      case PickupVariant.COLLECTIBLE: {
        newSubType = Isaac.GetItemIdByName(name);
        break;
      }
    }

    // If the subType is still -1, then the entity name is invalid.
    if (newSubType === -1) {
      fprint(`Invalid nameSubType: ${nameSubType}`);
      return undefined;
    }

    return getEntityIDFromConstituents(type, variant, newSubType);
  }
  return getEntityIDFromConstituents(type, variant, subType);
}

/**
 * Determine an Entity's EntityCategory from its EntityID or EntityType.
 *
 * @param entityIDOrEntityType The EntityID or EntityType to determine the EntityCategory from.
 * @returns The EntityCategory of the EntityID or EntityType.
 */
export function getEntityCategoryFromEntityID(
  entityIDOrEntityType: EntityID | EntityType,
): EntityCategory {
  const typeNumber = isEntityID(entityIDOrEntityType)
    ? Number(entityIDOrEntityType.split(".")[0])
    : entityIDOrEntityType;
  if (typeNumber === 0) {
    error(
      `getEntityCategoryFromEntityID: Invalid entityID ${entityIDOrEntityType}`,
    );
  }
  if (typeNumber === 1) {
    return EntityCategory.PLAYER;
  }
  if (typeNumber === 2) {
    return EntityCategory.TEAR;
  }
  if (typeNumber === 3) {
    return EntityCategory.FAMILIAR;
  }
  if (typeNumber === 4) {
    return EntityCategory.BOMB;
  }
  if (typeNumber === 5) {
    return EntityCategory.PICKUP;
  }
  if (typeNumber === 6) {
    return EntityCategory.SLOT;
  }
  if (typeNumber === 7) {
    return EntityCategory.LASER;
  }
  if (typeNumber === 8) {
    return EntityCategory.KNIFE;
  }
  if (typeNumber === 9) {
    return EntityCategory.PROJECTILE;
  }
  if (typeNumber >= 1000) {
    return EntityCategory.EFFECT;
  }

  return EntityCategory.NPC;
}

/**
 * Helper function to get all of the entities in the room or all of the entities that match a
 * specific EntityID.
 *
 * Due to bugs with Isaac.FindInRadius, this function uses Isaac.GetRoomEntities, which is more
 * expensive but also more robust. (If a matching entity type is provided, then Isaac.FindByType
 * will be used instead.)
 *
 * @param entityID The EntityID to match. If a constituent is -1, will match all entities of that
 *                 type.
 * @param ignoreFriendly Whether to ignore friendly entities (default is false).
 */
export function getEntitiesFromEntityID(
  entityID: EntityID,
  ignoreFriendly = false,
): readonly Entity[] {
  const constituents = getConstituentsFromEntityID(entityID);
  return getEntities(
    constituents[0],
    constituents[1],
    constituents[2],
    ignoreFriendly,
  );
}
